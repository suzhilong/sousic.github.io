<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/apple-touch-icon-next.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、算法基础 大部分是Leecode中的典型题目，也有笔试中的真题和剑指Offer中的题目。题解使用C++，代码均由本人在参考题解之后所写。相关github">
<meta property="og:type" content="article">
<meta property="og:title" content="SOUSIC的algorithm总结">
<meta property="og:url" content="https://github.com/suzhilong/suzhilong.github.io.git/2020/05/25/algorithm/index.html">
<meta property="og:site_name" content="SOUSIC">
<meta property="og:description" content="一、算法基础 大部分是Leecode中的典型题目，也有笔试中的真题和剑指Offer中的题目。题解使用C++，代码均由本人在参考题解之后所写。相关github">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/06/19/eLGVs6wMJf9BOyr.png">
<meta property="og:image" content="https://i.loli.net/2020/07/12/GXVphrYafON5jFw.png">
<meta property="og:image" content="https://i.loli.net/2020/07/29/N1O2xGlCm54yuQI.png">
<meta property="og:image" content="https://i.loli.net/2020/10/16/hGiceXPkE1marBQ.png">
<meta property="article:published_time" content="2020-05-25T08:00:00.000Z">
<meta property="article:modified_time" content="2020-10-16T07:13:15.716Z">
<meta property="article:author" content="Su Zhilong">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/06/19/eLGVs6wMJf9BOyr.png">

<link rel="canonical" href="https://github.com/suzhilong/suzhilong.github.io.git/2020/05/25/algorithm/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>SOUSIC的algorithm总结 | SOUSIC</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="SOUSIC" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SOUSIC</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">哈库呐玛塔塔</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/suzhilong/suzhilong.github.io.git/2020/05/25/algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Su Zhilong">
      <meta itemprop="description" content="I will always be with you">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SOUSIC">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SOUSIC的algorithm总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-25 16:00:00" itemprop="dateCreated datePublished" datetime="2020-05-25T16:00:00+08:00">2020-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-16 15:13:15" itemprop="dateModified" datetime="2020-10-16T15:13:15+08:00">2020-10-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/05/25/algorithm/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/05/25/algorithm/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>138k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2:05</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一、算法基础"><a href="#一、算法基础" class="headerlink" title="一、算法基础"></a>一、算法基础</h1><!--&emsp;&emsp;春节后疫情一直没开学，赋闲在家刷了一个多月的算法，总结了一下，形成了下面的文章。包含了`数据结构类`例题和`算法类`例题，-->
<p>大部分是Leecode中的典型题目，也有笔试中的真题和剑指Offer中的题目。题解使用C++，代码均由本人在参考题解之后所写。<br><a href="https://github.com/suzhilong/CS">相关github</a>  </p>
<span id="more"></span>
<h2 id="1-1-常用数据结构"><a href="#1-1-常用数据结构" class="headerlink" title="1.1 常用数据结构"></a>1.1 常用数据结构</h2><h3 id="1-1-1-链表"><a href="#1-1-1-链表" class="headerlink" title="1.1.1 链表"></a>1.1.1 链表</h3><p>链表又分为<code>单链表（线性链表）</code>、<code>双向链表</code>、<code>循环链表</code></p>
<h3 id="1-1-2-栈和队列"><a href="#1-1-2-栈和队列" class="headerlink" title="1.1.2 栈和队列"></a>1.1.2 栈和队列</h3><p><code>栈</code>：后进先出（last-in,first-out,LIFO）<br><code>队列</code>：先进先出（first-in,first-out,FIFO）<br><code>双端队列</code>：一种特殊的队列，两端都可以进出</p>
<h3 id="1-1-3-二叉树"><a href="#1-1-3-二叉树" class="headerlink" title="1.1.3 二叉树"></a>1.1.3 二叉树</h3><p>是树型结构的一种特殊形式。二叉树中，刷题中用到的有</p>
<ul>
<li><code>二叉搜索树/二叉查找树</code>，即左子树中的结点都比父结点小，右子树中的结点都比父结点大。</li>
<li><code>平衡树二叉树（AVL树）</code>，就是在二叉树的基础上，若树中每棵子树都满足其左子树和右子树的深度差都不超过 1，则这棵二叉树就是平衡二叉树。</li>
</ul>
<p>按照访问结点顺序的不同，可以将二叉树的<code>遍历</code>分为 <code>前序遍历</code>、<code>中序遍历</code>、<code>后序遍历</code>。</p>
<h3 id="1-1-4-图"><a href="#1-1-4-图" class="headerlink" title="1.1.4 图"></a>1.1.4 图</h3><p>图是由<code>顶点</code>和<code>边</code>构成的数据结构，一般来说，顶点表示的是数据，边表示数据之间的联系。图可以简单的分为<code>有向图</code>和<code>无向图</code>。<br>可以用<code>二维数组</code>来存储一个图。</p>
<h3 id="1-1-5-堆"><a href="#1-1-5-堆" class="headerlink" title="1.1.5 堆"></a>1.1.5 堆</h3><ul>
<li>大根堆</li>
<li>小根堆</li>
</ul>
<h2 id="1-2-时间复杂度、空间复杂度"><a href="#1-2-时间复杂度、空间复杂度" class="headerlink" title="1.2 时间复杂度、空间复杂度"></a>1.2 时间复杂度、空间复杂度</h2><p>算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，把算法的执行时间记为T(n)&#x3D;O(f(n))，他们的增长率相同，称做算法的渐进时间复杂度，简称<code>时间复杂度</code>。<br>相似的，<code>空间复杂度</code>S(n)&#x3D;O(f(n))用来度量算法所需的存储空间。</p>
<h2 id="1-3-排序（Sorting）、查找-x2F-搜索（Search）"><a href="#1-3-排序（Sorting）、查找-x2F-搜索（Search）" class="headerlink" title="1.3 排序（Sorting）、查找&#x2F;搜索（Search）"></a>1.3 排序（Sorting）、查找&#x2F;搜索（Search）</h2><h3 id="1-3-1-排序"><a href="#1-3-1-排序" class="headerlink" title="1.3.1 排序"></a>1.3.1 排序</h3><p>常用的八大排序：  </p>
<ul>
<li>插入排序</li>
<li>希尔排序</li>
<li>选择排序</li>
<li>冒泡排序</li>
<li>快速排序</li>
<li>堆排序</li>
<li>归并排序</li>
<li>基数排序</li>
</ul>
<p><img src="https://i.loli.net/2020/06/19/eLGVs6wMJf9BOyr.png" alt="排序复杂度"></p>
<h3 id="1-3-2-查找-x2F-搜索"><a href="#1-3-2-查找-x2F-搜索" class="headerlink" title="1.3.2 查找&#x2F;搜索"></a>1.3.2 查找&#x2F;搜索</h3><p><code>顺序查找</code>：一般情况下步长为1。根据不同的要求，会设置不同的步长。时间复杂度为O(n)。<br><code>二分查找（Binary Search，又叫折半查找）</code>：每次都与一个中点 <code>mid = (low+hight)/2</code> 相比较，时间复杂度为O(logn)。<br><code>二叉搜索/查找树</code>：见1.1.3。<code>中序遍历</code>二叉搜索树可以<code>有序</code>的输出关键字。<br><code>树的遍历</code>：前序遍历（根、左、右）、中序遍历（左、根、右）、后序遍历（左、右、根）。<br><code>广度优先搜索（BFS）</code>：类似于树的层序遍历，先访问最近一层所有的结点，再访问下一层的。<br><code>深度优先（DFS）</code>：类似于树的先序遍历，直到没有下一个结点才返回父结点。</p>
<h2 id="1-4-递归"><a href="#1-4-递归" class="headerlink" title="1.4 递归"></a>1.4 递归</h2><p>简单来说，递归的基本思想就是自己调用自己，这样就把问题变成了更小的子问题。<br>需要注意的是，递归函数中需要设置一个<code>终止条件</code>，以保证子问题最小时不再往下递归。</p>
<h2 id="1-5-分治"><a href="#1-5-分治" class="headerlink" title="1.5 分治"></a>1.5 分治</h2><p>分治策略中，需要递归的求解一个问题，在每层递归中会用到三个步骤[算法导论]：</p>
<ul>
<li>分解(Divide)：将原问题划分为规模更小的子问题。</li>
<li>解决(Conquer)：递归的求解子问题。如果子问题足够小，停止递归直接求解。</li>
<li>合并(Combine)：将子问题的解合成原问题的解。</li>
</ul>
<h1 id="二、数据结构类例题"><a href="#二、数据结构类例题" class="headerlink" title="二、数据结构类例题"></a>二、数据结构类例题</h1><p>主要从Leetcode的题中选出的代表性例题，也包括笔试或者其他资料上看到的比较好的题目。解答使用的cpp。  </p>
<h2 id="2-1-栈"><a href="#2-1-栈" class="headerlink" title="2.1 栈"></a>2.1 栈</h2><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><h4 id="1-739-每日温度（中等）"><a href="#1-739-每日温度（中等）" class="headerlink" title="1. 739. 每日温度（中等）"></a>1. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度（中等）</a></h4><p>根据每日 <code>气温</code> 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 <code>0</code> 来代替。<br>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</span><br></pre></td></tr></table></figure>

<p>题解：<br>维护一个单调递减的栈，栈中元素为温度值的索引。当前温度比栈顶索引温度低时，直接进栈；当前温度比栈顶索引温度高时，两个索引之间的差就是栈顶索引值所求结果。<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/">视频讲解</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;</span><br><span class="line">    int n = T.size();</span><br><span class="line">    vector&lt;int&gt; res(n,0);</span><br><span class="line">    stack&lt;int&gt; s;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        while (!s.empty() &amp;&amp; T[i] &gt; T[s.top()]) &#123;</span><br><span class="line">            int previousIndex = s.top();</span><br><span class="line">            res[previousIndex] = i - previousIndex;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)。空间复杂度O(n)。</p>
<h3 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h3><h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h4><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 <code>-1</code> )</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>
<p>题解：<br>一个栈入，一个栈出。当要插入数据时，直接插入入栈；当要取出数据时，如果出栈不为空，则从入栈依次取出放入出栈，直到入栈为空。这样就能保证<strong>后进先出</strong>。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class CQueue &#123;</span><br><span class="line">    stack&lt;int&gt; inputStack, outputStack;</span><br><span class="line">public:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">        while(!inputStack.empty())</span><br><span class="line">            inputStack.pop();</span><br><span class="line">        while(!outputStack.empty())</span><br><span class="line">            outputStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void appendTail(int value) &#123;</span><br><span class="line">        inputStack.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int deleteHead() &#123;</span><br><span class="line">        if(outputStack.empty())&#123;</span><br><span class="line">            while(!inputStack.empty())&#123;</span><br><span class="line">                outputStack.push(inputStack.top());</span><br><span class="line">                inputStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(outputStack.empty())</span><br><span class="line">            return -1;</span><br><span class="line">        else&#123;</span><br><span class="line">            int output = outputStack.top();</span><br><span class="line">            outputStack.pop();</span><br><span class="line">            return output;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="栈排序"><a href="#栈排序" class="headerlink" title="栈排序"></a>栈排序</h3><h4 id="使用两个栈进行排序（或着说使用一个辅助栈对栈进行排序）"><a href="#使用两个栈进行排序（或着说使用一个辅助栈对栈进行排序）" class="headerlink" title="使用两个栈进行排序（或着说使用一个辅助栈对栈进行排序）"></a>使用两个栈进行排序（或着说使用一个辅助栈对栈进行排序）</h4><p>每次都往辅助栈中放如当前剩余的最大的值，最后直到当前栈空了，再把辅助栈转移回去就可以完成排序。</p>
<p>弹出一个数：</p>
<ul>
<li>辅助栈为空，push</li>
<li>辅助栈不为空，如果弹出值大于辅助栈顶，则弹出辅助栈的元素放入当前栈，直到遇到小于或等于的就push进辅助栈。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//栈顶最大</span><br><span class="line">void sortStackByStack(stack&lt;int&gt; &amp;st)&#123;</span><br><span class="line">    stack&lt;int&gt; help;</span><br><span class="line">    while(!st.empty())&#123;</span><br><span class="line">        int curr=st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        while(!help.empty() &amp;&amp; curr&gt;help.top() )&#123;</span><br><span class="line">            st.push(help.top());</span><br><span class="line">            help.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        help.push(curr);</span><br><span class="line">    &#125;</span><br><span class="line">    while(!help.empty())&#123;</span><br><span class="line">        int tmp=help.top();</span><br><span class="line">        help.pop();</span><br><span class="line">        st.push(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-2-二叉树"><a href="#2-2-二叉树" class="headerlink" title="2.2 二叉树"></a>2.2 二叉树</h2><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历可以实现很多树相关的操作，如二叉树的序列化。二叉树的序列化本质上是对其值进行编码，更重要的是对其结构进行编码。可以遍历树来完成。  </p>
<p><a href="https://github.com/suzhilong/Algorithm/blob/master/BinaryTree/BinaryTreeTraversal.cpp">二叉树遍历的cpp实现</a></p>
<p>我们一般有两个策略：</p>
<h4 id="BFS（即层序遍历）：BFS-可以按照层次的顺序从上到下遍历所有的节点"><a href="#BFS（即层序遍历）：BFS-可以按照层次的顺序从上到下遍历所有的节点" class="headerlink" title="BFS（即层序遍历）：BFS 可以按照层次的顺序从上到下遍历所有的节点"></a>BFS（即层序遍历）：BFS 可以按照层次的顺序从上到下遍历所有的节点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void levelOrder(BinaryTree *root)&#123;</span><br><span class="line">    queue&lt;BinaryTree *&gt; que;</span><br><span class="line">    que.push(root);</span><br><span class="line"></span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        BinaryTree *curNode = que.front();</span><br><span class="line">        cout &lt;&lt; curNode-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        que.pop();</span><br><span class="line">        if(curNode-&gt;lc!=nullptr)</span><br><span class="line">            que.push(curNode-&gt;lc);</span><br><span class="line">        if(curNode-&gt;rc!=nullptr)</span><br><span class="line">            que.push(curNode-&gt;rc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DFS：DFS-可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将DFS策略区分为："><a href="#DFS：DFS-可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将DFS策略区分为：" class="headerlink" title="DFS：DFS 可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将DFS策略区分为："></a>DFS：DFS 可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将DFS策略区分为：</h4><h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">void preOrder_recursion(BinaryTree *root)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return;</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">    preOrder_recursion(root-&gt;lc);</span><br><span class="line">    preOrder_recursion(root-&gt;rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//非递归</span><br><span class="line">void preOrder_non_recursion(BinaryTree *root)&#123;</span><br><span class="line">    stack&lt;BinaryTree *&gt; st;</span><br><span class="line"></span><br><span class="line">    while(root!=nullptr || !st.empty())&#123;</span><br><span class="line">        if(root!=nullptr)&#123;</span><br><span class="line">            cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">            st.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            root = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            root = root-&gt;rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">void inOrder_recursion(BinaryTree *root)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return;</span><br><span class="line">    inOrder_recursion(root-&gt;lc);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">    inOrder_recursion(root-&gt;rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//非递归</span><br><span class="line">void inOrder_non_recursion(BinaryTree *root)&#123;</span><br><span class="line">    stack&lt;BinaryTree *&gt; st;</span><br><span class="line"></span><br><span class="line">    while(root!=nullptr || !st.empty())&#123;</span><br><span class="line">        if(root!=nullptr)&#123;</span><br><span class="line">            st.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            root = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">            root = root-&gt;rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">void posOrder_recursion(BinaryTree *root)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return;</span><br><span class="line">    posOrder_recursion(root-&gt;lc);</span><br><span class="line">    posOrder_recursion(root-&gt;rc);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//非递归</span><br><span class="line">void posOrder_non_recursion(BinaryTree *root)&#123;</span><br><span class="line">    stack&lt;BinaryTree *&gt; st;</span><br><span class="line">    BinaryTree *lastVisited = root;</span><br><span class="line"></span><br><span class="line">    while(root!=nullptr || !st.empty())&#123;</span><br><span class="line">        if(root!=nullptr)&#123;</span><br><span class="line">            st.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            root = st.top();</span><br><span class="line">            if(root-&gt;lc == nullptr || root-&gt;rc == lastVisited)&#123;</span><br><span class="line">                cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">                st.pop();</span><br><span class="line">                lastVisited = root;</span><br><span class="line">                root = nullptr;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                root = root-&gt;rc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Z形遍历-x2F-锯齿形遍历"><a href="#Z形遍历-x2F-锯齿形遍历" class="headerlink" title="Z形遍历&#x2F;锯齿形遍历"></a>Z形遍历&#x2F;锯齿形遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">Leetcode 103. 二叉树的锯齿形层次遍历（中等）</a><br>在层序遍历的基础上加了一个<code>reverse</code>标记，<code>reverse</code>为<code>true</code>时反向遍历。由于头和尾都要插入和弹出，使用双端队列<code>deque</code>会好一些，使用<code>vector</code>的<code>insert</code>比较耗时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    deque&lt;TreeNode *&gt; dque;</span><br><span class="line">    dque.push_back(root);</span><br><span class="line">    bool reverse = false;</span><br><span class="line">    while(!dque.empty())&#123;</span><br><span class="line">        int n = dque.size();</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        TreeNode *cur;</span><br><span class="line">        while(n--)&#123;</span><br><span class="line">            if(reverse)&#123;//后取前放</span><br><span class="line">                cur = dque.back();</span><br><span class="line">                dque.pop_back();</span><br><span class="line">                if(cur-&gt;right) dque.push_front(cur-&gt;right);//先右再左</span><br><span class="line">                if(cur-&gt;left) dque.push_front(cur-&gt;left);</span><br><span class="line">            &#125;else&#123;//前取后放</span><br><span class="line">                cur = dque.front();</span><br><span class="line">                dque.pop_front();</span><br><span class="line">                if(cur-&gt;left) dque.push_back(cur-&gt;left);//先左再右</span><br><span class="line">                if(cur-&gt;right) dque.push_back(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.push_back(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        reverse = !reverse;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h3 id="1-1028-从先序遍历还原二叉树（困难）"><a href="#1-1028-从先序遍历还原二叉树（困难）" class="headerlink" title="1. 1028. 从先序遍历还原二叉树（困难）"></a>1. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/">1028. 从先序遍历还原二叉树（困难）</a></h3><p>我们从二叉树的根节点 root 开始进行深度优先搜索。<br>在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。<br>如果节点只有一个子节点，那么保证该子节点为左子节点。<br>给出遍历输出 S，还原树并返回其根节点 root。</p>
<p>示例1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;1-2--3--4-5--6--7&quot;</span><br><span class="line">输出：[1,2,5,3,4,6,7]</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;1-2--3---4-5--6---7&quot;</span><br><span class="line">输出：[1,2,5,3,null,6,null,4,null,7]</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;1-401--349---90--88&quot;</span><br><span class="line">输出：[1,401,null,349,88,90]</span><br></pre></td></tr></table></figure>
<p>题解：<br>当前节点为T，上一个节点为S，只有两种情况：</p>
<ul>
<li>T 是 S 的左子节点；</li>
<li>T 是根节点到 S 这一条路径上（不包括 S，因为题目中规定了如果节点只有一个子节点，那么保证该子节点为左子节点）某一个节点的右子节点。</li>
</ul>
<p>所以，我们用一个栈保存<strong>根节点</strong>到当前节点的<strong>上一个节点</strong>的路径：</p>
<ol>
<li><strong>当前节点</strong>的深度刚好比<strong>栈的高度</strong>大1：<strong>当前节点</strong>正好是<strong>栈顶节点</strong>的<strong>左子节点</strong>；<em>ps. 深度是从0开始，所以当深度的值和栈高度相等时，就是深度刚好比栈的高度大1</em></li>
<li><strong>当前节点</strong>的深度小于等于<strong>栈的高度</strong>：<ul>
<li><strong>当前节点</strong>的深度刚和<strong>栈的高度</strong>相等：<strong>当前节点</strong>是<strong>栈顶节点右兄弟节点</strong>即<strong>栈顶节点父节点的右子节点</strong>；</li>
<li><strong>当前节点</strong>的深度小于<strong>栈的高度</strong>：<strong>当前节点</strong>是<strong>根节点</strong>到<strong>栈顶节点</strong>路径上某一个节点的<strong>右子节点</strong>。一直弹出栈顶节点直到满足情况<code>1</code>。</li>
<li>*ps. <strong>当前节点</strong>的深度刚和<strong>栈的高度</strong>相等 即 <code>level=path.size()-1</code>，也是需要弹出栈顶节点一次*<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* recoverFromPreorder(string S) &#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; path;</span><br><span class="line">    int pos = 0;</span><br><span class="line">    while(pos&lt;S.size())&#123;</span><br><span class="line">        int level = 0;</span><br><span class="line">        while(S[pos]==&#x27;-&#x27;)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int value = 0;</span><br><span class="line">        while (pos &lt; S.size() &amp;&amp; isdigit(S[pos]))&#123;//取当前节点的值</span><br><span class="line">            value = value * 10 + (S[pos] - &#x27;0&#x27;);</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *node = new TreeNode(value);</span><br><span class="line">        if(level==path.size())&#123;//第1种情况</span><br><span class="line">            if(!path.empty())</span><br><span class="line">                path.top()-&gt;left = node;</span><br><span class="line">        &#125;else&#123;//第2种情况</span><br><span class="line">            while(level!=path.size())</span><br><span class="line">                path.pop();</span><br><span class="line">            path.top()-&gt;right = node;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    while(path.size()&gt;1)</span><br><span class="line">        path.pop();</span><br><span class="line">    return path.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n)。n为S的长度<br>空间复杂度：O(h)。h为树的高度</li>
</ul>
</li>
</ol>
<h3 id="2-104-二叉树的最大深度（简单）"><a href="#2-104-二叉树的最大深度（简单）" class="headerlink" title="2. 104. 二叉树的最大深度（简单）"></a>2. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度（简单）</a></h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明</strong>: 叶子节点是指没有子节点的节点。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>层序遍历（BFS）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int maxDepth(TreeNode* root)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return 0;</span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">    que.push(root);</span><br><span class="line">    int hight = 0;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        hight++;</span><br><span class="line">        int n = que.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *curNode = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            if(curNode-&gt;left!=nullptr)</span><br><span class="line">                que.push(curNode-&gt;left);</span><br><span class="line">            if(curNode-&gt;right!=nullptr)</span><br><span class="line">                que.push(curNode-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return hight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
</li>
<li><p>递归。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int maxDepth(TreeNode* root)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return 0;</span><br><span class="line">    return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(hight)</p>
</li>
</ol>
<h3 id="3-110-平衡二叉树（简单）"><a href="#3-110-平衡二叉树（简单）" class="headerlink" title="3. 110. 平衡二叉树（简单）"></a>3. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树（简单）</a></h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回 true 。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   2</span><br><span class="line">    / \</span><br><span class="line">   3   3</span><br><span class="line">  / \</span><br><span class="line"> 4   4</span><br><span class="line">返回 false 。</span><br></pre></td></tr></table></figure>
<p>题解：<br>用到上一题的求深度。</p>
<ol>
<li><p>自上而下递归。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int getHight(TreeNode *root)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return 0;</span><br><span class="line">    return max(getHight(root-&gt;left),getHight(root-&gt;right))+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return true;</span><br><span class="line">    return abs(getHight(root-&gt;left)-getHight(root-&gt;right))&lt;2 </span><br><span class="line">            &amp;&amp; isBalanced(root-&gt;left)</span><br><span class="line">            &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)<br>空间复杂度：O(n)</p>
</li>
<li><p>自下而上递归。加了一个<code>hight</code>记录子树高度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bool helper(TreeNode *root, int &amp;height)&#123;</span><br><span class="line">    if(root==nullptr)&#123;</span><br><span class="line">        height = -1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int left,right;</span><br><span class="line">    if(helper(root-&gt;left,left) &amp;&amp; helper(root-&gt;right,right) &amp;&amp; abs(left-right)&lt;2)&#123;</span><br><span class="line">        height = max(left,right)+1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">    int height;</span><br><span class="line">    return helper(root,height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
</li>
</ol>
<h3 id="4-530-二叉搜索树的最小绝对差（简单）"><a href="#4-530-二叉搜索树的最小绝对差（简单）" class="headerlink" title="4. 530. 二叉搜索树的最小绝对差（简单）"></a>4. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差（简单）</a></h3><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    /</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。</span><br></pre></td></tr></table></figure>
<p>题解：<br>搜索二叉树的中序遍历就是升序排列，所以中序遍历是记录上一个节点的值，就可以求差值，维护一个最小值可以一边遍历得到答案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int res = INT_MAX;</span><br><span class="line">void midOrder(TreeNode* root, int &amp;last)&#123; //注意last要用引用，不然弹栈的时候上一个节点的值不能被记录</span><br><span class="line">    if(!root)</span><br><span class="line">        return;</span><br><span class="line">    midOrder(root-&gt;left, last);</span><br><span class="line">    if(last==-1)</span><br><span class="line">        last = root-&gt;val;</span><br><span class="line">    else</span><br><span class="line">        res = min(res, abs(root-&gt;val-last));</span><br><span class="line">    last = root-&gt;val;</span><br><span class="line">    midOrder(root-&gt;right, last);</span><br><span class="line">&#125;</span><br><span class="line">int getMinimumDifference(TreeNode* root) &#123;</span><br><span class="line">    int last = -1;</span><br><span class="line">    midOrder(root, last);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)，搜索二叉树可以会退化成链</p>
<h3 id="5-剑指-Offer-68-I-二叉搜索树的最近公共祖先（简单）"><a href="#5-剑指-Offer-68-I-二叉搜索树的最近公共祖先（简单）" class="headerlink" title="5. 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先（简单）"></a>5. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先（简单）</a></h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br><span class="line">    6</span><br><span class="line">   / \</span><br><span class="line">  2   8</span><br><span class="line"> /\   /\</span><br><span class="line">0  4 7  9</span><br><span class="line">  /\</span><br><span class="line"> 3  5</span><br></pre></td></tr></table></figure>
<p>题解：<br>要判断一个节点的左子树里有p，右子树里有q，那么当前节点就是最近公共祖先。从上往下遍历的时候，如果<code>(p-&gt;val &lt;= cur-&gt;val &amp;&amp; cur-&gt;val &lt;= q-&gt;val)</code>则说明该节点cur就是最近公共祖先了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">    while(root)&#123;</span><br><span class="line">        if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        else if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        else</span><br><span class="line">            return root;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h3 id="6-236-二叉树的最近公共祖先（中等）"><a href="#6-236-二叉树的最近公共祖先（中等）" class="headerlink" title="6. 236. 二叉树的最近公共祖先（中等）"></a>6. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先（中等）</a></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先 Lowest Common Ancestor(LCA)。上一题是二叉搜索树。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  5   1</span><br><span class="line"> /\   /\</span><br><span class="line">6  2 0  8</span><br><span class="line">  /\</span><br><span class="line"> 7  4</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>递归。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* ans;</span><br><span class="line">bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">    if (root == nullptr) return false;</span><br><span class="line">    bool lson = dfs(root-&gt;left, p, q);</span><br><span class="line">    bool rson = dfs(root-&gt;right, p, q);</span><br><span class="line">    if ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson)))&#123;// (左右都包含p/q) || (一边子树包含另p/q + 一边root节点是p/q)</span><br><span class="line">        ans = root;</span><br><span class="line">    &#125; </span><br><span class="line">    return lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val); //左子树包含||右子树包含||root为p/q</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">    dfs(root, p, q);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>可以用哈希表存储所有节点的父节点，然后就可以利用节点的父节点信息从 p 结点开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;int, TreeNode*&gt; parents;</span><br><span class="line">unordered_map&lt;int, bool&gt; visited;</span><br><span class="line">void dfs(TreeNode* root)&#123;//记录父节点</span><br><span class="line">    if (root-&gt;left != nullptr) &#123;</span><br><span class="line">        parents[root-&gt;left-&gt;val] = root;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    if (root-&gt;right != nullptr) &#123;</span><br><span class="line">        parents[root-&gt;right-&gt;val] = root;</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">    parents[root-&gt;val] = nullptr;</span><br><span class="line">    dfs(root);</span><br><span class="line">    while (p != nullptr) &#123;//从p往上走，也可以从q</span><br><span class="line">        visited[p-&gt;val] = true;</span><br><span class="line">        p = parents[p-&gt;val];</span><br><span class="line">    &#125;</span><br><span class="line">    while (q != nullptr) &#123;</span><br><span class="line">        if (visited[q-&gt;val]) return q;</span><br><span class="line">        q = parents[q-&gt;val];//从q往上走，碰到的第一个已经访问过的节点即为LCA节点</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h2 id="2-3-链表"><a href="#2-3-链表" class="headerlink" title="2.3 链表"></a>2.3 链表</h2><h3 id="面试题-02-01-移除重复节点（简单）"><a href="#面试题-02-01-移除重复节点（简单）" class="headerlink" title="面试题 02.01. 移除重复节点（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/">面试题 02.01. 移除重复节点（简单）</a></h3><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<p>示例1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1, 2, 3, 3, 2, 1]</span><br><span class="line">输出：[1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1, 1, 1, 1, 2]</span><br><span class="line">输出：[1, 2]</span><br></pre></td></tr></table></figure>
<p>题解：<br>用一个哈希表(<code>unordered_set</code>)保存已有元素。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ListNode* removeDuplicateNodes(ListNode* head) &#123;</span><br><span class="line">    if(head==nullptr || head-&gt;next==nullptr)</span><br><span class="line">        return head;</span><br><span class="line"></span><br><span class="line">    unordered_set&lt;int&gt; valSet;</span><br><span class="line">    ListNode *lastNode = head;</span><br><span class="line">    ListNode *cur = head-&gt;next;</span><br><span class="line">    valSet.insert(head-&gt;val);</span><br><span class="line">    while (cur != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if(valSet.find(cur-&gt;val) == valSet.end())&#123;//非重复节点</span><br><span class="line">            valSet.insert(cur-&gt;val);</span><br><span class="line">            lastNode-&gt;next = cur;</span><br><span class="line">            lastNode = lastNode-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;else&#123;//重复节点</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lastNode-&gt;next = cur;//nullptr</span><br><span class="line"></span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)  </p>
<p><em>ps. 在不允许用额外空间的情况下，可以用两重循环。时间O(n^2) ，空间o(1)。</em></p>
<h3 id="206-反转链表（简单）"><a href="#206-反转链表（简单）" class="headerlink" title="206. 反转链表（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表（简单）</a></h3><p>反转一个单链表。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>遍历反转。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">    if(head==nullptr || head-&gt;next==nullptr)</span><br><span class="line">        return head;</span><br><span class="line">    ListNode *pre = nullptr;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    while(cur!=nullptr)&#123;</span><br><span class="line">        ListNode *tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1) </p>
<ol start="2">
<li>递归。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">    if(head==nullptr || head-&gt;next==nullptr)</span><br><span class="line">        return head;</span><br><span class="line">    ListNode *cur = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = nullptr;</span><br><span class="line">    return cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h3 id="25-K-个一组翻转链表（困难）"><a href="#25-K-个一组翻转链表（困难）" class="headerlink" title="25. K 个一组翻转链表（困难）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表（困难）</a></h3><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</span><br><span class="line"></span><br><span class="line">当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;ListNode*, ListNode*&gt; reverseList(ListNode* head, ListNode* rear)&#123;</span><br><span class="line">    ListNode *pre = rear-&gt;next;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    while(pre != rear)&#123;</span><br><span class="line">        ListNode *tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;rear, head&#125;;//非递归反转链表并返回新链表头尾</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode* reverseKGroup(ListNode* head, int k) &#123;</span><br><span class="line">	ListNode *res = new ListNode(0);</span><br><span class="line">	res-&gt;next = head;</span><br><span class="line">	ListNode *preNode = res, *L = head;</span><br><span class="line">	ListNode *R, *nextNode;</span><br><span class="line">	while(L)&#123;</span><br><span class="line">		R = preNode;</span><br><span class="line">		for (int i = 0; i &lt; k; i++)&#123;  //选出要反转的k个</span><br><span class="line">			R = R-&gt;next;</span><br><span class="line">			if(R==nullptr)//剩下的不足k个直接返回</span><br><span class="line">				return res-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		nextNode = R-&gt;next;</span><br><span class="line">		auto ret = reverseList(L, R);</span><br><span class="line">		L = ret.first;</span><br><span class="line">		R = ret.second;</span><br><span class="line">        //把子链表重新接回原链表</span><br><span class="line">		preNode-&gt;next = L;</span><br><span class="line">		R-&gt;next = nextNode;</span><br><span class="line">		preNode = R;</span><br><span class="line">		L = R-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return res-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h3 id="92-反转链表-II（中等）"><a href="#92-反转链表-II（中等）" class="headerlink" title="92. 反转链表 II（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II（中等）</a></h3><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p><strong>说明</strong>:1 ≤ m ≤ n ≤ 链表长度。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>遍历交换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ListNode* reverseBetween(ListNode* head, int m, int n) &#123;</span><br><span class="line">    if(m==n)</span><br><span class="line">        return head;</span><br><span class="line">    if(m==1)&#123;</span><br><span class="line">        ListNode *lastRevers = head;</span><br><span class="line">        ListNode *pre = lastRevers;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        for(int i=m;i&lt;n;i++)&#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        lastRevers-&gt;next = cur;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        ListNode *before = head;</span><br><span class="line">        for(int i=1;i&lt;m-1;i++)</span><br><span class="line">            before = before-&gt;next;</span><br><span class="line">        ListNode *lastRevers = before-&gt;next;</span><br><span class="line">        ListNode *pre = lastRevers;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        for(int i=m;i&lt;n;i++)&#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        before-&gt;next = pre;</span><br><span class="line">        lastRevers-&gt;next = cur;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
</li>
<li><p>头插法。双指针，一个指针 A 指向要反转的前一个节点<code>m-1</code>，一个指针 B 指向要反转的第一个节点<code>m</code>。B在往后移动时，不停的把B后面的一个节点移到A后面，一直到<code>n-1</code>结束。这时已经反转了要求的链表。<br><em>ps. new一个节点指向头节点，就可以解决<code>m=1</code>的情况</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ListNode* reverseBetween(ListNode* head, int m, int n) &#123;</span><br><span class="line">    ListNode *preHead = new ListNode(0);</span><br><span class="line">    preHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    ListNode *A = preHead;</span><br><span class="line">    ListNode *B = head;</span><br><span class="line"></span><br><span class="line">    int step = 0;</span><br><span class="line">    while (step &lt; m - 1) &#123;</span><br><span class="line">        A = A-&gt;next; B = B-&gt;next;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n - m; i++) &#123;</span><br><span class="line">        ListNode *removed = B-&gt;next;</span><br><span class="line">        B-&gt;next = B-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        removed-&gt;next = A-&gt;next;</span><br><span class="line">        A-&gt;next = removed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return preHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
</li>
</ol>
<h3 id="142-环形链表-II（中等）"><a href="#142-环形链表-II（中等）" class="headerlink" title="142. 环形链表 II（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II（中等）</a></h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p><strong>说明</strong>：不允许修改给定的链表。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>哈希表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">    unordered_map&lt;ListNode*,int&gt; nodeMap;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    while(cur)&#123;</span><br><span class="line">        if(++nodeMap[cur]&gt;1)</span><br><span class="line">            return cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
</li>
<li><p>快慢指针。<br>快指针一次走2步，慢指针一次走一步。</p>
</li>
</ol>
<ul>
<li>快指针走到nullptr，说明无环</li>
<li>快指针慢指针第一次相遇节点记为<code>mark</code>，这时把慢指针移到头节点，快指针不变。他们都继续移动，都是一次走一步。当两个指针再次相遇时，就是头节点。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">    if(head == nullptr || head-&gt;next == nullptr)</span><br><span class="line">        return nullptr;</span><br><span class="line">    ListNode *fast = head, *slow = head;</span><br><span class="line">    do&#123;</span><br><span class="line">        if(fast == nullptr || fast-&gt;next == nullptr)</span><br><span class="line">            return nullptr;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;while(fast!=slow);</span><br><span class="line"></span><br><span class="line">    slow = head;</span><br><span class="line">    while(fast!=slow)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n)<br>空间复杂度：O(1)</li>
</ul>
<h2 id="2-4-图"><a href="#2-4-图" class="headerlink" title="2.4 图"></a>2.4 图</h2><h3 id="1-5211-概率最大的路径（中等）"><a href="#1-5211-概率最大的路径（中等）" class="headerlink" title="1. 5211. 概率最大的路径（中等）"></a>1. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-with-maximum-probability/">5211. 概率最大的路径（中等）</a></h3><p>给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 edges[i] &#x3D; [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。</p>
<p>指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。</p>
<p>如果不存在从 start 到 end 的路径，请 返回 0 。只要答案与标准答案的误差不超过 1e-5 ，就会被视作正确答案。</p>
<p>示例 1：<br><img src="https://i.loli.net/2020/07/12/GXVphrYafON5jFw.png" alt="ex1"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ul>
<li>先建图。<code>graph[i]</code> 表示第 <code>i</code> 个节点能够到达的下一个节点及概率。</li>
<li>bfs把与当前节点有连接的节点存入一个大根堆。（如果只用队列会出错）</li>
<li><code>hasVisited[i]</code> 表示 <code>i</code> 节点是否被访问过</li>
<li>循环直到堆为空</li>
</ul>
<p>其实就是 <code>Dijkstra</code> 算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const double zero = 1e-8;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;pair&lt;int,double&gt; &gt; &gt; buildGrapg(vector&lt;vector&lt;int&gt; &gt; &amp;edges, vector&lt;double&gt;&amp; succProb, int n)&#123;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;int,double&gt; &gt; &gt; graph(n);</span><br><span class="line">    for (int i = 0; i &lt; edges.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        graph[edges[i][0]].emplace_back(edges[i][1],succProb[i]);</span><br><span class="line">        graph[edges[i][1]].emplace_back(edges[i][0],succProb[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double maxProbability(int n, vector&lt;vector&lt;int&gt; &gt;&amp; edges, vector&lt;double&gt;&amp; succProb, int start, int end) &#123;</span><br><span class="line">    if(edges.empty())</span><br><span class="line">        return 0.0;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;int,double&gt; &gt; &gt; graph = buildGrapg(edges, succProb, n);</span><br><span class="line">    if(graph[end].empty() || graph[start].empty())</span><br><span class="line">        return 0.0;</span><br><span class="line"></span><br><span class="line">    vector&lt;double&gt; prob(n, 0.0); //从start到每个节点的最大概率</span><br><span class="line">    prob[start] = 1;</span><br><span class="line">    priority_queue&lt;pair&lt;double, int&gt; &gt; que;</span><br><span class="line">    vector&lt;bool&gt; hasVisited(n， false);</span><br><span class="line">    que.push(&#123;1, start&#125;);</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        auto cur = que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        double p = cur.first;</span><br><span class="line">        int node = cur.second;</span><br><span class="line">        if(hasVisited[node])</span><br><span class="line">            continue;</span><br><span class="line">        hasVisited[node] = true;</span><br><span class="line">        if(p&lt;zero)</span><br><span class="line">            continue;</span><br><span class="line">        for(auto edge:graph[node])&#123;</span><br><span class="line">            int v = edge.first;</span><br><span class="line">            double curProb = p * edge.second;</span><br><span class="line">            if(prob[v]&lt;curProb)&#123;</span><br><span class="line">                prob[v] = curProb;</span><br><span class="line">                que.push(&#123;prob[v], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return prob[end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-207-课程表（中等）有向图的拓扑排序"><a href="#2-207-课程表（中等）有向图的拓扑排序" class="headerlink" title="2. 207. 课程表（中等）有向图的拓扑排序"></a>2. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表（中等）</a>有向图的拓扑排序</h3><p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p>
<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。</span><br><span class="line">你可以假定输入的先决条件中没有重复的边。</span><br><span class="line">1 &lt;= numCourses &lt;= 10^5</span><br></pre></td></tr></table></figure>

<p>题解：  </p>
<ol>
<li>有向图的dfs遍历。<br><code>visited[i]</code>表示第i和节点的状态，0表示没有被访问过，1表示正在被访问，2表示访问结束的节点。<code>circle</code>表示有向图有环。使用dfs遍历有向图：</li>
</ol>
<ul>
<li>当正在访问的节点（visited[i]&#x3D;1）又被访问时，说明有向图存在环，返回false。</li>
<li>全部节点访问完毕，返回true<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bool circle = false;</span><br><span class="line"></span><br><span class="line">void dfs(int u, vector&lt;vector&lt;int&gt; &gt; &amp;graph, vector&lt;int&gt; &amp;visited)&#123;</span><br><span class="line">    visited[u] = 1;//正在访问该节点</span><br><span class="line">    for(int v:graph[u])&#123;</span><br><span class="line">        if(visited[v]==0)&#123;</span><br><span class="line">            dfs(v, graph, visited);</span><br><span class="line">            if(circle)</span><br><span class="line">                return;</span><br><span class="line">        &#125;else if(visited[v]==1)&#123;</span><br><span class="line">            circle = true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123;</span><br><span class="line">    if(prerequisites.empty())</span><br><span class="line">        return true;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graph(numCourses);</span><br><span class="line">    for (auto course : prerequisites)</span><br><span class="line">    &#123;//build graph</span><br><span class="line">        graph[course[1]].push_back(course[0]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; visited(numCourses);</span><br><span class="line">    for (int i = 0; i &lt; numCourses &amp;&amp; !circle; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visited[i])</span><br><span class="line">            dfs(i, graph, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    return !circle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(m+n)。m是有向图的边，n是有向图的节点。<br>空间复杂度：O(m+n)</li>
</ul>
<ol start="2">
<li>bfs入度为0的点<br>拓扑排序中，起点都是入度为0的点。把所有入度为0的节点放入队列，依次访问队列中的节点。访问的时候把所有从该节点出去的边都删掉，即该节点出发连接的边的入度都减1。再把入度减到0的点加入队列。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123;</span><br><span class="line">    if(prerequisites.empty())</span><br><span class="line">        return true;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graph(numCourses);</span><br><span class="line">    vector&lt;int&gt; inDegree(numCourses, 0);</span><br><span class="line">    for (auto course : prerequisites)</span><br><span class="line">    &#123;//build graph</span><br><span class="line">        graph[course[1]].push_back(course[0]);</span><br><span class="line">        inDegree[course[0]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    for (int i = 0; i &lt; numCourses;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(inDegree[i]==0)</span><br><span class="line">            que.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int visited = 0;</span><br><span class="line">    while (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        visited++;</span><br><span class="line">        int u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int v:graph[u])&#123;</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            if(inDegree[v]==0)</span><br><span class="line">                que.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return visited == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(m+n)。m是有向图的边，n是有向图的节点。<br>空间复杂度：O(m+n)</li>
</ol>
<h3 id="3-210-课程表-II（中等）"><a href="#3-210-课程表-II（中等）" class="headerlink" title="3.210. 课程表 II（中等）"></a>3.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II（中等）</a></h3><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p>
<p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: [0,1]</span><br><span class="line">解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。</span><br><span class="line">你可以假定输入的先决条件中没有重复的边。</span><br></pre></td></tr></table></figure>
<p>提示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</span><br><span class="line">通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</span><br><span class="line">拓扑排序也可以通过 BFS 完成。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>dfs。和上一题基本相同，只需要在节点访问完成时放入结果向量，因为dfs先访问的是最后的节点，所以需要把向量反转一下。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">bool circle = false;</span><br><span class="line">vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">void dfs(int u, vector&lt;vector&lt;int&gt; &gt; &amp;graph, vector&lt;int&gt; &amp;visited)&#123;</span><br><span class="line">    visited[u] = 1;//正在访问该节点</span><br><span class="line">    for(int v:graph[u])&#123;</span><br><span class="line">        if(visited[v]==0)&#123;</span><br><span class="line">            dfs(v, graph, visited);</span><br><span class="line">            if(circle)</span><br><span class="line">                return;</span><br><span class="line">        &#125;else if(visited[v]==1)&#123;</span><br><span class="line">            circle = true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = 2;</span><br><span class="line">    res.push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graph(numCourses);</span><br><span class="line">    for (auto course : prerequisites)</span><br><span class="line">    &#123;//build graph</span><br><span class="line">        graph[course[1]].push_back(course[0]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; visited(numCourses);</span><br><span class="line">    for (int i = 0; i &lt; numCourses &amp;&amp; !circle; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visited[i])</span><br><span class="line">            dfs(i, graph, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    if(circle)</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>bfs。同上题，只需要在节点访问完成时放入结果向量。时空复杂度与上题相同。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graph(numCourses);</span><br><span class="line">    vector&lt;int&gt; inDegree(numCourses, 0);</span><br><span class="line">    for (auto course : prerequisites)</span><br><span class="line">    &#123;//build graph</span><br><span class="line">        graph[course[1]].push_back(course[0]);</span><br><span class="line">        inDegree[course[0]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    for (int i = 0; i &lt; numCourses;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(inDegree[i]==0)</span><br><span class="line">            que.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    int visited = 0;</span><br><span class="line">    while (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        visited++;</span><br><span class="line">        int u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        res.push_back(u);</span><br><span class="line">        for (int v : graph[u])</span><br><span class="line">        &#123;</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            if(inDegree[v]==0)</span><br><span class="line">                que.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(visited!=numCourses)</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-133-克隆图（中等）"><a href="#4-133-克隆图（中等）" class="headerlink" title="4.133. 克隆图（中等）"></a>4.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/clone-graph/">133. 克隆图（中等）</a></h3><p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p>
<p>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>bfs</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Node* cloneGraph(Node* node) &#123;</span><br><span class="line">    if (node == nullptr) &#123;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line"></span><br><span class="line">    // 将题目给定的节点添加到队列</span><br><span class="line">    queue&lt;Node*&gt; que;</span><br><span class="line">    que.push(node);</span><br><span class="line">    // 克隆第一个节点并存储到哈希表中</span><br><span class="line">    visited[node] = new Node(node-&gt;val);</span><br><span class="line"></span><br><span class="line">    // 广度优先搜索</span><br><span class="line">    while (!que.empty()) &#123;</span><br><span class="line">        // 取出队列的头节点</span><br><span class="line">        auto curNode = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        // 遍历该节点的邻居</span><br><span class="line">        for (auto&amp; neighbor: curNode-&gt;neighbors) &#123;</span><br><span class="line">            if (visited.find(neighbor) == visited.end()) &#123;</span><br><span class="line">                // 如果没有被访问过，就克隆并存储在哈希表中</span><br><span class="line">                visited[neighbor] = new Node(neighbor-&gt;val);</span><br><span class="line">                // 将邻居节点加入队列中</span><br><span class="line">                que.push(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新当前节点的邻居列表</span><br><span class="line">            visited[curNode]-&gt;neighbors.emplace_back(visited[neighbor]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return visited[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>dfs<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line"></span><br><span class="line">Node* cloneGraph(Node* node) &#123;</span><br><span class="line">    if (node == nullptr) &#123;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(visited.find(node) != visited.end())</span><br><span class="line">        return visited[node];</span><br><span class="line"></span><br><span class="line">    Node *cloneNode = new Node(node-&gt;val);</span><br><span class="line">    visited[node] = cloneNode;</span><br><span class="line"></span><br><span class="line">    for(auto &amp;neighbor:node-&gt;neighbors)&#123;</span><br><span class="line">        cloneNode-&gt;neighbors.push_back(cloneGraph(neighbor));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return visited[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n)<br>空间复杂度：O(n)</li>
</ol>
<h2 id="2-5-堆"><a href="#2-5-堆" class="headerlink" title="2.5 堆"></a>2.5 堆</h2><h3 id="1-给一个数组h，h有n个元素；每次可以给数组h中最小的元素加x；总共可以加m次。求m次运算后的数组最小值。"><a href="#1-给一个数组h，h有n个元素；每次可以给数组h中最小的元素加x；总共可以加m次。求m次运算后的数组最小值。" class="headerlink" title="1. 给一个数组h，h有n个元素；每次可以给数组h中最小的元素加x；总共可以加m次。求m次运算后的数组最小值。"></a>1. 给一个数组<code>h</code>，<code>h</code>有<code>n</code>个元素；每次可以给数组<code>h</code>中最小的元素加<code>x</code>；总共可以加<code>m</code>次。求<code>m</code>次运算后的数组最小值。</h3><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：a = &#123;1,2,3&#125;, n = 3, x = 1, m =2</span><br><span class="line"></span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p>题解：<br>维护一个小根堆。每次从堆顶取出最小值，加上<code>x</code>后在放入堆中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int minimalAfterAdd(vector&lt;int&gt; &amp;h, int n, int m, int x)&#123;</span><br><span class="line">    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; pq;</span><br><span class="line">    for(int i:h)</span><br><span class="line">        pq.push(i);</span><br><span class="line"></span><br><span class="line">    while(m&gt;0)&#123;</span><br><span class="line">        int tmp = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        pq.push(tmp + x);</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pq.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-重复数组变换"><a href="#2-重复数组变换" class="headerlink" title="2. 重复数组变换"></a>2. 重复数组变换</h3><p><img src="https://i.loli.net/2020/07/29/N1O2xGlCm54yuQI.png" alt="堆例题"></p>
<p>题解：<br>用一个<code>map&lt;int,索引小根堆&gt;</code>来保存数组元素和索引。map是默认是按key升序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">bool repeat(map&lt;int, priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; &gt; &amp;numMap, map&lt;int, priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; &gt;::iterator &amp;iter)&#123;</span><br><span class="line">    /*检查有没有重复的元素，并返回了重复元素的 it*/</span><br><span class="line">    for (auto it = numMap.begin(); it != numMap.end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(it-&gt;second.size()&gt;1)&#123;</span><br><span class="line">            iter = it;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; delRepeat(vector&lt;int&gt; &amp;a)&#123;</span><br><span class="line">    int n = a.size();</span><br><span class="line">    //map&lt;元素，索引小根堆&gt;</span><br><span class="line">    map&lt;int, priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; &gt; numMap;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">        numMap[a[i]].push(i);</span><br><span class="line"></span><br><span class="line">    auto it = numMap.begin();</span><br><span class="line">    while (repeat(numMap,it))</span><br><span class="line">    &#123;</span><br><span class="line">        //it: &#123;第一个重复的元素,索引堆&#125;</span><br><span class="line">        it-&gt;second.pop();</span><br><span class="line">        int idx = it-&gt;second.top();</span><br><span class="line">        it-&gt;second.pop();</span><br><span class="line">        numMap[it-&gt;first * 2].push(idx);</span><br><span class="line">        a[idx] *= 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set&lt;int&gt; sIdx;</span><br><span class="line">    for (auto m : numMap)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!m.second.empty())&#123;</span><br><span class="line">            sIdx.insert(m.second.top());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for(int i:sIdx)&#123;</span><br><span class="line">        res.push_back(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、算法类例题"><a href="#三、算法类例题" class="headerlink" title="三、算法类例题"></a>三、算法类例题</h1><p>主要从Leetcode的题中选出的代表性例题，也包括笔试或者其他资料上看到的比较好的题目。<br><em>ps: 题解使用的 <code>cpp</code></em>  </p>
<h2 id="3-1-分治算法（Divide-and-conquer）"><a href="#3-1-分治算法（Divide-and-conquer）" class="headerlink" title="3.1 分治算法（Divide and conquer）"></a>3.1 分治算法（Divide and conquer）</h2><h3 id="Leetcode-241-为运算表达式设计优先级（中等）"><a href="#Leetcode-241-为运算表达式设计优先级（中等）" class="headerlink" title="Leetcode 241. 为运算表达式设计优先级（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">Leetcode 241. 为运算表达式设计优先级（中等）</a></h3><p>给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;2-1-1&quot; </span><br><span class="line">((2-1)-1) = 0</span><br><span class="line">(2-(1-1)) = 2</span><br><span class="line">Output : [0, 2]</span><br></pre></td></tr></table></figure>
<p>题解：<br>符号分开成左右两边，递归求出左右两边的结果，再排列组合成新结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; diffWaysToCompute(string s)&#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for (int i = 0; i &lt; s.size();i++)&#123;</span><br><span class="line">        if(s[i]==&#x27;+&#x27; || s[i]==&#x27;-&#x27; || s[i]==&#x27;*&#x27;)&#123;</span><br><span class="line">            vector&lt;int&gt; left = diffWaysToCompute(s.substr(0, i));</span><br><span class="line">            vector&lt;int&gt; right = diffWaysToCompute(s.substr(i + 1));</span><br><span class="line">            for(int l:left)&#123;</span><br><span class="line">                for(int r:right)&#123;</span><br><span class="line">                    if(s[i]==&#x27;+&#x27;)&#123;</span><br><span class="line">                        res.push_back(l + r);</span><br><span class="line">                    &#125;else if (s[i] == &#x27;-&#x27;)&#123;</span><br><span class="line">                        res.push_back(l - r);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (s[i] == &#x27;*&#x27;)&#123;</span><br><span class="line">                        res.push_back(l * r);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(res.empty())</span><br><span class="line">        res.push_back(stoi(s));</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Leetcode-95-不同的二叉搜索树-II（中等）"><a href="#Leetcode-95-不同的二叉搜索树-II（中等）" class="headerlink" title="Leetcode 95. 不同的二叉搜索树 II（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">Leetcode 95. 不同的二叉搜索树 II（中等）</a></h3><p>给定一个数字 n，要求生成所有值为 1…n 的二叉搜索树。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input: 3  </span><br><span class="line">Output:  </span><br><span class="line">[ </span><br><span class="line">  [1,null,3,2],  </span><br><span class="line">  [3,2,null,1],  </span><br><span class="line">  [3,1,null,null,2],  </span><br><span class="line">  [2,1,3],  </span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Explanation:  </span><br><span class="line">The above output corresponds to the 5 unique BST&#x27;s shown below:  </span><br><span class="line"></span><br><span class="line">1         3     3      2      1  </span><br><span class="line"> \       /     /      / \      \  </span><br><span class="line">  3     2     1      1   3      2  </span><br><span class="line"> /     /       \                 \  </span><br><span class="line">2     1         2                 3   </span><br></pre></td></tr></table></figure>

<p>题解：<br>把每一个节点当作父节点，递归求解左右子数，在把每个左右子树组合起来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;TreeNode *&gt; generateTreesCore(int start, int end)&#123;</span><br><span class="line">    if(start &gt; end)</span><br><span class="line">        return &#123;nullptr&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;TreeNode *&gt; res;</span><br><span class="line">    for (int i = start; i &lt;= end;i++)&#123;</span><br><span class="line">        vector&lt;TreeNode *&gt; left = generateTreesCore(start, i - 1);</span><br><span class="line">        vector&lt;TreeNode *&gt; right = generateTreesCore(i + 1, end);</span><br><span class="line">        for(auto l:left)&#123;</span><br><span class="line">            for(auto r:right)&#123;</span><br><span class="line">                TreeNode *root = new TreeNode(i);</span><br><span class="line">                root-&gt;left = l;</span><br><span class="line">                root-&gt;right = r;</span><br><span class="line">                res.push_back(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;TreeNode *&gt; generateTrees(int n)&#123;</span><br><span class="line">    if(n==0)</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    return generateTreesCore(1, n);</span><br><span class="line">    cout &lt;&lt; &quot;visual tree by debug.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-动态规划（Dynamic-programming）"><a href="#3-2-动态规划（Dynamic-programming）" class="headerlink" title="3.2 动态规划（Dynamic programming）"></a>3.2 动态规划（Dynamic programming）</h2><p><code>递归</code>和<code>动态规划</code>都是将原问题拆成多个子问题然后求解，他们之间最本质的<code>区别</code>是，动态规划保存了子问题的解，避免重复计算。<br>递归一般是<code>自上而下</code>——从愿问题开始，逐步往下求解；动态规划一般是<code>自下而上</code>——从最小子问题开始，逐步扩大问题规模。<br>（这里写一个动态规划算法伪代码模版） </p>
<h3 id="3-2-1-斐波那契数列（fabonacci）"><a href="#3-2-1-斐波那契数列（fabonacci）" class="headerlink" title="3.2.1 斐波那契数列（fabonacci）"></a>3.2.1 斐波那契数列（fabonacci）</h3><h4 id="Leetcode-70-爬楼梯（简单）"><a href="#Leetcode-70-爬楼梯（简单）" class="headerlink" title="Leetcode 70. 爬楼梯（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">Leetcode 70. 爬楼梯（简单）</a></h4><p>题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。  </p>
<p>题解：<br>dp。dp[i] 表示走到第 i 个楼梯的方法数目。第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。<br><code>dp[i] = dp[i - 1] + dp[i - 2]</code></p>
<ol>
<li>空间复杂度O(n)的方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int climbStairs(int n)&#123;</span><br><span class="line">    vector&lt;int&gt; dp(n+1, 1);//dp[0]=1, dp[1]=1</span><br><span class="line">    for (int i = 2; i &lt;= n;i++)</span><br><span class="line">        dp[i] = dp[i - 1] + dp[i - 2];</span><br><span class="line"></span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>空间复杂度O(1)的方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int climbStairs(int n)&#123;</span><br><span class="line">    vector&lt;int&gt; dp(3, 1);//dp[0]=1, dp[1]=1</span><br><span class="line">    for (int i = 2; i &lt;= n;i++)&#123;</span><br><span class="line">        dp[2] = dp[1] + dp[0];</span><br><span class="line">        dp[0] = dp[1];</span><br><span class="line">        dp[1] = dp[2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-198-打家劫舍（简单）"><a href="#Leetcode-198-打家劫舍（简单）" class="headerlink" title="Leetcode 198. 打家劫舍（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">Leetcode 198. 打家劫舍（简单）</a></h4><p>题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure>

<p>题解：<br>dp。dp[i] 表示抢到第 i 个住户时的最大抢劫量。由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以：<br><code>dp[i] = max(dp[i-2]+nums[i],dp[i-1])</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    if(n==0)</span><br><span class="line">        return 0;</span><br><span class="line">    vector&lt;int&gt; dp(3, 0);</span><br><span class="line">    dp[1] = nums[0];</span><br><span class="line">    for (int i = 2; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[2] = max(dp[0] + nums[i - 1], dp[1]);</span><br><span class="line">        dp[0] = dp[1];</span><br><span class="line">        dp[1] = dp[2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[1];//防止只有一个元素的情况</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-213-House-Robber-II-（中等）"><a href="#Leetcode-213-House-Robber-II-（中等）" class="headerlink" title="Leetcode 213. House Robber II （中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-ii/">Leetcode 213. House Robber II （中等）</a></h4><p>强盗在环形街区抢劫</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>
<p>题解：<br>在上一题的基础上，分成两个数组，一个包含第一家不包含最后一家，另一个不包含第一家但包含最后一家。分别 dp 求 max。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int helper(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    if(n==0)</span><br><span class="line">        return 0;</span><br><span class="line">    vector&lt;int&gt; dp(3, 0);</span><br><span class="line">    dp[1] = nums[0];</span><br><span class="line">    for (int i = 2; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[2] = max(dp[0] + nums[i - 1], dp[1]);</span><br><span class="line">        dp[0] = dp[1];</span><br><span class="line">        dp[1] = dp[2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int rob(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">    if(nums.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    if(nums.size()==1)</span><br><span class="line">        return nums[0];</span><br><span class="line">    vector&lt;int&gt; nums1(nums.begin(), nums.end() - 1);</span><br><span class="line">    vector&lt;int&gt; nums2(nums.begin()+1, nums.end());</span><br><span class="line">    return max(helper(nums1), helper(nums2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(2n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-634-寻找数组的错位排列（中等，会员题）"><a href="#Leetcode-634-寻找数组的错位排列（中等，会员题）" class="headerlink" title="Leetcode 634. 寻找数组的错位排列（中等，会员题）"></a>Leetcode 634. 寻找数组的错位排列（中等，会员题）</h4><p>题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量（所有信封都没有装各自的信）。</p>
<p>题解：<br>定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。</p>
<p>假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：</p>
<ul>
<li><code>i == k</code>，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 <code>dp[i-2]</code> 种错误装信的方式。<br>由于 j 有 i-1 种取值，因此共有 <code>(i-1)*dp[i-2]</code> 种错误装信方式。</li>
<li><code>i != k</code>，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 <code>dp[i-1]</code> 种错误装信方式。<br>由于 j 有 i-1 种取值，因此共有 <code>(i-1)*dp[i-1]</code> 种错误装信方式。</li>
</ul>
<p><code>dp[i] = (i-1)*dp[i-2] + (i-1)*dp[i-1]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int wrongLetterRank(int n)&#123;</span><br><span class="line">    if(n&lt;2)</span><br><span class="line">        return n;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; dp(3, 0);</span><br><span class="line">    dp[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= n;i++)&#123;</span><br><span class="line">        dp[2] = (i - 1) * dp[0] + (i - 1) * dp[1];</span><br><span class="line">        dp[0] = dp[1];</span><br><span class="line">        dp[1] = dp[2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="母牛生小牛问题"><a href="#母牛生小牛问题" class="headerlink" title="母牛生小牛问题"></a>母牛生小牛问题</h4><p>题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。  </p>
<p>题解：<br><code>dp[i]</code>表示第 i 年成熟的牛的数量：</p>
<ul>
<li><code>dp[i] = dp[i-1] + dp[i-3]</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int cowProduce(int n)&#123;</span><br><span class="line">    if(n&lt;=4)</span><br><span class="line">        return n;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; dp(4, 1); //dp[0] = 1;</span><br><span class="line">    dp[1] = 2;</span><br><span class="line">    dp[2] = 3;</span><br><span class="line">    for (int i = 4; i &lt;= n;i++)&#123;</span><br><span class="line">        dp[3] = dp[2] + dp[0];</span><br><span class="line">        dp[0] = dp[1];</span><br><span class="line">        dp[1] = dp[2];</span><br><span class="line">        dp[2] = dp[3];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n)<br>空间复杂度：O(1)</li>
</ul>
<h3 id="3-2-2-二维dp：二维网格路径问题"><a href="#3-2-2-二维dp：二维网格路径问题" class="headerlink" title="3.2.2 二维dp：二维网格路径问题"></a>3.2.2 二维dp：二维网格路径问题</h3><h4 id="Leetcode-64-最小路径和（中等）"><a href="#Leetcode-64-最小路径和（中等）" class="headerlink" title="Leetcode 64. 最小路径和（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/">Leetcode 64. 最小路径和（中等）</a></h4><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明</strong>：每次只能向下或者向右移动一步。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">    [1,3,1],  </span><br><span class="line">    [1,5,1],  </span><br><span class="line">    [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>二维dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int minPathSum(vector&lt;vector&lt;int&gt; &gt;&amp; grid) &#123;</span><br><span class="line">    if(grid.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int m = grid.size(), n = grid[0].size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(m, vector&lt;int&gt;(n,0));</span><br><span class="line"></span><br><span class="line">    dp[0][0] = grid[0][0];</span><br><span class="line">    for (int i = 1; i &lt; m; i++)</span><br><span class="line">        dp[i][0] = dp[i-1][0] + grid[i][0];</span><br><span class="line">    for (int j = 1; j &lt; n; j++)</span><br><span class="line">        dp[0][j] = dp[0][j-1] + grid[0][j];</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt; m;i++)&#123;</span><br><span class="line">        for (int j = 1; j &lt; n;j++)&#123;</span><br><span class="line">            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m - 1][n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m*n)<br>空间复杂度：O(m*n)</p>
<ol start="2">
<li>一维dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int minPathSum(vector&lt;vector&lt;int&gt; &gt;&amp; grid) &#123;</span><br><span class="line">    if(grid.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int m = grid.size(), n = grid[0].size();</span><br><span class="line">    vector&lt;int&gt; dp(n, 0);</span><br><span class="line"></span><br><span class="line">    dp[0] = grid[0][0];</span><br><span class="line">    for(int i = 1;i&lt;n;i++)</span><br><span class="line">        dp[i] = dp[i - 1] + grid[0][i];</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; m; i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">            if(j == 0)</span><br><span class="line">                dp[j] = dp[j] + grid[i][0];</span><br><span class="line">            else</span><br><span class="line">                dp[j] = min(dp[j - 1], dp[j]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m*n)<br>空间复杂度：O(n)</p>
<h4 id="Leetcode-62-不同路径（中等）"><a href="#Leetcode-62-不同路径（中等）" class="headerlink" title="Leetcode 62. 不同路径（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">Leetcode 62. 不同路径（中等）</a></h4><p>题目描述：统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移</p>
<ul>
<li><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code> 只用一行存储，空间复杂度可以优化为O(col)</li>
<li>也可以直接用数学公式求解，这是一个组合问题。<br>机器人总共移动的次数 S&#x3D;m+n-2，向下移动的次数 D&#x3D;m-1，那么问题可以看成从 S 中取出 D 个位置的组合数量，这个问题的解为 C(S, D)。</li>
</ul>
<p>题解：<br>一维dp。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int uniquePaths(int m, int n) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(n + 1, 1); //dp[0]==1  最左边一列都是1</span><br><span class="line">    for (int i = 1; i &lt; m;i++)&#123;//从第二行开始</span><br><span class="line">        for (int j = 1; j &lt; n;j++)</span><br><span class="line">            dp[j] = dp[j - 1] + dp[j];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m*n)<br>空间复杂度：O(n)</p>
<h3 id="3-2-3-子序列-x2F-子集-x2F-子数组-x2F-子矩阵"><a href="#3-2-3-子序列-x2F-子集-x2F-子数组-x2F-子矩阵" class="headerlink" title="3.2.3 子序列&#x2F;子集&#x2F;子数组&#x2F;子矩阵"></a>3.2.3 子序列&#x2F;子集&#x2F;子数组&#x2F;子矩阵</h3><p><strong>！！！注意！！！</strong>：<code>子序列</code> 和 <code>子串</code>并不相等，子序列&#x2F;子集可以不连续，字串是连续的。</p>
<h4 id="Leetcode-303-区域和检索-数组不可变（简单）"><a href="#Leetcode-303-区域和检索-数组不可变（简单）" class="headerlink" title="Leetcode 303. 区域和检索 - 数组不可变（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-immutable/">Leetcode 303. 区域和检索 - 数组不可变（简单）</a></h4><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure>
<p>题解：<br>前缀和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class NumArray &#123;</span><br><span class="line">public:</span><br><span class="line">    NumArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sums = new int[nums.size() + 1];</span><br><span class="line">        sums[0] = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.size();i++)</span><br><span class="line">            sums[i + 1] = sums[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~NumArray() &#123; delete[] sums; &#125;</span><br><span class="line"></span><br><span class="line">    int sumRange(int i, int j) &#123;</span><br><span class="line">        return sums[j + 1] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int *sums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-413-等差数列划分（中等）"><a href="#Leetcode-413-等差数列划分（中等）" class="headerlink" title="Leetcode 413. 等差数列划分（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/arithmetic-slices/">Leetcode 413. 等差数列划分（中等）</a></h4><p>函数要返回数组 A 中所有为等差数组的子数组个数。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A = [0, 1, 2, 3, 4]  </span><br><span class="line">return: 6, for 3 arithmetic slices in A:  </span><br><span class="line">[0, 1, 2],  </span><br><span class="line">[1, 2, 3],  </span><br><span class="line">[0, 1, 2, 3],  </span><br><span class="line">[0, 1, 2, 3, 4],  </span><br><span class="line">[ 1, 2, 3, 4],  </span><br><span class="line">[2, 3, 4]  </span><br></pre></td></tr></table></figure>
<p>题解：<br>dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。</p>
<p>当 A[i] - A[i-1] &#x3D;&#x3D; A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。  </p>
<p>dp[2] &#x3D; 1<br>[0, 1, 2]  </p>
<p>dp[3] &#x3D; dp[2] + 1 &#x3D; 2<br>[0, 1, 2, 3], &#x2F;&#x2F; [0, 1, 2] 之后加一个 3<br>[1, 2, 3]     &#x2F;&#x2F; 新的递增子区间  </p>
<p>dp[4] &#x3D; dp[3] + 1 &#x3D; 3<br>[0, 1, 2, 3, 4], &#x2F;&#x2F; [0, 1, 2, 3] 之后加一个 4<br>[1, 2, 3, 4],    &#x2F;&#x2F; [1, 2, 3] 之后加一个 4<br>[2, 3, 4]        &#x2F;&#x2F; 新的递增子区间  </p>
<p>综上，在 A[i] - A[i-1] &#x3D;&#x3D; A[i-1] - A[i-2] 时，dp[i] &#x3D; dp[i-1] + 1。因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 dp 数组累加的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A)&#123;</span><br><span class="line">    if(A.size()&lt;3)</span><br><span class="line">        return 0;</span><br><span class="line">    vector&lt;int&gt; dp(A.size(), 0);</span><br><span class="line">    for (int i = 2; i &lt; dp.size(); i++)&#123;</span><br><span class="line">        if(A[i]-A[i-1] == A[i-1]-A[i-2])</span><br><span class="line">            dp[i] = dp[i - 1] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for(auto dpi:dp)&#123;</span><br><span class="line">        res += dpi;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h4 id="Leetcode-343-整数拆分（中等）"><a href="#Leetcode-343-整数拆分（中等）" class="headerlink" title="Leetcode 343. 整数拆分（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/integer-break/">Leetcode 343. 整数拆分（中等）</a></h4><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<p>就是割绳子问题，剑指offer也有</p>
<p>For example, given n &#x3D; 2, return 1 (2 &#x3D; 1 + 1); given n &#x3D; 10, return 36 (10 &#x3D; 3 + 3 + 4). </p>
<p>题解：<br>dp。<code>dp[i]</code>表示 i 能分割出的最大积</p>
<p>当 <code>i ≥ 2</code> 时，假设对正整数 i 拆分出的其中一个正整数是 <code>j(1 ≤ j &lt; i)</code>，则有两种情况：</p>
<ul>
<li>将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 <code>j×(i−j)</code>；</li>
<li>将 i 拆分成 j 和 i-j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 <code>j×dp[i−j]</code>。</li>
</ul>
<p>当固定时：<code>dp[i] = max(j * dp[i - j], j * (i - j))</code>，所以遍历 j 的可能值，就可以求出 dp[i]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int integerBreak(int n)&#123;</span><br><span class="line">    vector&lt;int&gt; dp(n+1,0);</span><br><span class="line">    for (int i = 2; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(n)</p>
<h4 id="Leetcode-279-完全平方数（中等）"><a href="#Leetcode-279-完全平方数（中等）" class="headerlink" title="Leetcode 279. 完全平方数（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">Leetcode 279. 完全平方数（中等）</a></h4><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>For example, given n &#x3D; 12, return 3 because 12 &#x3D; 4 + 4 + 4;<br>given n &#x3D; 13, return 2 because 13 &#x3D; 4 + 9.  </p>
<p>题解：<br>dp。dp[i]表示组成和的完全平方数最少的个数：</p>
<ul>
<li><code>dp[i] = dp[i-sqr] + 1</code></li>
</ul>
<p>可以用四平方定理减少运算次数：任何一个正整数都可以表示成不超过四个整数的平方之和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int numSquares(int n) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(n + 1, 5); //四平方定理</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n;i++)&#123;</span><br><span class="line">        for (int j = 1; j * j &lt;= i;j++)&#123;</span><br><span class="line">            dp[i] = min(dp[i], dp[i - j * j] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n * √n)<br>空间复杂度：O(n)</p>
<h4 id="Leetcode-91-解码方法（中等）"><a href="#Leetcode-91-解码方法（中等）" class="headerlink" title="Leetcode 91.解码方法（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-ways/">Leetcode 91.解码方法（中等）</a></h4><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;A&#x27; -&gt; 1</span><br><span class="line">&#x27;B&#x27; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#x27;Z&#x27; -&gt; 26</span><br></pre></td></tr></table></figure>
<p>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p>
<p>Given encoded message “12”, return 2<br>It could be decoded as “AB” (1 2) or “L” (12). The number of ways decoding “12” is 2.</p>
<p>题解：<br>二维dp。dp[i]表示前i个字符有几种解码方式。分几种情况：</p>
<ul>
<li>s[i-1]!&#x3D;0 &amp;&amp; s[i-2]&#x3D;&#x3D;0 如“101”，最近两位为”01”不能解码，所以dp[i] &#x3D; dp[i-1]</li>
<li>s[i-1]&#x3D;&#x3D;0 &amp;&amp; s[i-2]&#x3D;&#x3D;0 即有两个连续的零，如“100” 则不可能转为字符，dp[i] &#x3D; 0</li>
<li>dp[i-2]dp[i-1]组成的数字 &gt;26：dp[i] &#x3D; dp[i-1]</li>
<li>dp[i-2]dp[i-1]组成的数字 &lt;&#x3D;26：dp[i] &#x3D; dp[i-1] + dp[i-2]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int numDecodings(string s)&#123;</span><br><span class="line">    vector&lt;int&gt; dp(s.size()+1, 0);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    dp[1] = s[0] == &#x27;0&#x27; ? 0 : 1;</span><br><span class="line">    for (int i = 2; i &lt;= s.size();i++)&#123;</span><br><span class="line">        //s[i-1]!=0 &amp;&amp; s[i-2]==0 如“101”，最近两位为&quot;01&quot;不能解码，所以dp[i] = dp[i-1];</span><br><span class="line">        //s[i-1]==0 &amp;&amp; s[i-2]==0 即有两个连续的零，如“100” 则不可能转为字符，dp[i] = 0。</span><br><span class="line">        if(s[i-1]!=&#x27;0&#x27;)</span><br><span class="line">            dp[i] = dp[i - 1];</span><br><span class="line">        if(s[i-2]==&#x27;0&#x27;)</span><br><span class="line">            continue;</span><br><span class="line">        //根据最近两位的大小判断能不能解码</span><br><span class="line">        int two = stoi(s.substr(i - 2, 2)); //= (s[i - 1] - &#x27;0&#x27;) * 10 + (s[i] - &#x27;0&#x27;);</span><br><span class="line">        if (two &lt;= 26)</span><br><span class="line">            dp[i] += dp[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n)<br>空间复杂度：O(n)</li>
</ul>
<p>一维dp。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int numDecodings(string s)&#123;</span><br><span class="line">    vector&lt;int&gt; dp(3, 0);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    dp[1] = s[0] == &#x27;0&#x27; ? 0 : 1;</span><br><span class="line">    for (int i = 2; i &lt;= s.size();i++)&#123;</span><br><span class="line">        //s[i-1]!=0 &amp;&amp; s[i-2]==0 如“101”，最近两位为&quot;01&quot;不能解码，所以dp[i] = dp[i-1];</span><br><span class="line">        //s[i-1]==0 &amp;&amp; s[i-2]==0 即有两个连续的零，如“100” 则不可能转为字符，dp[i] = 0。</span><br><span class="line">        dp[2] = 0;</span><br><span class="line">        if(s[i - 1] != &#x27;0&#x27;)</span><br><span class="line">            dp[2] = dp[1];</span><br><span class="line">        if (s[i - 2] == &#x27;0&#x27;)&#123;</span><br><span class="line">            dp[0] = dp[1];</span><br><span class="line">            dp[1] = dp[2];</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //根据最近两位的大小判断能不能解码</span><br><span class="line">        int two = stoi(s.substr(i - 2, 2)); //= (s[i - 1] - &#x27;0&#x27;) * 10 + (s[i] - &#x27;0&#x27;);</span><br><span class="line">        if (two &lt;= 26)</span><br><span class="line">            dp[2] += dp[0];</span><br><span class="line">        dp[0] = dp[1];</span><br><span class="line">        dp[1] = dp[2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="和为-k-的-子序列-x2F-子数组"><a href="#和为-k-的-子序列-x2F-子数组" class="headerlink" title="和为 k 的 子序列&#x2F;子数组"></a>和为 k 的 子序列&#x2F;子数组</h4><h5 id="和为-k-的-子数组"><a href="#和为-k-的-子数组" class="headerlink" title="和为 k 的 子数组"></a>和为 k 的 子数组</h5><ol>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">Leetcode 560. 和为K的子数组（中等）</a></li>
</ol>
<p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p>示例 1 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:nums = [1,1,1], k = 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure>
<p>题解：<br>前缀和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int subArrySumCnt(vector&lt;int&gt; &amp;A, int &amp;d)&#123;</span><br><span class="line">    unordered_map&lt;int, int&gt; umap; //key:前缀和  val:出现次数</span><br><span class="line">    int pre = 0, cnt = 0;</span><br><span class="line">    umap[0] = 1;</span><br><span class="line">    for (int &amp;a : A)&#123;</span><br><span class="line">        pre += a;</span><br><span class="line">        if(umap.find(pre-d) != umap.end())</span><br><span class="line">            cnt += umap[pre - d];</span><br><span class="line">        umap[pre]++;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>在 <code>1.</code> 的基础上，输出每一个子数组</li>
</ol>
<p>题解：<br>保留索引的前缀和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; subArrySum(vector&lt;int&gt; &amp;A, int &amp;d)&#123;</span><br><span class="line">    unordered_map&lt;int, vector&lt;pair&lt;int,int&gt; &gt; &gt; umap; //key:前缀和  val:出现的开始和结束索引 序列</span><br><span class="line">    int pre = 0;</span><br><span class="line">    umap[0].push_back(&#123;0, -1&#125;);</span><br><span class="line">    vector&lt;pair&lt;int, int&gt; &gt; idxs;</span><br><span class="line">    for (int i = 0; i &lt; A.size(); i++)&#123;</span><br><span class="line">        pre += A[i];</span><br><span class="line">        if(umap.find(pre-d) != umap.end())&#123;</span><br><span class="line">            for(auto &amp;p : umap[pre-d])//记录满足的索引</span><br><span class="line">                idxs.push_back(&#123;p.second + 1, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        umap[pre].push_back(&#123;0, i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    for(auto &amp;idx : idxs)&#123;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        for (int i = idx.first; i &lt;= idx.second; i++)</span><br><span class="line">            tmp.push_back(A[i]);</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="和为-k-的-子集合-x2F-子序列"><a href="#和为-k-的-子集合-x2F-子序列" class="headerlink" title="和为 k 的 子集合&#x2F;子序列"></a>和为 k 的 子集合&#x2F;子序列</h5><p>题解：<br>剪枝回溯，当和<code>&gt;k</code>时丢弃该分支。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">set&lt;vector&lt;int&gt; &gt; resSet;</span><br><span class="line"></span><br><span class="line">void backtracking(vector&lt;int&gt; &amp;pre, int preSum, int idx, vector&lt;int&gt; &amp;nums, int &amp;k)&#123;</span><br><span class="line">    if(preSum &gt; k)</span><br><span class="line">        return;</span><br><span class="line">    if(preSum == k)&#123;</span><br><span class="line">        sort(pre.begin(), pre.end());</span><br><span class="line">        resSet.insert(pre);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int curSum = preSum;</span><br><span class="line">    for (int i = idx; i &lt; nums.size(); i++)&#123;</span><br><span class="line">        pre.push_back(nums[i]);</span><br><span class="line">        curSum += nums[i];</span><br><span class="line">        backtracking(pre, curSum, i + 1, nums, k);</span><br><span class="line">        curSum -= nums[i];</span><br><span class="line">        pre.erase(pre.end() - 1, pre.end());</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; subSetSum(vector&lt;int&gt; &amp;nums, int &amp;k)&#123;//子集</span><br><span class="line">    vector&lt;int&gt; pre;</span><br><span class="line">    backtracking(pre, 0, 0, nums, k);</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res(resSet.begin(), resSet.end());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h4><p>&amp;emsp;&amp;emsp;已知一个序列 {S1, S2,…,Sn}，取出若干数组成新的序列 {Si1, Si2,…, Sim}，其中 i1、i2 … im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个子序列。如果在子序列中，当下标 ix &gt; iy 时，Six &gt; Siy，称子序列为原序列的一个递增子序列。<br>&amp;emsp;&amp;emsp;定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 Sn 结尾的序列的最长递增子序列长度。对于一个递增子序列 {Si1, Si2,…,Sim}，如果 im &lt; n 并且 Sim &lt; Sn，此时 {Si1, Si2,…, Sim, Sn} 为一个递增子序列，递增子序列的长度增加 1。<br>&amp;emsp;&amp;emsp;满足上述条件的递增子序列中，长度最长的那个递增子序列就是要找的，在长度最长的递增子序列上加上 Sn 就构成了以 Sn 为结尾的最长递增子序列。<br>&amp;emsp;&amp;emsp;因此 <code>dp[n] = max&#123; dp[i]+1 | Si &lt; Sn &amp;&amp; i &lt; n&#125;</code><br>&amp;emsp;&amp;emsp;因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 {Sn} 就构成了递增子序列，需要对前面的求解方程做修改，令 dp[n] 最小为 1，即：</p>
<ul>
<li><code>dp[n] = max&#123;1, dp[i] + 1 | Si &lt; Sn &amp;&amp; i &lt; n&#125;</code><br>&amp;emsp;&amp;emsp;对于一个长度为 N 的序列，最长递增子序列并不一定会以 SN 为结尾，因此 dp[N] 不是序列的最长递增子序列的长度，需要遍历 dp 数组找出最大值才是所要的结果，<code>max&#123; dp[i] | 1 &lt;= i &lt;= N&#125;</code> 即为所求。</li>
</ul>
<p>ref. <a target="_blank" rel="noopener" href="https://blog.csdn.net/u013178472/article/details/54926531">最长递增子序列的三种算法</a>  </p>
<ol>
<li>以上解法的时间复杂度为 O(N2)  </li>
<li>可以使用二分查找将时间复杂度降低为 O(NlogN)  </li>
<li>也可以用最长公共子序列法：查找原序列和排序后的序列的最长公共自序列，具体参见链接</li>
</ol>
<h5 id="Leetcode-300-最长上升（递增）子序列（中等）"><a href="#Leetcode-300-最长上升（递增）子序列（中等）" class="headerlink" title="Leetcode 300.  最长上升（递增）子序列（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">Leetcode 300.  最长上升（递增）子序列（中等）</a></h5><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>题解：  </p>
<ol>
<li>dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(nums.size(), 1); //至少是自身，1个</span><br><span class="line">    for (int i = 0; i &lt; nums.size();i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; i;j++)&#123;</span><br><span class="line">            if(nums[j]&lt;nums[i])</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for(int n:dp)</span><br><span class="line">        res = max(res, n);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>二分查找+贪心。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int BinarySearch(vector&lt;int&gt; &amp;tails,int len,int num)&#123;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = len - 1;</span><br><span class="line">    int mid;</span><br><span class="line">    while(left&lt;=right)&#123;</span><br><span class="line">        mid = (left + right) / 2;</span><br><span class="line">        if (tails[mid]&gt;num)</span><br><span class="line">            right = mid - 1;</span><br><span class="line">        else if(tails[mid]&lt;num)</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        else</span><br><span class="line">            return mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;//数组中不存在该元素，则返回该元素应该插入的位置</span><br><span class="line">&#125;</span><br><span class="line">int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    //tails[i]表示长度为 i+1 的最长上升子序列的末尾元素的最小值</span><br><span class="line">    if(nums.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    vector&lt;int&gt; tails(nums.size(), 0);</span><br><span class="line">    int res = 1;</span><br><span class="line">    tails[0] = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nums[i]&gt;tails[res-1])&#123;</span><br><span class="line">            tails[res] = nums[i];</span><br><span class="line">            res++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int pos = BinarySearch(tails,res,nums[i]);</span><br><span class="line">            tails[pos] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)<br>空间复杂度：O(n)</p>
<h5 id="Leetcode-646-最长数对链（中等）"><a href="#Leetcode-646-最长数对链（中等）" class="headerlink" title="Leetcode 646. 最长数对链（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/">Leetcode 646. 最长数对链（中等）</a></h5><p>给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。</p>
<p>现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。</p>
<p>给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p>
<p><strong>说明</strong>：对于 (a, b) 和 (c, d) ，如果 b &lt; c，则它们可以构成一条链。求一组整数对能够构成的最长链。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2], [2,3], [3,4]]  </span><br><span class="line">Output: 2  </span><br><span class="line">Explanation: The longest chain is [1,2] -&gt; [3,4]  </span><br></pre></td></tr></table></figure>

<p>题解：<br>和最长递增子序列很像。 </p>
<ol>
<li>dp。dp[i]是以i结尾时的最长链长度：<code>dp[i] = max&#123;dp[j]+1 | j~(1,i) &amp;&amp; pairs[i][0]&gt;pairs[j][1]&#125;</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b)&#123;</span><br><span class="line">    if(a[0]==b[0])</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    return a[0] &lt; b[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findLongestChain(vector&lt;vector&lt;int&gt; &gt;&amp; pairs) &#123;</span><br><span class="line">    if(pairs.size()&lt;2)</span><br><span class="line">        return pairs.size();</span><br><span class="line">    </span><br><span class="line">    sort(pairs.begin(), pairs.end(), cmp);</span><br><span class="line">    vector&lt;int&gt; dp(pairs.size(), 1);</span><br><span class="line">    for (int i = 1; i &lt; pairs.size(); i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; i;j++)&#123;</span><br><span class="line">            if (pairs[i][0] &gt; pairs[j][1])</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int res = 0;</span><br><span class="line">    for(auto d:dp)</span><br><span class="line">        res = max(res, d);</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>二分+贪心。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">int BinarySearch(vector&lt; vector&lt;int&gt; &gt; &amp;tails,int len,vector&lt;int&gt; inputPair)&#123;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = len-1;</span><br><span class="line">    int mid;</span><br><span class="line">    while (left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left + right) / 2;</span><br><span class="line">        if(tails[mid][1]&lt;inputPair[0])</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        else if(tails[mid][0]&gt;inputPair[1])</span><br><span class="line">            right = mid - 1;</span><br><span class="line">        else</span><br><span class="line">            return mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b)&#123;</span><br><span class="line">    if(a[0]==b[0])</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    return a[0] &lt; b[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findLongestChain(vector&lt;vector&lt;int&gt; &gt;&amp; pairs) &#123;</span><br><span class="line">    if(pairs.size()&lt;2)</span><br><span class="line">        return pairs.size();</span><br><span class="line">    </span><br><span class="line">    sort(pairs.begin(), pairs.end(), cmp);</span><br><span class="line">    vector&lt; vector&lt;int&gt; &gt; tails(pairs.size(),vector&lt;int&gt;(2,0));</span><br><span class="line">    tails[0] = pairs[0];</span><br><span class="line">    int res = 1;</span><br><span class="line">    for (int i = 1; i &lt; pairs.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pairs[i][0]&gt;tails[res-1][1])&#123;</span><br><span class="line">            tails[res] = pairs[i];</span><br><span class="line">            res++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int pos = BinarySearch(tails,res,pairs[i]);</span><br><span class="line">            if(tails[pos][1]&gt;pairs[i][1])</span><br><span class="line">                tails[pos] = pairs[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)<br>空间复杂度：O(n)</p>
<h5 id="Leetcode-376-摆动序列（中等）"><a href="#Leetcode-376-摆动序列（中等）" class="headerlink" title="Leetcode 376. 摆动序列（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/wiggle-subsequence/">Leetcode 376. 摆动序列（中等）</a></h5><p>如果一个序列中连续的数之间的差值在正数和负数之间来回交替，那么这个序列被称作摆动序列。如果存在第一个差值的话，可能为正数或者负数。长度小于2的序列被认为是摆动序列。  </p>
<p>例如：[1,7,4,9,2,5]为摆动序列。而[1,4,7,2,5] 和[1,7,4,5,5]不是摆动序列  </p>
<p>给定一组数，返回最长的摆动子序列。注意序列是由原数组删除一些元素(也可以不删除)并且保留元素顺序得到的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,7,4,9,2,5]  </span><br><span class="line">Output: 6  </span><br><span class="line">The entire sequence is a wiggle sequence.  </span><br><span class="line">Input: [1,17,5,10,13,15,10,5,16,8]  </span><br><span class="line">Output: 7  </span><br><span class="line">There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].  </span><br><span class="line">Input: [1,2,3,4,5,6,7,8,9]  </span><br><span class="line">Output: 2  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>dp。用两个分别保存上升和下降的最长长度。<ul>
<li><code>dpUp[i]</code> 表示 i 之前上升序列最长的子序列长度</li>
<li><code>dpDown[i]</code> 表示 i 之前下降序列最长的子序列长度</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    if(nums.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    vector&lt;int&gt; dpUp(nums.size());</span><br><span class="line">    vector&lt;int&gt; dpDown(nums.size());</span><br><span class="line">    dpUp[0] = 1;</span><br><span class="line">    dpDown[0] = 1;</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nums[i]&gt;nums[i-1])&#123;//状态是上升,应该接下降，并改状态</span><br><span class="line">            dpUp[i] = dpDown[i - 1] + 1;</span><br><span class="line">            dpDown[i] = dpDown[i - 1];</span><br><span class="line">        &#125;else if(nums[i]&lt;nums[i-1])&#123;//状态是下降，应该接上升，并改状态</span><br><span class="line">            dpDown[i] = dpUp[i - 1] + 1;</span><br><span class="line">            dpUp[i] = dpUp[i - 1];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            dpUp[i] = dpUp[i - 1];</span><br><span class="line">            dpDown[i] = dpDown[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for(auto d:dpUp)</span><br><span class="line">        res = max(res, d);</span><br><span class="line">    for(auto d:dpDown)</span><br><span class="line">        res = max(res, d);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(2n)<br>空间复杂度：O(2n)</p>
<ol start="2">
<li>因为只用到了前一个值，所以可以优化空间复杂度。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    if(nums.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int up = 1, down = 1;</span><br><span class="line">    for (int i = 1; i &lt; nums.size();i++)&#123;</span><br><span class="line">        if(nums[i]&gt;nums[i-1])</span><br><span class="line">            up = down + 1;</span><br><span class="line">        else if(nums[i]&lt;nums[i-1])</span><br><span class="line">            down = up + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return max(up, down);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="公共子序列"><a href="#公共子序列" class="headerlink" title="公共子序列"></a>公共子序列</h4><p><code>dp[i][j]</code> 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。  </p>
<p>考虑 <code>S1[i]</code> 与 <code>S2j</code> 值是否相等，分为两种情况：</p>
<ul>
<li>当 <code>S1[i] == S2[j]</code> 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，<br>最长公共子序列长度加 1，即 <code>dp[i][j] = dp[i-1][j-1] + 1</code>。</li>
<li>当 <code>S1[i] != S2[j]</code> 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，<br>或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，<br>即 <code>dp[i][j] = max&#123;dp[i-1][j], dp[i][j-1]&#125;</code>。</li>
</ul>
<p>对于长度为 N 的序列 S1 和长度为 M 的序列 S2，<code>dp[N][M]</code> 就是序列 S1 和序列 S2 的最长公共子序列长度。</p>
<h5 id="Leetcode-1143-最长公共子序列Longest-Common-Subsequence（中等）"><a href="#Leetcode-1143-最长公共子序列Longest-Common-Subsequence（中等）" class="headerlink" title="Leetcode 1143. 最长公共子序列Longest Common Subsequence（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">Leetcode 1143. 最长公共子序列Longest Common Subsequence（中等）</a></h5><p>求最长公共子序列</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure>

<p>题解：  </p>
<ol>
<li>二维dp。<code>dp[i][j]</code>表示第一个字符串的前 i 个和第二个字符串的前 j 个字符的LCS。<ul>
<li>当<code>s1[i-1] == s2[j-1]</code>时，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li>
<li>当<code>s1[i-1] != s2[j-1]</code>时，<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code></li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int longestCommonSubsequence(string text1, string text2) &#123;</span><br><span class="line">    if(text1.size()==0||text2.size()==0)</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    vector&lt; vector&lt;int&gt; &gt; dp(text1.size()+1,vector&lt;int&gt;(text2.size()+1));</span><br><span class="line">    for (int i = 1; i &lt;= text1.size();i++)&#123;</span><br><span class="line">        for (int j = 1; j &lt;= text2.size();j++)&#123;</span><br><span class="line">            if(text2[j-1]==text1[i-1])</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">            else</span><br><span class="line">                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[text1.size()][text2.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p>
<ol start="2">
<li>一维dp。注意：使用一维dp的时候，需要上一行的前一个数，所以不能使用上一个数和前一个数更新，还要保留上一行。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int longestCommonSubsequence(string text1, string text2) &#123;</span><br><span class="line">    if(text1.size()==0||text2.size()==0)</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; dp(text2.size()+1, 0);</span><br><span class="line">    vector&lt;int&gt; last(text2.size()+1, 0);</span><br><span class="line">    for (int i = 1; i &lt;= text1.size();i++)&#123;</span><br><span class="line">        for (int j = 1; j &lt;= text2.size();j++)&#123;</span><br><span class="line">            if(text2[j-1]==text1[i-1])</span><br><span class="line">                dp[j] = last[j - 1] + 1;</span><br><span class="line">            else</span><br><span class="line">                dp[j] = max(last[j], dp[j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        last = dp;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[text2.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(2n)</p>
<h5 id="Leetcode-583-两个字符串的删除操作（中等）"><a href="#Leetcode-583-两个字符串的删除操作（中等）" class="headerlink" title="Leetcode 583. 两个字符串的删除操作（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">Leetcode 583. 两个字符串的删除操作（中等）</a></h5><p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;sea&quot;, &quot;eat&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 第一步将&quot;sea&quot;变为&quot;ea&quot;，第二步将&quot;eat&quot;变为&quot;ea&quot;</span><br></pre></td></tr></table></figure>
<p>题解：<br>其实就是算最长公共子序列。  </p>
<ol>
<li>二维dp</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int minDistance(string word1, string word2) &#123;</span><br><span class="line">    if(word1.empty())</span><br><span class="line">        return word2.size();</span><br><span class="line">    if(word2.empty())</span><br><span class="line">        return word1.size();</span><br><span class="line"></span><br><span class="line">    int m = word1.size(), n = word2.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(m+1,vector&lt;int&gt;(n+1, 0));</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            if(word1[i-1]==word2[j-1])</span><br><span class="line">                dp[i][j] = dp[i-1][j-1]+1;</span><br><span class="line">            else</span><br><span class="line">                dp[i][j] = max(dp[i-1][j],dp[i][j-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return m+n-2*dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p>
<ol start="2">
<li>一维dp。注意：使用一维dp的时候，需要上一行的前一个数，所以不能使用上一个数和前一个数更新，还要保留上一行。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int minDistance(string word1, string word2) &#123;</span><br><span class="line">    if(word1.empty())</span><br><span class="line">        return word2.size();</span><br><span class="line">    if(word2.empty())</span><br><span class="line">        return word1.size();</span><br><span class="line"></span><br><span class="line">    int m = word1.size(), n = word2.size();</span><br><span class="line">    vector&lt;int&gt; dp(n+1);</span><br><span class="line">    vector&lt;int&gt; last(n+1);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        for (int j = 1; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (word1[i - 1] == word2[j - 1])</span><br><span class="line">                dp[j] = last[j-1] + 1;</span><br><span class="line">            else</span><br><span class="line">                dp[j] = max(last[j],dp[j-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        last = dp;</span><br><span class="line">    &#125;</span><br><span class="line">    return m+n-2*dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(2n)</p>
<h4 id="最大连续子数组"><a href="#最大连续子数组" class="headerlink" title="最大连续子数组"></a>最大连续子数组</h4><h5 id="Leetcode-53-最大子序和（简单）"><a href="#Leetcode-53-最大子序和（简单）" class="headerlink" title="Leetcode 53. 最大子序和（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">Leetcode 53. 最大子序和（简单）</a></h5><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>
<p>题解：<br>dp。优化空间复杂度为O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int pre = 0, res = nums[0];</span><br><span class="line">    for (const auto &amp;x: nums) &#123;</span><br><span class="line">        pre = max(pre + x, x);</span><br><span class="line">        res = max(res, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h5 id="返回最大子数组"><a href="#返回最大子数组" class="headerlink" title="返回最大子数组"></a>返回最大子数组</h5><p>在上题的基础上，要返回这个最大子数组，不只是和。</p>
<p>题解：<br>对于<code>dp[i]=max(dp[i-1]+nums[i], nums[i])</code></p>
<ul>
<li>当<code>dp[i-1]&lt;0</code>时，<code>nums[i]</code>大</li>
<li>当<code>dp[i-1]&gt;0</code>时，<code>dp[i-1]+nums[i]</code>大<br>因为要返回数组，所以在状态转移时需要更新一下开始索引。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int pre = nums[0], start = 0;</span><br><span class="line">    int maxSum = INT_MIN;</span><br><span class="line">    vector&lt;int&gt; resIdx(2);</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pre &gt; 0)&#123; //如果返回最长的子数组，这个就应该是 if(pre &gt;= 0)</span><br><span class="line">            pre = pre + nums[i];</span><br><span class="line">        &#125;else&#123;//子数组的开始索引要更新了</span><br><span class="line">            pre = nums[i];</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre &gt; maxSum)&#123;//更新答案</span><br><span class="line">            maxSum = pre;</span><br><span class="line">            resIdx[0] = start;</span><br><span class="line">            resIdx[1] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for (int i = resIdx[0]; i &lt;= resIdx[1]; i++)&#123;</span><br><span class="line">        res.push_back(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n)<br>空间复杂度：O(1)</li>
</ul>
<h4 id="旋转数组的最大连续子数组"><a href="#旋转数组的最大连续子数组" class="headerlink" title="旋转数组的最大连续子数组"></a>旋转数组的最大连续子数组</h4><h5 id="旋转连续子数组和"><a href="#旋转连续子数组和" class="headerlink" title="旋转连续子数组和"></a>旋转连续子数组和</h5><p>给定一个<strong>旋转</strong>数组<code>nums</code>，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>注意</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">旋转数组为首位相连的数组，如：</span><br><span class="line">[1,2,3] 的子数组有 [1,2],[2,3],[3,1]</span><br></pre></td></tr></table></figure>
<p>题解：<br>以<code>[2,1,3]</code>为例，最大子数组可能位于 <strong>中间</strong><code>(如[1,3])</code> 或者 <strong>两边</strong><code>([3,2])</code>。</p>
<ul>
<li>若最大子数组在中间，则用上题方法可得；</li>
<li>若最大子数组在两边，使用dp求出位于中间的最小子数组的和，就得到了位于两边的最大子数组和。因为数组和是一定的，中间的子数组和越小，位于两边的子数组和越大。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int maxSubArray(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">    //位于中间 最大和 的 子数组</span><br><span class="line">    int pre = 0, maxMid = nums[0];</span><br><span class="line">    for (const int n : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        pre = max(n, pre + n);</span><br><span class="line">        maxMid = max(maxMid, pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //位于两边 最大和 的 子数组</span><br><span class="line">    //中间最小和</span><br><span class="line">    pre = nums[0];</span><br><span class="line">    int minMid = nums[0], sumn = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre = min(nums[i], pre + nums[i]);</span><br><span class="line">        minMid = min(minMid, pre);</span><br><span class="line">        sumn += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int maxSide = sumn - minMid; //两边 最大和</span><br><span class="line"></span><br><span class="line">    return maxMid &gt; maxSide ? maxMid : maxSide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h5 id="返回最大和的旋转连续子数组"><a href="#返回最大和的旋转连续子数组" class="headerlink" title="返回最大和的旋转连续子数组"></a>返回最大和的旋转连续子数组</h5><p>给定一个<strong>旋转</strong>数组<code>nums</code>，返回一个具有最大和的连续子数组，不只是和。<br>题解：<br>在上题状态转移的基础上，增加了索引的记录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    //位于中间 最大和 的 子数组</span><br><span class="line">    int pre = nums[0], start = 0;</span><br><span class="line">    int maxMid = INT_MIN;    </span><br><span class="line">    vector&lt;int&gt; maxIdx(2);</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pre &gt; 0)&#123; //如果返回最长的子数组，这个就应该是 if(pre &gt;= 0)</span><br><span class="line">            pre = pre + nums[i];</span><br><span class="line">        &#125;else&#123;//子数组的开始索引要更新了</span><br><span class="line">            pre = nums[i];</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre &gt; maxMid)&#123;//更新答案</span><br><span class="line">            maxMid = pre;</span><br><span class="line">            maxIdx[0] = start;</span><br><span class="line">            maxIdx[1] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //位于两边 最大和 的 子数组</span><br><span class="line">    //中间最小和</span><br><span class="line">    pre = nums[0]; start = 0;</span><br><span class="line">    int minMid = nums[0], sumn = nums[0];</span><br><span class="line">    vector&lt;int&gt; minIdx(2);</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sumn += nums[i];</span><br><span class="line">        if(pre &lt; 0)&#123;</span><br><span class="line">            pre = pre + nums[i];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            pre = nums[i];</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre &lt; minMid)&#123;</span><br><span class="line">            minMid = pre;</span><br><span class="line">            minIdx[0] = start;</span><br><span class="line">            minIdx[1] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; resIdx(2);</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if(maxMid &gt; (sumn - minMid))&#123;//子数组在中间</span><br><span class="line">        resIdx = maxIdx;</span><br><span class="line"></span><br><span class="line">        for (int i = resIdx[0]; i &lt;= resIdx[1]; i++)&#123;</span><br><span class="line">            res.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;//子数组在两边</span><br><span class="line">        resIdx[0] = (minIdx[1] + 1) % nums.size();</span><br><span class="line">        resIdx[1] = (minIdx[0] - 1 + nums.size()) % nums.size();</span><br><span class="line"></span><br><span class="line">        for (int i = resIdx[0]; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            res.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt;= resIdx[1]; i++)&#123;</span><br><span class="line">            res.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="二维矩阵最大子矩阵和"><a href="#二维矩阵最大子矩阵和" class="headerlink" title="二维矩阵最大子矩阵和"></a>二维矩阵最大子矩阵和</h4><h5 id="最大子矩阵和"><a href="#最大子矩阵和" class="headerlink" title="最大子矩阵和"></a>最大子矩阵和</h5><p>给定一个正整数和负整数组成的矩阵<code>matrix</code>，返回元素总和最大的子矩阵。</p>
<p>题解：<br>我们在前面已经会求最大子数组和，最大矩阵和只需要把二维矩阵压缩为一维数组，再用之前求最大子数组和的方法，就可以得到最大矩阵和。</p>
<p>我们把矩阵垂直压缩成一维数组，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">matrix = [[1,2,3],</span><br><span class="line">          [1,2,3]]</span><br><span class="line"></span><br><span class="line">可以压缩成：nums = [2,4,6]</span><br><span class="line"></span><br><span class="line">其中: </span><br><span class="line">nums[0] = matrix[0][0] + matrix[1][0]</span><br><span class="line">nums[1] = matrix[0][1] + matrix[1][1]</span><br><span class="line">nums[2] = matrix[0][2] + matrix[1][2]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int pre = 0, res = nums[0];</span><br><span class="line">    for (const auto &amp;x: nums) &#123;</span><br><span class="line">        pre = max(pre + x, x);</span><br><span class="line">        res = max(res, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int maxSubMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)&#123;</span><br><span class="line">    if(matrix.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int rows = matrix.size();</span><br><span class="line">    int cols = matrix[0].size();</span><br><span class="line"></span><br><span class="line">    int res = INT_MIN;</span><br><span class="line">    for (int up = 0; up &lt; rows; up++)//上界</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; nums(cols, 0);//压缩为一维数组</span><br><span class="line">        for (int buttom = up; buttom &lt; rows; buttom++)//下界</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; cols;i++)//每次往下一行，就只需在之前的nums上加上这一行</span><br><span class="line">                nums[i] += matrix[buttom][i];</span><br><span class="line"></span><br><span class="line">            int maxArr = maxSubArray(nums);</span><br><span class="line">            res = max(maxArr, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="返回最大子矩阵"><a href="#返回最大子矩阵" class="headerlink" title="返回最大子矩阵"></a>返回最大子矩阵</h5><p>在更新最大和的时候记录左上角和右下角的索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">int maxSubArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt; &amp;maxIdx) &#123;</span><br><span class="line">    int pre = nums[0], start = 0;</span><br><span class="line">    int maxSum = INT_MIN;</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pre &gt; 0)&#123; //如果返回最长的子数组，这个就应该是 if(pre &gt;= 0)</span><br><span class="line">            pre = pre + nums[i];</span><br><span class="line">        &#125;else&#123;//子数组的开始索引要更新了</span><br><span class="line">            pre = nums[i];</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre &gt; maxSum)&#123;//更新答案</span><br><span class="line">            maxSum = pre;</span><br><span class="line">            maxIdx[0] = start;</span><br><span class="line">            maxIdx[1] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; maxSubMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)&#123;</span><br><span class="line">    if(matrix.empty())</span><br><span class="line">        return matrix;</span><br><span class="line">    int rows = matrix.size();</span><br><span class="line">    int cols = matrix[0].size();</span><br><span class="line"></span><br><span class="line">    int maxArr = INT_MIN;</span><br><span class="line">    vector&lt;int&gt; maxIdx(4);//0上、1左、2下、3右</span><br><span class="line">    for (int up = 0; up &lt; rows; up++)//上界</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; nums(cols, 0);//压缩为一维数组</span><br><span class="line">        for (int down = up; down &lt; rows; down++)//下界</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; cols;i++)//每次往下一行，就只需在之前的nums上加上这一行</span><br><span class="line">                nums[i] += matrix[down][i];</span><br><span class="line"></span><br><span class="line">            vector&lt;int&gt; tmpIdx(2);</span><br><span class="line">            int tmp = maxSubArray(nums, tmpIdx);</span><br><span class="line">            if(tmp &gt; maxArr)&#123;</span><br><span class="line">                maxArr = tmp;</span><br><span class="line">                maxIdx[0] = up;</span><br><span class="line">                maxIdx[1] = tmpIdx[0];</span><br><span class="line">                maxIdx[2] = down;</span><br><span class="line">                maxIdx[3] = tmpIdx[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int subRows = maxIdx[2] - maxIdx[0] + 1;</span><br><span class="line">    int subCols = maxIdx[3] - maxIdx[1] + 1;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res(subRows,vector&lt;int&gt;(subCols));</span><br><span class="line">    for (int row = maxIdx[0], i = 0; row &lt;= maxIdx[2]; row++, i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int col = maxIdx[1], j = 0; col &lt;= maxIdx[3]; col++, j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i][j] = matrix[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="二维矩阵最大旋转子矩阵"><a href="#二维矩阵最大旋转子矩阵" class="headerlink" title="二维矩阵最大旋转子矩阵"></a>二维矩阵最大旋转子矩阵</h4><h5 id="最旋转大子矩阵和"><a href="#最旋转大子矩阵和" class="headerlink" title="最旋转大子矩阵和"></a>最旋转大子矩阵和</h5><p>给定一个正整数和负整数组成的旋转矩阵<code>matrix</code>，返回元素总和最大的子矩阵。</p>
<p>题解：<br>只需要把上题求最大子数组和的函数换为上面提到的最大旋转子数组的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">int maxSubArray(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">    //位于中间 最大和 的 子数组</span><br><span class="line">    int pre = 0, maxMid = nums[0];</span><br><span class="line">    for (const int n : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        pre = max(n, pre + n);</span><br><span class="line">        maxMid = max(maxMid, pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //位于两边 最大和 的 子数组</span><br><span class="line">    //中间最小和</span><br><span class="line">    pre = nums[0];</span><br><span class="line">    int minMid = nums[0], sumn = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre = min(nums[i], pre + nums[i]);</span><br><span class="line">        minMid = min(minMid, pre);</span><br><span class="line">        sumn += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int maxSide = sumn - minMid;</span><br><span class="line"></span><br><span class="line">    return maxMid &gt; maxSide ? maxMid : maxSide;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int maxSubMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)&#123;</span><br><span class="line">    if(matrix.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int rows = matrix.size();</span><br><span class="line">    int cols = matrix[0].size();</span><br><span class="line"></span><br><span class="line">    int res = INT_MIN;</span><br><span class="line">    for (int up = 0; up &lt; rows; up++)//上界</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; nums(cols, 0);//压缩为一维数组</span><br><span class="line">        for (int buttom = up; buttom &lt; rows; buttom++)//下界</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; cols;i++)//每次往下一行，就只需在之前的nums上加上这一行</span><br><span class="line">                nums[i] += matrix[buttom][i];</span><br><span class="line"></span><br><span class="line">            int maxArr = maxSubArray(nums);</span><br><span class="line">            res = max(maxArr, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="返回最大旋转子矩阵"><a href="#返回最大旋转子矩阵" class="headerlink" title="返回最大旋转子矩阵"></a>返回最大旋转子矩阵</h5><p>在上题的基础上记录坐标。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">int maxSubArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt; &amp;resIdx) &#123;</span><br><span class="line">    //位于中间 最大和 的 子数组</span><br><span class="line">    int pre = nums[0], start = 0;</span><br><span class="line">    int maxMid = INT_MIN;    </span><br><span class="line">    vector&lt;int&gt; maxIdx(2);</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pre &gt; 0)&#123; //如果返回最长的子数组，这个就应该是 if(pre &gt;= 0)</span><br><span class="line">            pre = pre + nums[i];</span><br><span class="line">        &#125;else&#123;//子数组的开始索引要更新了</span><br><span class="line">            pre = nums[i];</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre &gt; maxMid)&#123;//更新答案</span><br><span class="line">            maxMid = pre;</span><br><span class="line">            maxIdx[0] = start;</span><br><span class="line">            maxIdx[1] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //位于两边 最大和 的 子数组</span><br><span class="line">    //中间最小和</span><br><span class="line">    pre = nums[0]; start = 0;</span><br><span class="line">    int minMid = nums[0], sumn = nums[0];</span><br><span class="line">    vector&lt;int&gt; minIdx(2);</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sumn += nums[i];</span><br><span class="line">        if(pre &lt; 0)&#123;</span><br><span class="line">            pre = pre + nums[i];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            pre = nums[i];</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre &lt; minMid)&#123;</span><br><span class="line">            minMid = pre;</span><br><span class="line">            minIdx[0] = start;</span><br><span class="line">            minIdx[1] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maxArr = sumn - minMid;</span><br><span class="line">    if (maxMid &gt; maxArr)&#123; //子数组在中间</span><br><span class="line">        resIdx = maxIdx;</span><br><span class="line">        maxArr = maxMid;</span><br><span class="line">    &#125;else&#123;//子数组在两边</span><br><span class="line">        resIdx[0] = (minIdx[1] + 1) % nums.size();</span><br><span class="line">        resIdx[1] = (minIdx[0] - 1 + nums.size()) % nums.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; maxSubMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)&#123;</span><br><span class="line">    if(matrix.empty())</span><br><span class="line">        return matrix;</span><br><span class="line">    int rows = matrix.size();</span><br><span class="line">    int cols = matrix[0].size();</span><br><span class="line"></span><br><span class="line">    int maxArr = INT_MIN;</span><br><span class="line">    vector&lt;int&gt; maxIdx(4);//0上、1左、2下、3右</span><br><span class="line">    for (int up = 0; up &lt; rows; up++)//上界</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; nums(cols, 0);//压缩为一维数组</span><br><span class="line">        for (int down = up; down &lt; rows; down++)//下界</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; cols;i++)//每次往下一行，就只需在之前的nums上加上这一行</span><br><span class="line">                nums[i] += matrix[down][i];</span><br><span class="line"></span><br><span class="line">            vector&lt;int&gt; tmpIdx(2);</span><br><span class="line">            int tmp = maxSubArray(nums, tmpIdx);</span><br><span class="line">            if(tmp &gt; maxArr)&#123;</span><br><span class="line">                maxArr = tmp;</span><br><span class="line">                maxIdx[0] = up;</span><br><span class="line">                maxIdx[1] = tmpIdx[0];</span><br><span class="line">                maxIdx[2] = down;</span><br><span class="line">                maxIdx[3] = tmpIdx[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int subRows = maxIdx[2] - maxIdx[0] + 1;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    if (maxIdx[3] &gt;= maxIdx[1])</span><br><span class="line">    &#123; //子矩阵在中间</span><br><span class="line">        int subCols = maxIdx[3] - maxIdx[1] + 1;</span><br><span class="line">        // vector&lt;int&gt; tmpVec(subCols);</span><br><span class="line">        res.resize(subRows, vector&lt;int&gt;(subCols));</span><br><span class="line">        for (int row = maxIdx[0], i = 0; row &lt;= maxIdx[2]; row++, i++)&#123;</span><br><span class="line">            for (int col = maxIdx[1], j = 0; col &lt;= maxIdx[3]; col++, j++)</span><br><span class="line">                res[i][j] = matrix[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123; //子矩阵在两边</span><br><span class="line">        int subCols = cols - (maxIdx[1] - maxIdx[3] - 1);</span><br><span class="line">        res.resize(subRows,vector&lt;int&gt;(subCols));</span><br><span class="line">        for (int row = maxIdx[0], i = 0; row &lt;= maxIdx[2]; row++, i++)&#123;</span><br><span class="line">            int j = 0;</span><br><span class="line">            for (int col = maxIdx[1]; col &lt; cols; col++, j++)</span><br><span class="line">                res[i][j] = matrix[row][col];</span><br><span class="line">            for (int col = 0; col &lt;= maxIdx[3]; col++,j++)</span><br><span class="line">                res[i][j] = matrix[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-2-4-0-1背包问题"><a href="#3-2-4-0-1背包问题" class="headerlink" title="3.2.4 0-1背包问题"></a>3.2.4 0-1背包问题</h3><p>&amp;emsp;&amp;emsp;有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。<br>&amp;emsp;设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：  </p>
<ul>
<li>第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值<br>就是总体积不超过 j 的前 i-1 件物品的最大价值，<code>dp[i][j] = dp[i-1][j]</code>。</li>
<li>第 i 件物品添加到背包中，<code>dp[i][j] = dp[i-1][j-w] + v</code>。</li>
</ul>
<p>&amp;emsp;&amp;emsp;第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：</p>
<ul>
<li><code>dp[i][j]=max(dp[i-1][j],dp[i-1][j-w]+v)</code></li>
</ul>
<h4 id="二维dp-0-1-背包"><a href="#二维dp-0-1-背包" class="headerlink" title="二维dp 0-1 背包"></a>二维dp 0-1 背包</h4><p><code>dp[i][j]</code>表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int knapsack(vector&lt;vector&lt;int&gt; &gt; &amp;nums, int N)&#123;</span><br><span class="line">    //nums = &#123; &#123;5,12&#125;,&#123;4,3&#125;,&#123;7,10&#125;,&#123;2,3&#125;,&#123;6,6&#125; &#125;;//&#123;wight,val&#125;</span><br><span class="line">    //N = 15;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(nums.size()+1,vector&lt;int&gt;(N+1));</span><br><span class="line">    for (int i = 1; i &lt;= nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= N;j++)&#123;</span><br><span class="line">            int weight = nums[i - 1][0];</span><br><span class="line">            int val = nums[i - 1][1];</span><br><span class="line">            if (j &gt;= weight)</span><br><span class="line">                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight] + val);</span><br><span class="line">            else</span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[nums.size()][N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p>
<h4 id="空间优化：一维dp-0-1-背包"><a href="#空间优化：一维dp-0-1-背包" class="headerlink" title="空间优化：一维dp 0-1 背包"></a>空间优化：一维dp 0-1 背包</h4><p>观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。</p>
<ul>
<li><code>d[j] = max(d[j],d[j-w]+v)</code></li>
</ul>
<p>因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，防止将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int knapsack(vector&lt;vector&lt;int&gt; &gt; &amp;nums, int N)&#123;</span><br><span class="line">    vector&lt;int&gt; dp(N+1);</span><br><span class="line">    for (int i = 1; i &lt;=nums.size();i++)&#123;</span><br><span class="line">        int weight = nums[i - 1][0];</span><br><span class="line">        int val = nums[i - 1][1];</span><br><span class="line">        for (int j = N; j &gt;= 1;j--)&#123;</span><br><span class="line">            if(j&gt;=weight)</span><br><span class="line">                dp[j] = max(dp[j], dp[j - weight] + val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(n)</p>
<h4 id="Leetcode-416-分割等和子集（中等）"><a href="#Leetcode-416-分割等和子集（中等）" class="headerlink" title="Leetcode 416. 分割等和子集（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">Leetcode 416. 分割等和子集（中等）</a></h4><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>示例：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 5, 11, 5]  </span><br><span class="line">Output: true  </span><br><span class="line">Explanation: The array can be partitioned as [1, 5, 5] and [11].  </span><br></pre></td></tr></table></figure>
<p>题解：<br>可以看成一个背包大小为 sum&#x2F;2 的 0-1 背包问题。</p>
<ol>
<li>二维dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.size();i++)</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    if(sum &amp; 1)//奇数</span><br><span class="line">        return false;</span><br><span class="line">    int W = sum / 2;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; dp(nums.size()+1,vector&lt;bool&gt;(W+1,false));</span><br><span class="line">    for (int m = 0; m &lt; nums.size();m++)</span><br><span class="line">        dp[m][0] = true;</span><br><span class="line">    for (int i = 1; i &lt;= nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= W; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = dp[i - 1][j];</span><br><span class="line">            if((!dp[i][j]) &amp;&amp; j&gt;=nums[i-1])</span><br><span class="line">                dp[i][j] = dp[i - 1][j - nums[i - 1]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[nums.size()][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>一维dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.size();i++)</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    if(sum &amp; 1)//奇数</span><br><span class="line">        return false;</span><br><span class="line">    int W = sum / 2;</span><br><span class="line"></span><br><span class="line">    vector&lt;bool&gt; dp1(W + 1,false);</span><br><span class="line">    dp1[0] = true;</span><br><span class="line">    for(auto num:nums)&#123;</span><br><span class="line">        for (int j = W; j &gt;= num;j--)</span><br><span class="line">            dp1[j] = dp1[j] || dp1[j - num];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp1[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="leetcode-494-目标和（中等）"><a href="#leetcode-494-目标和（中等）" class="headerlink" title="leetcode 494. 目标和（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">leetcode 494. 目标和（中等）</a></h4><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>示例：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: nums is [1, 1, 1, 1, 1], S is 3.  </span><br><span class="line">Output: 5   </span><br><span class="line">Explanation:  </span><br><span class="line">-1+1+1+1+1 = 3  </span><br><span class="line">+1-1+1+1+1 = 3  </span><br><span class="line">+1+1-1+1+1 = 3  </span><br><span class="line">+1+1+1-1+1 = 3  </span><br><span class="line">+1+1+1+1-1 = 3  </span><br><span class="line">There are 5 ways to assign symbols to make the sum of nums be target 3.  </span><br></pre></td></tr></table></figure>
<p>题解：<br>该问题可以转换为 Subset Sum 问题，从而使用 0-1 背包的方法来求解。</p>
<p>可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：</p>
<ul>
<li>sum(P) - sum(N) &#x3D; target</li>
<li>sum(P) + sum(N) + sum(P) - sum(N) &#x3D; target + sum(P) + sum(N)</li>
<li>2 * sum(P) &#x3D; target + sum(nums)</li>
</ul>
<p>因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))&#x2F;2，就证明存在解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123;</span><br><span class="line">    long sum = 0;</span><br><span class="line">    for (const int &amp;num : nums) sum += num;</span><br><span class="line">    if ((S + sum) % 2 == 1 || S &gt; sum) return 0;</span><br><span class="line">    S = (S + sum) / 2;</span><br><span class="line">    vector&lt;int&gt; dp(S+1);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    for (const int &amp;num : nums) &#123;</span><br><span class="line">        for (int j = S; j &gt;= num; j--)</span><br><span class="line">            dp[j] += dp[j - num];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[S];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nW)<br>空间复杂度：O(W)</p>
<h3 id="0-1-背包问题无法使用贪心算法的解释"><a href="#0-1-背包问题无法使用贪心算法的解释" class="headerlink" title="0-1 背包问题无法使用贪心算法的解释"></a>0-1 背包问题无法使用贪心算法的解释</h3><p>0-1 背包问题无法使用贪心算法来求解，也就是说不能按照先添加性价比最高的物品来达到最优，这是因为这种方式可能造成背包空间的浪费，从而无法达到最优。考虑下面的物品和一个容量为 5 的背包，如果先添加物品 0 再添加物品 1，那么只能存放的价值为 16，浪费了大小为 2 的空间。最优的方式是存放物品 1 和物品 2，价值为 22.  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>w</th>
<th>v</th>
<th>v&#x2F;w</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>10</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>12</td>
<td>4</td>
</tr>
</tbody></table>
<h4 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h4><ul>
<li>完全背包：物品数量为无限个</li>
<li>多重背包：物品数量有限制</li>
<li>多维费用背包：物品不仅有重量，还有体积，同时考虑这两种限制</li>
<li>其它：物品之间相互约束或者依赖</li>
</ul>
<h3 id="3-2-5-股票问题"><a href="#3-2-5-股票问题" class="headerlink" title="3.2.5 股票问题"></a>3.2.5 股票问题</h3><h4 id="Leetcode-121-买卖股票的最佳时机（简单）"><a href="#Leetcode-121-买卖股票的最佳时机（简单）" class="headerlink" title="Leetcode 121. 买卖股票的最佳时机（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">Leetcode 121. 买卖股票的最佳时机（简单）</a></h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>
<p>题解：<br>用<code>minPrices</code>来记录历史最低价，<code>res</code>目前的最大收益。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if(prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int minPrices = prices[0], res = 0;</span><br><span class="line">    for(int &amp;p:prices)&#123;</span><br><span class="line">        res = max(res, p - minPrices);</span><br><span class="line">        minPrices = min(p,minPrices);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-122-买卖股票的最佳时机-II（简单）"><a href="#Leetcode-122-买卖股票的最佳时机-II（简单）" class="headerlink" title="Leetcode 122. 买卖股票的最佳时机 II（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">Leetcode 122. 买卖股票的最佳时机 II（简单）</a></h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>示例：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>贪心。只要第二天价格有上升，就可以获利。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">        if (prices[i] &gt; prices[i - 1])</span><br><span class="line">            res += prices[i] - prices[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<ol start="2">
<li>空间优化dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if (prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int dp0 = 0, dp1 = -prices[0];</span><br><span class="line">    int n = prices.size();</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        int dp0_new = max(dp0, dp1 + prices[i]);</span><br><span class="line">        int dp1_new = max(dp1, dp0 - prices[i]);</span><br><span class="line">        dp0 = dp0_new;</span><br><span class="line">        dp1 = dp1_new;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-123-买卖股票的最佳时机-III（困难）"><a href="#Leetcode-123-买卖股票的最佳时机-III（困难）" class="headerlink" title="Leetcode 123. 买卖股票的最佳时机 III（困难）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">Leetcode 123. 买卖股票的最佳时机 III（困难）</a></h4><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,3,5,0,0,3,1,4]  </span><br><span class="line">输出: 6  </span><br><span class="line">解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。  </span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5]  </span><br><span class="line">输出: 4  </span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出,这笔交易所能获得利润 = 5-1 = 4。`注意`你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。  </span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]   </span><br><span class="line">输出: 0   </span><br><span class="line">解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if (prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    int n = prices.size();</span><br><span class="line">    vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; dp(n,vector&lt;vector&lt;int&gt; &gt;(3, vector&lt;int&gt;(2)));</span><br><span class="line">    dp[0][1][0] = 0;</span><br><span class="line">    dp[0][1][1] = -prices[0];</span><br><span class="line">    dp[0][2][0] = 0;</span><br><span class="line">    dp[0][2][1] = -prices[0];</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][2][0] = max(dp[i - 1][2][0], dp[i - 1][2][1] + prices[i]);</span><br><span class="line">        dp[i][2][1] = max(dp[i - 1][2][1], dp[i - 1][1][0] - prices[i]);</span><br><span class="line">        dp[i][1][0] = max(dp[i - 1][1][0], dp[i - 1][1][1] + prices[i]);</span><br><span class="line">        dp[i][1][1] = max(dp[i - 1][1][1], dp[i - 1][0][0] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n - 1][2][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>空间优化dp</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if (prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    int n = prices.size();</span><br><span class="line">    int dp10 = 0;</span><br><span class="line">    int dp11 = -prices[0];</span><br><span class="line">    int dp20 = 0;</span><br><span class="line">    int dp21 = -prices[0];</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        dp20 = max(dp20, dp21 + prices[i]);</span><br><span class="line">        dp21 = max(dp21, dp10 - prices[i]);</span><br><span class="line">        dp10 = max(dp10, dp11 + prices[i]);</span><br><span class="line">        dp11 = max(dp11, -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-188-买卖股票的最佳时机-IV（困难）"><a href="#Leetcode-188-买卖股票的最佳时机-IV（困难）" class="headerlink" title="Leetcode 188. 买卖股票的最佳时机 IV（困难）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">Leetcode 188. 买卖股票的最佳时机 IV（困难）</a></h4><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,4,1], k = 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</span><br></pre></td></tr></table></figure>
<p>题解：<br>一个有收益的交易至少需要两天（在前一天买入，在后一天卖出，前提是买入价格低于卖出价格）。如果股票价格数组的长度为 n，则有收益的交易的数量最多为 n &#x2F; 2（整数除法）。因此 k 的临界值是 n &#x2F; 2。如果给定的 k 不小于临界值，即 k &gt;&#x3D; n &#x2F; 2，则可以将 k 扩展为正无穷，此时问题等价于Leetcode 122。</p>
<p>其中用到了函数重载。</p>
<ol>
<li>dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">        if (prices[i] &gt; prices[i - 1])</span><br><span class="line">            res += prices[i] - prices[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if (prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int n = prices.size();</span><br><span class="line">    if (k &gt;= n / 2)</span><br><span class="line">        return maxProfit(prices);</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; dp(n,vector&lt;vector&lt;int&gt; &gt;(k+1, vector&lt;int&gt;(2)));</span><br><span class="line">    for (int i = 1; i &lt;= k; i++) &#123;</span><br><span class="line">        dp[0][i][0] = 0;</span><br><span class="line">        dp[0][i][1] = -prices[0];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = k; j &gt; 0; j--) &#123;</span><br><span class="line">            dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);</span><br><span class="line">            dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n - 1][k][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nk)<br>空间复杂度：O(nk)</p>
<ol start="2">
<li>空间优化。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">        if (prices[i] &gt; prices[i - 1])</span><br><span class="line">            res += prices[i] - prices[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if (prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int n = prices.size();</span><br><span class="line">    if (k &gt;= n / 2)</span><br><span class="line">        return maxProfit(prices);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(k+1, vector&lt;int&gt;(2));</span><br><span class="line">    for (int i = 1; i &lt;= k; i++) &#123;</span><br><span class="line">        dp[i][0] = 0;</span><br><span class="line">        dp[i][1] = -prices[0];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = k; j &gt; 0; j--) &#123;</span><br><span class="line">            dp[j][0] = max(dp[j][0], dp[j][1] + prices[i]);</span><br><span class="line">            dp[j][1] = max(dp[j][1], dp[j - 1][0] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[k][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nk)<br>空间复杂度：O(n)</p>
<h4 id="Leetcode-309-最佳买卖股票时机含冷冻期（中等）"><a href="#Leetcode-309-最佳买卖股票时机含冷冻期（中等）" class="headerlink" title="Leetcode 309. 最佳买卖股票时机含冷冻期（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">Leetcode 309. 最佳买卖股票时机含冷冻期（中等）</a></h4><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]  </span><br><span class="line">输出: 3   </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>dp。<code>dp[i]</code>表示第 i 天结束之后的<strong>累计最大收益</strong>。<ul>
<li><code>dp[i][0]</code>表示目前持有一支股票，对应的累计最大收益</li>
<li><code>dp[i][1]</code>表示目前不持有任何股票，并且处于冷冻期中，对应的累计最大收益</li>
<li><code>dp[i][2]</code>表示目前不持有任何股票，并且不处于冷冻期中，对应的累计最大收益</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if(prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(prices.size(), vector&lt;int&gt;(3));</span><br><span class="line">    dp[0][0] = -prices[0]; //dp[0][1] = dp[0][2] = 0</span><br><span class="line">    for (int i = 1; i &lt; prices.size();i++)&#123;</span><br><span class="line">        dp[i][0] = max(dp[i - 1][2] - prices[i], dp[i - 1][0]); //买了，或者没有买。不可能从冷却期直接到持有</span><br><span class="line">        dp[i][1] = dp[i - 1][0] + prices[i]; //卖了</span><br><span class="line">        dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]); //冷却期过度，或者没有买</span><br><span class="line">    &#125;</span><br><span class="line">    return max(dp[prices.size() - 1][1], dp[prices.size() - 1][2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>空间优化。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if(prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int dp0 = -prices[0];</span><br><span class="line">    int dp1 = 0;</span><br><span class="line">    int dp2 = 0;</span><br><span class="line">    for (int i = 1; i &lt; prices.size(); ++i) &#123;</span><br><span class="line">        int dp0_new = max(dp0, dp2 - prices[i]);</span><br><span class="line">        int dp1_new = dp0 + prices[i];</span><br><span class="line">        int dp2_new = max(dp1, dp2);</span><br><span class="line">        dp0 = dp0_new;</span><br><span class="line">        dp1 = dp1_new;</span><br><span class="line">        dp2 = dp2_new;</span><br><span class="line">    &#125;</span><br><span class="line">    return max(dp1, dp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-714-买卖股票的最佳时机含手续费（中等）"><a href="#Leetcode-714-买卖股票的最佳时机含手续费（中等）" class="headerlink" title="Leetcode 714. 买卖股票的最佳时机含手续费（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">Leetcode 714. 买卖股票的最佳时机含手续费（中等）</a></h4><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [1, 3, 2, 8, 4, 9], fee = 2  </span><br><span class="line">Output: 8  </span><br><span class="line">Explanation: The maximum profit can be achieved by:  </span><br><span class="line">Buying at prices[0] = 1  </span><br><span class="line">Selling at prices[3] = 8  </span><br><span class="line">Buying at prices[4] = 4  </span><br><span class="line">Selling at prices[5] = 9  </span><br><span class="line">The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">    if (prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int n = prices.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(n,vector&lt;int&gt;(2));</span><br><span class="line">    dp[0][0] = 0;</span><br><span class="line">    dp[0][1] = -prices[0];</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);</span><br><span class="line">        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n - 1][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>空间优化。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">    if (prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int n = prices.size();</span><br><span class="line">    int dp0 = 0;</span><br><span class="line">    int dp1 = -prices[0];</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        int dp0_new = max(dp0, dp1 + prices[i] - fee);</span><br><span class="line">        int dp1_new = max(dp1, dp0 - prices[i]);</span><br><span class="line">        dp0 = dp0_new;</span><br><span class="line">        dp1 = dp1_new;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="res"><a href="#res" class="headerlink" title="res"></a>res</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/circle/article/qiAgHn/">股票问题系列通解</a></p>
<h3 id="3-2-6-字符串问题"><a href="#3-2-6-字符串问题" class="headerlink" title="3.2.6 字符串问题"></a>3.2.6 字符串问题</h3><h4 id="Leetcode-650-只有两个键的键盘（中等）"><a href="#Leetcode-650-只有两个键的键盘（中等）" class="headerlink" title="Leetcode 650. 只有两个键的键盘（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/2-keys-keyboard/">Leetcode 650. 只有两个键的键盘（中等）</a></h4><p>最开始只有一个字符 A，问需要多少次操作能够得到 n 个字符 A，每次操作可以复制当前所有的字符，或者粘贴。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">最初, 我们只有一个字符 &#x27;A&#x27;。</span><br><span class="line">第 1 步, 我们使用 Copy All 操作。</span><br><span class="line">第 2 步, 我们使用 Paste 操作来获得 &#x27;AA&#x27;。</span><br><span class="line">第 3 步, 我们使用 Paste 操作来获得 &#x27;AAA&#x27;。</span><br></pre></td></tr></table></figure>
<p>题解：<br>dp。<code>dp[i]</code>表示通过复制粘贴操作，得到 i 个字符，最少需要几步操作。  </p>
<p>如果一个数是素数，那么最少操作就是一开始复制一个，最后一个个粘贴；如果一个数不是素数，那么最少操作就可以按它的因数分解一下，简化操作。  </p>
<p>比如12，可以分解为 以下几种情况：  </p>
<ul>
<li>12 &#x3D; 2*6, 需要操作CPCPPPPP总共8步  </li>
<li>12 &#x3D; 3*4, 需要操作CPPCPPP总共7步  </li>
<li>12 &#x3D; 4*3, 需要操作CPPPCPP总共7步  </li>
<li>12 &#x3D; 6*2, 需要操作CPPPPPCP总共8步</li>
</ul>
<p>其实可以发现，因子相同的情况下，交换因子相乘的顺序，需要的步骤是一样的。所以我们可以简化一下分解的步骤，只需要找到小于<code>sqrt(n)</code>的因子即可。假设找到的因子是 j ，那么需要的最小步骤就是 <code>dp[j] + dp[i/j]</code>，其中，<code>dp[j]</code>表示需要多少步生成这个因子，<code>dp[i/j]</code>表示需要多少步基于这个因子得到 i。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int minSteps(int n)&#123;</span><br><span class="line">    vector&lt;int&gt; dp(n + 1);</span><br><span class="line">    int h = sqrt(n);</span><br><span class="line">    for (int i = 2; i &lt;= n;i++)&#123;</span><br><span class="line">        dp[i] = i;</span><br><span class="line">        for (int j = 2; j &lt;= h; j++)&#123;</span><br><span class="line">            if(i%j==0)&#123;</span><br><span class="line">                dp[i] = dp[j] + dp[i / j];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^(1&#x2F;2))<br>空间复杂度：O(1)</p>
<h2 id="3-3-贪心算法-greedy"><a href="#3-3-贪心算法-greedy" class="headerlink" title="3.3 贪心算法(greedy)"></a>3.3 贪心算法(greedy)</h2><p>每次都选择局部最优的策略，最后达到全局最优。但是，有的问题使用贪心算法不能保证达到全局最优，如 0-1背包问题。  </p>
<h3 id="Leetcode-455-分发饼干（简单）"><a href="#Leetcode-455-分发饼干（简单）" class="headerlink" title="Leetcode 455. 分发饼干（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/assign-cookies/">Leetcode 455. 分发饼干（简单）</a></h3><p>每个孩子都有一个满足度 grid，每个饼干都有一个大小 size，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。  </p>
<p>示例：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid[1,3], size[1,2,4]  </span><br><span class="line">Output: 2  </span><br></pre></td></tr></table></figure>
<p>题解：<br>给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;</span><br><span class="line">    sort(g.begin(), g.end());</span><br><span class="line">    sort(s.begin(), s.end());</span><br><span class="line"></span><br><span class="line">    int m = g.size();</span><br><span class="line">    int n = s.size();</span><br><span class="line">    int idxG = 0, idxS = 0;</span><br><span class="line">    while(idxG&lt;m &amp;&amp; idxS&lt;n)&#123;</span><br><span class="line">        if(g[idxG]&lt;=s[idxS])</span><br><span class="line">            idxG++;</span><br><span class="line">        idxS++;</span><br><span class="line">    &#125;</span><br><span class="line">    return idxG;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)，因为要排序<br>空间复杂度：O(1)</p>
<h3 id="上一题的变体"><a href="#上一题的变体" class="headerlink" title="上一题的变体"></a>上一题的变体</h3><p>要求出满足最多孩子的方法中每个孩子得到的的饼干编号。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = &#123;90, 33, 16&#125; size = &#123;9, 20, 50, 40, 99, 1&#125;</span><br><span class="line"></span><br><span class="line">输出： 5 4 2</span><br></pre></td></tr></table></figure>
<p>题解：<br>使用了map的自动key排序功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; cookiesAssign2(vector&lt;int&gt; &amp;grid, vector&lt;int&gt; &amp;size)&#123;</span><br><span class="line">    map&lt;int, int&gt; sizeMap; //key: grid val: idx</span><br><span class="line">    map&lt;int, int&gt; gridMap; //key: size val: idx</span><br><span class="line">    for (int i = 0; i &lt; grid.size(); i++)</span><br><span class="line">        gridMap.insert(&#123;grid[i], i&#125;);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; size.size();i++)</span><br><span class="line">        sizeMap.insert(&#123;size[i], i&#125;);</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; res(grid.size(), -1);</span><br><span class="line">    for (auto itG = gridMap.begin(), itS = sizeMap.begin(); itG != gridMap.end() &amp;&amp; itS!=sizeMap.end(); itG++, itS++)</span><br><span class="line">    &#123;</span><br><span class="line">        while(itS!=sizeMap.end() &amp;&amp; itS-&gt;first &lt; itG-&gt;first)</span><br><span class="line">            itS++;</span><br><span class="line">        if(itS==sizeMap.end())</span><br><span class="line">            break;</span><br><span class="line">        res[itG-&gt;second] = itS-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Leetcode-435-无重叠区间（中等）"><a href="#Leetcode-435-无重叠区间（中等）" class="headerlink" title="Leetcode 435. 无重叠区间（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-overlapping-intervals/">Leetcode 435. 无重叠区间（中等）</a></h3><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [ [1,2], [1,2], [1,2] ]  </span><br><span class="line">Output: 2  </span><br><span class="line">Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.  </span><br><span class="line">Input: [ [1,2], [2,3] ]  </span><br><span class="line">Output: 0  </span><br><span class="line">Explanation: You don&#x27;t need to remove any of the intervals since they&#x27;re already non-overlapping.  </span><br></pre></td></tr></table></figure>
<p>题解：<br>先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123;</span><br><span class="line">    return a[1] &lt; b[1];</span><br><span class="line">&#125;</span><br><span class="line">int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals)&#123;</span><br><span class="line">    if(intervals.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    int end = intervals[0][0];</span><br><span class="line">    for(auto num:intervals)&#123;</span><br><span class="line">        if(num[0]&gt;=end)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            end = num[1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return intervals.size()-cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)，因为要排序<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-452-用最少数量的箭引爆气球（中等）"><a href="#Leetcode-452-用最少数量的箭引爆气球（中等）" class="headerlink" title="Leetcode 452. 用最少数量的箭引爆气球（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">Leetcode 452. 用最少数量的箭引爆气球（中等）</a></h3><p>气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:[[10,16], [2,8], [1,6], [7,12]]  </span><br><span class="line">Output:2  </span><br></pre></td></tr></table></figure>
<p>题解：<br>求解最小的投飞镖次数使所有气球都被刺破。也是计算不重叠的区间个数，不过和 Leetcode 435 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。所以if判定条件不要”&#x3D;”，<code>end</code>初始化要比<code>points[0][0]</code>小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123;</span><br><span class="line">    return a[1] &lt; b[1];</span><br><span class="line">&#125;</span><br><span class="line">int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">    if(points.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    sort(points.begin(), points.end(), cmp);</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    long end = (long)points[0][0]-1;</span><br><span class="line">    for(auto num:points)&#123;</span><br><span class="line">        if(num[0]&gt;end)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            end = num[1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)，因为要排序<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-406-根据身高重建队列（中等）"><a href="#Leetcode-406-根据身高重建队列（中等）" class="headerlink" title="Leetcode 406. 根据身高重建队列（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">Leetcode 406. 根据身高重建队列（中等）</a></h3><p>乱序重建：一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]  </span><br><span class="line">Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]  </span><br></pre></td></tr></table></figure>
<p>题解：<br>为了使插入操作不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置。身高 h 降序、个数 k 值升序，然后将某个学生插入队列的第 k 个位置中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool cmp0aca1dec(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123;</span><br><span class="line">    return a[0] == b[0] ? a[1] &lt;= b[1] : a[0] &gt; b[0];</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">    if(people.empty())</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    sort(people.begin(), people.end(), cmp0aca1dec);</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    for (int i = 0; i &lt; people.size(); i++)&#123;</span><br><span class="line">        auto pos = res.begin();</span><br><span class="line">        res.insert(pos+people[i][1], people[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Leetcode-605-种花问题（简单）"><a href="#Leetcode-605-种花问题（简单）" class="headerlink" title="Leetcode 605. 种花问题（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/can-place-flowers/">Leetcode 605. 种花问题（简单）</a></h3><p>flowerbed 数组中 1 表示已经种下了花朵。花朵之间至少需要一个单位的间隔，求解是否能种下 n 朵花。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: flowerbed = [1,0,0,0,1], n = 1  </span><br><span class="line">Output: True  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123;</span><br><span class="line">    int nFlower = flowerbed.size();</span><br><span class="line">    if(n==0)</span><br><span class="line">        return true;</span><br><span class="line">    for (int i = 0; i &lt; nFlower; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(flowerbed[i]==1)</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        int pre = i-1 &gt;= 0 ? flowerbed[i - 1] : 0; //第一个位置?</span><br><span class="line">        int next = i+1 &lt;= nFlower-1 ? flowerbed[i + 1] : flowerbed[nFlower-1];//最后一个位置?</span><br><span class="line">        if(pre==0 &amp;&amp; next==0 )&#123;</span><br><span class="line">            flowerbed[i] = 1;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n==0)</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-392-判断子序列（简单）"><a href="#Leetcode-392-判断子序列（简单）" class="headerlink" title="Leetcode 392.判断子序列（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/is-subsequence/">Leetcode 392.判断子序列（简单）</a></h3><p>判断是否为子序列 </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;abc&quot;, t = &quot;ahbgdc&quot;  </span><br><span class="line">Return true.  </span><br></pre></td></tr></table></figure>
<p>题解：<br>双指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool isSubsequence(string s, string t) &#123;</span><br><span class="line">    if(t.empty())&#123;</span><br><span class="line">        if(s.empty())</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int idxS=0,idxT=0;</span><br><span class="line">    while(idxS&lt;s.size() &amp;&amp; idxT&lt;t.size())&#123;</span><br><span class="line">        if(s[idxS]==t[idxT])</span><br><span class="line">            idxS++;</span><br><span class="line">        idxT++;</span><br><span class="line">    &#125;</span><br><span class="line">    return idxS==s.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m+n)<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-665-非递减数列（简单）"><a href="#Leetcode-665-非递减数列（简单）" class="headerlink" title="Leetcode 665. 非递减数列（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-decreasing-array/">Leetcode 665. 非递减数列（简单）</a></h3><p>判断一个数组是否能只修改一个数就成为非递减数组。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,2,3]  </span><br><span class="line">Output: True  </span><br><span class="line">Explanation: You could modify the first 4 to 1 to get a non-decreasing array.  </span><br></pre></td></tr></table></figure>
<p>题解：<br>如果下一个点有下降，我们当前点称为拐点，如[1,3,2]中的3。</p>
<ul>
<li>如果拐点前一个数小于等于拐点后一个数，如[1,3,2,4,5]中1&lt;2，则改变拐点的数，把 3 变成 2 能保证数列不减，且不改变前后的拐点数。</li>
<li>如果拐点前一个数大于拐点后一个数，如[2,3,1,4,5]中2&gt;1，则改变拐点后的数，把 1 变成 3 能保证数列不减，且不改变前后的拐点数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (int i = 1; i &lt; nums.size() &amp;&amp; cnt &lt; 2;i++)&#123;</span><br><span class="line">        if(nums[i]&gt;=nums[i-1])</span><br><span class="line">            continue;</span><br><span class="line">        cnt++;</span><br><span class="line">        if(i&gt;=2 &amp;&amp; nums[i-2]&gt;nums[i])</span><br><span class="line">            nums[i] = nums[i - 1];</span><br><span class="line">        else</span><br><span class="line">            nums[i - 1] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return (cnt &lt;= 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-763-划分字母区间（中等）"><a href="#Leetcode-763-划分字母区间（中等）" class="headerlink" title="Leetcode 763. 划分字母区间（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-labels/">Leetcode 763. 划分字母区间（中等）</a></h3><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ababcbacadefegdehijhklij&quot;  </span><br><span class="line">Output: [9,7,8]  </span><br><span class="line">Explanation:  </span><br><span class="line">The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.  </span><br><span class="line">This is a partition so that each letter appears in at most one part. A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts.  </span><br></pre></td></tr></table></figure>
<p>题解：<br>策略就是不断地选择从最左边起最小的区间。</p>
<p>可以从第一个字母开始分析，假设第一个字母是 ‘a’，那么第一个区间一定包含最后一次出现的 ‘a’。但第一个出现的 ‘a’ 和最后一个出现的 ‘a’ 之间可能还有其他字母，这些字母会让区间变大。举个例子，在 “abccaddbeffe” 字符串中，第一个最小的区间是 “abccaddb”。  </p>
<p>通过以上的分析，我们可以得出一个算法：对于遇到的每一个字母，去找这个字母最后一次出现的位置，用来更新当前的最小区间。如果要输出所有子串，把备注取消就可以。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; partitionLabels(string S) &#123;</span><br><span class="line">    vector&lt;int&gt; alphabet(26);</span><br><span class="line">    for (int i = 0; i &lt; S.size();i++)</span><br><span class="line">        alphabet[S[i] - &#x27;a&#x27;] = i;</span><br><span class="line"></span><br><span class="line">    int startIdx = 0, lastIdx = 0;</span><br><span class="line">    //vector&lt;string&gt; subS;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for (int i = 0; i &lt; S.size(); i++)&#123;</span><br><span class="line">        char tmp = S[i];</span><br><span class="line">        lastIdx = max(alphabet[tmp - &#x27;a&#x27;], lastIdx);</span><br><span class="line">        if(lastIdx==i)&#123;</span><br><span class="line">            res.push_back(lastIdx - startIdx + 1);</span><br><span class="line">            //string tmpStr = S.substr(startIdx, lastIdx - startIdx + 1);</span><br><span class="line">            //subS.push_back(tmpStr);</span><br><span class="line">            startIdx = i + 1;</span><br><span class="line">            lastIdx = i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h2 id="3-4-双指针"><a href="#3-4-双指针" class="headerlink" title="3.4 双指针"></a>3.4 双指针</h2><p>双指针主要用于遍历数组，两个指针指向不同的位置，协同完成任务。  </p>
<p>（剑指offer的双指针操作）</p>
<h3 id="Leetcode-167-两数之和-II-输入有序数组（简单）"><a href="#Leetcode-167-两数之和-II-输入有序数组（简单）" class="headerlink" title="Leetcode 167. 两数之和 II - 输入有序数组（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">Leetcode 167. 两数之和 II - 输入有序数组（简单）</a></h3><p>给定一个已按照<strong>升序排列</strong>的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<p><strong>说明</strong>:</p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numbers=&#123;2, 7, 11, 15&#125;, target=9  </span><br><span class="line">Output: index1=1, index2=2  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历：</li>
</ol>
<ul>
<li>如果两个指针指向元素的和 sum &#x3D;&#x3D; target，那么得到要求的结果；</li>
<li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li>
<li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">    if(numbers.empty())</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    int start = 0;</span><br><span class="line">    int end = numbers.size()-1;</span><br><span class="line">    while(start&lt;end)&#123;</span><br><span class="line">        if(numbers[start]+numbers[end] == target)</span><br><span class="line">            return &#123;start+1, end+1&#125;;</span><br><span class="line">        if(numbers[start]+numbers[end]&gt;target)</span><br><span class="line">            end --;</span><br><span class="line">        else if(numbers[start]+numbers[end]&lt;target)</span><br><span class="line">            start ++;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<ol start="2">
<li>哈希表。无序的序列也适用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">    unordered_map&lt;int, int&gt; numMap;</span><br><span class="line">    for (int i = 0; i &lt; numbers.size();i++)</span><br><span class="line">        numMap[numbers[i]] = i;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; numbers.size();i++)&#123;</span><br><span class="line">        auto it = numMap.find(target - numbers[i]);</span><br><span class="line">        if (it != numMap.end())</span><br><span class="line">            return &#123;i + 1, it-&gt;second+1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h3 id="Leetcode-633-平方数之和（简单）"><a href="#Leetcode-633-平方数之和（简单）" class="headerlink" title="Leetcode 633. 平方数之和（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-square-numbers/">Leetcode 633. 平方数之和（简单）</a></h3><p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 &#x3D; c 。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 5  </span><br><span class="line">Output: True  </span><br><span class="line">Explanation: 1 * 1 + 2 * 2 = 5  </span><br></pre></td></tr></table></figure>
<p>题解：<br>本题和 「167. 两数之和 II - 输入有序数组」 类似，只有一个明显区别：一个是和为 target，一个是平方和为 target。本题同样可以使用双指针得到两个数，使其平方和为 target。<br>本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 0^2 + x^2 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。因为最多只需要遍历一次 0-sqrt(target)，所以时间复杂度为 O(sqrt(target))。又因为只使用了两个额外的变量，因此空间复杂度为 O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool judgeSquareSum(int c) &#123;</span><br><span class="line">    if(c &lt; 0) </span><br><span class="line">        return false;</span><br><span class="line">    int start = 0;</span><br><span class="line">    int end = sqrt(c);</span><br><span class="line">    while(start&lt;=end)&#123;</span><br><span class="line">        if((long)start*start + (long)end*end == (long)c)</span><br><span class="line">            return true;</span><br><span class="line">        else if((long)start*start + (long)end*end &gt; (long)c)</span><br><span class="line">            end--;</span><br><span class="line">        else</span><br><span class="line">            start++;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(c^(1&#x2F;2))<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-345-反转字符串中的元音字母（简单）"><a href="#Leetcode-345-反转字符串中的元音字母（简单）" class="headerlink" title="Leetcode 345. 反转字符串中的元音字母（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">Leetcode 345. 反转字符串中的元音字母（简单）</a></h3><p>反转字符串中的元音字符</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given s = &quot;Leetcode&quot;, return &quot;Leotcede&quot;.  </span><br></pre></td></tr></table></figure>
<p>题解：<br>使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。为了快速判断一个字符是不是元音字符，我们将全部元音字符添加到集合 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">string reverseVowels(string s) &#123;</span><br><span class="line">    unordered_set&lt;char&gt; hs = &#123;&#x27;a&#x27;,&#x27;e&#x27;,&#x27;i&#x27;,&#x27;o&#x27;,&#x27;u&#x27;,&#x27;A&#x27;,&#x27;E&#x27;,&#x27;I&#x27;,&#x27;O&#x27;,&#x27;U&#x27;&#125;;//c++11之后才可以这样初始化</span><br><span class="line">    int start = 0;</span><br><span class="line">    int end = s.size() - 1;</span><br><span class="line">    string res = s;</span><br><span class="line">    while (start&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        char tmp_start = s[start];</span><br><span class="line">        char tmp_end = s[end];</span><br><span class="line">        if (hs.find(tmp_start)==hs.end())//tmp不在hs中</span><br><span class="line">            res[start++] = tmp_start;</span><br><span class="line">        else if(hs.find(tmp_end)==hs.end())</span><br><span class="line">            res[end--] = tmp_end;</span><br><span class="line">        else&#123;</span><br><span class="line">            res[start++] = tmp_end;</span><br><span class="line">            res[end--] = tmp_start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-680-验证回文字符串-Ⅱ（简单）"><a href="#Leetcode-680-验证回文字符串-Ⅱ（简单）" class="headerlink" title="Leetcode 680. 验证回文字符串 Ⅱ（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome-ii/">Leetcode 680. 验证回文字符串 Ⅱ（简单）</a></h3><p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abca&quot;  </span><br><span class="line">Output: True  </span><br><span class="line">Explanation: You could delete the character &#x27;c&#x27;.  </span><br></pre></td></tr></table></figure>
<p>题解：<br>使用双指针可以很容易判断一个字符串是否是回文字符串：<br>令一个指针从左到右遍历，一个指针从右到左遍历，这两个指针同时移动一个位置，每次都判断两个指针指向的字符是否相同，如果都相同，字符串才是具有左右对称性质的回文字符串。在判断是否为回文字符串时，我们不需要判断整个字符串，因为左指针左边和右指针右边的字符之前已经判断过具有对称性质，所以只需要判断中间的子字符串即可。在试着删除字符时，我们既可以删除左指针指向的字符，也可以删除右指针指向的字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool isPalindrome(string s,int start,int end)&#123;</span><br><span class="line">    while(start &lt; end)&#123;</span><br><span class="line">        if (s[start++]!=s[end--])</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">bool validPalindrome(string s) &#123;</span><br><span class="line">    if(s.size()&lt;=1)</span><br><span class="line">        return true;</span><br><span class="line">    int start = 0;</span><br><span class="line">    int end = s.size() - 1;</span><br><span class="line">    bool res = true;</span><br><span class="line">    while (start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        if (s[start] != s[end])</span><br><span class="line">        &#123;</span><br><span class="line">            res = isPalindrome(s, start + 1, end) || isPalindrome(s, start, end - 1);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-88-合并两个有序数组（简单）"><a href="#Leetcode-88-合并两个有序数组（简单）" class="headerlink" title="Leetcode 88. 合并两个有序数组（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-sorted-array/">Leetcode 88. 合并两个有序数组（简单）</a></h3><p>归并两个有序数组，把归并结果存到第一个数组上。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:  </span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3  </span><br><span class="line">nums2 = [2,5,6],       n = 3  </span><br><span class="line">Output: [1,2,2,3,5,6]  </span><br></pre></td></tr></table></figure>
<p>题解：<br>需要从尾开始遍历，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">    int idx1 = m - 1;</span><br><span class="line">    int idx2 = n - 1;</span><br><span class="line">    int idx = m + n - 1;</span><br><span class="line">    while (idx1&gt;=0 || idx2&gt;=0)&#123;</span><br><span class="line">        if(idx1&lt;0)</span><br><span class="line">            nums1[idx--] = nums2[idx2--];</span><br><span class="line">        else if(idx2&lt;0)//这时候nums2已经插完，其实可以直接return nums1了</span><br><span class="line">            nums1[idx--] = nums1[idx1--];</span><br><span class="line">        else if(nums1[idx1]&gt;nums2[idx2])</span><br><span class="line">            nums1[idx--] = nums1[idx1--];</span><br><span class="line">        else</span><br><span class="line">            nums1[idx--] = nums2[idx2--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m+n)<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-141-环形链表（简单）"><a href="#Leetcode-141-环形链表（简单）" class="headerlink" title="Leetcode 141. 环形链表（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">Leetcode 141. 环形链表（简单）</a></h3><p>判断链表是否存在环</p>
<ol>
<li>双指针（快慢指针），一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool hasCycle(ListNode *head) &#123;</span><br><span class="line">    if(head == nullptr || head-&gt;next == nullptr)</span><br><span class="line">        return false;</span><br><span class="line">    ListNode *p1 = head-&gt;next;</span><br><span class="line">    ListNode *p2 = head-&gt;next-&gt;next;</span><br><span class="line">    while(p2!=nullptr &amp;&amp; p2-&gt;next!=nullptr)&#123;</span><br><span class="line">        if(p1-&gt;val == p2-&gt;val)</span><br><span class="line">            return true;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<ol start="2">
<li>哈希表。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool hasCycle(ListNode *head) &#123;</span><br><span class="line">    if(head == nullptr || head-&gt;next == nullptr)</span><br><span class="line">        return false;</span><br><span class="line">    unordered_set&lt;ListNode *&gt; us;</span><br><span class="line">    while (head != nullptr)&#123;</span><br><span class="line">        if (us.count(head))</span><br><span class="line">            return true;</span><br><span class="line">        us.insert(head);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h3 id="Leetcode-524-通过删除字母匹配到字典里最长单词（中等）"><a href="#Leetcode-524-通过删除字母匹配到字典里最长单词（中等）" class="headerlink" title="Leetcode 524. 通过删除字母匹配到字典里最长单词（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">Leetcode 524. 通过删除字母匹配到字典里最长单词（中等）</a></h3><p>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]  </span><br><span class="line">Output: &quot;apple&quot;  </span><br></pre></td></tr></table></figure>
<p>题解：<br>可以使用双指针来判断一个字符串是否为另一个字符串的子序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool isSubstr(string s, string d)&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(i&lt;s.size() &amp;&amp; j&lt;d.size())&#123;</span><br><span class="line">        if(s[i]==d[j])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return j == d.size();</span><br><span class="line">&#125;</span><br><span class="line">string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    for (string cur:d)&#123;</span><br><span class="line">        if(res.size()&gt;cur.size() || (res.size()==cur.size() &amp;&amp; res&lt;cur))</span><br><span class="line">            continue;</span><br><span class="line">        if (isSubstr(s, cur))</span><br><span class="line">            res = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nl)，l 是字典里字符串的平均长度<br>空间复杂度：O(n)</p>
<h3 id="Leetcode-75-颜色分类（中等）"><a href="#Leetcode-75-颜色分类（中等）" class="headerlink" title="Leetcode 75. 颜色分类（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/">Leetcode 75. 颜色分类（中等）</a></h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,0,2,1,1,0] </span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int zero = -1;</span><br><span class="line">    int one = 0;</span><br><span class="line">    int two = nums.size();</span><br><span class="line">    while(one&lt;two)&#123;</span><br><span class="line">        if(nums[one]==0)</span><br><span class="line">            swap(nums[++zero],nums[one++]);</span><br><span class="line">        else if(nums[one]==2)</span><br><span class="line">            swap(nums[--two], nums[one]); //从后面换上来的可能是0，所以one不能往后移动</span><br><span class="line">        else</span><br><span class="line">            one++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-42-接雨水（困难）"><a href="#Leetcode-42-接雨水（困难）" class="headerlink" title="Leetcode 42. 接雨水（困难）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/">Leetcode 42. 接雨水（困难）</a></h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>用<code>left_max[i]</code> 和 <code>right_max[i]</code> 表示 i 左边和右边的最大值。这样就把暴力法时间复杂度的O(n^2)降为O(n)。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int trap(vector&lt;int&gt;&amp; height)</span><br><span class="line">&#123;</span><br><span class="line">    if (height.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int res = 0;</span><br><span class="line">    int n = height.size();</span><br><span class="line">    vector&lt;int&gt; left_max(n), right_max(n);</span><br><span class="line">    left_max[0] = height[0];</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        left_max[i] = max(height[i], left_max[i - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    right_max[n - 1] = height[n - 1];</span><br><span class="line">    for (int i = n - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">        right_max[i] = max(height[i], right_max[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; n - 1; i++) &#123;</span><br><span class="line">        res += min(left_max[i], right_max[i]) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>双指针。<br><img src="https://i.loli.net/2020/10/16/hGiceXPkE1marBQ.png" alt="算法"></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int trap(vector&lt;int&gt;&amp; height)</span><br><span class="line">&#123;</span><br><span class="line">    int left = 0, right = height.size() - 1;</span><br><span class="line">    int res = 0;</span><br><span class="line">    int left_max = 0, right_max = 0;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        if (height[left] &lt; height[right]) &#123;</span><br><span class="line">            height[left] &gt;= left_max ? (left_max = height[left]) : res += (left_max - height[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            height[right] &gt;= right_max ? (right_max = height[right]) : res += (right_max - height[right]);</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h2 id="3-5-排序（Sorting）"><a href="#3-5-排序（Sorting）" class="headerlink" title="3.5 排序（Sorting）"></a>3.5 排序（Sorting）</h2><p><a href="https://github.com/suzhilong/CS/blob/master/sort.py">python实现的八大排序</a>  </p>
<p>cpp实现八大排序：</p>
<ul>
<li><p><a href="https://github.com/suzhilong/Algorithm/blob/master/sort/cpp/insertSort.cpp">插入排序</a></p>
</li>
<li><p><a href="https://github.com/suzhilong/Algorithm/blob/master/sort/cpp/shellSort.cpp">希尔排序</a></p>
</li>
<li><p><a href="https://github.com/suzhilong/Algorithm/blob/master/sort/cpp/selectionSort.cpp">选择排序</a></p>
</li>
<li><p><a href="https://github.com/suzhilong/Algorithm/blob/master/sort/cpp/bubbleSort.cpp">冒泡排序</a></p>
</li>
<li><p><a href="https://github.com/suzhilong/Algorithm/blob/master/sort/cpp/quickSort.cpp">快速排序</a></p>
</li>
<li><p><a href="https://github.com/suzhilong/Algorithm/blob/master/sort/cpp/heapSort.cpp">堆排序</a></p>
</li>
<li><p><a href="https://github.com/suzhilong/Algorithm/blob/master/sort/cpp/mergeSort.cpp">归并排序</a></p>
</li>
<li><p><a href="https://github.com/suzhilong/Algorithm/blob/master/sort/cpp/radixSort.cpp">基数排序</a></p>
</li>
<li><p>快排变为稳定排序的方法。三遍扫描原序列：</p>
<ol>
<li>第一遍先把小于pivot的元素按先后顺序放到tmp里，然后把pivot放到它的正确位置tmp[k]；</li>
<li>第二遍把大于pivot的元素按先后顺序追加在tmp里，这样除了pivot以前的其他元素，都保持了和原序列中一样的顺序；</li>
<li>第三遍把tmp赋值回原数组A。</li>
</ol>
</li>
</ul>
<h3 id="3-5-1-Partition函数"><a href="#3-5-1-Partition函数" class="headerlink" title="3.5.1 Partition函数"></a>3.5.1 Partition函数</h3><p>Partition函数可以用在快排中，也可以用来实现在长度为n的数组中查找第k大的数字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int Partition(std::vector&lt;int&gt; &amp;nums, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    if (nums.size() &lt; 2 || start&lt;0 || end&gt;nums.size())</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    int idx = start + std::rand() % (end - start + 1);//随机生成一个[start,end]的整数</span><br><span class="line">    int pivot = nums[idx];</span><br><span class="line">    nums[idx] = nums[start];//相当于把nums[idx]换到首位</span><br><span class="line">    while (start &lt; end) &#123;</span><br><span class="line">        while (start &lt; end &amp;&amp; nums[end] &gt;= pivot)</span><br><span class="line">            end--;</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        while (start &lt; end &amp;&amp; nums[start] &lt;= pivot)</span><br><span class="line">            start++;</span><br><span class="line">        nums[end] = nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[start] = pivot;</span><br><span class="line">    return start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快排（cpp）"><a href="#快排（cpp）" class="headerlink" title="快排（cpp）"></a>快排（cpp）</h3><h4 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void QuickSort(vector&lt;int&gt; &amp;arr, int start, int end)&#123;</span><br><span class="line">    if(start==end)</span><br><span class="line">        return;</span><br><span class="line">    int mid = Partition(arr, start, end);</span><br><span class="line">    if(mid&gt;start)</span><br><span class="line">        QuickSort(arr, start, mid - 1);</span><br><span class="line">    if(mid&lt;end)</span><br><span class="line">        QuickSort(arr, mid + 1, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非递归版"><a href="#非递归版" class="headerlink" title="非递归版"></a>非递归版</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void QuickSort(vector&lt;int&gt; &amp;nums)&#123;</span><br><span class="line">    if (nums.empty())</span><br><span class="line">        return;</span><br><span class="line">    stack&lt;int&gt; stk;</span><br><span class="line">    stk.push(nums.size()-1);//先压右指针</span><br><span class="line">    stk.push(0);//再压左指针</span><br><span class="line">    while (!stk.empty())&#123;</span><br><span class="line">        int start = stk.top();//先弹出左指针</span><br><span class="line">        stk.pop();</span><br><span class="line">        int end = stk.top();//再弹出右指针</span><br><span class="line">        stk.pop();</span><br><span class="line">        if (start &lt; end)&#123;</span><br><span class="line">            int mid = Partition(nums, start, end);</span><br><span class="line">            if (mid &gt; start)&#123;//保存中间变量</span><br><span class="line">                stk.push(mid - 1);</span><br><span class="line">                stk.push(start);  </span><br><span class="line">            &#125;</span><br><span class="line">            if (end &gt; mid)&#123;</span><br><span class="line">                stk.push(end);</span><br><span class="line">                stk.push(mid + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-2-例题"><a href="#3-5-2-例题" class="headerlink" title="3.5.2 例题"></a>3.5.2 例题</h3><h4 id="TOP-K-问题"><a href="#TOP-K-问题" class="headerlink" title="TOP K 问题"></a>TOP K 问题</h4><ul>
<li>排序 ：时间复杂度 O(NlogN)，空间复杂度 O(1)  </li>
<li>堆 ：时间复杂度 O(NlogK)，空间复杂度 O(K)  </li>
<li>快速选择 ：时间复杂度 O(N)，空间复杂度 O(1)</li>
</ul>
<h5 id="Leetcode-215-数组中的第K个最大元素（中等）"><a href="#Leetcode-215-数组中的第K个最大元素（中等）" class="headerlink" title="Leetcode 215. 数组中的第K个最大元素（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">Leetcode 215. 数组中的第K个最大元素（中等）</a></h5><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,1,5,6,4] and k = 2  </span><br><span class="line">Output: 5  </span><br><span class="line">Kth Element, 在排序数组中 == 找到倒数第 k 个的元素。  </span><br></pre></td></tr></table></figure>

<p>题解：  </p>
<ol>
<li>快排变形。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">    int target = nums.size()-k;</span><br><span class="line">    int l = 0;</span><br><span class="line">    int r = nums.size()-1;</span><br><span class="line">    while(l&lt;r)&#123;</span><br><span class="line">        int m = Partition(nums,l,r);</span><br><span class="line">        if(m==target)</span><br><span class="line">            return nums[m];</span><br><span class="line">        else if(m&lt;target)</span><br><span class="line">            l = m+1;</span><br><span class="line">        else</span><br><span class="line">            r = m-1;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(logn)，递归的栈深度</p>
<ol start="2">
<li>堆</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void adjustHeap(std::vector&lt;int&gt; &amp;nums, int parents, int end)</span><br><span class="line">&#123;</span><br><span class="line">    //非叶子结点parents的两个子节点（假设都存在）</span><br><span class="line">    int lchild = 2 * parents + 1;</span><br><span class="line">    int rchild = 2 * parents + 2;</span><br><span class="line">    int maxIdx = parents;</span><br><span class="line">    if (lchild &lt;= end &amp;&amp; nums[maxIdx] &lt; nums[lchild]) </span><br><span class="line">        maxIdx = lchild;</span><br><span class="line">    if (rchild &lt;= end &amp;&amp; nums[maxIdx] &lt; nums[rchild])</span><br><span class="line">        maxIdx = rchild;</span><br><span class="line">    if (maxIdx != parents) &#123;</span><br><span class="line">        swap(nums[parents],nums[maxIdx]);</span><br><span class="line">        //交换之后，nums[maxIdx]应该是较小的元素，所以应该向下继续调整</span><br><span class="line">        adjustHeap(nums, maxIdx, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void buildHeap(std::vector&lt;int&gt; &amp;nums)</span><br><span class="line">&#123;//建堆</span><br><span class="line">    for (int i = nums.size() / 2 - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        //从倒数第一个非叶子结点开始调整</span><br><span class="line">        adjustHeap(nums, i, nums.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">    int end = nums.size()-1;</span><br><span class="line">    buildHeap(nums);</span><br><span class="line">    for (int i = nums.size() - 1; i &gt;= nums.size() - k + 1; i--) &#123;</span><br><span class="line">        swap(nums[0], nums[i]);</span><br><span class="line">        end--;</span><br><span class="line">        adjustHeap(nums, 0, end);</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)，建堆的时间代价是 O(n)，删除的总代价是 O(klogn)。因为k &lt; n，所以是O(nlogn)<br>空间复杂度：O(logn)</p>
<h5 id="BFPRT"><a href="#BFPRT" class="headerlink" title="BFPRT"></a>BFPRT</h5><p>也可以用BFPRT算法，具体实现如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">int BFPRT(vector&lt;int&gt; &amp;nums, int start, int end, int k); //因为findMidIdx与BFPRT互相调用，所以最好在前面声明</span><br><span class="line">int findMidIdx(vector&lt;int&gt; &amp;nums, int start, int end);</span><br><span class="line"></span><br><span class="line">int selectSort(vector&lt;int&gt; &amp;nums,int start,int end)</span><br><span class="line">&#123;//选择排序，返回中位数下标</span><br><span class="line">    int temp;</span><br><span class="line">    for (int i = start; i &lt; end; i++)&#123;</span><br><span class="line">        for (int j = i + 1; j &lt;= end; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[i] &gt; nums[j])</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (((end - start) / 2) + start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findMidIdx(vector&lt;int&gt; &amp;nums,int start,int end)</span><br><span class="line">&#123;//返回中位数的中位数下标</span><br><span class="line">    if (end - start &lt; 5)</span><br><span class="line">        return (selectSort(nums, start, end));//插入排序也可以</span><br><span class="line"></span><br><span class="line">    int subRIdx = start - 1;</span><br><span class="line">    for (int i = start; i + 4 &lt;= end; i += 5)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = selectSort(nums, i, i + 4); //找到五个元素的中位数的下标</span><br><span class="line">        swap(nums[++subRIdx], nums[index]);   //依次放在左侧</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return BFPRT(nums, start, subRIdx, ((subRIdx - start + 1) / 2) + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Partition(vector&lt;int&gt; &amp;nums,int start,int end,int pivotIdx)</span><br><span class="line">&#123;</span><br><span class="line">    swap(nums[pivotIdx], nums[end]);</span><br><span class="line"></span><br><span class="line">    int divideIdx = start;</span><br><span class="line">    for (int i = start; i &lt; end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nums[i]&lt;nums[end])</span><br><span class="line">            swap(nums[divideIdx++], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(nums[divideIdx], nums[end]);</span><br><span class="line">    return divideIdx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int BFPRT(vector&lt;int&gt; &amp;nums, int start,int end,int k)</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">    求第k小，返回其位置的下标。</span><br><span class="line">    如果求TOP K，改变大小于符号，或者返回 n-K+1</span><br><span class="line">    */</span><br><span class="line">    int pivotIdx = findMidIdx(nums, start, end); //得到中位数的中位数下标</span><br><span class="line">    int divideIdx = Partition(nums, start, end, pivotIdx); //进行划分，返回划分边界</span><br><span class="line">    int n = divideIdx - start + 1;</span><br><span class="line">    if (n == k)</span><br><span class="line">        return divideIdx;</span><br><span class="line">    else if (n &gt; k)</span><br><span class="line">        return BFPRT(nums, start, divideIdx - 1, k);</span><br><span class="line">    else</span><br><span class="line">        return BFPRT(nums, divideIdx + 1, end, k - n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-347-前-K-个高频元素（中等）"><a href="#Leetcode-347-前-K-个高频元素（中等）" class="headerlink" title="Leetcode 347. 前 K 个高频元素（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/top-k-frequent-elements/">Leetcode 347. 前 K 个高频元素（中等）</a></h4><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given [1,1,1,2,2,3] and k = 2, return [1,2].  </span><br></pre></td></tr></table></figure>

<p>Leetcode提交的答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class cmp&#123;</span><br><span class="line">public:</span><br><span class="line">    bool operator()(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b)&#123;</span><br><span class="line">        return a.second &gt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; topKFrequent(vector&lt;int&gt; &amp;nums, int k)&#123;</span><br><span class="line">    map&lt;int, int&gt; numMap;</span><br><span class="line">    for(int n:nums)</span><br><span class="line">        numMap[n]++;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;pair&lt;int, int&gt;,vector&lt;pair&lt;int,int&gt; &gt;, cmp &gt; pq;</span><br><span class="line">    for (auto it = numMap.begin(); it != numMap.end(); it++)&#123;</span><br><span class="line">        pq.push(*it);</span><br><span class="line">        if(pq.size()&gt;k)</span><br><span class="line">            pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; res(k);</span><br><span class="line">    for (int i = k - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        res[i] = pq.top().first;</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小根堆：  </p>
<ul>
<li>遍历数组，哈希表录入频率</li>
<li>遍历哈希表，维护一个出现频率前k多的小根堆</li>
<li>优先队列已满，需要判断当前元素的频率是否大于优先队列的最小频率元素的频率，如果大于，则替换。</li>
<li>优先队列未满，进队即可</li>
</ul>
<p>桶：<br>设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void topKFrequent()&#123;</span><br><span class="line">//小根堆</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1, 1, 1, 2, 2, 3&#125;;</span><br><span class="line">    int k = 2;</span><br><span class="line">    //map里面是（元素，频率）</span><br><span class="line">    unordered_map&lt;int,int&gt; freq;</span><br><span class="line">    for (int i = 0; i &lt; nums.size();i++)&#123;</span><br><span class="line">        freq[nums[i]]++; //可以验证，freq[nums[i]]初始化为0哦</span><br><span class="line">    &#125;</span><br><span class="line">    //优先队列中，按频率排序，所以数据对是(频率，元素)形式</span><br><span class="line">    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; pq;</span><br><span class="line">    for (auto it = freq.begin(); it != freq.end();it++)&#123;</span><br><span class="line">        if(pq.size()==k)&#123;//队列满了</span><br><span class="line">            if(pq.top().first &lt; it-&gt;second)&#123;</span><br><span class="line">                pq.pop();</span><br><span class="line">                pq.push(make_pair(it-&gt;second,it-&gt;first));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            pq.push(make_pair(it-&gt;second, it-&gt;first));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    while(!pq.empty())&#123;</span><br><span class="line">        result.push_back(pq.top().second);</span><br><span class="line">        // cout &lt;&lt; pq.top().second &lt;&lt; endl;</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;  </span><br><span class="line">//桶</span><br><span class="line">    int n = nums.size()+1;</span><br><span class="line">    vector&lt; vector&lt;int&gt; &gt; buckets(n);</span><br><span class="line">    for (auto it = freq.begin(); it != freq.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        buckets[it-&gt;second].push_back(it-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; topK;</span><br><span class="line">    for (int i = buckets.size() - 1; i &gt; 0 &amp;&amp; topK.size()&lt;k; i--)&#123;</span><br><span class="line">        if(buckets[i].size()==0)</span><br><span class="line">            continue;</span><br><span class="line">        for (int j = 0; j &lt; buckets[i].size() &amp;&amp; topK.size() &lt; k;j++)&#123;</span><br><span class="line">            topK.push_back(buckets[i].back());</span><br><span class="line">            buckets[i].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-451-根据字符出现频率排序（中等）"><a href="#Leetcode-451-根据字符出现频率排序（中等）" class="headerlink" title="Leetcode 451. 根据字符出现频率排序（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">Leetcode 451. 根据字符出现频率排序（中等）</a></h4><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">&#x27;c&#x27;和&#x27;a&#x27;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。</span><br><span class="line">注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;Aabb&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">&quot;bbAa&quot;</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。</span><br><span class="line">注意&#x27;A&#x27;和&#x27;a&#x27;被认为是两种不同的字符。</span><br></pre></td></tr></table></figure>

<p>题解：  </p>
<ol>
<li>桶。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">string frequencySort(string s) &#123;</span><br><span class="line">    unordered_map&lt;char, int&gt; freq;</span><br><span class="line">    for (int i = 0; i &lt; s.size();i++)</span><br><span class="line">        freq[s[i]]++;</span><br><span class="line">    //桶</span><br><span class="line">    int n = s.size();</span><br><span class="line">    vector&lt;vector&lt;char&gt; &gt; buckets(n + 1);</span><br><span class="line">    for (auto it = freq.begin(); it != freq.end();it++)&#123;</span><br><span class="line">        buckets[it-&gt;second].push_back(it-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    for (int i = buckets.size() - 1; i &gt; 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        if(buckets[i].size()==0)</span><br><span class="line">            continue;</span><br><span class="line">        for(auto s : buckets[i])&#123;</span><br><span class="line">            for (int j = 0; j &lt; i; j++)</span><br><span class="line">                res += s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>堆。方法同Leetcode 347。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">string frequencySort(string s) &#123;</span><br><span class="line">    unordered_map&lt;char, int&gt; ump;</span><br><span class="line">    for (char &amp;c : s)</span><br><span class="line">        ump[c]++;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;pair&lt;int, char&gt;&gt; pq;</span><br><span class="line">    for (auto &amp;m : ump)</span><br><span class="line">        pq.push(&#123;m.second, m.first&#125;);</span><br><span class="line"></span><br><span class="line">    string res;</span><br><span class="line">    while (!pq.empty()) &#123;</span><br><span class="line">        auto tmp = pq.top(); </span><br><span class="line">        pq.pop();</span><br><span class="line">        res.append(tmp.first, tmp.second);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(k)，k为不同字母的数量，最大为26</p>
<h4 id="范围排序"><a href="#范围排序" class="headerlink" title="范围排序"></a>范围排序</h4><p>给一个无序不重复的数组<code>nums</code>，两个整数<code>int a</code>和<code>int b</code>，其中<code>a &lt;= b &lt;= nums.size()-1</code>。返回第<code>a</code>到第<code>b</code>个排序子数组。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = &#123;3,5,4,1,2&#125;, a = 2, b = 4</span><br><span class="line"></span><br><span class="line">输出：[2,3,4]</span><br></pre></td></tr></table></figure>
<p>题解：<br>快排的变形。Partition找位置<code>i</code>，再根据<code>i</code>与<code>a</code>、<code>b</code>的比较来递归往下排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//Partition函数在上面</span><br><span class="line"></span><br><span class="line">void quickSort(vector&lt;int&gt; &amp;nums, int start, int end, int a, int b)&#123;</span><br><span class="line">    if(start &gt; end)</span><br><span class="line">        return;</span><br><span class="line">    int mid = Partition(nums, start, end);</span><br><span class="line">    if(mid&gt;=b-1)</span><br><span class="line">        quickSort(nums, start, mid - 1, a, b);</span><br><span class="line">    if(mid&lt;=a-1)</span><br><span class="line">        quickSort(nums, mid + 1, end, a, b);</span><br><span class="line">    if(mid&gt;a-1 &amp;&amp; mid&lt;b-1)&#123;</span><br><span class="line">        quickSort(nums, start, mid - 1, a, b);</span><br><span class="line">        quickSort(nums, mid + 1, end, a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; getVec(vector&lt;int&gt; &amp;nums, int a, int b)&#123;</span><br><span class="line">    quickSort(nums, 0, nums.size() - 1, a, b);</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for (int i = a-1; i &lt;= b-1; i++)</span><br><span class="line">        res.push_back(nums[i]);</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特殊规则排序"><a href="#特殊规则排序" class="headerlink" title="特殊规则排序"></a>特殊规则排序</h4><p>有一种排序算法：每次只能把一个元素提到数组的开头。输入一个乱序数组，输出最少需要多少次操作才能是数组升序排列。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： [2,1,3,4]</span><br><span class="line"></span><br><span class="line">输出： 1</span><br><span class="line"></span><br><span class="line">解释：把 1 提到开头就能满足要求</span><br></pre></td></tr></table></figure>
<p>题解：<br>只需求有多少个数已经按升序的顺序位于数组中就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int timesToAsc(vector&lt;int&gt; &amp;nums)&#123;</span><br><span class="line">    vector&lt;int&gt; finalNum = nums;</span><br><span class="line">    sort(finalNum.begin(), finalNum.end());</span><br><span class="line">    int i, j , cnt = 0;</span><br><span class="line">    i = j = nums.size() - 1;</span><br><span class="line">    for (; i &gt;= 0;i--)&#123;</span><br><span class="line">        if(finalNum[j] == nums[i])&#123;</span><br><span class="line">            j--;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.size() - cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-6-查找-x2F-搜索（Search）"><a href="#3-6-查找-x2F-搜索（Search）" class="headerlink" title="3.6 查找&#x2F;搜索（Search）"></a>3.6 查找&#x2F;搜索（Search）</h2><h3 id="3-6-1-回溯算法（backtracking）"><a href="#3-6-1-回溯算法（backtracking）" class="headerlink" title="3.6.1 回溯算法（backtracking）"></a>3.6.1 回溯算法（backtracking）</h3><h4 id="回溯法框架"><a href="#回溯法框架" class="headerlink" title="回溯法框架"></a>回溯法框架</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    if 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        return</span><br><span class="line">    for 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-17-电话号码的字母组合（中等）"><a href="#Leetcode-17-电话号码的字母组合（中等）" class="headerlink" title="Leetcode 17. 电话号码的字母组合（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">Leetcode 17. 电话号码的字母组合（中等）</a></h4><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;23&quot;  </span><br><span class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>回溯。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">map&lt;char, string&gt; keys = &#123;</span><br><span class="line">    &#123;&#x27;2&#x27;, &quot;abc&quot;&#125;, &#123;&#x27;3&#x27;, &quot;def&quot;&#125;, &#123;&#x27;4&#x27;, &quot;ghi&quot;&#125;, &#123;&#x27;5&#x27;, &quot;jkl&quot;&#125;, &#123;&#x27;6&#x27;, &quot;mno&quot;&#125;,</span><br><span class="line">    &#123;&#x27;7&#x27;, &quot;pqrs&quot;&#125;, &#123;&#x27;8&#x27;, &quot;tuv&quot;&#125;, &#123;&#x27;9&#x27;, &quot;wxyz&quot;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void backtracking(string preStr, vector&lt;string&gt; &amp;combinations, const string &amp;digits)&#123;</span><br><span class="line">    if(preStr.size()==digits.size())&#123;</span><br><span class="line">        combinations.push_back(preStr);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int curIdx = preStr.size();</span><br><span class="line">    char curDigital = digits[curIdx];</span><br><span class="line">    string curKeys = keys[curDigital];</span><br><span class="line">    for(char &amp;k : curKeys)&#123;</span><br><span class="line">        preStr += k;</span><br><span class="line">        backtracking(preStr,combinations,digits);</span><br><span class="line">        preStr.erase(preStr.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;string&gt; letterCombinations(string digits) &#123;</span><br><span class="line">    if(digits.empty())</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    backtracking(&quot;&quot;, res, digits);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(3^m * 4^n)，其中 m 是输入中对应 3 个字母的数字个数（包括数字 2、3、4、5、6、8），n 是输入中对应 4 个字母的数字个数（包括数字 7、9），m+n 是输入数字的总个数。<br>空间复杂度：O(m+n)</p>
<ol start="2">
<li>队列<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">map&lt;char, string&gt; keys = &#123;</span><br><span class="line">    &#123;&#x27;2&#x27;, &quot;abc&quot;&#125;, &#123;&#x27;3&#x27;, &quot;def&quot;&#125;, &#123;&#x27;4&#x27;, &quot;ghi&quot;&#125;, &#123;&#x27;5&#x27;, &quot;jkl&quot;&#125;, &#123;&#x27;6&#x27;, &quot;mno&quot;&#125;,</span><br><span class="line">    &#123;&#x27;7&#x27;, &quot;pqrs&quot;&#125;, &#123;&#x27;8&#x27;, &quot;tuv&quot;&#125;, &#123;&#x27;9&#x27;, &quot;wxyz&quot;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; letterCombinations(string digits) &#123;</span><br><span class="line">    queue&lt;string&gt; que;</span><br><span class="line">    for (int idx = 0; idx &lt; digits.size();idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        char s = digits[idx];</span><br><span class="line">        string key = keys[s];</span><br><span class="line">        if(que.empty())&#123;</span><br><span class="line">            for(auto k:key)&#123;</span><br><span class="line">                string tmp(1, k);</span><br><span class="line">                que.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            while(que.front().size()&lt;=idx)&#123;</span><br><span class="line">                string preStr = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                for(auto k:key)</span><br><span class="line">                    que.push(preStr + k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    while (!que.empty())&#123;</span><br><span class="line">        res.push_back(que.front());</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Leetcode-93-复原IP地址（中等）"><a href="#Leetcode-93-复原IP地址（中等）" class="headerlink" title="Leetcode 93. 复原IP地址（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/restore-ip-addresses/">Leetcode 93. 复原IP地址（中等）</a></h4><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given &quot;25525511135&quot;,  </span><br><span class="line">return [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;].  </span><br></pre></td></tr></table></figure>
<p>题解：<br>回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(int k, string preIp, string resStr, vector&lt;string&gt; &amp;addresses)&#123;</span><br><span class="line">    if(k==4 || resStr.size()==0)&#123;</span><br><span class="line">        if(k==4 &amp;&amp; resStr.size()==0)</span><br><span class="line">            addresses.push_back(preIp);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; resStr.size() &amp;&amp; i &lt; 3;i++)&#123;</span><br><span class="line">        if(i!=0 &amp;&amp; resStr[0]==&#x27;0&#x27;)</span><br><span class="line">            break;</span><br><span class="line">        string part = resStr.substr(0, i + 1);</span><br><span class="line">        if(stoi(part)&lt;=255)&#123;</span><br><span class="line">            if(preIp.size()!=0)</span><br><span class="line">                part = &#x27;.&#x27; + part;</span><br><span class="line">            preIp = preIp + part;</span><br><span class="line">            backtracking(k + 1, preIp, resStr.substr(i + 1), addresses);</span><br><span class="line">            preIp = preIp.erase(preIp.size() - part.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;string&gt; restoreIpAddresses(string s) &#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    backtracking(0, &quot;&quot;, s, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="huawei-真题"><a href="#huawei-真题" class="headerlink" title="huawei 真题"></a>huawei 真题</h4><p>求最大递归调用链栈总和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; inputStack = &#123;</span><br><span class="line">                                    &#123;5,2,3,1,0,0&#125;,</span><br><span class="line">                                    &#123;1,20,2,3&#125;,</span><br><span class="line">                                    &#123;2,30,3,4,5&#125;,</span><br><span class="line">                                    &#123;3,50,4&#125;,</span><br><span class="line">                                    &#123;4,60&#125;,</span><br><span class="line">                                    &#123;5,80&#125;</span><br><span class="line">                                  &#125;;</span><br><span class="line">void backtracking(int fun, vector&lt;bool&gt; &amp;isHead, bool &amp;isRecursive, vector&lt;bool&gt; &amp;hasVisited, vector&lt;int&gt; &amp;preChain, vector&lt;vector&lt;int&gt; &gt; &amp;callChains)&#123;</span><br><span class="line">    if(isRecursive)</span><br><span class="line">        return;</span><br><span class="line">    if (inputStack[0][fun] == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        callChains.push_back(preChain);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 2; i &lt; inputStack[fun].size();i++)&#123;</span><br><span class="line">        int nextFun = inputStack[fun][i];</span><br><span class="line">        if(hasVisited[nextFun])&#123;</span><br><span class="line">            isRecursive = true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        isHead[nextFun] = false;</span><br><span class="line">        hasVisited[nextFun] = true;</span><br><span class="line">        preChain.push_back(nextFun);</span><br><span class="line">        backtracking(nextFun, isHead, isRecursive, hasVisited, preChain, callChains);</span><br><span class="line">        preChain.pop_back();</span><br><span class="line">        hasVisited[nextFun] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void maxStack()&#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; callChains;</span><br><span class="line">    vector&lt;int&gt; preChain;</span><br><span class="line">    vector&lt;bool&gt; isHead(inputStack[0][0]+1,true);</span><br><span class="line">    bool isRecursive = false; //注意！ 如果这个变量不是放在main函数前的全局变量，递归函数传值就必须传引用，不然会因为函数参数传值的复制造成递归的时候不能改变</span><br><span class="line">    for (int i = 1; i &lt;= inputStack[0][0]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(isHead[i])&#123;</span><br><span class="line">            vector&lt;bool&gt; hasVisited(inputStack[0][0] + 1, false);</span><br><span class="line">            preChain.push_back(i);</span><br><span class="line">            hasVisited[i] = true;</span><br><span class="line">            backtracking(i, isHead, isRecursive, hasVisited, preChain, callChains);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(isRecursive)</span><br><span class="line">        cout &lt;&lt; &#x27;R&#x27; &lt;&lt; endl;</span><br><span class="line">    else&#123;</span><br><span class="line">        for (auto cc : callChains)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int c:cc)</span><br><span class="line">                cout &lt;&lt; c &lt;&lt; &quot; &quot;;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-46-全排列（中等）"><a href="#Leetcode-46-全排列（中等）" class="headerlink" title="Leetcode 46. 全排列（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">Leetcode 46. 全排列（中等）</a></h4><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3] have the following permutations:  </span><br><span class="line"></span><br><span class="line">[ [1,2,3],  </span><br><span class="line">  [1,3,2],  </span><br><span class="line">  [2,1,3],  </span><br><span class="line">  [2,3,1],  </span><br><span class="line">  [3,1,2],  </span><br><span class="line">  [3,2,1] ]</span><br></pre></td></tr></table></figure>
<p>题解：<br>回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(vector&lt;int&gt; &amp;resNums, vector&lt;int&gt; &amp;preNum, vector&lt;vector&lt;int&gt; &gt; &amp;permuteList)&#123;</span><br><span class="line">    if(resNums.size()==0)&#123;</span><br><span class="line">        permuteList.push_back(preNum);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; resNums.size();i++)&#123;</span><br><span class="line">        int curNum = resNums[i];</span><br><span class="line">        auto it = resNums.begin();</span><br><span class="line">        resNums.erase(it + i);</span><br><span class="line">        preNum.push_back(curNum);</span><br><span class="line">        backtracking(resNums, preNum, permuteList);</span><br><span class="line">        preNum.pop_back();</span><br><span class="line">        resNums.insert(it + i, curNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    vector&lt;int&gt; preNum;</span><br><span class="line">    backtracking(nums, preNum, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n*n!)<br>空间复杂度：O(n)</p>
<h4 id="Leetcode-77-组合（中等）"><a href="#Leetcode-77-组合（中等）" class="headerlink" title="Leetcode 77. 组合（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/">Leetcode 77. 组合（中等）</a></h4><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">If n = 4 and k = 2, a solution is:</span><br><span class="line">[ </span><br><span class="line">  [2,4],  </span><br><span class="line">  [3,4],  </span><br><span class="line">  [2,3],  </span><br><span class="line">  [1,2],  </span><br><span class="line">  [1,3],  </span><br><span class="line">  [1,4], ]</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void combinationsCore(int n, int k, int start, vector&lt;int&gt; &amp;preRes, vector&lt;vector&lt;int&gt; &gt; &amp;res)&#123;</span><br><span class="line">    if(preRes.size()==k)&#123;</span><br><span class="line">        res.push_back(preRes);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = start; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        preRes.push_back(i);</span><br><span class="line">        combinationsCore(n, k, i + 1, preRes, res);</span><br><span class="line">        preRes.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    vector&lt;int&gt; preRes;</span><br><span class="line">    combinationsCore(n, k, 1, preRes, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Leetcode-39-组合总和（中等）"><a href="#Leetcode-39-组合总和（中等）" class="headerlink" title="Leetcode 39.组合总和（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">Leetcode 39.组合总和（中等）</a></h4><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">given candidate set [2, 3, 6, 7] and target 7, A solution set is:  </span><br><span class="line">[ [7],[2, 2, 3] ]  </span><br></pre></td></tr></table></figure>
<p>题解：<br>回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(int target, vector&lt;int&gt; &amp;preCombination, int start, vector&lt;vector&lt;int&gt; &gt; &amp;combination, vector&lt;int&gt; &amp;candidates)&#123;</span><br><span class="line">    if(target==0)&#123;</span><br><span class="line">        combination.push_back(preCombination);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = start; i &lt; candidates.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int curNum = candidates[i];</span><br><span class="line">        if (target &gt;= curNum)</span><br><span class="line">        &#123;</span><br><span class="line">            preCombination.push_back(curNum);</span><br><span class="line">            backtracking(target - curNum, preCombination, i, combination, candidates);</span><br><span class="line">            preCombination.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    vector&lt;int&gt; preCombination;</span><br><span class="line">    backtracking(target, preCombination, 0, res, candidates);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Leetcode-40-组合总和-II（中等）"><a href="#Leetcode-40-组合总和-II（中等）" class="headerlink" title="Leetcode 40. 组合总和 II（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">Leetcode 40. 组合总和 II（中等）</a></h4><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,</span><br><span class="line">A solution set is:  </span><br><span class="line">[ [1, 7],  </span><br><span class="line">[1, 2, 5],  </span><br><span class="line">[2, 6],  </span><br><span class="line">[1, 1, 6]  ]  </span><br></pre></td></tr></table></figure>
<p>题解：<br>回溯</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(int target, vector&lt;int&gt; &amp;preCombination, int start, vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;candidates)&#123;</span><br><span class="line">    if(target==0)&#123;</span><br><span class="line">        auto it = find(res.begin(), res.end(), preCombination);</span><br><span class="line">        if(it==res.end())&#123;//因为candidates中有重复元素，会导致重复的解，所以查找是否有重复解，没有再放到解集中</span><br><span class="line">            res.push_back(preCombination);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = start; i &lt; candidates.size();i++)&#123;</span><br><span class="line">        int curNum = candidates[i];</span><br><span class="line">        if(curNum&lt;=target)&#123;</span><br><span class="line">            preCombination.push_back(curNum);</span><br><span class="line">            backtracking(target - curNum, preCombination, i + 1, res, candidates);</span><br><span class="line">            preCombination.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">    sort(candidates.begin(),candidates.end());//先排序才好查重复解</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;int&gt; preCombination;</span><br><span class="line">    vector&lt;bool&gt; hasVisited(candidates.size(),false);</span><br><span class="line">    backtracking(target, preCombination, 0, res, candidates);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Leetcode-216-组合总和-III（中等）"><a href="#Leetcode-216-组合总和-III（中等）" class="headerlink" title="Leetcode 216. 组合总和 III（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iii/">Leetcode 216. 组合总和 III（中等）</a></h4><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: k = 3, n = 9  </span><br><span class="line">Output:  </span><br><span class="line">[[1,2,6], [1,3,5], [2,3,4]]  </span><br><span class="line">从 1-9 数字中选出 k 个数不重复的数，使得它们的和为 n。  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(int k, int target, int start, vector&lt;int&gt; &amp;preCombination, vector&lt;vector&lt;int&gt; &gt; &amp;res)&#123;</span><br><span class="line">    // if(target&lt;0)</span><br><span class="line">    //     return;</span><br><span class="line">    if (target == 0 &amp;&amp; k == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(preCombination);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(target==0 || k==0)</span><br><span class="line">        return;</span><br><span class="line">    for (int i = start; i &lt;= 9;i++)&#123;</span><br><span class="line">        if(target&lt;i)//后面的都大于target，不用再往后找了。如果上面用了target&lt;0的判断，这里可以不用，但是下面的调用次数会多一些</span><br><span class="line">            break;</span><br><span class="line">        preCombination.push_back(i);</span><br><span class="line">        backtracking(k - 1, target - i, i+1, preCombination, res);</span><br><span class="line">        preCombination.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    vector&lt;int&gt; preCombination;</span><br><span class="line">    backtracking(k, n, 1, preCombination, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Leetcode-78-子集（中等）"><a href="#Leetcode-78-子集（中等）" class="headerlink" title="Leetcode 78. 子集（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">Leetcode 78. 子集（中等）</a></h4><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">找出集合的所有子集，子集不能重复，[1, 2] 和 [2, 1] 这种子集算重复  </span><br><span class="line">输入: nums = [1,2,3]  </span><br><span class="line">输出:  </span><br><span class="line">[ [3],  </span><br><span class="line">  [1],  </span><br><span class="line">  [2],  </span><br><span class="line">  [1,2,3],  </span><br><span class="line">  [1,3],  </span><br><span class="line">  [2,3],  </span><br><span class="line">  [1,2],  </span><br><span class="line">  []  ]</span><br></pre></td></tr></table></figure>
<p>题解：<br>回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(int start, int size, vector&lt;int&gt; &amp;preSet, vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;nums)&#123;</span><br><span class="line">    if(preSet.size()==size)&#123;</span><br><span class="line">        res.push_back(preSet);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = start; i &lt; nums.size();i++)&#123;</span><br><span class="line">        preSet.push_back(nums[i]);</span><br><span class="line">        backtracking(i + 1, size, preSet, res, nums);</span><br><span class="line">        preSet.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;int&gt; preSet;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    for (int size = 0; size &lt;= nums.size();size++)//子集的大小</span><br><span class="line">        backtracking(0, size, preSet, res, nums); </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-90-子集-II（中等）"><a href="#Leetcode-90-子集-II（中等）" class="headerlink" title="Leetcode 90. 子集 II（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets-ii/">Leetcode 90. 子集 II（中等）</a></h4><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。  </p>
<p>说明：解集不能包含重复的子集。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,2]  </span><br><span class="line">输出:  </span><br><span class="line">[   [2],</span><br><span class="line">    [1],</span><br><span class="line">    [1,2,2],</span><br><span class="line">    [2,2],</span><br><span class="line">    [1,2],</span><br><span class="line">    [] ]</span><br></pre></td></tr></table></figure>
<p>题解：<br>回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(int start, int size, vector&lt;int&gt; &amp;preSet, vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;nums)&#123;</span><br><span class="line">    if(preSet.size()==size)&#123;</span><br><span class="line">        res.push_back(preSet);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = start; i &lt; nums.size();i++)&#123;</span><br><span class="line">        preSet.push_back(nums[i]);</span><br><span class="line">        backtracking(i + 1, size, preSet, res, nums);</span><br><span class="line">        preSet.pop_back();</span><br><span class="line">        while(i&lt;nums.size()-1 &amp;&amp; nums[i+1]==nums[i])//后面的数字如果相等要跳过，不然会导致重复</span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    vector&lt;int&gt; preSet;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    for (int size = 0; size &lt;= nums.size(); size++)</span><br><span class="line">        backtracking(0, size, preSet, res, nums);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-131-分割回文串（中等）"><a href="#Leetcode-131-分割回文串（中等）" class="headerlink" title="Leetcode 131. 分割回文串（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-partitioning/">Leetcode 131. 分割回文串（中等）</a></h4><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 s 所有可能的分割方案。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For example, given s = &quot;aab&quot;,  </span><br><span class="line">Return  </span><br><span class="line">[ [&quot;aa&quot;,&quot;b&quot;],  </span><br><span class="line">[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]  ]</span><br></pre></td></tr></table></figure>
<p>题解：<br>回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool isPalindrome(string s, int start, int end)&#123;</span><br><span class="line">    while(start&lt;end)&#123;</span><br><span class="line">        if(s[start++]!=s[end--])</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">void partitioning(string s, vector&lt;string&gt; &amp;prePartition, vector&lt;vector&lt;string&gt; &gt; &amp;result)&#123;</span><br><span class="line">    if(s.size()==0)&#123;</span><br><span class="line">        result.push_back(prePartition);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; s.size();i++)&#123;</span><br><span class="line">        if(isPalindrome(s,0,i))&#123;</span><br><span class="line">            prePartition.push_back(s.substr(0, i + 1));</span><br><span class="line">            partitioning(s.substr(i + 1, s.size() - (i + 1)), prePartition, result);</span><br><span class="line">            prePartition.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;</span><br><span class="line">    vector&lt;string&gt; prePartition;</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt; res;</span><br><span class="line">    partitioning(s, prePartition, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-37-解数独（困难）"><a href="#Leetcode-37-解数独（困难）" class="headerlink" title="Leetcode 37. 解数独（困难）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sudoku-solver/">Leetcode 37. 解数独（困难）</a></h4><p>通过填充空格来解决数独问题。</p>
<p>一个数独的解法需遵循如下规则：  </p>
<ol>
<li>数字 1-9 在每一行只能出现一次。  </li>
<li>数字 1-9 在每一列只能出现一次。  </li>
<li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</li>
</ol>
<p>空白格用 ‘.’ 表示。  </p>
<p>题解：<br>回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">int cube(int i, int j)&#123;</span><br><span class="line">    return (i / 3) * 3 + j / 3; //0-8</span><br><span class="line">&#125;</span><br><span class="line">bool backtracking(int row, int col, vector&lt;vector&lt;bool&gt; &gt; &amp;rowUsed, vector&lt;vector&lt;bool&gt; &gt; colUsed, vector&lt;vector&lt;bool&gt; &gt; cubeUsed, vector&lt;vector&lt;char&gt; &gt; &amp;board)&#123;</span><br><span class="line">    while (row &lt; 9 &amp;&amp; board[row][col]!=&#x27;.&#x27;)&#123;</span><br><span class="line">        row = col == 8 ? row + 1 : row;</span><br><span class="line">        col = col == 8 ? 0 : col + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(row==9)//全部填完</span><br><span class="line">        return true;</span><br><span class="line">    for (int num = 1; num &lt;= 9;num++)&#123;</span><br><span class="line">        if(rowUsed[row][num] || colUsed[col][num] || cubeUsed[cube(row,col)][num])</span><br><span class="line">            continue;</span><br><span class="line">        rowUsed[row][num] = true;</span><br><span class="line">        colUsed[col][num] = true;</span><br><span class="line">        cubeUsed[cube(row, col)][num] = true;</span><br><span class="line">        board[row][col] = &#x27;0&#x27; + num;</span><br><span class="line">        if(backtracking(row,col,rowUsed,colUsed,cubeUsed,board))</span><br><span class="line">            return true;</span><br><span class="line">        board[row][col] = &#x27;.&#x27;;</span><br><span class="line">        rowUsed[row][num] = false;</span><br><span class="line">        colUsed[col][num] = false;</span><br><span class="line">        cubeUsed[cube(row, col)][num] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; rowUsed(9,vector&lt;bool&gt;(10,false));</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; colUsed(9,vector&lt;bool&gt;(10,false));</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; cubeUsed(9,vector&lt;bool&gt;(10,false));</span><br><span class="line">    for (int i = 0; i &lt; 9; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; 9;j++)&#123;</span><br><span class="line">            if(board[i][j]==&#x27;.&#x27;)</span><br><span class="line">                continue;</span><br><span class="line">            int num = board[i][j] - &#x27;0&#x27;;</span><br><span class="line">            rowUsed[i][num] = true;</span><br><span class="line">            colUsed[j][num] = true;</span><br><span class="line">            cubeUsed[cube(i,j)][num] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(0, 0, rowUsed, colUsed, cubeUsed, board);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h4><p>输入n，输出解法的数量。（下一题还需要输出解法）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void solveNQueen(int n, int row, vector&lt;bool&gt; &amp;diagonal45, vector&lt;bool&gt; &amp;diagonal135, vector&lt;bool&gt; &amp;colUsed, int &amp;res)&#123;</span><br><span class="line">    if(row == n)&#123;</span><br><span class="line">        res++;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int col = 0; col &lt; n;col++)&#123;</span><br><span class="line">        int idx45 = row + col;</span><br><span class="line">        int idx135 = n - 1 - (row - col);</span><br><span class="line">        if(colUsed[col] || diagonal135[idx135] || diagonal45[idx45])</span><br><span class="line">            continue;</span><br><span class="line">        colUsed[col] = diagonal45[idx45] = diagonal135[idx135] = true;</span><br><span class="line">        solveNQueen(n, row + 1, diagonal45, diagonal135, colUsed, res);</span><br><span class="line">        colUsed[col] = diagonal45[idx45] = diagonal135[idx135] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int NQueen(int n)&#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    vector&lt;bool&gt; diagonal45(2 * n - 1, false);</span><br><span class="line">    vector&lt;bool&gt; diagonal135(2 * n - 1, false);</span><br><span class="line">    vector&lt;bool&gt; colUsed(n, false);</span><br><span class="line">    solveNQueen(n, 0, diagonal45, diagonal135, colUsed, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-51-N皇后（困难）"><a href="#Leetcode-51-N皇后（困难）" class="headerlink" title="Leetcode 51. N皇后（困难）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens/">Leetcode 51. N皇后（困难）</a></h4><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: 4  </span><br><span class="line">输出: [  </span><br><span class="line">[&quot;.Q..&quot;,  // 解法 1  </span><br><span class="line">&quot;...Q&quot;,  </span><br><span class="line">&quot;Q...&quot;,  </span><br><span class="line">&quot;..Q.&quot;],  </span><br><span class="line"></span><br><span class="line">[&quot;..Q.&quot;,  // 解法 2  </span><br><span class="line">&quot;Q...&quot;,  </span><br><span class="line">&quot;...Q&quot;,  </span><br><span class="line">&quot;.Q..&quot;]  </span><br><span class="line">]  </span><br><span class="line">解释: 4 皇后问题存在两个不同的解法。  </span><br></pre></td></tr></table></figure>
<p>题解：<br>回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(int n, int row, vector&lt;bool&gt; &amp;diagonal45, vector&lt;bool&gt; &amp;diagonal135, vector&lt;bool&gt; &amp;colUsed, vector&lt;string&gt; &amp;oneSolution, vector&lt;vector&lt;string&gt; &gt; &amp;res)&#123;</span><br><span class="line">    if(row==n)&#123;</span><br><span class="line">        res.push_back(oneSolution);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int col = 0; col &lt; n;col++)&#123;</span><br><span class="line">        int idx45 = row + col;</span><br><span class="line">        int idx135 = n - 1 - (row - col);</span><br><span class="line">        if(colUsed[col] || diagonal135[idx135] || diagonal45[idx45])</span><br><span class="line">            continue;</span><br><span class="line">        oneSolution[row][col] = &#x27;Q&#x27;;</span><br><span class="line">        colUsed[col] = diagonal135[idx135] = diagonal45[idx45] = true;</span><br><span class="line">        backtracking(n, row + 1, diagonal45, diagonal135, colUsed, oneSolution, res);</span><br><span class="line">        colUsed[col] = diagonal135[idx135] = diagonal45[idx45] = false;</span><br><span class="line">        oneSolution[row][col] = &#x27;.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt; res;</span><br><span class="line">    string tmp = &quot;&quot;;</span><br><span class="line">    for (int i = 0; i &lt; n;i++)</span><br><span class="line">        tmp += &quot;.&quot;;</span><br><span class="line">    vector&lt;string&gt; oneSolution(n, tmp);</span><br><span class="line">    vector&lt;bool&gt; diagonal45(2*n-1,false);</span><br><span class="line">    vector&lt;bool&gt; diagonal135(2*n-1,false);</span><br><span class="line">    vector&lt;bool&gt; colUsed(n,false);</span><br><span class="line"></span><br><span class="line">    backtracking(n, 0, diagonal45, diagonal135, colUsed, oneSolution, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-2-广度优先（BFS）"><a href="#3-6-2-广度优先（BFS）" class="headerlink" title="3.6.2 广度优先（BFS）"></a>3.6.2 广度优先（BFS）</h3><h4 id="Leetcode-1091-二进制矩阵中的最短路径（中等）"><a href="#Leetcode-1091-二进制矩阵中的最短路径（中等）" class="headerlink" title="Leetcode 1091. 二进制矩阵中的最短路径（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">Leetcode 1091. 二进制矩阵中的最短路径（中等）</a></h4><p>可以往8个方向走，0 表示可以经过某个位置，求解从左上角到右下角的最短路径长度。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input:   </span><br><span class="line">0 0 0  </span><br><span class="line">1 1 0  </span><br><span class="line">1 1 0  </span><br><span class="line">output: 4 ([0,0],[0,1],[1,2],[2,2])</span><br></pre></td></tr></table></figure>
<p>题解：<br>队列实现“层序遍历”，bfs。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    int rows = grid.size();</span><br><span class="line">    int cols = grid[0].size();</span><br><span class="line">    if (rows==0 || cols==0 || grid[0][0]==1 || grid[cols-1][rows-1]==1)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    //从当前点的右边开始逆时针</span><br><span class="line">    int direction[8][2] = &#123; &#123;0, 1&#125;, &#123;1, 1&#125;, &#123;1, 0&#125;, &#123;1, -1&#125;, &#123;0, -1&#125;, &#123;-1, -1&#125;, &#123;-1, 0&#125;, &#123;-1, 1&#125; &#125;;</span><br><span class="line">    queue&lt;vector&lt;int&gt; &gt; que;</span><br><span class="line">    que.push(&#123;0,0&#125;);</span><br><span class="line">    int res = 0;</span><br><span class="line">    while (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int size = que.size();//这一层有多少节点</span><br><span class="line">        res++;</span><br><span class="line">        while(size-- &gt;0)&#123;//把这一层的节点处理完</span><br><span class="line">            vector&lt;int&gt; cur = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            if(grid[cur[0]][cur[1]]==1)//已经经过的点</span><br><span class="line">                //由于加入队列的顺序的原因，有些在待处理队列里面的为0的点，会被重复加入队列。</span><br><span class="line">                //如果这里不判断的话，已经更新为1的节点还是会被重复处理</span><br><span class="line">                continue;</span><br><span class="line">            if (cur[0] == rows - 1 &amp;&amp; cur[1] == cols - 1)</span><br><span class="line">                return res;</span><br><span class="line"></span><br><span class="line">            grid[cur[0]][cur[1]] = 1;//走过的路标记为1</span><br><span class="line">            for(auto d:direction)&#123;</span><br><span class="line">                int row = cur[0] + d[0];</span><br><span class="line">                int col = cur[1] + d[1];</span><br><span class="line">                if(row&lt;0 || row&gt;=rows || col&lt;0 || col&gt;=cols || grid[row][col])</span><br><span class="line">                    //超过了上下左右边界 || 不能经过或者已经经过的点</span><br><span class="line">                    continue;</span><br><span class="line">                vector&lt;int&gt; tmp = &#123;row, col&#125;;</span><br><span class="line">                que.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-279-完全平方数（中等）-1"><a href="#Leetcode-279-完全平方数（中等）-1" class="headerlink" title="Leetcode 279. 完全平方数（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">Leetcode 279. 完全平方数（中等）</a></h4><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">given n = 12</span><br><span class="line">return 3</span><br><span class="line">because 12 = 4 + 4 + 4; </span><br><span class="line"></span><br><span class="line">given n = 13</span><br><span class="line">return 2 </span><br><span class="line">because 13 = 4 + 9.  </span><br></pre></td></tr></table></figure>
<p>题解：<br>bfs。可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。本题也可以用动态规划求解，在之前动态规划部分中已经出现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int numSquares(int n) &#123;</span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    que.push(n);  //从n开始或者从1开始都行</span><br><span class="line">    bool marked[n];</span><br><span class="line">    for (int i = 0; i &lt; n;i++)</span><br><span class="line">        marked[i] = 0;//false</span><br><span class="line"></span><br><span class="line">    int res = 0;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        res++;</span><br><span class="line">        int size = que.size();</span><br><span class="line">        while(size-- &gt; 0)&#123;</span><br><span class="line">            int cur = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            for(int i = 1; i * i &lt;= n; i++)&#123;</span><br><span class="line">                int next = cur - i*i;</span><br><span class="line">                if(next&lt;0)</span><br><span class="line">                    break;</span><br><span class="line">                if(next==0)</span><br><span class="line">                    return res;</span><br><span class="line"></span><br><span class="line">                if(marked[next])</span><br><span class="line">                    continue;</span><br><span class="line">                marked[next] = 1;</span><br><span class="line">                que.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Leetcode-127-单词接龙（中等）"><a href="#Leetcode-127-单词接龙（中等）" class="headerlink" title="Leetcode 127. 单词接龙（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder/">Leetcode 127. 单词接龙（中等）</a></h4><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p>
<ol>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ol>
<p><strong>说明</strong>:</p>
<ul>
<li>如果不存在这样的转换序列，返回 0。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li>
</ul>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:  </span><br><span class="line">beginWord = &quot;hit&quot;,  </span><br><span class="line">endWord = &quot;cog&quot;,  </span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]  </span><br><span class="line"></span><br><span class="line">Output: 5  </span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, return its length 5.</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:  </span><br><span class="line">beginWord = &quot;hit&quot;  </span><br><span class="line">endWord = &quot;cog&quot;  </span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]  </span><br><span class="line"></span><br><span class="line">Output: 0  </span><br><span class="line"></span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.  </span><br><span class="line">题目描述：找出一条从 beginWord 到 endWord 的最短路径，每次移动规定为改变一个字符，并且改变之后的字符串必须在 wordList 中。</span><br></pre></td></tr></table></figure>
<p>题解：<br>bfs。官方双向bfs的C++版本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">int n;</span><br><span class="line">unordered_map&lt;string, vector&lt;string&gt; &gt; umap;</span><br><span class="line"></span><br><span class="line">int bfs(queue&lt;pair&lt;string, int&gt; &gt; &amp;curQueue, unordered_map&lt;string, int&gt;&amp; visited, unordered_map&lt;string, int&gt;&amp; anoVisited)&#123;</span><br><span class="line">    string curWord = curQueue.front().first;</span><br><span class="line">    int len = curQueue.front().second;</span><br><span class="line">    curQueue.pop();</span><br><span class="line">    for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">        string index = curWord.substr(0, i)+&quot;*&quot;+curWord.substr(i+1, n);</span><br><span class="line">        for(string str : umap[index])&#123;</span><br><span class="line">            if(anoVisited[str])</span><br><span class="line">                return len + anoVisited[str]; </span><br><span class="line">            if(!visited[str])&#123;</span><br><span class="line">                curQueue.push(make_pair(str, len+1));</span><br><span class="line">                visited[str] = len+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">    n = beginWord.size();</span><br><span class="line">    bool flag = false;</span><br><span class="line">    for(string str : wordList)&#123;</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            string tp = str.substr(0,i)+&quot;*&quot;+str.substr(i+1, n);</span><br><span class="line">            umap[tp].push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        if(str == endWord)</span><br><span class="line">            flag = true;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag) return 0;//endWord不在wordList里</span><br><span class="line">    </span><br><span class="line">    unordered_map&lt;string, int&gt; beginVisited, endVisited;</span><br><span class="line">    queue&lt;pair&lt;string, int&gt; &gt; begQueue, endQueue;</span><br><span class="line">    begQueue.push(make_pair(beginWord, 1));</span><br><span class="line">    endQueue.push(make_pair(endWord, 1));</span><br><span class="line">    beginVisited[beginWord] = 1;</span><br><span class="line">    endVisited[endWord] = 1;</span><br><span class="line">    while(!begQueue.empty() &amp;&amp; !endQueue.empty())&#123;</span><br><span class="line">        int curlen = bfs(begQueue, beginVisited, endVisited);</span><br><span class="line">        if(curlen != -1)</span><br><span class="line">            return curlen;</span><br><span class="line">        curlen = bfs(endQueue, endVisited, beginVisited);</span><br><span class="line">        if(curlen != -1)</span><br><span class="line">            return curlen;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-3-深度优先（DFS）"><a href="#3-6-3-深度优先（DFS）" class="headerlink" title="3.6.3 深度优先（DFS）"></a>3.6.3 深度优先（DFS）</h3><h4 id="Leetcode-695-岛屿的最大面积（中等）"><a href="#Leetcode-695-岛屿的最大面积（中等）" class="headerlink" title="Leetcode 695. 岛屿的最大面积（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-area-of-island/">Leetcode 695. 岛屿的最大面积（中等）</a></h4><p>查找最大的连通面积。一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设<code>grid</code>的四个边缘都被 0（代表水）包围着。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[0,0,1,0,0,0,0,1,0,0,0,0,0],  </span><br><span class="line">[0,0,0,0,0,0,0,1,1,1,0,0,0],  </span><br><span class="line">[0,1,1,0,1,0,0,0,0,0,0,0,0],  </span><br><span class="line">[0,1,0,0,1,1,0,0,1,0,1,0,0],  </span><br><span class="line">[0,1,0,0,1,1,0,0,1,1,1,0,0],  </span><br><span class="line">[0,0,0,0,0,0,0,0,0,0,1,0,0],  </span><br><span class="line">[0,0,0,0,0,0,0,1,1,1,0,0,0],  </span><br><span class="line">[0,0,0,0,0,0,0,1,1,0,0,0,0]  </span><br><span class="line">output: 6    </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><ol>
<li>STL栈实现</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; direction = &#123; &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125; &#125;;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; grid.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; grid[0].size();j++)&#123;</span><br><span class="line">            int res_ij = 0;</span><br><span class="line">            stack&lt;vector&lt;int&gt; &gt; st;</span><br><span class="line">            vector&lt;int&gt; tmp = &#123;i, j&#125;;</span><br><span class="line">            st.push(tmp);</span><br><span class="line">            while (!st.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                int cur_i = st.top()[0];</span><br><span class="line">                int cur_j = st.top()[1];</span><br><span class="line">                st.pop();</span><br><span class="line">                if(cur_i&lt;0 || cur_j&lt;0</span><br><span class="line">                    || cur_i&gt;=grid.size() || cur_j&gt;=grid[0].size()</span><br><span class="line">                    || grid[cur_i][cur_j]!=1 )//这个条件一定要放到最后，要先满足坐标的条件，不然grid会越界</span><br><span class="line">                    continue;</span><br><span class="line">                grid[cur_i][cur_j] = 0;</span><br><span class="line">                res_ij++;</span><br><span class="line">                for (auto dir : direction)</span><br><span class="line">                &#123;</span><br><span class="line">                    int next_i = cur_i + dir[0];</span><br><span class="line">                    int next_j = cur_j + dir[1];</span><br><span class="line">                    vector&lt;int&gt; tmp2 = &#123;next_i, next_j&#125;;</span><br><span class="line">                    st.push(tmp2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, res_ij);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>递归。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int dfs(vector&lt;vector&lt;int&gt; &gt; &amp;grid,int cur_i, int cur_j)&#123;</span><br><span class="line">    if(cur_i&lt;0 || cur_j&lt;0 || cur_i &gt;= grid.size() || cur_j &gt;= grid[0].size() || grid[cur_i][cur_j] != 1)</span><br><span class="line">        return 0;</span><br><span class="line">    grid[cur_i][cur_j] = 0;</span><br><span class="line">    int res = 1;</span><br><span class="line">    int dir_i[] = &#123;1, 0, 0, -1&#125;;</span><br><span class="line">    int dir_j[] = &#123;0, 1, -1, 0&#125;;</span><br><span class="line">    for (int i = 0; i &lt; 4;i++)&#123;</span><br><span class="line">        int next_i = cur_i + dir_i[i];</span><br><span class="line">        int next_j = cur_j + dir_j[i];</span><br><span class="line">        res += dfs(grid, next_i, next_j);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; grid.size();i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; grid[0].size();j++)</span><br><span class="line">            res = max(res, dfs(grid, i, j));</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="BFS也可以"><a href="#BFS也可以" class="headerlink" title="BFS也可以"></a>BFS也可以</h5><p>把栈改为队列就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int maxAreaOfIsland(vector&lt;vector&lt;int&gt; &gt; &amp;grid)&#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; direction = &#123; &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125; &#125;;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; grid.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; grid[0].size();j++)&#123;</span><br><span class="line">            int res_ij = 0;</span><br><span class="line">            queue&lt;vector&lt;int&gt; &gt; st;</span><br><span class="line">            vector&lt;int&gt; tmp = &#123;i, j&#125;;</span><br><span class="line">            st.push(tmp);</span><br><span class="line">            while (!st.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                int cur_i = st.front()[0];</span><br><span class="line">                int cur_j = st.front()[1];</span><br><span class="line">                st.pop();</span><br><span class="line">                if(cur_i&lt;0 || cur_j&lt;0</span><br><span class="line">                    || cur_i&gt;=grid.size() || cur_j&gt;=grid[0].size()</span><br><span class="line">                    || grid[cur_i][cur_j]!=1 )//这个条件一定要放到最后，要先满足坐标的条件，不然grid会越界</span><br><span class="line">                    continue;</span><br><span class="line">                grid[cur_i][cur_j] = 0;</span><br><span class="line">                res_ij++;</span><br><span class="line">                for (auto dir : direction)</span><br><span class="line">                &#123;</span><br><span class="line">                    int next_i = cur_i + dir[0];</span><br><span class="line">                    int next_j = cur_j + dir[1];</span><br><span class="line">                    vector&lt;int&gt; tmp2 = &#123;next_i, next_j&#125;;</span><br><span class="line">                    st.push(tmp2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, res_ij);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-200-岛屿数量（中等）"><a href="#Leetcode-200-岛屿数量（中等）" class="headerlink" title="Leetcode 200. 岛屿数量（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">Leetcode 200. 岛屿数量（中等）</a></h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:  </span><br><span class="line">[</span><br><span class="line">    [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">    [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">    [&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">    [&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;1&#x27;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Output: 3  </span><br></pre></td></tr></table></figure>
<p>题解：<br>dfs。求矩阵中的连通分量数目。可以将矩阵表示看成一张有向图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void dfs(vector&lt;vector&lt;char&gt; &gt; &amp;grid, int i, int j)&#123;</span><br><span class="line">    if(i&lt;0 || i&gt;=grid.size() || j&lt;0 || j&gt;=grid[0].size() || grid[i][j]==&#x27;0&#x27;)</span><br><span class="line">        return;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; directions = &#123; &#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125; &#125;;</span><br><span class="line">    grid[i][j] = &#x27;0&#x27;;</span><br><span class="line">    for(auto d:directions)&#123;</span><br><span class="line">        int next_i = i + d[0];</span><br><span class="line">        int next_j = j + d[1];</span><br><span class="line">        dfs(grid, next_i, next_j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int numIslands(vector&lt;vector&lt;char&gt; &gt;&amp; grid) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; grid.size();i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; grid[0].size();j++)&#123;</span><br><span class="line">            if(grid[i][j] != &#x27;0&#x27;)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bfs也可以（待补充）</p>
<h4 id="Leetcode-547-朋友圈（中等）"><a href="#Leetcode-547-朋友圈（中等）" class="headerlink" title="Leetcode 547. 朋友圈（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/friend-circles/">Leetcode 547. 朋友圈（中等）</a></h4><p>好友关系可以看成是一个无向图，例如第 0 个人与第 1 个人是好友，那么 M[0][1] 和 M[1][0] 的值都为 1。求朋友圈的个数。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:  </span><br><span class="line">[[1,1,0],  </span><br><span class="line">[1,1,0],  </span><br><span class="line">[0,0,1]]</span><br><span class="line"></span><br><span class="line">Output: 2  </span><br><span class="line"></span><br><span class="line">已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。</span><br><span class="line">第2个学生自己在一个朋友圈。所以返回 2 。</span><br></pre></td></tr></table></figure>
<p>题解：<br>dfs。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void dfs(vector&lt;vector&lt;int&gt; &gt; &amp;nums, int i, vector&lt;bool&gt; &amp;isFriend)&#123;</span><br><span class="line">    isFriend[i] = true;</span><br><span class="line">    for (int j = 0; j &lt; nums.size();j++)&#123;</span><br><span class="line">        if(!isFriend[j] &amp;&amp; nums[i][j]==1)&#123;</span><br><span class="line">            dfs(nums, j, isFriend);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    vector&lt;bool&gt; isFriend(M.size());</span><br><span class="line">    for (int i = 0; i &lt; M.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!isFriend[i])&#123;</span><br><span class="line">            res++;</span><br><span class="line">            dfs(M, i, isFriend);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-130-被围绕的区域（中等）"><a href="#Leetcode-130-被围绕的区域（中等）" class="headerlink" title="Leetcode 130. 被围绕的区域（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">Leetcode 130. 被围绕的区域（中等）</a></h4><p>使被 ‘X’ 包围的 ‘O’ 转换为 ‘X’。任何边界上的 ‘O’ 都不会被填充为 ‘X’。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">For example,  </span><br><span class="line">X X X X  </span><br><span class="line">X O O X  </span><br><span class="line">X X O X  </span><br><span class="line">X O X X  </span><br><span class="line">After running your function, the board should be:  </span><br><span class="line">X X X X  </span><br><span class="line">X X X X  </span><br><span class="line">X X X X  </span><br><span class="line">X O X X  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>dfs方法一。先把和最外侧的’O’相连的’O’用dfs找出来标记成其他，剩下的就是里侧的需要填充的了。填充的时候顺便把不需要填充的’O’换回来</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void dfs(vector&lt;vector&lt;char&gt; &gt; &amp;board, int i, int j)&#123;</span><br><span class="line">    if(i&lt;0 || i&gt;= board.size() || j&lt;0 || j&gt;=board[0].size() || board[i][j] != &#x27;O&#x27;)</span><br><span class="line">        return;</span><br><span class="line">    board[i][j] = &#x27;*&#x27;;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; directions = &#123; &#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;1,0&#125; &#125;;</span><br><span class="line">    for(auto d:directions)</span><br><span class="line">        dfs(board, i + d[0], j + d[1]);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">    if(board.empty())</span><br><span class="line">        return;</span><br><span class="line">    for (int i = 0; i &lt; board[0].size();i++)&#123;</span><br><span class="line">        dfs(board, 0, i);</span><br><span class="line">        dfs(board, board.size() - 1, i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; board.size();i++)&#123;</span><br><span class="line">        dfs(board, i, 0);</span><br><span class="line">        dfs(board, i, board[0].size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; board.size(); i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; board[0].size(); j++)&#123;</span><br><span class="line">            if(board[i][j]==&#x27;O&#x27;)</span><br><span class="line">                board[i][j] = &#x27;X&#x27;;</span><br><span class="line">            else if (board[i][j]== &#x27;*&#x27;)</span><br><span class="line">                board[i][j] = &#x27;O&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>dfs方法二</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,vector&lt;int&gt; &amp; s,vector&lt;vector&lt;bool&gt; &gt; &amp;marked)&#123;</span><br><span class="line">    int x=s[0],y=s[1];</span><br><span class="line">    if(board[x][y]==&#x27;X&#x27; || marked[x][y])</span><br><span class="line">        return;</span><br><span class="line">    marked[x][y] = true;</span><br><span class="line">    for(auto d:dirs)&#123;</span><br><span class="line">        int next_i = x+d[0], next_j = y+d[1];</span><br><span class="line">        vector&lt;int&gt; tmp = &#123;next_i,next_j&#125;;</span><br><span class="line">        if((next_i &gt; 0 &amp;&amp; next_i &lt; board.size())</span><br><span class="line">        &amp;&amp; (next_j &gt; 0 &amp;&amp; next_j &lt; board[0].size()))</span><br><span class="line">            dfs(board,tmp,marked);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">    if(board.empty())</span><br><span class="line">        return;</span><br><span class="line">    int m = board.size(),n = board[0].size();</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; marked(m,vector&lt;bool&gt;(n, false));</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; side;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        if(board[0][i]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;0,i&#125;);</span><br><span class="line">            //marked[0][i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(board[m-1][i]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;m-1,i&#125;);</span><br><span class="line">            //marked[m-1][i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;m-1;i++)&#123;</span><br><span class="line">        if(board[i][0]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;i,0&#125;);</span><br><span class="line">            //marked[i][0] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(board[i][n-1]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;i,n-1&#125;);</span><br><span class="line">            //marked[i][n-1] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(auto s:side)&#123;</span><br><span class="line">        dfs(board,s,marked);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            if(!marked[i][j] &amp;&amp; board[i][j]==&#x27;O&#x27;)</span><br><span class="line">                board[i][j] = &#x27;X&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-417-太平洋大西洋水流问题（中等）"><a href="#Leetcode-417-太平洋大西洋水流问题（中等）" class="headerlink" title="Leetcode 417. 太平洋大西洋水流问题（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">Leetcode 417. 太平洋大西洋水流问题（中等）</a></h4><p>左边和上边是太平洋，右边和下边是大西洋，内部的数字代表海拔，海拔高的地方的水能够流到低的地方，求解水能够流到太平洋和大西洋的所有位置。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given the following 5x5 matrix:</span><br><span class="line"></span><br><span class="line">Pacific ~   ~   ~   ~   ~  </span><br><span class="line">    ~  1   2   2   3  (5) *  </span><br><span class="line">    ~  3   2   3  (4) (4) *  </span><br><span class="line">    ~  2   4  (5)  3   1  *  </span><br><span class="line">    ~ (6) (7)  1   4   5  *  </span><br><span class="line">    ~ (5)  1   1   2   4  *  </span><br><span class="line">    *   *   *   *   * Atlantic</span><br><span class="line"></span><br><span class="line">Return:  </span><br><span class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]   </span><br><span class="line">(positions with parentheses in above matrix).  </span><br></pre></td></tr></table></figure>
<p>题解：<br>从边缘逆流dfs，P逆流能到达的地方的标记，A逆流能到达的地方标记，都为1的位置即所求位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void dfs(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int i, int j, vector&lt;vector&lt;bool&gt; &gt; &amp;canTo)&#123;</span><br><span class="line">    if(canTo[i][j])</span><br><span class="line">        return;</span><br><span class="line">    canTo[i][j] = true;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; directions = &#123; &#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125; &#125;;</span><br><span class="line">    for(auto d:directions)&#123;</span><br><span class="line">        int next_i = i + d[0];</span><br><span class="line">        int next_j = j + d[1];</span><br><span class="line">        if(next_i&lt;0 || next_i&gt;=matrix.size() || </span><br><span class="line">        next_j&lt;0 || next_j&gt;=matrix[0].size() || </span><br><span class="line">        matrix[next_i][next_j]&lt;matrix[i][j])&#123;//这里i j一定要看清楚！因为i j调了一个小时！</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(matrix, next_i, next_j, canTo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    if(matrix.empty())</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    int m = matrix.size();</span><br><span class="line">    int n = matrix[0].size();</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; canToAtlatic(m, vector&lt;bool&gt;(n, false));</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; canToPacific(m,vector&lt;bool&gt;(n,false));</span><br><span class="line">    for (int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        dfs(matrix, i, 0, canToPacific);</span><br><span class="line">        dfs(matrix, i, n - 1, canToAtlatic);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        dfs(matrix, 0, i, canToPacific);</span><br><span class="line">        dfs(matrix, m - 1, i, canToAtlatic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    for (int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; n;j++)&#123;</span><br><span class="line">            if(canToAtlatic[i][j] &amp;&amp; canToPacific[i][j])&#123;</span><br><span class="line">                vector&lt;int&gt; tmp = &#123;i, j&#125;;</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-329-矩阵中的最长递增路径（困难）"><a href="#Leetcode-329-矩阵中的最长递增路径（困难）" class="headerlink" title="Leetcode 329. 矩阵中的最长递增路径（困难）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">Leetcode 329. 矩阵中的最长递增路径（困难）</a></h4><p>给定一个整数矩阵，找出最长递增路径的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = </span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure>
<p>题解：<br>有记忆的dfs。<br>普通dfs会超时，所以加了二位矩阵来记录已经得到的最长序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; dirs = &#123; &#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">int dfs(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int i, int j, vector&lt;vector&lt;int&gt; &gt; &amp;memo)&#123;</span><br><span class="line">    if(memo[i][j]!=0)</span><br><span class="line">        return memo[i][j];</span><br><span class="line">    memo[i][j] = 1;</span><br><span class="line">    for(auto d:dirs)&#123;</span><br><span class="line">        if (i + d[0] &gt;= 0 &amp;&amp; i + d[0] &lt; matrix.size() </span><br><span class="line">            &amp;&amp; j + d[1] &gt;= 0 &amp;&amp; j + d[1] &lt; matrix[0].size() </span><br><span class="line">            &amp;&amp; matrix[i + d[0]][j + d[1]] &gt; matrix[i][j])</span><br><span class="line">            memo[i][j] = max(memo[i][j], dfs(matrix, i + d[0], j + d[1], memo) + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return memo[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int longestIncreasingPath(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123;</span><br><span class="line">    if(matrix.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int m = matrix.size(), n = matrix[0].size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; memo(m, vector&lt;int&gt;(n, 0));</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            res = max(res, dfs(matrix, i, j, memo));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p>
<h4 id="Leetcode-79-单词搜索（中等）"><a href="#Leetcode-79-单词搜索（中等）" class="headerlink" title="Leetcode 79. 单词搜索（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search/">Leetcode 79. 单词搜索（中等）</a></h4><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">For example,  </span><br><span class="line">Given board =  </span><br><span class="line">[ [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;],  </span><br><span class="line">[&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;],  </span><br><span class="line">[&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]  ]  </span><br><span class="line">word = &quot;ABCCED&quot;, -&gt; returns true,  </span><br><span class="line">word = &quot;SEE&quot;, -&gt; returns true,  </span><br><span class="line">word = &quot;ABCB&quot;, -&gt; returns false.  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool dfs(vector&lt;vector&lt;char&gt; &gt; &amp;board, string resWord, vector&lt;vector&lt;bool&gt; &gt; &amp;hasVisited, int i, int j)&#123;</span><br><span class="line">    if(resWord.size()==0)</span><br><span class="line">        return true;</span><br><span class="line">    if(i&lt;0 || i&gt;=board.size() || j&lt;0 || j&gt;=board[0].size() || board[i][j]!=resWord[0] || hasVisited[i][j])</span><br><span class="line">        return false;</span><br><span class="line">    hasVisited[i][j] = true;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; directions = &#123; &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125; &#125;;</span><br><span class="line">    for(auto d:directions)&#123;</span><br><span class="line">        if(dfs(board,resWord.substr(1,resWord.size()-1),hasVisited,i+d[0],j+d[1]))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    hasVisited[i][j] = false;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; hasVisited(board.size(),vector&lt;bool&gt;(board[0].size(),false));</span><br><span class="line">    for (int i = 0; i &lt; board.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; board[0].size();j++)&#123;</span><br><span class="line">            if(dfs(board, word, hasVisited, i, j))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-257-二叉树的所有路径（简单）"><a href="#Leetcode-257-二叉树的所有路径（简单）" class="headerlink" title="Leetcode 257. 二叉树的所有路径（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">Leetcode 257. 二叉树的所有路径（简单）</a></h4><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">     1  </span><br><span class="line">    / \  </span><br><span class="line">   2   3  </span><br><span class="line">    \  </span><br><span class="line">     5 </span><br><span class="line"></span><br><span class="line">输出：[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; res;</span><br><span class="line">void dfs(TreeNode *biTree, string prePath, TreeNode *curNode)&#123;</span><br><span class="line">    if(curNode==NULL)</span><br><span class="line">        return;</span><br><span class="line">    string curStr = to_string(curNode-&gt;val);</span><br><span class="line">    if (prePath.size() != 0)</span><br><span class="line">        curStr = &quot;-&gt;&quot; + curStr;</span><br><span class="line">    prePath = prePath + curStr;</span><br><span class="line">    if (curNode-&gt;left == NULL &amp;&amp; curNode-&gt;right == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(prePath);</span><br><span class="line">        return;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        dfs(biTree, prePath, curNode-&gt;left);</span><br><span class="line">        dfs(biTree, prePath, curNode-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    prePath = prePath.erase(prePath.size()-curStr.size());</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">    dfs(root, &quot;&quot;, root);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(n^2)</p>
<h3 id="3-6-4-滑动窗口"><a href="#3-6-4-滑动窗口" class="headerlink" title="3.6.4 滑动窗口"></a>3.6.4 滑动窗口</h3><h4 id="滑动窗口算法框架"><a href="#滑动窗口算法框架" class="headerlink" title="滑动窗口算法框架"></a>滑动窗口算法框架</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int left = 0, right = 0;</span><br><span class="line"></span><br><span class="line">while (right &lt; s.size()) &#123;`</span><br><span class="line">    // 增大窗口</span><br><span class="line">    window.add(s[right]);</span><br><span class="line">    right++;</span><br><span class="line"></span><br><span class="line">    while (window needs shrink) &#123;</span><br><span class="line">        // 缩小窗口</span><br><span class="line">        window.remove(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-424-替换后的最长重复字符"><a href="#Leetcode-424-替换后的最长重复字符" class="headerlink" title="Leetcode 424.替换后的最长重复字符"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/hua-dong-chuang-kou-chang-gui-tao-lu-by-xiaoneng/">Leetcode 424.替换后的最长重复字符</a></h4><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。  </p>
<p>在执行上述操作后，找到包含重复字母的最长子串的长度。  </p>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int characterReplacement(string s, int k) &#123;</span><br><span class="line">    vector&lt;int&gt; numOfAlpha(26);</span><br><span class="line">    int left = 0, right = 0, res = 0, maxCount = 0;</span><br><span class="line">    while(right&lt;s.size())&#123;</span><br><span class="line">        numOfAlpha[s[right] - &#x27;A&#x27;]++;</span><br><span class="line">        maxCount = max(maxCount, numOfAlpha[s[right]-&#x27;A&#x27;]);</span><br><span class="line">        if(right-left+1 - maxCount &gt;k)&#123;</span><br><span class="line">            numOfAlpha[s[left] - &#x27;A&#x27;]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, right - left + 1);</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-567-字符串的排列（中等）"><a href="#Leetcode-567-字符串的排列（中等）" class="headerlink" title="Leetcode 567. 字符串的排列（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutation-in-string/">Leetcode 567. 字符串的排列（中等）</a></h4><p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p>
<p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p>
<p>示例1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">输出: False</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题解：<br>用一个哈希表保存字母出现的个数，然后使用滑动窗口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool checkInclusion(string s1, string s2) &#123;</span><br><span class="line">    unordered_map&lt;char, int&gt; cmap;</span><br><span class="line">    for(char &amp;c:s1)</span><br><span class="line">        cmap[c]++;</span><br><span class="line">    int idxL = 0, idxR = 0;</span><br><span class="line">    while(idxR &lt; s2.size())&#123;</span><br><span class="line">        char c = s2[idxR++]; //窗口右边增大</span><br><span class="line">        cmap[c]--;</span><br><span class="line">        while(idxL&lt;idxR &amp;&amp; cmap[c]&lt;0) //窗口左边减小</span><br><span class="line">            cmap[s2[idxL++]]++;</span><br><span class="line">        if(idxR - idxL == s1.size())</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-5-二分查找-x2F-折半查找"><a href="#3-6-5-二分查找-x2F-折半查找" class="headerlink" title="3.6.5 二分查找&#x2F;折半查找"></a>3.6.5 二分查找&#x2F;折半查找</h3><h4 id="二分查找框架"><a href="#二分查找框架" class="headerlink" title="二分查找框架"></a>二分查找框架</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0, right = ...;</span><br><span class="line"></span><br><span class="line">    while(...) &#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两种计算中值 m 的方式：<br>m &#x3D; (l + h) &#x2F; 2<br>m &#x3D; l + (h - l) &#x2F; 2<br>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。<br>所以，最好使用第二种计算法方法。</p>
<h4 id="Leetcode-69-x-的平方根（简单）"><a href="#Leetcode-69-x-的平方根（简单）" class="headerlink" title="Leetcode 69. x 的平方根（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sqrtx/">Leetcode 69. x 的平方根（简单）</a></h4><p>实现 int sqrt(int x) 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: 4  </span><br><span class="line">Output: 2  </span><br><span class="line"></span><br><span class="line">Input: 8  </span><br><span class="line">Output: 2  </span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.</span><br></pre></td></tr></table></figure>
<p>题解：<br>后面 <strong>面试高频</strong> 中有返回不是int的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int mySqrt(int x) &#123;</span><br><span class="line">    if(x&lt;=1)</span><br><span class="line">        return x;</span><br><span class="line"></span><br><span class="line">    int low = 1, hight = x;</span><br><span class="line">    while(low&lt;=hight)&#123;</span><br><span class="line">        int mid = low + (hight - low) / 2;</span><br><span class="line">        if((long)mid * mid==x)</span><br><span class="line">            return mid;</span><br><span class="line">        else if((long)mid * mid&gt;x)</span><br><span class="line">            hight = mid - 1;</span><br><span class="line">        else</span><br><span class="line">            low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return hight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(logx)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-744-寻找比目标字母大的最小字母"><a href="#Leetcode-744-寻找比目标字母大的最小字母" class="headerlink" title="Leetcode 744. 寻找比目标字母大的最小字母"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">Leetcode 744. 寻找比目标字母大的最小字母</a></h4><p>给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:  </span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]  </span><br><span class="line">target = &quot;d&quot;  </span><br><span class="line">Output: &quot;f&quot;  </span><br><span class="line">Input:  </span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]  </span><br><span class="line">target = &quot;k&quot;  </span><br><span class="line">Output: &quot;c&quot;   </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123;</span><br><span class="line">    int n = letters.size();</span><br><span class="line">    int low = 0, hight = n-1;</span><br><span class="line">    while(low&lt;=hight)&#123;</span><br><span class="line">        int mid = low + (hight - low) / 2;</span><br><span class="line">        if(letters[mid]&lt;=target)</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        else</span><br><span class="line">            hight = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    char res = low &lt; n ? letters[low] : letters[0];</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-540-有序数组中的单一元素（中等）"><a href="#Leetcode-540-有序数组中的单一元素（中等）" class="headerlink" title="Leetcode 540. 有序数组中的单一元素（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">Leetcode 540. 有序数组中的单一元素（中等）</a></h4><p>给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。要求以 O(logN) 时间复杂度进行求解，因此不能遍历数组并进行异或操作来求解，这么做的时间复杂度为 O(N)。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 1, 2, 3, 3, 4, 4, 8, 8]  </span><br><span class="line">Output: 2  </span><br></pre></td></tr></table></figure>
<p>题解：<br>令 index 为 Single Element 在数组中的位置。在 index 之后，数组中原来存在的成对状态被改变。如果 m 为偶数，并且 m + 1 &lt; index，那么 nums[m] &#x3D;&#x3D; nums[m + 1]；m + 1 &gt;&#x3D; index，那么 nums[m] !&#x3D; nums[m + 1]。  </p>
<p>从上面的规律可以知道，如果 nums[m] &#x3D;&#x3D; nums[m + 1]，那么 index 所在的数组位置为 [m + 2, h]，此时令 l &#x3D; m + 2；如果 nums[m] !&#x3D; nums[m + 1]，那么 index 所在的数组位置为 [l, m]，此时令 h &#x3D; m。因为 h 的赋值表达式为 h &#x3D; m，那么循环条件也就只能使用 l &lt; h 这种形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int low = 0, hight = nums.size() - 1;</span><br><span class="line">    while(low&lt;hight)&#123;</span><br><span class="line">        int mid = low + (hight - low) / 2;</span><br><span class="line">        if(mid%2==1)  //保证m为偶数</span><br><span class="line">            mid--;</span><br><span class="line">        if(nums[mid] == nums[mid+1])</span><br><span class="line">            low = mid + 2;</span><br><span class="line">        else</span><br><span class="line">            hight = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>
<p>类似的题</p>
<h4 id="Leetcode-136-只出现一次的数字（简单）"><a href="#Leetcode-136-只出现一次的数字（简单）" class="headerlink" title="Leetcode 136. 只出现一次的数字（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/">Leetcode 136. 只出现一次的数字（简单）</a></h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p>题解：<br>任何数和其自身做异或运算结果是0，任何数和 0 做异或运算结果仍然是原来的数。所以依次异或就能得到。无序的话也不能用二分来做。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int num : nums) &#123;</span><br><span class="line">        res ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-137-只出现一次的数字-II（中等）"><a href="#Leetcode-137-只出现一次的数字-II（中等）" class="headerlink" title="Leetcode 137. 只出现一次的数字 II（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number-ii/">Leetcode 137. 只出现一次的数字 II（中等）</a></h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,1,0,1,99]</span><br><span class="line">输出: 99</span><br></pre></td></tr></table></figure>
<p>题解：<br>哈希表的话空间复杂度为O(n)，但是我们需要空间复杂度为O(1)。具体看题解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int seenOnce = 0, seenTwice = 0;</span><br><span class="line">    for (int num : nums) &#123;</span><br><span class="line">        seenOnce = ~seenTwice &amp; (seenOnce ^ num);</span><br><span class="line">        seenTwice = ~seenOnce &amp; (seenTwice ^ num);</span><br><span class="line">    &#125;</span><br><span class="line">    return seenOnce;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-278-第一个错误的版本（简单）"><a href="#Leetcode-278-第一个错误的版本（简单）" class="headerlink" title="Leetcode 278. 第一个错误的版本（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-bad-version/">Leetcode 278. 第一个错误的版本（简单）</a></h4><p>给定一个元素 n 代表有 [1, 2, …, n] 版本，在第 x 位置开始出现错误版本，导致后面的版本都错误。</p>
<p>如果第 m 个版本出错，则表示第一个错误的版本在 [l, m] 之间，令 h &#x3D; m；否则第一个错误的版本在 [m + 1, h] 之间，令 l &#x3D; m + 1。因为 h 的赋值表达式为 h &#x3D; m，因此循环条件为 l &lt; h。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 n = 5，并且 version = 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5) -&gt; true</span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。</span><br></pre></td></tr></table></figure>
<p>题解：<br>二分法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int firstBadVersion(int n) &#123;</span><br><span class="line">    int low = 1, hight = n;</span><br><span class="line">    while(low &lt; hight)&#123;</span><br><span class="line">        int mid = low + (hight - low) / 2;</span><br><span class="line">        if(isBadVersion(mid))</span><br><span class="line">            hight = mid;</span><br><span class="line">        else</span><br><span class="line">            low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-153-寻找旋转排序数组中的最小值（中等）"><a href="#Leetcode-153-寻找旋转排序数组中的最小值（中等）" class="headerlink" title="Leetcode 153. 寻找旋转排序数组中的最小值（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">Leetcode 153. 寻找旋转排序数组中的最小值（中等）</a></h4><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。(例如，数组[0,1,2,4,5,6,7]可能变为[4,5,6,7,0,1,2])</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1 </span><br></pre></td></tr></table></figure>
<p>题解：<br>二分法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int low = 0, hight = nums.size() - 1;</span><br><span class="line">    while(low &lt; hight)&#123;</span><br><span class="line">        int mid = low + (hight - low) / 2;</span><br><span class="line">        if(nums[mid] &lt;= nums[hight])</span><br><span class="line">            hight = mid;</span><br><span class="line">        else</span><br><span class="line">            low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-34-在排序数组中查找元素的第一个和最后一个位置（中等）"><a href="#Leetcode-34-在排序数组中查找元素的第一个和最后一个位置（中等）" class="headerlink" title="Leetcode 34. 在排序数组中查找元素的第一个和最后一个位置（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">Leetcode 34. 在排序数组中查找元素的第一个和最后一个位置（中等）</a></h4><p>给定一个有序数组 nums 和一个目标 target，要求找到 target 在 nums 中的第一个位置和最后一个位置。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 8  </span><br><span class="line">Output: [3,4]  </span><br><span class="line">Input: nums = [5,7,7,8,8,10], target = 6  </span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure>
<p>题解：<br>可以用二分查找找出第一个位置和最后一个位置，但是寻找的方法有所不同，需要实现两个二分查找。</p>
<p>我们将寻找 target 最后一个位置，转换成寻找 target+1 第一个位置，再往前移动一个位置。这样我们只需要实现一个二分查找代码即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int findFirst(vector&lt;int&gt; &amp;nums, int target)&#123;</span><br><span class="line">    int low = 0, hight = nums.size() - 1;</span><br><span class="line">    if(target&gt;nums[hight])&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    while(low&lt;hight)&#123;</span><br><span class="line">        int mid = low + (hight - low) / 2;</span><br><span class="line">        if(nums[mid]&gt;=target)</span><br><span class="line">            hight = mid;</span><br><span class="line">        else</span><br><span class="line">            low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target)&#123;</span><br><span class="line">    if(nums.empty() || target&lt;nums[0] || target&gt;nums[nums.size()-1])</span><br><span class="line">        return &#123;-1, -1&#125;;</span><br><span class="line"></span><br><span class="line">    int first = findFirst(nums, target);</span><br><span class="line">    int next = findFirst(nums, target + 1);</span><br><span class="line">    if (first == -1 || nums[first] != target)</span><br><span class="line">        return &#123;-1, -1&#125;;</span><br><span class="line"></span><br><span class="line">    int last = 0;</span><br><span class="line">    if (next == -1)</span><br><span class="line">        last = nums.size() - 1;</span><br><span class="line">    else</span><br><span class="line">        last = next - 1;</span><br><span class="line">    return &#123;first, last&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-315-计算右侧小于当前元素的个数"><a href="#Leetcode-315-计算右侧小于当前元素的个数" class="headerlink" title="Leetcode 315. 计算右侧小于当前元素的个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">Leetcode 315. 计算右侧小于当前元素的个数</a></h4><p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,2,6,1]</span><br><span class="line">输出：[2,1,1,0] </span><br><span class="line">解释：</span><br><span class="line">5 的右侧有 2 个更小的元素 (2 和 1)</span><br><span class="line">2 的右侧仅有 1 个更小的元素 (1)</span><br><span class="line">6 的右侧有 1 个更小的元素 (1)</span><br><span class="line">1 的右侧有 0 个更小的元素</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>归并排序。归并的过程中记录右边比左边小的个数和索引。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; indexs; //原始索引</span><br><span class="line">vector&lt;int&gt; ans;  //要求的答案</span><br><span class="line">vector&lt;int&gt; ordered;  //存排好序的临时数组</span><br><span class="line">vector&lt;int&gt; orderedIndex;  //存排好序的临时数组索引</span><br><span class="line"></span><br><span class="line">void Merge(vector&lt;int&gt; &amp;nums, int l, int mid, int r)&#123;</span><br><span class="line">	int i = l, j = mid + 1, p = l;</span><br><span class="line">	while (i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">		if (nums[i] &lt;= nums[j])&#123;</span><br><span class="line">			ordered[p] = nums[i];</span><br><span class="line">			orderedIndex[p] = indexs[i];</span><br><span class="line">			ans[indexs[i]] += (j - mid - 1);</span><br><span class="line">			i++;</span><br><span class="line">			p++;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			ordered[p] = nums[j];</span><br><span class="line">			orderedIndex[p] = indexs[j];</span><br><span class="line">			j++;</span><br><span class="line">			p++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (i &lt;= mid) &#123;</span><br><span class="line">		ordered[p] = nums[i];</span><br><span class="line">		orderedIndex[p] = indexs[i];</span><br><span class="line">		ans[indexs[i]] += (j - mid - 1);</span><br><span class="line">		i++;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (j &lt;= r)&#123;</span><br><span class="line">		ordered[p] = nums[j];</span><br><span class="line">		orderedIndex[p] = indexs[j];</span><br><span class="line">		j++;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int k = l; k &lt;= r; k++)&#123;</span><br><span class="line">		indexs[k] = orderedIndex[k];</span><br><span class="line">		nums[k] = ordered[k];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> void MergeSort(vector&lt;int&gt; &amp;a, int L, int R)&#123;</span><br><span class="line">	if (L &gt;= R) </span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	int mid = (L + R) &gt;&gt; 1;</span><br><span class="line">	MergeSort(a, L, mid);</span><br><span class="line">	MergeSort(a, mid + 1, R);</span><br><span class="line">	Merge(a, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; countSmaller(vector&lt;int&gt; &amp;nums)&#123;</span><br><span class="line">	int n = nums.size();</span><br><span class="line">	indexs.resize(n);</span><br><span class="line">	ans.resize(n);</span><br><span class="line">	ordered.resize(n);</span><br><span class="line">	orderedIndex.resize(n);</span><br><span class="line"></span><br><span class="line">	for(int i = 0; i &lt; n; ++i)</span><br><span class="line">		indexs[i] = i;</span><br><span class="line"></span><br><span class="line">	MergeSort(nums, 0, n - 1);</span><br><span class="line"></span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>把数组从后往前的元素依次插入一个初始为空的排序数组，插入的索引即为该元素右侧比它小的元素个数。如：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 [5,2,6,1]</span><br><span class="line"></span><br><span class="line">        排序数组</span><br><span class="line">step1   [1]         return 0</span><br><span class="line">step2   [1,6]       return 1</span><br><span class="line">step3   [1,2,6]     return 1</span><br><span class="line">step4   [1,2,5,6]   return 2</span><br><span class="line"></span><br><span class="line">所以最后答案为  [2,1,1,0]</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int insertNums(vector&lt;int&gt; &amp;sorted, int num)&#123;</span><br><span class="line">	if(sorted.size()==1)&#123;</span><br><span class="line">		if(num&gt;sorted[0])&#123;</span><br><span class="line">			sorted.push_back(num);</span><br><span class="line">			return 1;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			sorted.insert(sorted.begin(),num);</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int l = 0, r = sorted.size()-1;</span><br><span class="line">	int mid = (l + r) / 2;</span><br><span class="line">	while (l &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		if(sorted[mid]&lt;num)</span><br><span class="line">			l = mid + 1;</span><br><span class="line">		else</span><br><span class="line">			r = mid - 1;</span><br><span class="line">		mid = (l+r)/2;</span><br><span class="line">	&#125;</span><br><span class="line">	sorted.insert(sorted.begin()+l, num);</span><br><span class="line">	return l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">	if(nums.empty())</span><br><span class="line">		return &#123;&#125;;</span><br><span class="line">	vector&lt;int&gt; sorted;</span><br><span class="line">	vector&lt;int&gt; res(nums.size());</span><br><span class="line">	sorted.push_back(nums[nums.size()-1]);</span><br><span class="line">	for(int i=nums.size()-2;i&gt;=0;i--)&#123;</span><br><span class="line">		int idx = insertNums(sorted, nums[i]);</span><br><span class="line">		res[i] = idx;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：一开始以为是O(nlogn)，后来发现insert是O(n)的复杂度，所以是O(n^2)，就是插入排序的复杂度。但是Leetcode还是过了<br>空间复杂度：O(n)</p>
<h2 id="3-7-字符串"><a href="#3-7-字符串" class="headerlink" title="3.7 字符串"></a>3.7 字符串</h2><h3 id="字符串的统计字符串"><a href="#字符串的统计字符串" class="headerlink" title="字符串的统计字符串"></a>字符串的统计字符串</h3><p>给定一个字符串str，返回str的统计字符串。例如“aaabbbbcccd”的统计字符串为“a_3_b_4_c_3_d_1”。</p>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">string calcuChar(string s)&#123;</span><br><span class="line">	char c = s[0];</span><br><span class="line">    int cnt = 1;</span><br><span class="line">	string res = &quot;&quot;;</span><br><span class="line">	string cur_s;</span><br><span class="line">	for (int i = 1; i &lt; s.size(); i++)&#123;</span><br><span class="line">		if(s[i] == c)</span><br><span class="line">            cnt++;</span><br><span class="line">        else&#123;</span><br><span class="line">			cur_s = c;</span><br><span class="line">			res += (cur_s + &quot;_&quot; + to_string(cnt) + &quot;_&quot;);</span><br><span class="line">			c = s[i];</span><br><span class="line">			cnt = 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cur_s = c;</span><br><span class="line">	res += (cur_s + &quot;_&quot; + to_string(cnt));</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h3><h4 id="暴力匹配算法框架"><a href="#暴力匹配算法框架" class="headerlink" title="暴力匹配算法框架"></a>暴力匹配算法框架</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int search(String pat, String txt) &#123;</span><br><span class="line">    int M = pat.length;</span><br><span class="line">    int N = txt.length;</span><br><span class="line">    for (int i = 0; i &lt;= N - M; i++) &#123;</span><br><span class="line">        int j;</span><br><span class="line">        for (j = 0; j &lt; M; j++) &#123;</span><br><span class="line">            if (pat[j] != txt[i+j])</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        // pat 全都匹配了</span><br><span class="line">        if (j == M) return i;</span><br><span class="line">    &#125;</span><br><span class="line">    // txt 中不存在 pat 子串</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/v_july_v/article/details/7041827">从头到尾彻底理解KMP</a>  </p>
<h4 id="Leetcode-28-实现-strStr"><a href="#Leetcode-28-实现-strStr" class="headerlink" title="Leetcode 28. 实现 strStr()"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-strstr/solution/kmp-suan-fa-xiang-jie-by-labuladong/">Leetcode 28. 实现 strStr()</a></h4><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。<br>示例 1:<br>输入: haystack &#x3D; “hello”, needle &#x3D; “ll”<br>输出: 2<br>示例 2:<br>输入: haystack &#x3D; “aaaaa”, needle &#x3D; “bba”<br>输出: -1  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（待完善）</span><br></pre></td></tr></table></figure>

<h3 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h3><p>（待完善）</p>
<h2 id="3-8-并查集（联合-查找算法-Union-find-Algorithm）"><a href="#3-8-并查集（联合-查找算法-Union-find-Algorithm）" class="headerlink" title="3.8 并查集（联合-查找算法 Union-find Algorithm）"></a>3.8 并查集（联合-查找算法 Union-find Algorithm）</h2><p>并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（Union-find Algorithm）定义了两个用于此数据结构的操作：</p>
<ul>
<li>Union：将两个子集合并成同一个集合。<br>由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（Union-find Data Structure）或合并-查找集合（Merge-find Set）。</li>
<li>Find：找到元素的root结点，每个root结点代表了一个子集。就能确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/tag/union-find/">Leetcode并查集题库</a></p>
<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>我们在查询过程中只关心根结点是什么，并不关心这棵树的形态(有一些题除外)。因此我们可以在查询操作的时候将访问过的每个点都指向树根，这样的方法叫做路径压缩，单次操作复杂度为𝑂(𝑙𝑜𝑔𝑁)。</p>
<h3 id="代码模版"><a href="#代码模版" class="headerlink" title="代码模版"></a>代码模版</h3><ul>
<li>初始化：把每个元素单独成为一个集合，即自己是自己的父结点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">    pre[i]=i;</span><br></pre></td></tr></table></figure></li>
<li>查询（含路径压缩）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int Find(int x)&#123;</span><br><span class="line">    if(x==pre[x]) return x;</span><br><span class="line">    return pre[x]=Find(pre[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>合并<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void merge(int x,int y)&#123;</span><br><span class="line">    int rootX=Find(x),rootY=Find(y);</span><br><span class="line">    if(rootX!=rootY) pre[rootX]=rootY;</span><br><span class="line">&#125;</span><br><span class="line">//主函数内</span><br><span class="line">merge(a,b);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="76-亲戚"><a href="#76-亲戚" class="headerlink" title="76. 亲戚"></a>76. <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1551">亲戚</a></h3><p>规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。<br>输入格式<br>第一行：三个整数n,m,p，（n&lt;&#x3D;5000,m&lt;&#x3D;5000,p&lt;&#x3D;5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。<br>以下m行：每行两个数Mi，Mj，1&lt;&#x3D;Mi，Mj&lt;&#x3D;N，表示Mi和Mj具有亲戚关系。<br>接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。<br>输出格式<br>P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。  </p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">6 5 3</span><br><span class="line">1 2</span><br><span class="line">1 5</span><br><span class="line">3 4</span><br><span class="line">5 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 3</span><br><span class="line">5 6</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<p>题解（略）</p>
<h3 id="Leetcode每日一题-2020年六月：6月8日"><a href="#Leetcode每日一题-2020年六月：6月8日" class="headerlink" title="Leetcode每日一题-2020年六月：6月8日"></a><a target="_blank" rel="noopener" href="https://suzhilong.github.io/2020/06/01/LeetcodeDaily/">Leetcode每日一题-2020年六月：6月8日</a></h3><h1 id="四、面试高频题"><a href="#四、面试高频题" class="headerlink" title="四、面试高频题"></a>四、面试高频题</h1><h2 id="4-1-自己实现atoi"><a href="#4-1-自己实现atoi" class="headerlink" title="4.1 自己实现atoi"></a>4.1 自己实现atoi</h2><p>这个相当高频，面试遇到过至少2次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int myAtoi(const string &amp;str)&#123;</span><br><span class="line">    string s = str;</span><br><span class="line">    int flag = 1;</span><br><span class="line">    if(str[0]==&#x27;-&#x27;)&#123;</span><br><span class="line">        s = s.substr(1, s.size() - 1);</span><br><span class="line">        flag = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    long res = 0;</span><br><span class="line">    for (int i = 0; i &lt; s.size();i++)&#123;</span><br><span class="line">        res = res * 10 + (s[i] - &#x27;0&#x27;);</span><br><span class="line">        if(res&gt;=INT_MAX &amp;&amp; flag==1)</span><br><span class="line">            return INT_MAX;</span><br><span class="line">        if(res&gt;INT_MAX &amp;&amp; flag==-1)</span><br><span class="line">            return INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    return (int)res * flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-string模拟数字运算"><a href="#4-2-string模拟数字运算" class="headerlink" title="4.2 string模拟数字运算"></a>4.2 string模拟数字运算</h2><h3 id="大数相乘"><a href="#大数相乘" class="headerlink" title="大数相乘"></a>大数相乘</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">string bigMultiple(string num1, string num2)&#123;</span><br><span class="line">    int m = num1.size(), n = num2.size();</span><br><span class="line">    vector&lt;long long&gt; num(m + n - 1, 0); //m位*n位 最小是 m+n-1 位，进位插到前面</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m;i++)&#123;//前面是高位，后面是低位</span><br><span class="line">        int a = num1[i] - &#x27;0&#x27;;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int b = num2[j] - &#x27;0&#x27;;</span><br><span class="line">            num[i + j] += a * b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int carry = 0;</span><br><span class="line">    for (int i = num.size() - 1; i &gt;= 0;i--)&#123;//前面是高位，后面是低位</span><br><span class="line">        int cur = num[i] + carry;</span><br><span class="line">        num[i] = cur % 10;</span><br><span class="line">        carry = cur / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    while(carry!=0)&#123;</span><br><span class="line">        int cur = carry % 10;</span><br><span class="line">        carry /= 10;</span><br><span class="line">        num.insert(num.begin(), cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    for (auto a : num)</span><br><span class="line">    &#123;</span><br><span class="line">        res += to_string(a);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m*n)<br>空间复杂度：O(m+n)</p>
<h3 id="大数相加"><a href="#大数相加" class="headerlink" title="大数相加"></a>大数相加</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">string bigAdd(string &amp;num1, string &amp;num2)&#123;</span><br><span class="line">    int i = num1.size() - 1, j = num2.size() - 1;</span><br><span class="line">    int carry = 0;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    while(i&gt;=0 || j&gt;=0 || carry!=0)&#123;</span><br><span class="line">        int n1 = i &gt;= 0 ? num1[i] - &#x27;0&#x27; : 0;</span><br><span class="line">        int n2 = j &gt;= 0 ? num2[j] - &#x27;0&#x27; : 0;</span><br><span class="line">        int tmp = n1 + n2 + carry;</span><br><span class="line">        res.push_back(&#x27;0&#x27; + tmp % 10);</span><br><span class="line">        carry = tmp / 10;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大数相减"><a href="#大数相减" class="headerlink" title="大数相减"></a>大数相减</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">string bigAdd(string &amp;num1, string &amp;num2)&#123;</span><br><span class="line">    int i = num1.size() - 1, j = num2.size() - 1;</span><br><span class="line">    int carry = 0;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    while(i&gt;=0 || j&gt;=0 || carry!=0)&#123;</span><br><span class="line">        int n1 = i &gt;= 0 ? num1[i] - &#x27;0&#x27; : 0;</span><br><span class="line">        int n2 = j &gt;= 0 ? num2[j] - &#x27;0&#x27; : 0;</span><br><span class="line">        int tmp = n1 + n2 + carry;</span><br><span class="line">        res.push_back(&#x27;0&#x27; + tmp % 10);</span><br><span class="line">        carry = tmp / 10;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string GreaterMinSmaller(string num1, string num2)&#123;</span><br><span class="line">    int borrow = 0;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    int i = num1.size() - 1, j = num2.size() - 1;</span><br><span class="line">    while(i&gt;=0)&#123;</span><br><span class="line">        int cur1 = num1[i] - &#x27;0&#x27; - borrow;</span><br><span class="line">        borrow = 0;</span><br><span class="line">        int cur2 = j &gt;= 0 ? num2[j] - &#x27;0&#x27; : 0;</span><br><span class="line">        if(cur1 &lt; cur2)&#123;</span><br><span class="line">            cur1 += 10;</span><br><span class="line">            borrow = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(&#x27;0&#x27; + (cur1 - cur2));</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    int not0 = 0;</span><br><span class="line">    while(res[not0]==&#x27;0&#x27;)</span><br><span class="line">        not0++;</span><br><span class="line">    return res.substr(not0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string bigMinis(string &amp;num1, string &amp;num2)&#123;</span><br><span class="line">    if(num1 == num2)</span><br><span class="line">        return &quot;0&quot;;</span><br><span class="line">    int flag1 = 1, flag2 = 1;</span><br><span class="line">    string s1 = num1, s2 = num2;</span><br><span class="line">    if (num1[0] == &#x27;-&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        s1 = s1.substr(1);</span><br><span class="line">        flag1 = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (num2[0] == &#x27;-&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        s2 = s2.substr(1);</span><br><span class="line">        flag2 = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag1==-1 &amp;&amp; flag2==1)</span><br><span class="line">        return &quot;-&quot; + bigAdd(s1, s2);</span><br><span class="line">    else if (flag1 == 1 &amp;&amp; flag2 == -1)</span><br><span class="line">        return bigAdd(s1, s2);</span><br><span class="line">    else if (flag1 == 1 &amp;&amp; flag2 == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        bool flag = true;</span><br><span class="line">        if(s1.size()&lt;s2.size())&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;else if(s1.size()==s2.size())&#123;</span><br><span class="line">            int idx = 0;</span><br><span class="line">            while(s1[idx]==s2[idx])</span><br><span class="line">                idx++;</span><br><span class="line">            if(s1[idx]&gt;s2[idx])</span><br><span class="line">                flag = true;</span><br><span class="line">            else</span><br><span class="line">                flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)</span><br><span class="line">            return GreaterMinSmaller(s1, s2);</span><br><span class="line">        else</span><br><span class="line">            return &quot;-&quot; + GreaterMinSmaller(s2, s1);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (flag1 == -1 &amp;&amp; flag2 == -1)</span><br><span class="line">    &#123;//(-a)-(-b) = -(a-b)</span><br><span class="line">        string res = bigMinis(s1, s2);</span><br><span class="line">        if(res[0]==&#x27;-&#x27;)</span><br><span class="line">            return res.substr(1);</span><br><span class="line">        else</span><br><span class="line">            return &quot;-&quot; + res;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-位操作"><a href="#4-3-位操作" class="headerlink" title="4.3 位操作"></a>4.3 位操作</h2><h3 id="奇偶位交换-unsigned-int"><a href="#奇偶位交换-unsigned-int" class="headerlink" title="奇偶位交换(unsigned int)"></a>奇偶位交换(unsigned int)</h3><p>只要把奇数位（从低到高）拿出来左移1位，偶数位拿出来右移1位，再相或。</p>
<p><code>0xAAAA</code> 的偶数位都为1，<code>0x5555</code>的奇数位都为1，分别相与可以得到奇数位和偶数位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void swapBit(unsigned int &amp;num)&#123;</span><br><span class="line">    num = ((num &amp; 0xAAAA) &gt;&gt; 1) | ((num &amp; 0x5555) &lt;&lt; 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-实现sqrt函数"><a href="#4-4-实现sqrt函数" class="headerlink" title="4.4 实现sqrt函数"></a>4.4 实现sqrt函数</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">float sqrtBiSearch(float n)&#123;</span><br><span class="line">    if(n&lt;0)</span><br><span class="line">        return 0.0;</span><br><span class="line">    float eps = 1e-8;</span><br><span class="line">    float left, right;</span><br><span class="line">    if (n &gt; 1)&#123;</span><br><span class="line">        left = 0;</span><br><span class="line">        right = n;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        left = n;</span><br><span class="line">        right = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    float mid = (left + right) / 2, last;</span><br><span class="line">    while(abs(mid-last) &gt; eps)&#123;</span><br><span class="line">        if(mid*mid &gt; n)</span><br><span class="line">            right = mid;</span><br><span class="line">        else</span><br><span class="line">            left = mid;</span><br><span class="line">        last = mid;</span><br><span class="line">        mid = (left + right) / 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="牛顿迭代"><a href="#牛顿迭代" class="headerlink" title="牛顿迭代"></a>牛顿迭代</h3><p><code>x_n+1 = x_n - f(x_n)/f&#39;(x_n)</code>。因为<code>f(x) = x^2 - n</code>，所以<code>f&#39;(x) = 2x</code>，即<code>x = (x + n/x)/2</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">float sqrtNewton(float n)&#123;</span><br><span class="line">    float eps = 1e-8;</span><br><span class="line">    if(abs(n-0.0) &gt; eps)</span><br><span class="line">        return 0.0;</span><br><span class="line">    float x = n ,last = 0 ;</span><br><span class="line">    while (abs(x-last) &gt; eps)&#123;</span><br><span class="line">        last = x ;</span><br><span class="line">        x = (x + n / x) / 2.0 ;</span><br><span class="line">    &#125;</span><br><span class="line">     return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-抢红包的实现"><a href="#4-5-抢红包的实现" class="headerlink" title="4.5 抢红包的实现"></a>4.5 抢红包的实现</h2><ol>
<li>每次把需要剩下的保证后面的人至少都有最低金额的钱减掉（比如还剩下10个人，每个人至少1分钱，就需要留下至少0.1元）。把金额*100后用int来做，最后 &#x2F;100 就能保证 2 位小数。最后一个人为剩下的所有钱。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;float&gt; redBag(const float &amp;money, int cnt)&#123;</span><br><span class="line">	int Money = money * 100;</span><br><span class="line">	int minMoney = 1;</span><br><span class="line">	int lastMoney = Money;</span><br><span class="line">	int lastCnt = cnt;</span><br><span class="line">	int maxMoney = lastMoney - lastCnt*minMoney;</span><br><span class="line">	vector&lt;float&gt; res;</span><br><span class="line">	for (int i = 0; i &lt; cnt-1; i++)&#123;</span><br><span class="line">		int cur = rand() % maxMoney;</span><br><span class="line">		res.push_back(cur/100.0);</span><br><span class="line">		lastMoney -= cur;</span><br><span class="line">		lastCnt--;</span><br><span class="line">		maxMoney = lastMoney - lastCnt*minMoney;</span><br><span class="line">	&#125;</span><br><span class="line">	res.push_back(lastMoney/100.0);</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>随机生产<code>cnt</code>个整数，这些整数加起来的和为<code>sums</code>，每个人分到的钱就为<code>x/sums * money</code>。<code>((float)(int)(cur * 100) / 100.0)</code>能保证两位小数。最后一个人得到剩下的所有。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;float&gt; redBag(const float &amp;money, int cnt)&#123;</span><br><span class="line">	vector&lt;float&gt; res(cnt);</span><br><span class="line">	int sums = 0;</span><br><span class="line">	for (int i = 0; i &lt; cnt; i++)&#123;</span><br><span class="line">		res[i] = rand() % cnt;</span><br><span class="line">		sums += res[i];</span><br><span class="line">	&#125;</span><br><span class="line">	float sumM = 0.0;</span><br><span class="line">	for (int i = 0; i &lt; cnt - 1; i++)&#123;</span><br><span class="line">		float cur = (res[i] / sums) * money;</span><br><span class="line">		cur = ((float)(int)(cur * 100) / 100.0);</span><br><span class="line">		sumM += cur;</span><br><span class="line">		res[i] = cur;</span><br><span class="line">	&#125;</span><br><span class="line">	res[cnt - 1] = money - sumM;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li>严蔚敏, 吴伟民. 数据结构（C语言版）. 清华大学出版社</li>
<li>算法导论（中文版）. 机械工业出版社</li>
<li>Leetcode</li>
<li>何海涛. 剑指 Offer: 名企面试官精讲典型编程题. 电子工业出版社</li>
<li><a href="https://github.com/CyC2018/CS-Notes">CyC2018</a></li>
<li><a target="_blank" rel="noopener" href="https://labuladong.github.io/ebook/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.html">labuladong的算法小抄</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cyanigence-oi/p/11774190.html#fn1">并查集</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41593380/article/details/81146850?utm_medium=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">通俗易懂的并查集讲解</a></li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Su Zhilong 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Su Zhilong 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/08/02/blogBuild/" rel="prev" title="Nginx搭建基于Hexo的Blog">
      <i class="fa fa-chevron-left"></i> Nginx搭建基于Hexo的Blog
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/29/autonomousDriving/" rel="next" title="自动驾驶学习笔记">
      自动驾驶学习笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">一、算法基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 常用数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-%E9%93%BE%E8%A1%A8"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1 链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2 栈和队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.1.3 二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-4-%E5%9B%BE"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.1.4 图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-5-%E5%A0%86"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.1.5 堆</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 时间复杂度、空间复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E6%8E%92%E5%BA%8F%EF%BC%88Sorting%EF%BC%89%E3%80%81%E6%9F%A5%E6%89%BE-x2F-%E6%90%9C%E7%B4%A2%EF%BC%88Search%EF%BC%89"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 排序（Sorting）、查找&#x2F;搜索（Search）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1 排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-%E6%9F%A5%E6%89%BE-x2F-%E6%90%9C%E7%B4%A2"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2 查找&#x2F;搜索</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E9%80%92%E5%BD%92"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E5%88%86%E6%B2%BB"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 分治</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%E4%BE%8B%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">二、数据结构类例题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E6%A0%88"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">2.1.1.</span> <span class="nav-text">单调栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">1. 739. 每日温度（中等）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">2.1.2.</span> <span class="nav-text">两个栈实现队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">剑指 Offer 09. 用两个栈实现队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E6%8E%92%E5%BA%8F"><span class="nav-number">2.1.3.</span> <span class="nav-text">栈排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%EF%BC%88%E6%88%96%E7%9D%80%E8%AF%B4%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E8%BE%85%E5%8A%A9%E6%A0%88%E5%AF%B9%E6%A0%88%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">使用两个栈进行排序（或着说使用一个辅助栈对栈进行排序）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.1.</span> <span class="nav-text">二叉树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BFS%EF%BC%88%E5%8D%B3%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%89%EF%BC%9ABFS-%E5%8F%AF%E4%BB%A5%E6%8C%89%E7%85%A7%E5%B1%82%E6%AC%A1%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">BFS（即层序遍历）：BFS 可以按照层次的顺序从上到下遍历所有的节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DFS%EF%BC%9ADFS-%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%A0%B9%E5%BC%80%E5%A7%8B%EF%BC%8C%E4%B8%80%E7%9B%B4%E5%BB%B6%E4%BC%B8%E5%88%B0%E6%9F%90%E4%B8%AA%E5%8F%B6%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9B%9E%E5%88%B0%E6%A0%B9%EF%BC%8C%E5%88%B0%E8%BE%BE%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF%E3%80%82%E6%A0%B9%E6%8D%AE%E6%A0%B9%E8%8A%82%E7%82%B9%E3%80%81%E5%B7%A6%E8%8A%82%E7%82%B9%E5%92%8C%E5%8F%B3%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E5%AF%B9%E9%A1%BA%E5%BA%8F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%B0%86DFS%E7%AD%96%E7%95%A5%E5%8C%BA%E5%88%86%E4%B8%BA%EF%BC%9A"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">DFS：DFS 可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将DFS策略区分为：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.1.2.1.</span> <span class="nav-text">先序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.1.2.2.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.1.2.3.</span> <span class="nav-text">后序遍历</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Z%E5%BD%A2%E9%81%8D%E5%8E%86-x2F-%E9%94%AF%E9%BD%BF%E5%BD%A2%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">Z形遍历&#x2F;锯齿形遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1028-%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="nav-number">2.2.2.</span> <span class="nav-text">1. 1028. 从先序遍历还原二叉树（困难）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">2.2.3.</span> <span class="nav-text">2. 104. 二叉树的最大深度（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">2.2.4.</span> <span class="nav-text">3. 110. 平衡二叉树（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">2.2.5.</span> <span class="nav-text">4. 530. 二叉搜索树的最小绝对差（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%89%91%E6%8C%87-Offer-68-I-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">2.2.6.</span> <span class="nav-text">5. 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">2.2.7.</span> <span class="nav-text">6. 236. 二叉树的最近公共祖先（中等）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E9%93%BE%E8%A1%A8"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-01-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">2.3.1.</span> <span class="nav-text">面试题 02.01. 移除重复节点（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">2.3.2.</span> <span class="nav-text">206. 反转链表（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="nav-number">2.3.3.</span> <span class="nav-text">25. K 个一组翻转链表（困难）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">2.3.4.</span> <span class="nav-text">92. 反转链表 II（中等）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">2.3.5.</span> <span class="nav-text">142. 环形链表 II（中等）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E5%9B%BE"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5211-%E6%A6%82%E7%8E%87%E6%9C%80%E5%A4%A7%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">2.4.1.</span> <span class="nav-text">1. 5211. 概率最大的路径（中等）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-207-%E8%AF%BE%E7%A8%8B%E8%A1%A8%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">2.4.2.</span> <span class="nav-text">2. 207. 课程表（中等）有向图的拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-210-%E8%AF%BE%E7%A8%8B%E8%A1%A8-II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">2.4.3.</span> <span class="nav-text">3.210. 课程表 II（中等）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-133-%E5%85%8B%E9%9A%86%E5%9B%BE%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">2.4.4.</span> <span class="nav-text">4.133. 克隆图（中等）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E5%A0%86"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BB%99%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84h%EF%BC%8Ch%E6%9C%89n%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%9B%E6%AF%8F%E6%AC%A1%E5%8F%AF%E4%BB%A5%E7%BB%99%E6%95%B0%E7%BB%84h%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0%E5%8A%A0x%EF%BC%9B%E6%80%BB%E5%85%B1%E5%8F%AF%E4%BB%A5%E5%8A%A0m%E6%AC%A1%E3%80%82%E6%B1%82m%E6%AC%A1%E8%BF%90%E7%AE%97%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E5%80%BC%E3%80%82"><span class="nav-number">2.5.1.</span> <span class="nav-text">1. 给一个数组h，h有n个元素；每次可以给数组h中最小的元素加x；总共可以加m次。求m次运算后的数组最小值。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%87%8D%E5%A4%8D%E6%95%B0%E7%BB%84%E5%8F%98%E6%8D%A2"><span class="nav-number">2.5.2.</span> <span class="nav-text">2. 重复数组变换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%AE%97%E6%B3%95%E7%B1%BB%E4%BE%8B%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">三、算法类例题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%EF%BC%88Divide-and-conquer%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 分治算法（Divide and conquer）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-241-%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.1.1.</span> <span class="nav-text">Leetcode 241. 为运算表达式设计优先级（中等）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.1.2.</span> <span class="nav-text">Leetcode 95. 不同的二叉搜索树 II（中等）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88Dynamic-programming%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 动态规划（Dynamic programming）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%EF%BC%88fabonacci%EF%BC%89"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 斐波那契数列（fabonacci）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">Leetcode 70. 爬楼梯（简单）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">Leetcode 198. 打家劫舍（简单）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-213-House-Robber-II-%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">Leetcode 213. House Robber II （中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-634-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E9%94%99%E4%BD%8D%E6%8E%92%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%8C%E4%BC%9A%E5%91%98%E9%A2%98%EF%BC%89"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">Leetcode 634. 寻找数组的错位排列（中等，会员题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%8D%E7%89%9B%E7%94%9F%E5%B0%8F%E7%89%9B%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.1.5.</span> <span class="nav-text">母牛生小牛问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E4%BA%8C%E7%BB%B4dp%EF%BC%9A%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 二维dp：二维网格路径问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">Leetcode 64. 最小路径和（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">Leetcode 62. 不同路径（中等）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-%E5%AD%90%E5%BA%8F%E5%88%97-x2F-%E5%AD%90%E9%9B%86-x2F-%E5%AD%90%E6%95%B0%E7%BB%84-x2F-%E5%AD%90%E7%9F%A9%E9%98%B5"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.2.3 子序列&#x2F;子集&#x2F;子数组&#x2F;子矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">Leetcode 303. 区域和检索 - 数组不可变（简单）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-413-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">Leetcode 413. 等差数列划分（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">Leetcode 343. 整数拆分（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.3.4.</span> <span class="nav-text">Leetcode 279. 完全平方数（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.3.5.</span> <span class="nav-text">Leetcode 91.解码方法（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%92%8C%E4%B8%BA-k-%E7%9A%84-%E5%AD%90%E5%BA%8F%E5%88%97-x2F-%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">3.2.3.6.</span> <span class="nav-text">和为 k 的 子序列&#x2F;子数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%92%8C%E4%B8%BA-k-%E7%9A%84-%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">3.2.3.6.1.</span> <span class="nav-text">和为 k 的 子数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%92%8C%E4%B8%BA-k-%E7%9A%84-%E5%AD%90%E9%9B%86%E5%90%88-x2F-%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">3.2.3.6.2.</span> <span class="nav-text">和为 k 的 子集合&#x2F;子序列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">3.2.3.7.</span> <span class="nav-text">递增子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Leetcode-300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%EF%BC%88%E9%80%92%E5%A2%9E%EF%BC%89%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.3.7.1.</span> <span class="nav-text">Leetcode 300.  最长上升（递增）子序列（中等）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Leetcode-646-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.3.7.2.</span> <span class="nav-text">Leetcode 646. 最长数对链（中等）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Leetcode-376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.3.7.3.</span> <span class="nav-text">Leetcode 376. 摆动序列（中等）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">3.2.3.8.</span> <span class="nav-text">公共子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Leetcode-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97Longest-Common-Subsequence%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.3.8.1.</span> <span class="nav-text">Leetcode 1143. 最长公共子序列Longest Common Subsequence（中等）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Leetcode-583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.3.8.2.</span> <span class="nav-text">Leetcode 583. 两个字符串的删除操作（中等）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">3.2.3.9.</span> <span class="nav-text">最大连续子数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.2.3.9.1.</span> <span class="nav-text">Leetcode 53. 最大子序和（简单）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">3.2.3.9.2.</span> <span class="nav-text">返回最大子数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">3.2.3.10.</span> <span class="nav-text">旋转数组的最大连续子数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">3.2.3.10.1.</span> <span class="nav-text">旋转连续子数组和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E6%9C%80%E5%A4%A7%E5%92%8C%E7%9A%84%E6%97%8B%E8%BD%AC%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">3.2.3.10.2.</span> <span class="nav-text">返回最大和的旋转连续子数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C"><span class="nav-number">3.2.3.11.</span> <span class="nav-text">二维矩阵最大子矩阵和</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C"><span class="nav-number">3.2.3.11.1.</span> <span class="nav-text">最大子矩阵和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5"><span class="nav-number">3.2.3.11.2.</span> <span class="nav-text">返回最大子矩阵</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E6%9C%80%E5%A4%A7%E6%97%8B%E8%BD%AC%E5%AD%90%E7%9F%A9%E9%98%B5"><span class="nav-number">3.2.3.12.</span> <span class="nav-text">二维矩阵最大旋转子矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E6%97%8B%E8%BD%AC%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C"><span class="nav-number">3.2.3.12.1.</span> <span class="nav-text">最旋转大子矩阵和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E6%9C%80%E5%A4%A7%E6%97%8B%E8%BD%AC%E5%AD%90%E7%9F%A9%E9%98%B5"><span class="nav-number">3.2.3.12.2.</span> <span class="nav-text">返回最大旋转子矩阵</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.4.</span> <span class="nav-text">3.2.4 0-1背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4dp-0-1-%E8%83%8C%E5%8C%85"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">二维dp 0-1 背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96%EF%BC%9A%E4%B8%80%E7%BB%B4dp-0-1-%E8%83%8C%E5%8C%85"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">空间优化：一维dp 0-1 背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">Leetcode 416. 分割等和子集（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#leetcode-494-%E7%9B%AE%E6%A0%87%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.4.4.</span> <span class="nav-text">leetcode 494. 目标和（中等）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-1-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="nav-number">3.2.5.</span> <span class="nav-text">0-1 背包问题无法使用贪心算法的解释</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E7%A7%8D"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">变种</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-5-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.6.</span> <span class="nav-text">3.2.5 股票问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.2.6.1.</span> <span class="nav-text">Leetcode 121. 买卖股票的最佳时机（简单）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.2.6.2.</span> <span class="nav-text">Leetcode 122. 买卖股票的最佳时机 II（简单）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-III%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="nav-number">3.2.6.3.</span> <span class="nav-text">Leetcode 123. 买卖股票的最佳时机 III（困难）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-IV%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="nav-number">3.2.6.4.</span> <span class="nav-text">Leetcode 188. 买卖股票的最佳时机 IV（困难）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.6.5.</span> <span class="nav-text">Leetcode 309. 最佳买卖股票时机含冷冻期（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.6.6.</span> <span class="nav-text">Leetcode 714. 买卖股票的最佳时机含手续费（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#res"><span class="nav-number">3.2.6.7.</span> <span class="nav-text">res</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.7.</span> <span class="nav-text">3.2.6 字符串问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-650-%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.2.7.1.</span> <span class="nav-text">Leetcode 650. 只有两个键的键盘（中等）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-greedy"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 贪心算法(greedy)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.3.1.</span> <span class="nav-text">Leetcode 455. 分发饼干（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E4%B8%80%E9%A2%98%E7%9A%84%E5%8F%98%E4%BD%93"><span class="nav-number">3.3.2.</span> <span class="nav-text">上一题的变体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.3.3.</span> <span class="nav-text">Leetcode 435. 无重叠区间（中等）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.3.4.</span> <span class="nav-text">Leetcode 452. 用最少数量的箭引爆气球（中等）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.3.5.</span> <span class="nav-text">Leetcode 406. 根据身高重建队列（中等）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-605-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.3.6.</span> <span class="nav-text">Leetcode 605. 种花问题（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.3.7.</span> <span class="nav-text">Leetcode 392.判断子序列（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-665-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.3.8.</span> <span class="nav-text">Leetcode 665. 非递减数列（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.3.9.</span> <span class="nav-text">Leetcode 763. 划分字母区间（中等）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.4.1.</span> <span class="nav-text">Leetcode 167. 两数之和 II - 输入有序数组（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-633-%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.4.2.</span> <span class="nav-text">Leetcode 633. 平方数之和（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.4.3.</span> <span class="nav-text">Leetcode 345. 反转字符串中的元音字母（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-680-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2-%E2%85%A1%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.4.4.</span> <span class="nav-text">Leetcode 680. 验证回文字符串 Ⅱ（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.4.5.</span> <span class="nav-text">Leetcode 88. 合并两个有序数组（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.4.6.</span> <span class="nav-text">Leetcode 141. 环形链表（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-524-%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.4.7.</span> <span class="nav-text">Leetcode 524. 通过删除字母匹配到字典里最长单词（中等）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.4.8.</span> <span class="nav-text">Leetcode 75. 颜色分类（中等）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="nav-number">3.4.9.</span> <span class="nav-text">Leetcode 42. 接雨水（困难）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E6%8E%92%E5%BA%8F%EF%BC%88Sorting%EF%BC%89"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 排序（Sorting）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-Partition%E5%87%BD%E6%95%B0"><span class="nav-number">3.5.1.</span> <span class="nav-text">3.5.1 Partition函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E6%8E%92%EF%BC%88cpp%EF%BC%89"><span class="nav-number">3.5.2.</span> <span class="nav-text">快排（cpp）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%89%88"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">递归版</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%89%88"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">非递归版</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-%E4%BE%8B%E9%A2%98"><span class="nav-number">3.5.3.</span> <span class="nav-text">3.5.2 例题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TOP-K-%E9%97%AE%E9%A2%98"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">TOP K 问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Leetcode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.5.3.1.1.</span> <span class="nav-text">Leetcode 215. 数组中的第K个最大元素（中等）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BFPRT"><span class="nav-number">3.5.3.1.2.</span> <span class="nav-text">BFPRT</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.5.3.2.</span> <span class="nav-text">Leetcode 347. 前 K 个高频元素（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.5.3.3.</span> <span class="nav-text">Leetcode 451. 根据字符出现频率排序（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E6%8E%92%E5%BA%8F"><span class="nav-number">3.5.3.4.</span> <span class="nav-text">范围排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99%E6%8E%92%E5%BA%8F"><span class="nav-number">3.5.3.5.</span> <span class="nav-text">特殊规则排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E6%9F%A5%E6%89%BE-x2F-%E6%90%9C%E7%B4%A2%EF%BC%88Search%EF%BC%89"><span class="nav-number">3.6.</span> <span class="nav-text">3.6 查找&#x2F;搜索（Search）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%88backtracking%EF%BC%89"><span class="nav-number">3.6.1.</span> <span class="nav-text">3.6.1 回溯算法（backtracking）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%A1%86%E6%9E%B6"><span class="nav-number">3.6.1.1.</span> <span class="nav-text">回溯法框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.1.2.</span> <span class="nav-text">Leetcode 17. 电话号码的字母组合（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.1.3.</span> <span class="nav-text">Leetcode 93. 复原IP地址（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#huawei-%E7%9C%9F%E9%A2%98"><span class="nav-number">3.6.1.4.</span> <span class="nav-text">huawei 真题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.1.5.</span> <span class="nav-text">Leetcode 46. 全排列（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-77-%E7%BB%84%E5%90%88%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.1.6.</span> <span class="nav-text">Leetcode 77. 组合（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.1.7.</span> <span class="nav-text">Leetcode 39.组合总和（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.1.8.</span> <span class="nav-text">Leetcode 40. 组合总和 II（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.1.9.</span> <span class="nav-text">Leetcode 216. 组合总和 III（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-78-%E5%AD%90%E9%9B%86%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.1.10.</span> <span class="nav-text">Leetcode 78. 子集（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-90-%E5%AD%90%E9%9B%86-II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.1.11.</span> <span class="nav-text">Leetcode 90. 子集 II（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.1.12.</span> <span class="nav-text">Leetcode 131. 分割回文串（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%AC%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="nav-number">3.6.1.13.</span> <span class="nav-text">Leetcode 37. 解数独（困难）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="nav-number">3.6.1.14.</span> <span class="nav-text">N皇后问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-51-N%E7%9A%87%E5%90%8E%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="nav-number">3.6.1.15.</span> <span class="nav-text">Leetcode 51. N皇后（困难）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%EF%BC%88BFS%EF%BC%89"><span class="nav-number">3.6.2.</span> <span class="nav-text">3.6.2 广度优先（BFS）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-1091-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.2.1.</span> <span class="nav-text">Leetcode 1091. 二进制矩阵中的最短路径（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89-1"><span class="nav-number">3.6.2.2.</span> <span class="nav-text">Leetcode 279. 完全平方数（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.2.3.</span> <span class="nav-text">Leetcode 127. 单词接龙（中等）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-3-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%EF%BC%88DFS%EF%BC%89"><span class="nav-number">3.6.3.</span> <span class="nav-text">3.6.3 深度优先（DFS）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.3.1.</span> <span class="nav-text">Leetcode 695. 岛屿的最大面积（中等）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DFS"><span class="nav-number">3.6.3.1.1.</span> <span class="nav-text">DFS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BFS%E4%B9%9F%E5%8F%AF%E4%BB%A5"><span class="nav-number">3.6.3.1.2.</span> <span class="nav-text">BFS也可以</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.3.2.</span> <span class="nav-text">Leetcode 200. 岛屿数量（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-547-%E6%9C%8B%E5%8F%8B%E5%9C%88%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.3.3.</span> <span class="nav-text">Leetcode 547. 朋友圈（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.3.4.</span> <span class="nav-text">Leetcode 130. 被围绕的区域（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-417-%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.3.5.</span> <span class="nav-text">Leetcode 417. 太平洋大西洋水流问题（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-329-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="nav-number">3.6.3.6.</span> <span class="nav-text">Leetcode 329. 矩阵中的最长递增路径（困难）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.3.7.</span> <span class="nav-text">Leetcode 79. 单词搜索（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.6.3.8.</span> <span class="nav-text">Leetcode 257. 二叉树的所有路径（简单）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-4-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">3.6.4.</span> <span class="nav-text">3.6.4 滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6"><span class="nav-number">3.6.4.1.</span> <span class="nav-text">滑动窗口算法框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6"><span class="nav-number">3.6.4.2.</span> <span class="nav-text">Leetcode 424.替换后的最长重复字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.4.3.</span> <span class="nav-text">Leetcode 567. 字符串的排列（中等）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-5-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-x2F-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="nav-number">3.6.5.</span> <span class="nav-text">3.6.5 二分查找&#x2F;折半查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%A1%86%E6%9E%B6"><span class="nav-number">3.6.5.1.</span> <span class="nav-text">二分查找框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-69-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.6.5.2.</span> <span class="nav-text">Leetcode 69. x 的平方根（简单）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-744-%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D"><span class="nav-number">3.6.5.3.</span> <span class="nav-text">Leetcode 744. 寻找比目标字母大的最小字母</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-540-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.5.4.</span> <span class="nav-text">Leetcode 540. 有序数组中的单一元素（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.6.5.5.</span> <span class="nav-text">Leetcode 136. 只出现一次的数字（简单）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-II%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.5.6.</span> <span class="nav-text">Leetcode 137. 只出现一次的数字 II（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">3.6.5.7.</span> <span class="nav-text">Leetcode 278. 第一个错误的版本（简单）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.5.8.</span> <span class="nav-text">Leetcode 153. 寻找旋转排序数组中的最小值（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.6.5.9.</span> <span class="nav-text">Leetcode 34. 在排序数组中查找元素的第一个和最后一个位置（中等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">3.6.5.10.</span> <span class="nav-text">Leetcode 315. 计算右侧小于当前元素的个数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.7.</span> <span class="nav-text">3.7 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.7.1.</span> <span class="nav-text">字符串的统计字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D"><span class="nav-number">3.7.2.</span> <span class="nav-text">暴力匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6"><span class="nav-number">3.7.2.1.</span> <span class="nav-text">暴力匹配算法框架</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="nav-number">3.7.3.</span> <span class="nav-text">KMP算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Leetcode-28-%E5%AE%9E%E7%8E%B0-strStr"><span class="nav-number">3.7.3.1.</span> <span class="nav-text">Leetcode 28. 实现 strStr()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BM%E7%AE%97%E6%B3%95"><span class="nav-number">3.7.4.</span> <span class="nav-text">BM算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%88%E8%81%94%E5%90%88-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-Union-find-Algorithm%EF%BC%89"><span class="nav-number">3.8.</span> <span class="nav-text">3.8 并查集（联合-查找算法 Union-find Algorithm）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="nav-number">3.8.1.</span> <span class="nav-text">路径压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88"><span class="nav-number">3.8.2.</span> <span class="nav-text">代码模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#76-%E4%BA%B2%E6%88%9A"><span class="nav-number">3.8.3.</span> <span class="nav-text">76. 亲戚</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2020%E5%B9%B4%E5%85%AD%E6%9C%88%EF%BC%9A6%E6%9C%888%E6%97%A5"><span class="nav-number">3.8.4.</span> <span class="nav-text">Leetcode每日一题-2020年六月：6月8日</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">四、面试高频题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0atoi"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 自己实现atoi</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-string%E6%A8%A1%E6%8B%9F%E6%95%B0%E5%AD%97%E8%BF%90%E7%AE%97"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 string模拟数字运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E7%9B%B8%E4%B9%98"><span class="nav-number">4.2.1.</span> <span class="nav-text">大数相乘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-number">4.2.2.</span> <span class="nav-text">大数相加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%87%8F"><span class="nav-number">4.2.3.</span> <span class="nav-text">大数相减</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 位操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%87%E5%81%B6%E4%BD%8D%E4%BA%A4%E6%8D%A2-unsigned-int"><span class="nav-number">4.3.1.</span> <span class="nav-text">奇偶位交换(unsigned int)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E5%AE%9E%E7%8E%B0sqrt%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 实现sqrt函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">4.4.1.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3"><span class="nav-number">4.4.2.</span> <span class="nav-text">牛顿迭代</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.5.</span> <span class="nav-text">4.5 抢红包的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">5.</span> <span class="nav-text">Reference</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Su Zhilong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Su Zhilong</p>
  <div class="site-description" itemprop="description">I will always be with you</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/suzhilong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;suzhilong"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Su Zhilong</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">380k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:46</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'uaEz4DL2UqM1jg1eGmpd8vhF-gzGzoHsz',
      appKey     : 'SzL1ETN5dDwbXjnzyJYJkjTb',
      placeholder: "comment",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
