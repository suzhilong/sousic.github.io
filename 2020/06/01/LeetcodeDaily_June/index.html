<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/apple-touch-icon-next.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="6月份每日一题">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode每日一题 - 2020年六月">
<meta property="og:url" content="https://github.com/suzhilong/suzhilong.github.io.git/2020/06/01/LeetcodeDaily_June/index.html">
<meta property="og:site_name" content="SOUSIC">
<meta property="og:description" content="6月份每日一题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/06/16/DwJHZvu7SbTaBkC.png">
<meta property="article:published_time" content="2020-06-01T08:00:00.000Z">
<meta property="article:modified_time" content="2020-08-17T07:39:58.237Z">
<meta property="article:author" content="Su Zhilong">
<meta property="article:tag" content="Leetcode daily">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/06/16/DwJHZvu7SbTaBkC.png">

<link rel="canonical" href="https://github.com/suzhilong/suzhilong.github.io.git/2020/06/01/LeetcodeDaily_June/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Leetcode每日一题 - 2020年六月 | SOUSIC</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="SOUSIC" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SOUSIC</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">哈库呐玛塔塔</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/suzhilong/suzhilong.github.io.git/2020/06/01/LeetcodeDaily_June/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Su Zhilong">
      <meta itemprop="description" content="I will always be with you">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SOUSIC">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Leetcode每日一题 - 2020年六月
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-01 16:00:00" itemprop="dateCreated datePublished" datetime="2020-06-01T16:00:00+08:00">2020-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-17 15:39:58" itemprop="dateModified" datetime="2020-08-17T15:39:58+08:00">2020-08-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/06/01/LeetcodeDaily_June/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/01/LeetcodeDaily_June/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>58k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>53 分钟</span>
            </span>
            <div class="post-description">6月份每日一题</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="6月1日-1431-拥有最多糖果的孩子（简单）"><a href="#6月1日-1431-拥有最多糖果的孩子（简单）" class="headerlink" title="6月1日 1431. 拥有最多糖果的孩子（简单）"></a>6月1日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/">1431. 拥有最多糖果的孩子（简单）</a></h1><p>给你一个数组 <code>candies</code> 和一个整数 <code>extraCandies</code> ，其中 <code>candies[i]</code> 代表第 <code>i</code> 个孩子拥有的糖果数目。<br>对每一个孩子，检查是否存在一种方案，将额外的 <code>extraCandies</code> 个糖果分配给孩子们之后，此孩子有 <strong>最多</strong> 的糖果。注意，允许有多个孩子同时拥有 <strong>最多</strong> 的糖果数目。<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：candies = [4,2,1,1,2], extraCandies = 1</span><br><span class="line">输出：[true,false,false,false,false] </span><br><span class="line">解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;= candies.length &lt;= 100</span><br><span class="line">1 &lt;= candies[i] &lt;= 100</span><br><span class="line">1 &lt;= extraCandies &lt;= 50</span><br></pre></td></tr></table></figure>
<p>题解：<br>如果采用暴力法，在每个孩子的糖果数上加上extraCandies再与其他孩子比，时间复杂度为O(n2)。<br>可以先找出最大值<code>most</code>，遍历时与<code>most-extraCandies</code>比较，此时只需O(n)。<br>找数组中的最大值可以自己实现，也可以使用STL实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int getMostCandies(vector&lt;int&gt;&amp; candies)&#123;</span><br><span class="line">    int most = 0;</span><br><span class="line">    for(int n:candies)&#123;</span><br><span class="line">        if(n&gt;most)</span><br><span class="line">            most = n;</span><br><span class="line">    &#125;</span><br><span class="line">    return most;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;bool&gt; kidsWithCandies(vector&lt;int&gt;&amp; candies, int extraCandies) &#123;</span><br><span class="line">    int most = getMostCandies(candies);</span><br><span class="line">    vector&lt;bool&gt; isMostCandies(candies.size());</span><br><span class="line">    for(int i=0;i&lt;candies.size();i++)&#123;</span><br><span class="line">        if(most-candies[i]&gt;extraCandies)</span><br><span class="line">            isMostCandies[i] = false;</span><br><span class="line">        else</span><br><span class="line">            isMostCandies[i] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    return isMostCandies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6月2日-剑指Offer面试题64-求1-2-…-n"><a href="#6月2日-剑指Offer面试题64-求1-2-…-n" class="headerlink" title="6月2日 剑指Offer面试题64. 求1+2+…+n"></a>6月2日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指Offer面试题64. 求1+2+…+n</a></h1><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。<br><code>1 &lt;= n &lt;= 10000</code><br>题解：<br>通常实现递归的时候我们都会利用条件判断语句来决定递归的出口，但由于题目的限制我们不能使用条件判断语句，所以我们使用<code>逻辑运算符的短路性质</code>：<br>以逻辑运算符 &amp;&amp; 为例，对于 A &amp;&amp; B 这个表达式，如果 A 表达式返回 False ，那么 A &amp;&amp; B 已经确定为 False ，此时不会去执行表达式 B。同理，对于逻辑运算符 ||， 对于 A || B 这个表达式，如果 A 表达式返回 True ，那么 A || B 已经确定为 True ，此时不会去执行表达式 B。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sumNums(int n) &#123;</span><br><span class="line">    n &amp;&amp; (n += sumNums(n-1));</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6月3日-837-新21点（中等）"><a href="#6月3日-837-新21点（中等）" class="headerlink" title="6月3日 837. 新21点（中等）"></a>6月3日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/new-21-game/">837. 新21点（中等）</a></h1><p>爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：<br>爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。<br>当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：N = 21, K = 17, W = 10</span><br><span class="line">输出：0.73278</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= K &lt;= N &lt;= 10000</span><br><span class="line">1 &lt;= W &lt;= 10000</span><br></pre></td></tr></table></figure>
<p>题解：<br><code>dp[x]</code>为她已经获得的分数为x时，能获胜的概率。  </p>
<ul>
<li><code>dp[x] = (dp[x+1]+dp[x+2]+dp[x+3]...+dp[x+W])/W</code>  </li>
<li><code>dp[x-1] = (dp[x]+dp[x+1]+dp[x+2]...+dp[x-1+W])/W</code></li>
<li><code>dp[x-1]-dp[x] = (dp[x]-dp[x-1+W])/W</code></li>
</ul>
<p>最后公式为：</p>
<ul>
<li><code>dp[x] = x &lt;= N ? 1 : 0</code>&amp;emsp;&amp;emsp;K &lt;&#x3D; x &lt; K+W</li>
<li><code>dp[K-1] = (dp[K]+dp[K+1]+dp[K+2]...+dp[K-1+W])/W</code></li>
<li><code>dp[x-1] = dp[x] + (dp[x]-dp[x+W])/W</code>&amp;emsp;&amp;emsp;0 &lt;&#x3D; x &lt; K-1</li>
</ul>
<p>如果不求<code>dp[x]</code>与<code>dp[x-1]</code>的状态转移方程，可以用概率和的状态转移方程代替：</p>
<ul>
<li><code>sumOfW[x] = sumOfW[x+1] - dp[x+W] + dp[x]</code></li>
</ul>
<p>因为抽取点数机会都是均等的，她能抽取的面值在[1,W]之间，所以将概率之和平均一下就是dp[x]的概率。<br>她可能达到的最大牌面是K-1+W，而一开始她的牌面是0，所以我们用一个长度为K+W的dp数组来保存她在所有面值下的胜率。<br>dp[0]就是最开始爱丽丝还没有抽牌时的胜率。</p>
<p>使用dp状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">double new21Game(int N, int K, int W) &#123;</span><br><span class="line">    if(K==0)</span><br><span class="line">        return 1.0;</span><br><span class="line">    vector&lt;double&gt; dp(K + W);</span><br><span class="line">    double sumOfW = 0;</span><br><span class="line">    for (int i = K; i &lt; K + W;i++)&#123;</span><br><span class="line">        dp[i] = i &lt;= N ? 1.0 : 0.0;</span><br><span class="line">        sumOfW += dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[K - 1] = sumOfW / W;</span><br><span class="line">    for (int i = K - 2; i &gt;= 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = dp[i + 1] + (dp[i + 1] - dp[i +1 + W]) / W;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用概率和状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">double new21Game(int N, int K, int W) &#123;</span><br><span class="line">    vector&lt;double&gt; dp(K + W + 1);</span><br><span class="line">    double sumOfW = 0;</span><br><span class="line">    for (int i = K; i &lt; K + W;i++)&#123;</span><br><span class="line">        //不能抽牌时，超过N为0，不超过N为1</span><br><span class="line">        dp[i] = i &lt;= N ? 1 : 0;</span><br><span class="line">        sumOfW += dp[i];//为了方便求sum(dp[x+1]...dp[x+W])</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = K - 1; i &gt;= 0;i--)&#123;</span><br><span class="line">        //使用分析中的公式</span><br><span class="line">        dp[i] = sumOfW / W;</span><br><span class="line">        sumOfW = sumOfW - dp[i + W] + dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="6月4日-238-除自身以外数组的乘积（中等）"><a href="#6月4日-238-除自身以外数组的乘积（中等）" class="headerlink" title="6月4日 238. 除自身以外数组的乘积（中等）"></a>6月4日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积（中等）</a></h1><p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。<br>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong> 题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。<br><strong>说明:</strong> 请不要使用除法（数组中有0时失效），且在 O(n) 时间复杂度内完成此题。</p>
<p>题解：</p>
<ul>
<li>时间复杂度O(N)，空间复杂度O(N)的方法：<br>利用左侧所有数字的乘积和右侧所有数字的乘积相乘得到：通过两次遍历（从前向后，从后向前）得到两个乘积表：<br><code>productOfLeft(n)</code>和<code>productOfRight(n)</code><br><code>productOfLeft(i) = productOfLeft[i-1] * nums[i-1]</code>表示<code>nums[i]</code>左边所有数的乘积，其中<code>productOfLeft(0)=1</code>；<br><code>productOfRight(i) = productOfRight[i+1] * nums[i+1]</code>表示<code>nums[i]</code>右边所有数的乘积，其中<code>productOfLeft(n-1)=1</code>。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; productOfLeft(n,0), productOfRight(n,0), output(n,0);</span><br><span class="line">    </span><br><span class="line">    productOfLeft[0] = 1;</span><br><span class="line">    for(int i=1;i&lt;n;i++)</span><br><span class="line">        productOfLeft[i] = productOfLeft[i-1] * nums[i-1];</span><br><span class="line">    </span><br><span class="line">    productOfRight[n-1] = 1;</span><br><span class="line">    for(int i = n-2;i&gt;=0;i--)</span><br><span class="line">        productOfRight[i] = productOfRight[i+1] * nums[i+1];</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i&lt;n;i++)</span><br><span class="line">        output[i] = productOfLeft[i] * productOfRight[i];</span><br><span class="line"></span><br><span class="line">    return output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>时间复杂度O(N)，空间复杂度O(1)的方法，这是对上面方法的优化：<br>1）把<code>productOfLeft(n)</code>存放都<code>output(n)</code>中（输出数组不算占用空间）<br>2）用一个<code>int</code>来代替<code>productOfRight(n)</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; output(n,0);</span><br><span class="line">    </span><br><span class="line">    output[0] = 1;</span><br><span class="line">    for(int i=1;i&lt;n;i++)</span><br><span class="line">        output[i] = output[i-1] * nums[i-1];</span><br><span class="line">    </span><br><span class="line">    int productOfRight = 1;</span><br><span class="line">    for(int i = n-1;i&gt;=0;i--)&#123;</span><br><span class="line">        output[i] = output[i] * productOfRight;</span><br><span class="line">        productOfRight *= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="6月5日-剑指Offer面试题29-顺时针打印矩阵（简单）"><a href="#6月5日-剑指Offer面试题29-顺时针打印矩阵（简单）" class="headerlink" title="6月5日 剑指Offer面试题29. 顺时针打印矩阵（简单）"></a>6月5日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指Offer面试题29. 顺时针打印矩阵（简单）</a></h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>
<p>题解：<br>顺时针访问矩阵共有4个遍历方向，依次循环直到全部访问：1）从左到右；2）从上到下；3）从右到左；4）从下到上。<br>关键是方向改变的判定条件。</p>
<p>可以设置一个hasVisited[row][col]数组来不标记访问过的元素。这需要这样的话空间复杂度为O(row*col)。</p>
<p>也可以使用4个int分别表示上下左右的访问边界，每次变换方向，就把该行&#x2F;列的边界向里面缩一行。</p>
<p>第二种方法的代码：<br>时间复杂度O(row*col)：其中 row 和 col 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。<br>空间复杂度：O(1)。除了输出数组以外，只需要4个int来表示边界。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    if(matrix.empty())</span><br><span class="line">        return result;</span><br><span class="line">    int upWall = 0,downWall = matrix.size()-1,leftWall = 0,rightWall = matrix[0].size()-1;</span><br><span class="line">    //1 L To R; 2 Up To D; 3R To L; 4 D To Up</span><br><span class="line">    int dir = 1;</span><br><span class="line">    int row = 0, col = 0;</span><br><span class="line">    while(upWall&lt;=downWall &amp;&amp; leftWall&lt;=rightWall)&#123;</span><br><span class="line">        result.push_back(matrix[row][col]);</span><br><span class="line">        if(dir==1)&#123;//从左到右</span><br><span class="line">            if(col!=rightWall)</span><br><span class="line">                col++;</span><br><span class="line">            else&#123;</span><br><span class="line">                row++;</span><br><span class="line">                upWall++;</span><br><span class="line">                dir = 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(dir==2)&#123;//从上到下</span><br><span class="line">            if(row!=downWall)</span><br><span class="line">                row++;</span><br><span class="line">            else&#123;</span><br><span class="line">                col--;</span><br><span class="line">                rightWall--;</span><br><span class="line">                dir = 3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(dir==3)&#123;//从右到左</span><br><span class="line">            if(col!=leftWall)</span><br><span class="line">                col--;</span><br><span class="line">            else&#123;</span><br><span class="line">                row--;</span><br><span class="line">                downWall--;</span><br><span class="line">                dir = 4;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;//从下到上</span><br><span class="line">            if(row!=upWall)</span><br><span class="line">                row--;</span><br><span class="line">            else&#123;</span><br><span class="line">                col++;</span><br><span class="line">                leftWall++;</span><br><span class="line">                dir = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6月6日-128-最长连续序列（困难）"><a href="#6月6日-128-最长连续序列（困难）" class="headerlink" title="6月6日 128. 最长连续序列（困难）"></a>6月6日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列（困难）</a></h1><p>给定一个未排序的整数数组，找出最长连续序列的长度。<br>要求算法的时间复杂度为 O(n)。<br>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [100, 4, 200, 1, 3, 2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<ol>
<li>暴力枚举。最外层枚举每一个元素O(n)；每个数要找它的前一个和后一个连续数O(n)；在数组中定位一个元素，暴力法O(n)，map、set这些红黑树实现的O（lgn），哈希表O(1)。所以纯暴力法时间复杂度O(n3)，最优也是用哈希表的O(n2)。</li>
<li>排序。时间复杂度为O(n*lgn)。虽然不满足要求，但是提交能过。<br>排序后用双指针，遍历一遍O(n)。（去重可以用stl库的unique函数，这里直接设置一个重复计数器eqNums，最后减掉重复数即可）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    if(nums.size()==0)</span><br><span class="line">        return 0;</span><br><span class="line">    sort(nums.begin(),nums.end());</span><br><span class="line">    int idxL = 0, idxR = 0, maxSub = 1, eqNums = 0;</span><br><span class="line">    for(int i = 1;i&lt;nums.size();i++)&#123;</span><br><span class="line">        if(nums[i]==nums[i-1])&#123;</span><br><span class="line">            idxR++;</span><br><span class="line">            eqNums++;</span><br><span class="line">        &#125;else if(nums[i]==nums[i-1]+1)&#123;</span><br><span class="line">            idxR++;</span><br><span class="line">            maxSub = max(maxSub,idxR-idxL+1-eqNums);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            maxSub = max(maxSub,idxR-idxL+1-eqNums);</span><br><span class="line">            idxL = i;</span><br><span class="line">            idxR = i;</span><br><span class="line">            eqNums = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxSub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用哈希表(unordered_set)一遍遍历O(n)。在进入while循环，以当前数字为首增加currentSub时，先在哈希表中寻找前一位数字是否存在。只有前一位不存在，才开始以当前数字为首扩充子序列。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    unordered_set&lt;int&gt; num_set;</span><br><span class="line">    for (const int&amp; num : nums) &#123;</span><br><span class="line">        num_set.insert(num);</span><br><span class="line">    &#125;</span><br><span class="line">    int maxSub = 0;</span><br><span class="line">    for (const int&amp; num : num_set) &#123;</span><br><span class="line">        if (!num_set.count(num - 1)) &#123;</span><br><span class="line">            int currentNum = num;</span><br><span class="line">            int currentSub = 1;</span><br><span class="line"></span><br><span class="line">            while (num_set.count(currentNum + 1)) &#123;</span><br><span class="line">                currentNum += 1;</span><br><span class="line">                currentSub += 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxSub = max(maxSub, currentSub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxSub;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>并查集<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av68236186/">(视频讲解)</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/93647900">什么是并查集</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/cbing-cha-ji-xie-fa-dai-ma-ji-duan-by-leck/">代码：</a><br>初始化的时候先把数组里每个元素初始化为他的下一个数；<br>并的时候找他能到达的最远的数字就可以了。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;int,int&gt; a;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    return a.count(x)?a[x]=find(a[x]):x;</span><br><span class="line">&#125;</span><br><span class="line">int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    for(auto i:nums)</span><br><span class="line">        a[i]=i+1;</span><br><span class="line">    int maxSub=0;</span><br><span class="line">    for(auto i:nums)&#123;</span><br><span class="line">        int y=find(i+1);</span><br><span class="line">        maxSub=max(maxSub,y-i);</span><br><span class="line">    &#125;</span><br><span class="line">    return maxSub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="6月7日-126-单词接龙-II（困难）"><a href="#6月7日-126-单词接龙-II（困难）" class="headerlink" title="6月7日 126. 单词接龙 II（困难）"></a>6月7日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder-ii/">126. 单词接龙 II（困难）</a></h1><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：<br>每次转换只能改变一个字母；转换过程中的中间单词必须是字典中的单词。<br><strong>说明:</strong><br>如果不存在这样的转换序列，返回一个空列表。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。<br>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">输出: []</span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<ol>
<li><p>回溯算法。先建图，然后找出所有路径，然后再从所有路径中找出最短路径。<br><strong>建图</strong>时间复杂度：建图需要外层枚举O(n)，里层遍历O(n)，两个单词之间的比较O(m)（m为单词的长度）。所以时间复杂度为O(n2*m)。<br>但是在回溯算法找路径时，时间会随字典中的单词数成指数增长。<br>下面代码能通过19&#x2F;39，最后超时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">bool isConnection(string word1, string word2)&#123;</span><br><span class="line">    int diff = 0;</span><br><span class="line">    for (int i = 0; i &lt; word1.size() &amp;&amp; diff&lt;=1 ;i++)&#123;</span><br><span class="line">        if(word1[i]!=word2[i])</span><br><span class="line">            diff++;</span><br><span class="line">    &#125;</span><br><span class="line">    return diff == 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; buildGraphic(vector&lt;string&gt;&amp; wordList)&#123;</span><br><span class="line">    int N = wordList.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graphic(N);</span><br><span class="line">    for (int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        string curWord = wordList[i];</span><br><span class="line">        for (int j = 0; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            string nextWord = wordList[j];</span><br><span class="line">            if (isConnection(curWord,nextWord))</span><br><span class="line">                graphic[i].push_back(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(auto g:graphic)&#123;</span><br><span class="line">        for(int n:g)</span><br><span class="line">            cout &lt;&lt; n &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;build graphic done&quot; &lt;&lt; endl;</span><br><span class="line">    return graphic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backTracking(vector&lt;string&gt; &amp;wordList, vector&lt;vector&lt;int&gt; &gt; &amp;graphic, vector&lt;bool&gt; &amp;hasVisted, vector&lt;string&gt; &amp;preWord, vector&lt;vector&lt;string&gt; &gt; &amp;result, string endWord, int current)</span><br><span class="line">&#123;</span><br><span class="line">    if (wordList[current] == endWord)</span><br><span class="line">    &#123;</span><br><span class="line">        result.push_back(preWord);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int next : graphic[current])&#123;</span><br><span class="line">        if(hasVisted[next])</span><br><span class="line">            continue;</span><br><span class="line">        preWord.push_back(wordList[next]);</span><br><span class="line">        hasVisted[next] = true;</span><br><span class="line">        backTracking(wordList, graphic, hasVisted, preWord, result, endWord, next);</span><br><span class="line">        hasVisted[next] = false;</span><br><span class="line">        preWord.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;string&gt; &gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt; resultAll;</span><br><span class="line">    vector&lt;string&gt;::iterator it = find(wordList.begin(), wordList.end(), endWord);</span><br><span class="line">    if(it==wordList.end())//wordList中没有endWord</span><br><span class="line">        return resultAll;</span><br><span class="line">    wordList.push_back(beginWord);</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graphic = buildGraphic(wordList);</span><br><span class="line"></span><br><span class="line">    vector&lt;bool&gt; hasVisted(wordList.size(), false);</span><br><span class="line">    hasVisted[wordList.size() - 1] = true;//beginWord</span><br><span class="line">    vector&lt;string&gt; preWord;</span><br><span class="line">    preWord.push_back(beginWord);</span><br><span class="line">    backTracking(wordList, graphic, hasVisted, preWord, resultAll, endWord, wordList.size() - 1);</span><br><span class="line"></span><br><span class="line">    int less = wordList.size();</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt; result;</span><br><span class="line">    for (auto res : resultAll)//找长度最小值</span><br><span class="line">        less = res.size() &lt; less ? res.size() : less;</span><br><span class="line">    for(auto res : resultAll)&#123;//过滤长度最小的</span><br><span class="line">        if(res.size()==less)</span><br><span class="line">            result.push_back(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先通过<strong>BFS</strong>找到最短路径长度（方法可以看我的<a target="_blank" rel="noopener" href="https://suzhilong.github.io/2020/05/25/algorithm/">算法总结：查找&#x2F;BFS 专题中的62题</a>），然后再在方法1回溯的时候加上路径长度条件。<br>虽然减少了一些分支，但是还是最坏情况的时间复杂度还是和1一样，与单词数成指数相关。<br>21&#x2F;39个通过，最后超时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">bool isConnection(string word1, string word2)&#123;</span><br><span class="line">    int diff = 0;</span><br><span class="line">    for (int i = 0; i &lt; word1.size() &amp;&amp; diff&lt;=1 ;i++)&#123;</span><br><span class="line">        if(word1[i]!=word2[i])</span><br><span class="line">            diff++;</span><br><span class="line">    &#125;</span><br><span class="line">    return diff == 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; buildGraphic(vector&lt;string&gt;&amp; wordList)&#123;</span><br><span class="line">    int N = wordList.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graphic(N);</span><br><span class="line">    for (int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        string curWord = wordList[i];</span><br><span class="line">        for (int j = 0; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            string nextWord = wordList[j];</span><br><span class="line">            if (isConnection(curWord,nextWord))</span><br><span class="line">                graphic[i].push_back(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return graphic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getShortestPath(vector&lt;string&gt; &amp;wordList, vector&lt;vector&lt;int&gt; &gt; &amp;graphic, string endWord)&#123;</span><br><span class="line">    int N = graphic.size();</span><br><span class="line">    vector&lt;bool&gt; hasVisited(N, false);</span><br><span class="line">    hasVisited[N - 1] = true;</span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    que.push(N - 1);//beginWord</span><br><span class="line">    int shortestPath = 1;</span><br><span class="line">    while (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        shortestPath++;</span><br><span class="line">        int size = que.size();</span><br><span class="line">        while(size-- &gt; 0)&#123;</span><br><span class="line">            int current = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            for(int next : graphic[current])&#123;</span><br><span class="line">                if(wordList[next]==endWord)</span><br><span class="line">                    return shortestPath;</span><br><span class="line">                if(hasVisited[next])</span><br><span class="line">                    continue;</span><br><span class="line">                hasVisited[next] = true;</span><br><span class="line">                que.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backTracking(vector&lt;string&gt; &amp;wordList, vector&lt;vector&lt;int&gt; &gt; &amp;graphic, vector&lt;bool&gt; &amp;hasVisted, vector&lt;string&gt; &amp;preWord, vector&lt;vector&lt;string&gt; &gt; &amp;result, string endWord, int current, int curPath, int shortestPath)</span><br><span class="line">&#123;</span><br><span class="line">    if(curPath&gt;shortestPath)</span><br><span class="line">        return;</span><br><span class="line">    if (wordList[current] == endWord)</span><br><span class="line">    &#123;</span><br><span class="line">        result.push_back(preWord);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int next : graphic[current])&#123;</span><br><span class="line">        if(hasVisted[next])</span><br><span class="line">            continue;</span><br><span class="line">        preWord.push_back(wordList[next]);</span><br><span class="line">        hasVisted[next] = true;</span><br><span class="line">        backTracking(wordList, graphic, hasVisted, preWord, result, endWord, next, curPath+1, shortestPath);</span><br><span class="line">        hasVisted[next] = false;</span><br><span class="line">        preWord.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;string&gt; &gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt; result;</span><br><span class="line">    vector&lt;string&gt;::iterator it = find(wordList.begin(), wordList.end(), endWord);</span><br><span class="line">    if(it==wordList.end())//wordList中没有endWord</span><br><span class="line">        return result;</span><br><span class="line">    wordList.push_back(beginWord);</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graphic = buildGraphic(wordList);</span><br><span class="line"></span><br><span class="line">    int shortestPath = getShortestPath(wordList, graphic, endWord);</span><br><span class="line"></span><br><span class="line">    vector&lt;bool&gt; hasVisted(wordList.size(), false);</span><br><span class="line">    hasVisted[wordList.size() - 1] = true;//beginWord</span><br><span class="line">    vector&lt;string&gt; preWord;</span><br><span class="line">    preWord.push_back(beginWord);</span><br><span class="line">    backTracking(wordList, graphic, hasVisted, preWord, result, endWord, wordList.size() - 1, 1, shortestPath);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>反向BFS建图，从endWord开始向上BFS，同时记录每个结点的父结点。再从beginWord开始回溯。<br>（代码略）</p>
</li>
<li><p>双向BFS建图。<br>使用<code>unordered_map&lt;string, vector&lt;string&gt; &gt; graphic</code>来记录单词的子结点，<code>string</code>是wordList中的单词，<code>vector&lt;string&gt;</code>是可以与<code>string</code>连接的子结点（与这个<code>string</code>只有一个字母之差且存在与字典中的集合）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt; &gt; result;</span><br><span class="line"></span><br><span class="line">bool isConnection(string word1, string word2)&#123;</span><br><span class="line">    int diff = 0;</span><br><span class="line">    for (int i = 0; i &lt; word1.size() &amp;&amp; diff&lt;=1 ;i++)&#123;</span><br><span class="line">        if(word1[i]!=word2[i])</span><br><span class="line">            diff++;</span><br><span class="line">    &#125;</span><br><span class="line">    return diff == 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;string, vector&lt;string&gt; &gt; buildGraphic(vector&lt;string&gt;&amp; wordList, string beginWord, string endWord)&#123;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; graphic; //存储string能连接到的下一层结点</span><br><span class="line">    unordered_set&lt;string&gt; dict(wordList.begin(), wordList.end());</span><br><span class="line">    unordered_set&lt;string&gt; beginToEnd&#123;beginWord&#125;;</span><br><span class="line">    unordered_set&lt;string&gt; endToBegin&#123;endWord&#125;;</span><br><span class="line">    bool findShortest = false; //是否找到最短序列标志,</span><br><span class="line">    bool dirction = 0; //方向标志。0:begin to end   1:end to begin</span><br><span class="line">    while(!beginToEnd.empty())&#123;</span><br><span class="line">        unordered_set&lt;string&gt; nextLayer;</span><br><span class="line">        for (string s : beginToEnd) //把图里已经有的从list中删除</span><br><span class="line">            dict.erase(s);</span><br><span class="line">        for(string curStr:beginToEnd)&#123;//建立下一层连接</span><br><span class="line">            for(string nextStr:dict)&#123;</span><br><span class="line">                if(isConnection(curStr,nextStr))&#123;</span><br><span class="line">                    if(endToBegin.find(nextStr) != endToBegin.end())//双边遍历碰到了</span><br><span class="line">                        findShortest = true;</span><br><span class="line">                    else</span><br><span class="line">                        nextLayer.insert(nextStr);</span><br><span class="line">                    dirction ? graphic[nextStr].push_back(curStr) : graphic[curStr].push_back(nextStr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(findShortest)</span><br><span class="line">            break;</span><br><span class="line">        if(nextLayer.size()&lt;=endToBegin.size())</span><br><span class="line">            beginToEnd = nextLayer;</span><br><span class="line">        else&#123;</span><br><span class="line">            beginToEnd = endToBegin;</span><br><span class="line">            endToBegin = nextLayer;</span><br><span class="line">            dirction = !dirction;//end和begin反转，方向标志也要反转</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return graphic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backTracking(unordered_map&lt;string, vector&lt;string&gt; &gt; &amp;graphic, vector&lt;string&gt;&amp; preWords, string beginWord, string endWord)</span><br><span class="line">&#123;</span><br><span class="line">    if (beginWord == endWord)</span><br><span class="line">    &#123;</span><br><span class="line">        result.push_back(preWords);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(graphic.find(beginWord) == graphic.end())</span><br><span class="line">        return;</span><br><span class="line">    for(string str:graphic[beginWord])&#123;</span><br><span class="line">        preWords.push_back(str);</span><br><span class="line">        backTracking(graphic, preWords, str, endWord);</span><br><span class="line">        preWords.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;string&gt; &gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">    vector&lt;string&gt;::iterator it = find(wordList.begin(), wordList.end(), endWord);</span><br><span class="line">    if(it==wordList.end())//wordList中没有endWord</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt; &gt; graphic = buildGraphic(wordList, beginWord, endWord);</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; preWords = &#123;beginWord&#125;;</span><br><span class="line"></span><br><span class="line">    backTracking(graphic, preWords, beginWord, endWord);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<br>建图需要O(n^2)。建图时比较两个单词是否可以连接需要O(c)，c为单词的长度。普通BFS时间复杂度为O(n2)。<br>回溯需要O(2^m)，m为建好的图中的单词数。<br>普通BFS建图中单词数m&#x3D;n，双向BFS建图可以大大减少图中的单词数。</p>
</li>
</ol>
<h1 id="6月8日-990-等式方程的可满足性（中等）"><a href="#6月8日-990-等式方程的可满足性（中等）" class="headerlink" title="6月8日 990. 等式方程的可满足性（中等）"></a>6月8日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">990. 等式方程的可满足性（中等）</a></h1><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：”a&#x3D;&#x3D;b” 或 “a!&#x3D;b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p>
<p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a==b&quot;,&quot;b!=a&quot;]</span><br><span class="line">输出：false</span><br><span class="line">解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：[&quot;b==a&quot;,&quot;a==b&quot;]</span><br><span class="line">输入：true</span><br><span class="line">解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p>示例 5：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= equations.length &lt;= 500</span><br><span class="line">equations[i].length == 4</span><br><span class="line">equations[i][0] 和 equations[i][3] 是小写字母</span><br><span class="line">equations[i][1] 要么是 &#x27;=&#x27;，要么是 &#x27;!&#x27;</span><br><span class="line">equations[i][2] 是 &#x27;=&#x27;</span><br></pre></td></tr></table></figure>

<p>题解：<br>这题需要用到<strong>并查集</strong>，相关专题可以查看我的<a target="_blank" rel="noopener" href="https://suzhilong.github.io/2020/05/25/algorithm/">博客</a>。<br>把相等的左右两边放到一个子集里面，然后看不相等的是否在同一个子集里。如果在同一个子集的两个字母不相等返回<code>false</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; parent;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    UnionFind() &#123;</span><br><span class="line">        parent.resize(26);</span><br><span class="line">        iota(parent.begin(), parent.end(), 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int find(int index) &#123;</span><br><span class="line">        if (index == parent[index]) &#123;</span><br><span class="line">            return index;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[index] = find(parent[index]);</span><br><span class="line">        return parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void unite(int index1, int index2) &#123;</span><br><span class="line">        parent[find(index1)] = find(index2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123;</span><br><span class="line">        UnionFind uf;</span><br><span class="line">        for (const string&amp; str: equations) &#123;</span><br><span class="line">            if (str[1] == &#x27;=&#x27;) &#123;</span><br><span class="line">                int index1 = str[0] - &#x27;a&#x27;;</span><br><span class="line">                int index2 = str[3] - &#x27;a&#x27;;</span><br><span class="line">                uf.unite(index1, index2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (const string&amp; str: equations) &#123;</span><br><span class="line">            if (str[1] == &#x27;!&#x27;) &#123;</span><br><span class="line">                int index1 = str[0] - &#x27;a&#x27;;</span><br><span class="line">                int index2 = str[3] - &#x27;a&#x27;;</span><br><span class="line">                if (uf.find(index1) == uf.find(index2)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="6月9日-剑指Offer面试题46-把数字翻译成字符串（中等）"><a href="#6月9日-剑指Offer面试题46-把数字翻译成字符串（中等）" class="headerlink" title="6月9日 剑指Offer面试题46. 把数字翻译成字符串（中等）"></a>6月9日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指Offer面试题46. 把数字翻译成字符串（中等）</a></h1><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。<br>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= num &lt; 2^31</span><br></pre></td></tr></table></figure>
<p>题解：<br>典型的动态规划题，同类型例题可以看我的<a target="_blank" rel="noopener" href="https://suzhilong.github.io/2020/05/25/algorithm/">算法总结中的动态规划专题</a><br><code>dp[i]</code>表示第 i 位数字之前（含）的不同翻译种数，i&#x3D;[1,n]，dp[0]是为了递推方便初始化的，没有实际意义。<br>有两种情况：</p>
<ul>
<li><code>dp[i] = dp[i-1]</code>前2位中的第一位是为0，如求506的dp[3]时，前一位为0，所以dp[3] &#x3D; dp[2]；前面两位数字大于25，如535，其中35不能翻译为字母，所以dp[3]&#x3D;dp[2]</li>
<li><code>dp[i] = dp[i-1] + dp[i-2]</code>如516，dp[3]&#x3D;dp[2]+dp[1]：516的翻译方法等于5的翻译种数（尾巴添16），加上51的翻译方法种数（尾巴添6）。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int translateNum(int num)&#123;</span><br><span class="line">    string numStr = to_string(num);</span><br><span class="line">    int n = numStr.size();</span><br><span class="line">    vector&lt;int&gt; dp(n + 1);</span><br><span class="line">    dp[0] = 1, dp[1] = 1;//dp[i]表示第i数字之前（含）的不同翻译种数，i=[1,n]，dp[0]是为了递推方便初始化的，没有实际意义</span><br><span class="line">    for (int i = 2; i &lt;= n; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        string pre1num = numStr.substr(i - 2, 1);//看前面2位中的第一位是否为0</span><br><span class="line">        string pre2num = numStr.substr(i - 2, 2);</span><br><span class="line">        dp[i] = (stoi(pre2num) &gt; 25 || stoi(pre1num)==0) ? dp[i - 1] : dp[i - 1] + dp[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度O(n)<br>空间复杂度O(n)。因为只用到前面2个，所以可以优化为O(1)，只用dp[0],dp[1],dp[2]（代码略）。</li>
</ul>
<h1 id="6月10日-回文数（简单）"><a href="#6月10日-回文数（简单）" class="headerlink" title="6月10日 回文数（简单）"></a>6月10日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-number/">回文数（简单）</a></h1><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<ol>
<li><p>将数字转换为字符串，设置双指针<code>idxL</code>和<code>idxR</code>，分别指向字符串的头和尾。两个指针边比较边向中间移动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool isPalindrome(int x) &#123;</span><br><span class="line">    if(x&lt;0)</span><br><span class="line">        return false;</span><br><span class="line">    string numStr = to_string(x);</span><br><span class="line">    int idxL = 0, idxR = numStr.size() - 1;</span><br><span class="line">    while (idxR&gt;idxL)</span><br><span class="line">    &#123;</span><br><span class="line">        if(numStr[idxL]!=numStr[idxR])</span><br><span class="line">            return false;</span><br><span class="line">        else&#123;</span><br><span class="line">            idxL++;</span><br><span class="line">            idxR--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)<br>空间复杂度O(n)<br>n是数字的位数</p>
</li>
<li><p>不转换成字符串。当x位数为偶数时只用看后一半反转后与前一半是否相等；当x位数为奇数时，我们可以通过 revertedNum&#x2F;10 去除处于中位的数字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool isPalindrome(int x) &#123;</span><br><span class="line">    if(x&lt;0 || (x % 10 == 0 &amp;&amp; x != 0))//末尾是0的也不可能是回文</span><br><span class="line">        return false;</span><br><span class="line">    int revertedNum = 0;</span><br><span class="line">    while(x &gt; revertedNum)&#123;//已经到一半了</span><br><span class="line">        revertedNum = revertedNum * 10 + x % 10;</span><br><span class="line">        x /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return x == revertedNum || x == revertedNum / 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="6月11日-739-每日温度（中等）"><a href="#6月11日-739-每日温度（中等）" class="headerlink" title="6月11日 739. 每日温度（中等）"></a>6月11日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度（中等）</a></h1><p>根据每日 <code>气温</code> 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<p>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<ol>
<li><p>纯暴力法（超时）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;</span><br><span class="line">    vector&lt;int&gt; res(T.size(),0);</span><br><span class="line">    for(int i=0;i&lt;T.size();i++)&#123;</span><br><span class="line">        for(int j=i+1;j&lt;T.size();j++)&#123;</span><br><span class="line">            if(T[j]&gt;T[i])&#123;</span><br><span class="line">                res[i] = j-i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n^2)。空间复杂度(1)。</p>
</li>
<li><p>温度数组加暴力。由于温度范围在<code>[30, 100]</code>之内，因此可以维护一个数组<code>tempFirstPos</code>记录每个温度第一次出现的下标。数组<code>tempFirstPos</code>中的元素初始化为<code>n</code>，因为数组的最大索引为<code>n-1</code>。在<strong>反向</strong>遍历温度列表的过程中更新 tempFirstPos 的值。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;</span><br><span class="line">    int n = T.size();</span><br><span class="line">    vector&lt;int&gt; res(n), tempFirstPos(101, n);</span><br><span class="line">    for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        int warmerIndex = n;//最大值为数组长度</span><br><span class="line">        for (int t = T[i] + 1; t &lt;= 100; t++) &#123;</span><br><span class="line">            warmerIndex = min(warmerIndex, tempFirstPos[t]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (warmerIndex != n) &#123;</span><br><span class="line">            res[i] = warmerIndex - i;</span><br><span class="line">        &#125;</span><br><span class="line">        tempFirstPos[T[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n*m)，n是数组长度，m是温度的范围。空间复杂度O(n)。</p>
</li>
<li><p>单调栈。维护一个单调递减的栈，栈中元素为温度值的索引。当前温度比栈顶索引温度低时，直接进栈；当前温度比栈顶索引温度高时，两个索引之间的差就是栈顶索引值所求结果。<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/">视频讲解</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;</span><br><span class="line">    int n = T.size();</span><br><span class="line">    vector&lt;int&gt; res(n,0);</span><br><span class="line">    stack&lt;int&gt; s;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        while (!s.empty() &amp;&amp; T[i] &gt; T[s.top()]) &#123;</span><br><span class="line">            int previousIndex = s.top();</span><br><span class="line">            res[previousIndex] = i - previousIndex;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)。空间复杂度O(n)。</p>
</li>
</ol>
<h1 id="6月12日-15-三数之和"><a href="#6月12日-15-三数之和" class="headerlink" title="6月12日 15. 三数之和"></a>6月12日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h1><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p><strong>注意</strong>：答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>题解：  </p>
<ol>
<li><p>暴力（超时）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    set&lt;vector&lt;int&gt; &gt; resultSet;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">    if (n &lt; 3)</span><br><span class="line">        return result;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = i + 1; j &lt; n; j++)&#123;</span><br><span class="line">            for (int k = j + 1; k &lt; n; k++)&#123;</span><br><span class="line">                if(nums[i]+nums[j]+nums[k]==0)&#123;</span><br><span class="line">                    vector&lt;int&gt; tmp;</span><br><span class="line">                    tmp.push_back(nums[i]);</span><br><span class="line">                    tmp.push_back(nums[j]);</span><br><span class="line">                    tmp.push_back(nums[k]);</span><br><span class="line">                    sort(tmp.begin(), tmp.end());</span><br><span class="line">                    resultSet.insert(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(auto s:resultSet)&#123;</span><br><span class="line">        result.push_back(s);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>311 &#x2F; 313 个通过测试用例<br>时间复杂度O(n^3)，空间复杂度O(1)  </p>
</li>
<li><p>把最里面一层改为二分查找，需要先排序。还是超时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">bool biSearch(int resNum, int &amp;idx, vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">    int idxL = 0, idxR = nums.size()-1;</span><br><span class="line">    int mid = idxR / 2;</span><br><span class="line">    while(idxL &lt;= idxR)&#123;</span><br><span class="line">        if(resNum &gt; nums[mid])&#123;</span><br><span class="line">            idxL = mid + 1;</span><br><span class="line">        &#125;else if(resNum &lt; nums[mid])&#123;</span><br><span class="line">            idxR = mid - 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            idx = mid;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (idxL+idxR)/2;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">    unordered_set&lt;vector&lt;int&gt; &gt; resultSet;</span><br><span class="line">    </span><br><span class="line">    sort(nums.begin(),nums.end());</span><br><span class="line">    if (n &lt; 3 || nums[0] &gt; 0 || nums[n-1] &lt; 0)//全正或全负</span><br><span class="line">        return result;</span><br><span class="line">    if(nums[0] == 0 &amp;&amp; nums[n-1] == 0)&#123;//全是0</span><br><span class="line">        vector&lt;int&gt; tmp0 = &#123;0, 0, 0&#125;;</span><br><span class="line">        result.push_back(tmp0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">            if(j == i)</span><br><span class="line">                continue;</span><br><span class="line">            int resNum = 0 - nums[i] - nums[j];</span><br><span class="line">            int idx = -1;</span><br><span class="line">            if(biSearch(resNum,idx,nums) &amp;&amp; idx != i &amp;&amp; idx != j)&#123;</span><br><span class="line">                vector&lt;int&gt; tmp;</span><br><span class="line">                tmp.push_back(nums[i]);</span><br><span class="line">                tmp.push_back(nums[j]);</span><br><span class="line">                tmp.push_back(nums[idx]);</span><br><span class="line">                sort(tmp.begin(), tmp.end());</span><br><span class="line">                resultSet.insert(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(auto s:resultSet)&#123;</span><br><span class="line">        result.push_back(s);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>313 &#x2F; 313 个通过测试用例<br>时间复杂度O(N^2 * logn)，空间复杂度O(1)</p>
</li>
</ol>
<p>还可以在最里层用一个unordered_set&#x2F;map来查找。可以把时间复杂度降到O(n^2)。但是每次建立unordered_set都需要去掉nums[i] 和 nums[j] 的值，如果有重复，在查重的时候又要增加时间复杂度。</p>
<ol start="3">
<li>双指针。先排序O(nlong)。第一层循环O(n)，第二个数和第三个数是此消彼长的关系。所以<strong>左指针</strong>向右移动时，<strong>右指针</strong>也需要忘左缩进（因为随着第二个数的增加，第三个数必然会减小）。这样时间复杂度就从两层循环O(n^2)减少至只需要一层循环O(n)。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">    </span><br><span class="line">    if (n &lt; 3 || nums[0] &gt; 0 || nums[n-1] &lt; 0)//全正或全负</span><br><span class="line">        return result;</span><br><span class="line">    if(nums[0] == 0 &amp;&amp; nums[n-1] == 0)&#123;//全是0</span><br><span class="line">        vector&lt;int&gt; tmp0 = &#123;0, 0, 0&#125;;</span><br><span class="line">        result.push_back(tmp0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 第一个数循环</span><br><span class="line">    for (int first = 0; first &lt; n; ++first) &#123;</span><br><span class="line">        // 去重</span><br><span class="line">        if (first &gt; 0 &amp;&amp; nums[first] == nums[first - 1]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 第三个数对应的指针初始指向数组的最右端</span><br><span class="line">        int third = n - 1;</span><br><span class="line">        int target = -nums[first];</span><br><span class="line">        // 第二层循环</span><br><span class="line">        for (int second = first + 1; second &lt; n; ++second) &#123;</span><br><span class="line">            if (second &gt; first + 1 &amp;&amp; nums[second] == nums[second - 1]) &#123;// 去重</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 需要保证第二个数指针在第三个数指针的左侧</span><br><span class="line">            while (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;</span><br><span class="line">                --third;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果指针重合，随着第二个数的增加，就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span><br><span class="line">            if (second == third) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[second] + nums[third] == target) &#123;</span><br><span class="line">                result.push_back(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="6月13日-70-爬楼梯（简单）"><a href="#6月13日-70-爬楼梯（简单）" class="headerlink" title="6月13日 70. 爬楼梯（简单）"></a>6月13日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯（简单）</a></h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意</strong>：给定 n 是一个正整数。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>
<p>题解：<br>和6月9日的题一样，典型的dp问题。可以看我的<a target="_blank" rel="noopener" href="https://suzhilong.github.io/2020/05/25/algorithm/">算法总结</a>里的dp专题。</p>
<p>一维dp问题。<code>dp[i] = dp[i-1] + dp[i-2]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int climbStairs(int n) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(n + 1);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    dp[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= n;i++)&#123;</span><br><span class="line">        dp[i] = dp[i - 1] + dp[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)<br>空间复杂度O(n)</p>
<p>空间优化：实际上，只用到了前两个<code>dp[i-1]</code>，<code>dp[i-2]</code>。所以可以只用到3个int，把空间优化为O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int climbStairs(int n) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(3);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    dp[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= n;i++)&#123;</span><br><span class="line">        dp[2] = dp[1] + dp[0];</span><br><span class="line">        dp[0] = dp[1];</span><br><span class="line">        dp[1] = dp[2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第28场双周赛-6-13"><a href="#第28场双周赛-6-13" class="headerlink" title="第28场双周赛 6.13"></a>第28场双周赛 6.13</h1><h2 id="5420-商品折扣后的最终价格（简单）"><a href="#5420-商品折扣后的最终价格（简单）" class="headerlink" title="5420. 商品折扣后的最终价格（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/final-prices-with-a-special-discount-in-a-shop/">5420. 商品折扣后的最终价格（简单）</a></h2><p>给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。<br>商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j &gt; i 且 prices[j] &lt;&#x3D; prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。<br>请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [8,4,6,2,3]</span><br><span class="line">输出：[4,2,4,2,3]</span><br><span class="line">解释：</span><br><span class="line">商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。</span><br><span class="line">商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。</span><br><span class="line">商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。</span><br><span class="line">商品 3 和 4 都没有折扣。</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; finalPrices(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    vector&lt;int&gt; res = prices;</span><br><span class="line">    for (int i = 0; i &lt; prices.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = i + 1; j &lt; prices.size();j++)&#123;</span><br><span class="line">            if(prices[j]&lt;=prices[i])&#123;</span><br><span class="line">                res[i] = prices[i] - prices[j];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5423-找两个和为目标值且不重叠的子数组（中等）"><a href="#5423-找两个和为目标值且不重叠的子数组（中等）" class="headerlink" title="5423. 找两个和为目标值且不重叠的子数组（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subrectangle-queries/">5423. 找两个和为目标值且不重叠的子数组（中等）</a></h2><p>给你一个整数数组 arr 和一个整数值 target 。<br>请你在 arr 中找 两个互不重叠的子数组 且它们的和都等于 target 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。<br>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,2,4,3], target = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：只有两个子数组和为 3 （[3] 和 [3]）。它们的长度和为 2 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [7,3,4,7], target = 7</span><br><span class="line">输出：2</span><br><span class="line">解释：尽管我们有 3 个互不重叠的子数组和为 7 （[7], [3,4] 和 [7]），但我们会选择第一个和第三个子数组，因为它们的长度和 2 是最小值。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [4,3,2,6,2,3,4], target = 6</span><br><span class="line">输出：-1</span><br><span class="line">解释：我们只有一个和为 6 的子数组。</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<ol>
<li>最容易想到的办法就是遍历数组得到所有sum为target的子数组，再从子数组列表中找出不重合的最小的两个子数组。找子数组处理重合的时候要很仔细。（代码略）  </li>
<li>双指针（滑动窗口）。左右指针从右到左移动，同时用一个数组<code>len</code>记录后面的最小子数组。其中，<code>len[i]</code>表示<code>i</code>后面（含i）的最小子数组长度。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int minSumOfLengths(vector&lt;int&gt;&amp; arr, int target) &#123;</span><br><span class="line">    int sum = 0, r = arr.size() - 1, ans = 200000; </span><br><span class="line">    vector&lt;int&gt; len(arr.size() + 1, 200000);//后面子数组的最小长度</span><br><span class="line">    for (int l = r; l &gt;= 0; --l) &#123; //l,r是滑动区间的左右坐标</span><br><span class="line">        sum += arr[l];</span><br><span class="line">        while (sum &gt; target)</span><br><span class="line">            sum -= arr[r--];</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            int cur = r - l + 1; //子数组长度</span><br><span class="line">            ans = min(ans, cur + len[r + 1]); //子数组长度 + r后面子数组的最小长度</span><br><span class="line">            len[l] = min(len[l + 1], r - l + 1); //更新l后面子数组的最小长度</span><br><span class="line">        &#125;else</span><br><span class="line">            len[l] = len[l + 1]; //更新子数组的最小长度</span><br><span class="line">    &#125;</span><br><span class="line">    return ans == 200000 ? -1 : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5421-安排邮筒（困难）"><a href="#5421-安排邮筒（困难）" class="headerlink" title="5421. 安排邮筒（困难）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/allocate-mailboxes/">5421. 安排邮筒（困难）</a></h2><p>给你一个房屋数组houses 和一个整数 k ，其中 houses[i] 是第 i 栋房子在一条街上的位置，现需要在这条街上安排 k 个邮筒。<br>请你返回每栋房子与离它最近的邮筒之间的距离的 最小 总和。<br>答案保证在 32 位有符号整数范围以内。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [1,4,8,10,20], k = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：将邮筒分别安放在位置 3， 9 和 20 处。</span><br><span class="line">每个房子到最近邮筒的距离和为 |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [2,3,5,12,18], k = 2</span><br><span class="line">输出：9</span><br><span class="line">解释：将邮筒分别安放在位置 3 和 14 处。</span><br><span class="line">每个房子到最近邮筒距离和为 |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [7,4,6,1], k = 1</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [3,6,14,10], k = 4</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n == houses.length</span><br><span class="line">1 &lt;= n &lt;= 100</span><br><span class="line">1 &lt;= houses[i] &lt;= 10^4</span><br><span class="line">1 &lt;= k &lt;= n</span><br><span class="line">数组 houses 中的整数互不相同。</span><br></pre></td></tr></table></figure>

<h1 id="第193场周赛-6-14"><a href="#第193场周赛-6-14" class="headerlink" title="第193场周赛 6.14"></a>第193场周赛 6.14</h1><h2 id="5436-一维数组的动态和（简单）"><a href="#5436-一维数组的动态和（简单）" class="headerlink" title="5436. 一维数组的动态和（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/running-sum-of-1d-array/">5436. 一维数组的动态和（简单）</a></h2><p>题目难度Easy<br>给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] &#x3D; sum(nums[0]…nums[i]) 。</p>
<p>请返回 nums 的动态和。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3,4]<br>输出：[1,3,6,10]<br>解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。<br>示例 2：</p>
<p>输入：nums &#x3D; [1,1,1,1,1]<br>输出：[1,2,3,4,5]<br>解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。<br>示例 3：</p>
<p>输入：nums &#x3D; [3,1,2,10,1]<br>输出：[3,4,6,16,17]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;int&gt; res(nums.size(),0);</span><br><span class="line">    res[0] = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">        res[i] = res[i - 1] + nums[i];</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5437-不同整数的最少数目（Medium）"><a href="#5437-不同整数的最少数目（Medium）" class="headerlink" title="5437. 不同整数的最少数目（Medium）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/least-number-of-unique-integers-after-k-removals/">5437. 不同整数的最少数目（Medium）</a></h2><p>给你一个整数数组 arr 和一个整数 k 。现需要从数组中恰好移除 k 个元素，请找出移除后数组中不同整数的最少数目。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [5,5,4], k = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：移除 1 个 4 ，数组中只剩下 5 一种整数。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [4,3,1,1,3,3,2], k = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：先移除 4、2 ，然后再移除两个 1 中的任意 1 个或者三个 3 中的任意 1 个，最后剩下 1 和 3 两种整数。</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bool cmpByValue(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123;//注意！这个函数要在类外面定义</span><br><span class="line">    return a[1] &gt; b[1];//value降序</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findLeastNumOfUniqueInts(vector&lt;int&gt;&amp; arr, int k) &#123;</span><br><span class="line">    map&lt;int, int&gt; numMap;</span><br><span class="line">    for(int n:arr)&#123;</span><br><span class="line">        if(numMap.count(n) == 0)</span><br><span class="line">            numMap.insert(pair&lt;int, int&gt;(n, 1));</span><br><span class="line">        else</span><br><span class="line">            numMap[n]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; numMapV;</span><br><span class="line">    for (auto m : numMap)</span><br><span class="line">        numMapV.push_back(&#123;m.first, m.second&#125;);</span><br><span class="line"></span><br><span class="line">    sort(numMapV.begin(), numMapV.end(), cmpByValue);</span><br><span class="line"></span><br><span class="line">    while (k &gt; 0 &amp;&amp; numMap.size() &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; minNum = numMapV.back();</span><br><span class="line">        if (minNum[1] &gt; k)</span><br><span class="line">            return numMap.size();</span><br><span class="line">        else if(minNum[1] == k)</span><br><span class="line">            return numMap.size() - 1;</span><br><span class="line">        else&#123;</span><br><span class="line">            k = k - minNum[1];</span><br><span class="line">            numMap.erase(minNum[0]);</span><br><span class="line">            numMapV.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return numMap.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5438-制作-m-束花所需的最少天数（Medium）"><a href="#5438-制作-m-束花所需的最少天数（Medium）" class="headerlink" title="5438. 制作 m 束花所需的最少天数（Medium）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/">5438. 制作 m 束花所需的最少天数（Medium）</a></h2><p>给你一个整数数组 bloomDay，以及两个整数 m 和 k 。<br>现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花。<br>花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。<br>请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay = [1,10,3,10,2], m = 3, k = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。</span><br><span class="line">现在需要制作 3 束花，每束只需要 1 朵。</span><br><span class="line">1 天后：[x, _, _, _, _]   // 只能制作 1 束花</span><br><span class="line">2 天后：[x, _, _, _, x]   // 只能制作 2 束花</span><br><span class="line">3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay = [1,10,3,10,2], m = 3, k = 2</span><br><span class="line">输出：-1</span><br><span class="line">解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3</span><br><span class="line">输出：12</span><br><span class="line">解释：要制作 2 束花，每束需要 3 朵。</span><br><span class="line">花园在 7 天后和 12 天后的情况如下：</span><br><span class="line">7 天后：[x, x, x, x, _, x, x]</span><br><span class="line">可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。</span><br><span class="line">12 天后：[x, x, x, x, x, x, x]</span><br><span class="line">显然，我们可以用不同的方式制作两束花。</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay = [1000000000,1000000000], m = 1, k = 1</span><br><span class="line">输出：1000000000</span><br><span class="line">解释：需要等 1000000000 天才能采到花来制作花束</span><br></pre></td></tr></table></figure>
<p>示例 5：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>
<p>题解：<br>（待补充）</p>
<h2 id="5188-树节点的第-K-个祖先（困难）"><a href="#5188-树节点的第-K-个祖先（困难）" class="headerlink" title="5188. 树节点的第 K 个祖先（困难）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-ancestor-of-a-tree-node/">5188. 树节点的第 K 个祖先（困难）</a></h2><p>给你一棵树，树上有 n 个节点，按从 0 到 n-1 编号。树以父节点数组的形式给出，其中 parent[i] 是节点 i 的父节点。树的根节点是编号为 0 的节点。<br>请你设计并实现 getKthAncestor(int node, int k) 函数，函数返回节点 node 的第 k 个祖先节点。如果不存在这样的祖先节点，返回 -1 。<br>树节点的第 k 个祖先节点是从该节点到根节点路径上的第 k 个节点。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;TreeAncestor&quot;,&quot;getKthAncestor&quot;,&quot;getKthAncestor&quot;,&quot;getKthAncestor&quot;]</span><br><span class="line">[[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,1,0,-1]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);</span><br><span class="line"></span><br><span class="line">treeAncestor.getKthAncestor(3, 1);  // 返回 1 ，它是 3 的父节点</span><br><span class="line">treeAncestor.getKthAncestor(5, 2);  // 返回 0 ，它是 5 的祖父节点</span><br><span class="line">treeAncestor.getKthAncestor(6, 3);  // 返回 -1 因为不存在满足要求的祖先节点</span><br></pre></td></tr></table></figure>
<p>题解：<br>（待补充）</p>
<h1 id="6月14日-1300-转变数组后最接近目标值的数组和（中等）"><a href="#6月14日-1300-转变数组后最接近目标值的数组和（中等）" class="headerlink" title="6月14日 1300. 转变数组后最接近目标值的数组和（中等）"></a>6月14日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/">1300. 转变数组后最接近目标值的数组和（中等）</a></h1><p>给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。<br>如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。<br>请注意，答案不一定是 arr 中的数字。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [4,9,3], target = 10</span><br><span class="line">输出：3</span><br><span class="line">解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [2,3,5], target = 10</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [60864,25176,27249,21296,20204], target = 56803</span><br><span class="line">输出：11361</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= arr.length &lt;= 10^4</span><br><span class="line">1 &lt;= arr[i], target &lt;= 10^5</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>其实就是从一个范围中找到一个数。这个范围的下界是0，因为<code>arr[i]</code>&gt;&#x3D;1，所以sum肯定是&gt;&#x3D;1的。上界是<code>arr</code>中的最大值<code>maxNum</code>，因为当<code>value &gt; maxNum</code>时，<code>arr</code>中的元素不会变，得到的sum是一样的。所以就是从<code>[0, maxNum]</code>中找到value。从排序的数组中查找，用<strong>二分查找</strong>来减少时间复杂度。初始条件 <code>l=0, r=maxNum, mid=(l+r)/2</code>， 判定条件是：当<code>sum(mid)-target &gt; 0</code>（value&#x3D;mid）时，值偏大，<code>r = mid - 1</code>；当<code>sum(mid)-target &lt; 0</code>时，值偏小，<code>l = mid + 1</code>；当<code>sum(mid)-target == 0</code>时mid为所寻找的值。循环条件为<code>l&lt;=r &amp;&amp; sumArr != target</code>。循环中需要用一个minAbs来保存最接近的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">int getSum(vector&lt;int&gt; arr, int value)&#123;</span><br><span class="line">    int sumArr = 0;</span><br><span class="line">    for (int i = 0; i &lt; arr.size();i++)&#123;</span><br><span class="line">        if(arr[i]&lt;=value)</span><br><span class="line">            sumArr += arr[i];</span><br><span class="line">        else</span><br><span class="line">            sumArr += value;</span><br><span class="line">    &#125;</span><br><span class="line">    return sumArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findBestValue(vector&lt;int&gt;&amp; arr, int target) &#123;</span><br><span class="line">    int maxNum = 0, sumArr = 0;</span><br><span class="line">    for (int a : arr)&#123;</span><br><span class="line">        sumArr += a;</span><br><span class="line">        maxNum = max(maxNum, a);</span><br><span class="line">    &#125;</span><br><span class="line">    if(sumArr&lt;=target)</span><br><span class="line">        return maxNum;</span><br><span class="line"></span><br><span class="line">    int l = 0, r = maxNum, mid;</span><br><span class="line">    int minAbs = sumArr - target &gt; 0 ? sumArr - target : target - sumArr;</span><br><span class="line">    int value = maxNum;</span><br><span class="line">    int diff, abs;</span><br><span class="line">    while (l &lt;= r &amp;&amp; sumArr != target)&#123;</span><br><span class="line">        mid = (l + r) / 2;</span><br><span class="line">        sumArr = getSum(arr, mid);//看value==mid后的和</span><br><span class="line">        diff = sumArr - target;</span><br><span class="line">        if(diff==0)&#123;//找到其中一个</span><br><span class="line">            value = min(value, mid);</span><br><span class="line">        &#125;else if(diff&gt;0)&#123;</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;//diff&lt;0</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        abs = diff &gt; 0 ? diff : -diff;</span><br><span class="line">        if(abs&lt;minAbs || (abs==minAbs &amp;&amp; mid&lt;value))&#123;</span><br><span class="line">            value = mid;</span><br><span class="line">            minAbs = abs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(logc*n)，c为最大值maxNum，n为数组长度。<br>空间复杂度：O(1)</p>
</li>
<li><p>先排序，再从头遍历，当<code>arr[i] &gt; (target-preSum[i]) / (n-i)</code>时，就是不能再增大了，返回<strong>剩余的平均值</strong>。<code>preSum[i]</code>是 <code>arr[i]</code> 之前的所有数的和。注意小数部分的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int findBestValue(vector&lt;int&gt;&amp; arr, int target)&#123;</span><br><span class="line">    int maxNum = 0, sumArr = 0;</span><br><span class="line">    for (int a : arr)&#123;</span><br><span class="line">        sumArr += a;</span><br><span class="line">        maxNum = max(maxNum, a);</span><br><span class="line">    &#125;</span><br><span class="line">    if(sumArr&lt;=target)</span><br><span class="line">        return maxNum;</span><br><span class="line"></span><br><span class="line">    sort(arr.begin(), arr.end());</span><br><span class="line">    </span><br><span class="line">    int preSum = 0, n = arr.size();</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int x = (target - preSum) / (n - i);</span><br><span class="line">        if (x &lt; arr[i]) &#123;</span><br><span class="line">            double t = ((double)(target - preSum)) / (n - i);</span><br><span class="line">            if (t - x &gt; 0.5) &#123;</span><br><span class="line">                return x + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        preSum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return arr[n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：排序O(nlogn)，遍历O(n)，所以是O(nlogn)。<br>空间复杂度：O(1)</p>
</li>
</ol>
<h1 id="6月15日-14-最长公共前缀（简单）"><a href="#6月15日-14-最长公共前缀（简单）" class="headerlink" title="6月15日 14. 最长公共前缀（简单）"></a>6月15日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀（简单）</a></h1><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有输入只包含小写字母 a-z 。</span><br></pre></td></tr></table></figure>
<p>题解：<br>一位一位比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    bool stop = false;</span><br><span class="line">    for(int i = 0; !stop; i++)&#123;</span><br><span class="line">        char cur = strs[0][i];</span><br><span class="line">        for(string s:strs)&#123;</span><br><span class="line">            if(s.size()==i+1)//有一个str已经到最后一位了</span><br><span class="line">                stop = true;</span><br><span class="line">            if(s[i]==cur)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                return res;</span><br><span class="line">        &#125;</span><br><span class="line">        res += cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m*n)，m 是 strs 中最短字符串的长度，n是字符串列表的长度。<br>空间复杂度：O(1)</p>
<h1 id="6月16日-297-二叉树的序列化与反序列化（困难）"><a href="#6月16日-297-二叉树的序列化与反序列化（困难）" class="headerlink" title="6月16日 297. 二叉树的序列化与反序列化（困难）"></a>6月16日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化（困难）</a></h1><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。<br>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>示例: <br><img src="https://i.loli.net/2020/06/16/DwJHZvu7SbTaBkC.png" alt="示例"></p>
<p><strong>提示</strong>: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p><strong>说明</strong>: 不要使用类的成员 &#x2F; 全局 &#x2F; 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p>
<p>树的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>按照示例<strong>层序遍历</strong>，即<strong>BFS</strong>。可以使用队列来序列化，也可以使用递归。  </p>
</li>
<li><p><strong>先序遍历</strong>，即<strong>DFS</strong>。使用栈来系列化，也可以使用递归。</p>
</li>
</ol>
<h1 id="6月17日-1014-最佳观光组合（中等）"><a href="#6月17日-1014-最佳观光组合（中等）" class="headerlink" title="6月17日 1014. 最佳观光组合（中等）"></a>6月17日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-sightseeing-pair/">1014. 最佳观光组合（中等）</a></h1><p>给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。<br>一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。<br>返回一对观光景点能取得的最高分。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[8,1,5,2,6]</span><br><span class="line">输出：11</span><br><span class="line">解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>暴力（超时）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">    int maxScore = 0;</span><br><span class="line">    for (int i = 0; i &lt; A.size();i++)&#123;</span><br><span class="line">        for (int j = i + 1; j &lt; A.size();j++)</span><br><span class="line">            maxScore = max(maxScore, A[i] + A[j] + i - j);</span><br><span class="line">    &#125;</span><br><span class="line">    return maxScore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p>
</li>
<li><p>把<code>A[i]+A[j]+i-j</code>分解为两部分：<code>A[i]+i</code> 和 <code>A[j]-j</code>。<code>dpPre[j] = max(dpPre[j-1],A[j-1]+j-1)</code>，表示索引<code>j</code>之前<code>A[i]+i</code>的最大值；<br><code>dp[i] = max(dp[i-1],dpPre[i-1]+A[i]-i)</code>。但是这需要O(n)的空间复杂度保存之前的最大值。因为dp只用到了之前的一个值，所以可以优化为只用两个 int 来保存前面的状态，遍历时同时更新<code>dpPre</code>和<code>dp</code>。<br>用一个<code>preMax</code>保存<code>j</code>前面<code>A[i]+i</code>的最大值，<code>maxScore</code>保存答案。同时更新两个量，一遍遍历即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">    int maxScore = 0, preMax = A[0] + 0;</span><br><span class="line">    for (int j = 1; j &lt; A.size();j++)&#123;</span><br><span class="line">        maxScore = max(maxScore, preMax + A[j] - j);//更新dp[j]</span><br><span class="line">        preMax = max(preMax, A[j] + j);//更新下一次j的dpPre[j-1]</span><br><span class="line">    &#125;</span><br><span class="line">    return maxScore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
</li>
</ol>
<h1 id="6月18日-1028-从先序遍历还原二叉树（困难）"><a href="#6月18日-1028-从先序遍历还原二叉树（困难）" class="headerlink" title="6月18日 1028. 从先序遍历还原二叉树（困难）"></a>6月18日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/">1028. 从先序遍历还原二叉树（困难）</a></h1><p>我们从二叉树的根节点 root 开始进行深度优先搜索。<br>在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。<br>如果节点只有一个子节点，那么保证该子节点为左子节点。<br>给出遍历输出 S，还原树并返回其根节点 root。</p>
<p>示例1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;1-2--3--4-5--6--7&quot;</span><br><span class="line">输出：[1,2,5,3,4,6,7]</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;1-2--3---4-5--6---7&quot;</span><br><span class="line">输出：[1,2,5,3,null,6,null,4,null,7]</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;1-401--349---90--88&quot;</span><br><span class="line">输出：[1,401,null,349,88,90]</span><br></pre></td></tr></table></figure>
<p>题解：<br>当前节点为T，上一个节点为S，只有两种情况：</p>
<ul>
<li>T 是 S 的左子节点；</li>
<li>T 是根节点到 S 这一条路径上（不包括 S，因为题目中规定了如果节点只有一个子节点，那么保证该子节点为左子节点）某一个节点的右子节点。</li>
</ul>
<p>所以，我们用一个栈保存<strong>根节点</strong>到当前节点的<strong>上一个节点</strong>的路径：</p>
<ol>
<li><strong>当前节点</strong>的深度刚好比<strong>栈的高度</strong>大1：<strong>当前节点</strong>正好是<strong>栈顶节点</strong>的<strong>左子节点</strong>；<em>ps. 深度是从0开始，所以当深度的值和栈高度相等时，就是深度刚好比栈的高度大1</em></li>
<li><strong>当前节点</strong>的深度小于等于<strong>栈的高度</strong>：<ul>
<li><strong>当前节点</strong>的深度刚和<strong>栈的高度</strong>相等：<strong>当前节点</strong>是<strong>栈顶节点右兄弟节点</strong>即<strong>栈顶节点父节点的右子节点</strong>；</li>
<li><strong>当前节点</strong>的深度小于<strong>栈的高度</strong>：<strong>当前节点</strong>是<strong>根节点</strong>到<strong>栈顶节点</strong>路径上某一个节点的<strong>右子节点</strong>。一直弹出栈顶节点直到满足情况<code>1</code>。</li>
<li>*ps. <strong>当前节点</strong>的深度刚和<strong>栈的高度</strong>相等 即 <code>level=path.size()-1</code>，也是需要弹出栈顶节点一次*<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* recoverFromPreorder(string S) &#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; path;</span><br><span class="line">    int pos = 0;</span><br><span class="line">    while(pos&lt;S.size())&#123;</span><br><span class="line">        int level = 0;</span><br><span class="line">        while(S[pos]==&#x27;-&#x27;)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int value = 0;</span><br><span class="line">        while (pos &lt; S.size() &amp;&amp; isdigit(S[pos]))&#123;//取当前节点的值</span><br><span class="line">            value = value * 10 + (S[pos] - &#x27;0&#x27;);</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *node = new TreeNode(value);</span><br><span class="line">        if(level==path.size())&#123;//第1种情况</span><br><span class="line">            if(!path.empty())</span><br><span class="line">                path.top()-&gt;left = node;</span><br><span class="line">        &#125;else&#123;//第2种情况</span><br><span class="line">            while(level!=path.size())</span><br><span class="line">                path.pop();</span><br><span class="line">            path.top()-&gt;right = node;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    while(path.size()&gt;1)</span><br><span class="line">        path.pop();</span><br><span class="line">    return path.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n)。n为S的长度<br>空间复杂度：O(h)。h为树的高度</li>
</ul>
</li>
</ol>
<h1 id="6月19日-125-验证回文串（简单）"><a href="#6月19日-125-验证回文串（简单）" class="headerlink" title="6月19日 125. 验证回文串（简单）"></a>6月19日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome/">125. 验证回文串（简单）</a></h1><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p><strong>说明</strong>：本题中，我们将空字符串定义为有效的回文串。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>题解：<br>用一前一后双指针依次往中间遍历，直到指针碰见。可以在开始时用<code>transform()</code>先把字符串全部转换为小写字母，也可以在比较时使用<code>toupper()/tolower()</code>转单个字母。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool isPalindrome(string s) &#123;</span><br><span class="line">    // transform(s.begin(), s.end(), s.begin(), ::tolower);</span><br><span class="line">    if (s.size() == 0)</span><br><span class="line">        return true;</span><br><span class="line">    int idxL = 0, idxR = s.size() - 1;</span><br><span class="line">    while(idxL&lt;idxR)&#123;</span><br><span class="line">        while(!isalnum(s[idxL]) &amp;&amp; idxL&lt;idxR)</span><br><span class="line">            idxL++; </span><br><span class="line">        while(!isalnum(s[idxR]) &amp;&amp; idxL&lt;idxR)</span><br><span class="line">            idxR--;</span><br><span class="line">        if(tolower(s[idxL]) != tolower(s[idxR]))</span><br><span class="line">            return false;</span><br><span class="line">        else&#123;</span><br><span class="line">            idxL++;</span><br><span class="line">            idxR--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)。n为字符串s的长度<br>空间复杂度：O(1)</p>
<h1 id="6月20日-10-正则表达式匹配（困难）"><a href="#6月20日-10-正则表达式匹配（困难）" class="headerlink" title="6月20日 10. 正则表达式匹配（困难）"></a>6月20日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配（困难）</a></h1><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;.&#x27; 匹配任意单个字符</span><br><span class="line">&#x27;*&#x27; 匹配零个或多个前面的那一个元素</span><br><span class="line">所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s 可能为空，且只包含从 a-z 的小写字母。</span><br><span class="line">p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</span><br></pre></td></tr></table></figure>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span><br></pre></td></tr></table></figure>
<p>示例 4:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#x27;*&#x27; 表示零个或多个，这里 &#x27;c&#x27; 为 0 个, &#x27;a&#x27; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure>
<p>示例 5:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>递归（超时）。需要用到有限状态机的思想。</p>
<ul>
<li>当p索引的下一个字符是’*’时：<ul>
<li>当前字符匹配：当作没有’*‘ || 转移状态，看s的下一位 ||’*‘匹配0个</li>
<li>当前字符不匹配：’*‘匹配0个，p索引向后移动两位</li>
</ul>
</li>
<li>当p索引的下一个字符不是’*‘时。如果当前字符匹配，则都向后移动一位。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool matchCore(string s, string p, int idxS, int idxP)&#123;</span><br><span class="line">    if(idxS==s.size() &amp;&amp; idxP==p.size())</span><br><span class="line">        return true;</span><br><span class="line">    if(idxS&lt;s.size() &amp;&amp; idxP==p.size())</span><br><span class="line">        return false;</span><br><span class="line">    </span><br><span class="line">    if(p[idxP+1]==&#x27;*&#x27;)&#123;//p索引的下一个字符是&#x27;*&#x27;</span><br><span class="line">        if(p[idxP]==s[idxS] || (p[idxP]==&#x27;.&#x27; &amp;&amp; idxS&lt;s.size())) //当前字符匹配</span><br><span class="line">            return matchCore(s, p, idxS + 1, idxP + 2)//当作没有*</span><br><span class="line">                || matchCore(s, p, idxS + 1, idxP) //</span><br><span class="line">                || matchCore(s, p, idxS, idxP + 2);//*匹配0个</span><br><span class="line">        else //当前字符不匹配</span><br><span class="line">            return matchCore(s, p, idxS, idxP + 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(s[idxS]==p[idxP] || (p[idxP]==&#x27;.&#x27; &amp;&amp; idxS&lt;s.size())) //p索引的下一个字符不是&#x27;*&#x27;</span><br><span class="line">        return matchCore(s, p, idxS + 1, idxP + 1);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isMatch(string s, string p)</span><br><span class="line">&#123;</span><br><span class="line">    return matchCore(s, p, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>dp。用 <code>dp[i][j]</code> 表示 <code>s</code> 的前 <code>i</code> 个字符与 <code>p</code> 中的前 <code>j</code> 个字符是否能够匹配。</p>
<ul>
<li>p[j]不是’*‘<ul>
<li><code>dp[i][j] = dp[i-1][j-1]</code> (s[i] &#x3D;&#x3D; p[j] 含p[j]&#x3D;&#x3D;’.’的情况)</li>
<li>false (s[i] !&#x3D; p[j])</li>
</ul>
</li>
<li>p[j]是’*‘<ul>
<li><code>dp[i][j] = dp[i-1][j](匹配s的该位字符) || dp[i][j-2](字母+星号不匹配任何字符)</code> (s[i] &#x3D;&#x3D; p[j-1] s[i] &#x3D;&#x3D; p[j] 含p[j-1]&#x3D;&#x3D;’.’的情况)</li>
<li><code>dp[i][j] = dp[i][j-2]</code> (s[i]!&#x3D;p[j-1])</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><em>ps. 需要特别注意字符串的索引是从0开始的，和dp的索引相差1</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">bool isMatch(string s, string p)</span><br><span class="line">&#123;</span><br><span class="line">    int m = s.size(), n = p.size();</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; dp(m+1,vector&lt;bool&gt;(n+1));</span><br><span class="line"></span><br><span class="line">    //初始化很重要！！！</span><br><span class="line">    dp[0][0] = true;</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        if (p[i-1] == &#x27;*&#x27; &amp;&amp; dp[0][i - 2])&#123;</span><br><span class="line">            // p[0]不可能是&#x27;\*&#x27;，因为&#x27;\*&#x27;必须依附前面的字符。</span><br><span class="line">            // p = &quot;a*c*b*a&quot;这种情况，dp[0][2/4/6]都为true</span><br><span class="line">            dp[0][i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(p[j-1]!=&#x27;*&#x27;)&#123;</span><br><span class="line">                if(s[i-1]==p[j-1] || p[j-1]==&#x27;.&#x27;)</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">                else</span><br><span class="line">                    dp[i][j] = false;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(s[i-1]==p[j-2] || p[j-2]==&#x27;.&#x27;)&#123;</span><br><span class="line">                    dp[i][j] = (dp[i - 1][j] || dp[i][j - 2]);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - 2];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6月21日-124-二叉树中的最大路径和（困难）"><a href="#6月21日-124-二叉树中的最大路径和（困难）" class="headerlink" title="6月21日 124. 二叉树中的最大路径和（困难）"></a>6月21日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和（困难）</a></h1><p>给定一个非空二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [-10,9,20,null,null,15,7]</span><br><span class="line">       -10</span><br><span class="line">       / \</span><br><span class="line">      9  20</span><br><span class="line">        /  \</span><br><span class="line">       15   7</span><br><span class="line"></span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure>
<p>题解：<br>递归。<br>一个节点处于最大路径上时，可能有两种情况：</p>
<ul>
<li>他是最上层节点，不再父节点走。这时候需要求<code>lANDr</code>：当前节点和左右路径的最大值</li>
<li>他不是最上层，有父节点。这时候需要求<code>lORr</code>：当前节点往左子树<strong>还是</strong>子树和更大</li>
</ul>
<p>递归函数返回的是左&#x2F;右子树的最大路径和。同时更新一个保存全局最大路径和的<strong>引用</strong><code>maxSum</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int getMaxPathSum(TreeNode* root, int &amp;maxSum)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return 0;</span><br><span class="line">    int lPath = getMaxPathSum(root-&gt;left, maxSum);</span><br><span class="line">	int rPath = getMaxPathSum(root-&gt;right, maxSum);</span><br><span class="line">	int lANDr = root-&gt;val + max(0, lPath) + max(0, rPath);</span><br><span class="line">	int lORr = root-&gt;val + max(0, max(lPath, rPath));</span><br><span class="line">	maxSum = max(maxSum, max(lANDr, lORr));</span><br><span class="line">	return lORr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int maxPathSum(TreeNode* root) &#123;</span><br><span class="line">    int maxSum = INT_MIN;</span><br><span class="line">    getMaxPathSum(root, maxSum);</span><br><span class="line">    return maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，其中 n 是二叉树中的节点个数。对每个节点访问不超过 2 次。<br>空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用层数，最大层数等于二叉树的高度，最坏情况下，二叉树的高度等于二叉树中的节点个数。</p>
<h1 id="第194场周赛-6-21"><a href="#第194场周赛-6-21" class="headerlink" title="第194场周赛 6.21"></a>第194场周赛 6.21</h1><h2 id="5440-数组异或操作"><a href="#5440-数组异或操作" class="headerlink" title="5440. 数组异或操作"></a>5440. 数组异或操作</h2><p>题目难度Easy<br>给你两个整数，n 和 start 。</p>
<p>数组 nums 定义为：nums[i] &#x3D; start + 2*i（下标从 0 开始）且 n &#x3D;&#x3D; nums.length 。</p>
<p>请返回 nums 中所有元素按位异或（XOR）后得到的结果。</p>
<p>示例 1：</p>
<p>输入：n &#x3D; 5, start &#x3D; 0<br>输出：8<br>解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) &#x3D; 8 。<br>     “^” 为按位异或 XOR 运算符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int xorOperation(int n, int start) &#123;</span><br><span class="line">    vector&lt;int&gt; nums(n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">        nums[i] = start + 2 * i;</span><br><span class="line"></span><br><span class="line">    int res = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; n;i++)</span><br><span class="line">        res ^= nums[i];</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5441-保证文件名唯一（中等）"><a href="#5441-保证文件名唯一（中等）" class="headerlink" title="5441. 保证文件名唯一（中等）"></a>5441. 保证文件名唯一（中等）</h2><p>给你一个长度为 n 的字符串数组 names 。你将会在文件系统中创建 n 个文件夹：在第 i 分钟，新建名为 names[i] 的文件夹。</p>
<p>由于两个文件 不能 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 (k) 的形式为新文件夹的文件名添加后缀，其中 k 是能保证文件名唯一的 最小正整数 。</p>
<p>返回长度为 n 的字符串数组，其中 ans[i] 是创建第 i 个文件夹时系统分配给该文件夹的实际名称。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]</span><br><span class="line">输出：[&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]</span><br><span class="line">解释：文件系统将会这样创建文件名：</span><br><span class="line">&quot;pes&quot; --&gt; 之前未分配，仍为 &quot;pes&quot;</span><br><span class="line">&quot;fifa&quot; --&gt; 之前未分配，仍为 &quot;fifa&quot;</span><br><span class="line">&quot;gta&quot; --&gt; 之前未分配，仍为 &quot;gta&quot;</span><br><span class="line">&quot;pes(2019)&quot; --&gt; 之前未分配，仍为 &quot;pes(2019)&quot;</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece&quot;]</span><br><span class="line">输出：[&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece(4)&quot;]</span><br><span class="line">解释：当创建最后一个文件夹时，最小的正有效 k 为 4 ，文件名变为 &quot;onepiece(4)&quot;。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido&quot;,&quot;kaido(1)&quot;]</span><br><span class="line">输出：[&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido(2)&quot;,&quot;kaido(1)(1)&quot;]</span><br><span class="line">解释：注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; getFolderNames(vector&lt;string&gt;&amp; names) &#123;</span><br><span class="line">    unordered_map&lt;string, int&gt; fileMap;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    for (int i = 0; i &lt; names.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int tmp = fileMap[names[i]]; //如果该key不存在，会自动创建一个&#123;key,0&#125;的插入map，并返回0</span><br><span class="line">        if (tmp == 0)</span><br><span class="line">        &#123;//文件名不存在</span><br><span class="line">            res.push_back(names[i]);</span><br><span class="line">            fileMap[names[i]] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;//文件名已存在</span><br><span class="line">            while (fileMap.count(names[i]+&quot;(&quot;+to_string(tmp)+&quot;)&quot;))</span><br><span class="line">                tmp++;</span><br><span class="line">            res.push_back(names[i]+&quot;(&quot;+to_string(tmp)+&quot;)&quot;);</span><br><span class="line">            fileMap[names[i]] = tmp;</span><br><span class="line">            fileMap[names[i]+&quot;(&quot;+to_string(tmp)+&quot;)&quot;] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5442-避免洪水泛滥（中等）"><a href="#5442-避免洪水泛滥（中等）" class="headerlink" title="5442. 避免洪水泛滥（中等）"></a>5442. 避免洪水泛滥（中等）</h2><p>你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 n 个湖泊下雨的时候，如果第 n 个湖泊是空的，那么它就会装满水，否则这个湖泊会发生洪水。你的目标是避免任意一个湖泊发生洪水。</p>
<p>给你一个整数数组 rains ，其中：<br>rains[i] &gt; 0 表示第 i 天时，第rains[i]个湖泊会下雨。<br>rains[i] &#x3D;&#x3D; 0 表示第 i 天没有湖泊会下雨，你可以选择一个湖泊并抽干这个湖泊的水。</p>
<p>请返回一个数组 ans ，满足：<br>ans.length &#x3D;&#x3D; rains.length<br>如果 rains[i] &gt; 0 ，那么ans[i] &#x3D;&#x3D; -1 。<br>如果 rains[i] &#x3D;&#x3D; 0 ，ans[i] 是你第 i 天选择抽干的湖泊。<br>如果有多种可行解，请返回它们中的任意一个 。如果没办法阻止洪水，请返回一个空的数组。</p>
<p>请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生（详情请看示例 4）。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：rains = [1,2,3,4]</span><br><span class="line">输出：[-1,-1,-1,-1]</span><br><span class="line">解释：第一天后，装满水的湖泊包括 [1]</span><br><span class="line">第二天后，装满水的湖泊包括 [1,2]</span><br><span class="line">第三天后，装满水的湖泊包括 [1,2,3]</span><br><span class="line">第四天后，装满水的湖泊包括 [1,2,3,4]</span><br><span class="line">没有哪一天你可以抽干任何湖泊的水，也没有湖泊会发生洪水。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：rains = [1,2,0,0,2,1]</span><br><span class="line">输出：[-1,-1,2,1,-1,-1]</span><br><span class="line">解释：第一天后，装满水的湖泊包括 [1]</span><br><span class="line">第二天后，装满水的湖泊包括 [1,2]</span><br><span class="line">第三天后，我们抽干湖泊 2 。所以剩下装满水的湖泊包括 [1]</span><br><span class="line">第四天后，我们抽干湖泊 1 。所以暂时没有装满水的湖泊了。</span><br><span class="line">第五天后，装满水的湖泊包括 [2]。</span><br><span class="line">第六天后，装满水的湖泊包括 [1,2]。</span><br><span class="line">可以看出，这个方案下不会有洪水发生。同时， [-1,-1,1,2,-1,-1] 也是另一个可行的没有洪水的方案。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：rains = [1,2,0,1,2]</span><br><span class="line">输出：[]</span><br><span class="line">解释：第二天后，装满水的湖泊包括 [1,2]。我们可以在第三天抽干一个湖泊的水。</span><br><span class="line">但第三天后，湖泊 1 和 2 都会再次下雨，所以不管我们第三天抽干哪个湖泊的水，另一个湖泊都会发生洪水。</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rains = [69,0,0,0,69]</span><br><span class="line">输出：[-1,69,1,1,-1]</span><br><span class="line">解释：任何形如 [-1,69,x,y,-1], [-1,x,69,y,-1] 或者 [-1,x,y,69,-1] 都是可行的解，其中 1 &lt;= x,y &lt;= 10^9</span><br></pre></td></tr></table></figure>
<p>示例 5：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rains = [10,20,20]</span><br><span class="line">输出：[]</span><br><span class="line">解释：由于湖泊 20 会连续下 2 天的雨，所以没有没有办法阻止洪水。</span><br></pre></td></tr></table></figure>
<p>题解：<br><code>lastRainDay</code>保存了湖号(key)到目前的最后一天下雨的日期。<br>set <code>s</code> 保存了前面未下雨的日期。</p>
<ul>
<li><p>碰到rains[i]&#x3D;&#x3D;0后（没下雨），把未下雨的天数先存到<code>s</code>里，继续往后。</p>
</li>
<li><p>如果下雨</p>
<ul>
<li>湖<code>lakeNum</code>未满，就更新<code>lastRainDay[lakeNum]=i</code>和<code>res[i]=-1</code></li>
<li>湖<code>lakeNum</code>满了，就从未下雨的日期set <code>s</code> 中取出 湖<code>lakeNum</code> 最后下雨日期<code>lastRainDay[lakeNum]</code> 之后<strong>最近的未下雨的日期</strong>，在<code>lastRainDay[lakeNum]</code>当天把<code>lakeNum</code>抽干。</li>
</ul>
</li>
</ul>
<p>简单来说，就是在碰到水满之后，把最前面没下雨的一天用来抽该湖上次下的雨。（当然，抽水的日期要在下雨日期之后）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; avoidFlood(vector&lt;int&gt;&amp; rains) &#123;</span><br><span class="line">    set&lt;int&gt; s;</span><br><span class="line">    vector&lt;int&gt; res(rains.size(), 1);</span><br><span class="line">    unordered_map&lt;int, int&gt; lastRainDay;//key是第i天下雨的湖号码，val是i</span><br><span class="line">    for (int i = 0; i &lt; rains.size(); i++) &#123;</span><br><span class="line">        int lakeNum = rains[i];//第i天下雨的湖号</span><br><span class="line">        //第i天没下雨</span><br><span class="line">        if (lakeNum == 0) &#123;</span><br><span class="line">            s.insert(i);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //第i天下雨了</span><br><span class="line">        res[i] = -1;</span><br><span class="line">        if (lastRainDay.find(lakeNum) == lastRainDay.end()) &#123;//湖里没水</span><br><span class="line">            lastRainDay[lakeNum] = i;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //湖里有水</span><br><span class="line">        auto lastDay = lastRainDay[lakeNum];</span><br><span class="line">        auto it = s.upper_bound(lastDay);</span><br><span class="line">        if (it == s.end()) &#123;</span><br><span class="line">            return vector&lt;int&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res[*it] = lakeNum;</span><br><span class="line">        lastRainDay[lakeNum] = i;</span><br><span class="line">        s.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6月22日-面试题-16-18-模式匹配（中等）"><a href="#6月22日-面试题-16-18-模式匹配（中等）" class="headerlink" title="6月22日 面试题 16.18. 模式匹配（中等）"></a>6月22日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pattern-matching-lcci/">面试题 16.18. 模式匹配（中等）</a></h1><p>你有两个字符串，即pattern和value。 pattern字符串由字母”a”和”b”组成，用于描述字符串中的模式。例如，字符串”catcatgocatgo”匹配模式”aabab”（其中”cat”是”a”，”go”是”b”），该字符串也匹配像”a”、”ab”和”b”这样的模式。但需注意”a”和”b”不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： pattern = &quot;abba&quot;, value = &quot;dogcatcatdog&quot;</span><br><span class="line">输出： true</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： pattern = &quot;abba&quot;, value = &quot;dogcatcatfish&quot;</span><br><span class="line">输出： false</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： pattern = &quot;aaaa&quot;, value = &quot;dogcatcatdog&quot;</span><br><span class="line">输出： false</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： pattern = &quot;abba&quot;, value = &quot;dogdogdogdog&quot;</span><br><span class="line">输出： true</span><br><span class="line">解释： &quot;a&quot;=&quot;dogdog&quot;,b=&quot;&quot;，反之也符合规则</span><br></pre></td></tr></table></figure>
<p>题解：<br>枚举模式a和b的长度<code>lA</code> 和 <code>lB</code>，在看该长度下的substr是否满足条件。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">bool patternMatching(string pattern, string value) &#123;</span><br><span class="line">    if(pattern==&quot;&quot; &amp;&amp; value!=&quot;&quot;)</span><br><span class="line">        return false;</span><br><span class="line">    if (pattern.size() == 1 || (pattern==&quot;&quot; &amp;&amp; value==&quot;&quot;))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    int cntA = 0, cntB = 0;</span><br><span class="line">    for(char c:pattern)&#123;//统计pattern里种类的数量</span><br><span class="line">        if(c==&#x27;a&#x27;)</span><br><span class="line">            cntA++;</span><br><span class="line">        if(c==&#x27;b&#x27;)</span><br><span class="line">            cntB++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(cntA==0 || cntB==0)&#123;//只有1个模式</span><br><span class="line">        if(value.size()%pattern.size()!=0)</span><br><span class="line">            return false;</span><br><span class="line">        int n = pattern.size();</span><br><span class="line">        int nSub = value.size() / pattern.size();</span><br><span class="line">        for (int i = 1; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int idx = i * nSub;</span><br><span class="line">            for (int j = 0; j &lt; nSub;j++)&#123;</span><br><span class="line">                if(value[j]!=value[idx+j])</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123; //2个模式</span><br><span class="line">        if(value.size()==0)</span><br><span class="line">            return false;</span><br><span class="line">        if(cntA==1 || cntB==1)</span><br><span class="line">            return true;</span><br><span class="line">        //枚举每个模式的字符串长度</span><br><span class="line">        for (int lA = 0; lA &lt;= value.size() / cntA; lA++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int lB = 0; lB &lt;= value.size() / cntB;lB++)&#123;</span><br><span class="line">                if(lA*cntA + lB*cntB != value.size())</span><br><span class="line">                    continue;</span><br><span class="line">                </span><br><span class="line">                map&lt;char, string&gt; pMap;</span><br><span class="line">                int idxA = 0, idxB = 0;</span><br><span class="line">                int a = 0, b = 0;</span><br><span class="line">                while (pattern[a++] != &#x27;a&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    idxA += lB;</span><br><span class="line">                &#125;</span><br><span class="line">                while(pattern[b++]!=&#x27;b&#x27;)</span><br><span class="line">                    idxB += lA;</span><br><span class="line">                </span><br><span class="line">                pMap[&#x27;a&#x27;] = value.substr(idxA, lA);</span><br><span class="line">                pMap[&#x27;b&#x27;] = value.substr(idxB, lB);</span><br><span class="line">                </span><br><span class="line">                //按模式的长度lA和lB验证是否匹配</span><br><span class="line">                int pos = 0;</span><br><span class="line">                for (int i = 0; i &lt; pattern.size(); i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    char cur = pattern[i];</span><br><span class="line">                    int l = cur == &#x27;a&#x27; ? lA : lB;</span><br><span class="line">                    if (pMap[cur] == value.substr(pos,l))&#123;</span><br><span class="line">                        pos += l;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(pos==value.size())</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6月23日-67-二进制求和（简单）"><a href="#6月23日-67-二进制求和（简单）" class="headerlink" title="6月23日 67. 二进制求和（简单）"></a>6月23日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-binary/">67. 二进制求和（简单）</a></h1><p>给你两个二进制字符串，返回它们的和（用二进制表示）。<br>输入为 非空 字符串且只包含数字 1 和 0。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">输出: &quot;100&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>数位法。和做大数乘法一样，处理每一位和进位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">string addBinary(string a, string b) &#123;</span><br><span class="line">    int carry = 0;</span><br><span class="line">    int i = a.size() - 1, j = b.size() - 1;</span><br><span class="line">    string endDigital = &quot;&quot;;</span><br><span class="line">    while (i &gt;= 0 &amp;&amp; j &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        string curDigit = &quot;&quot;;</span><br><span class="line">        if(carry == 0)&#123;</span><br><span class="line">            if(a[i]==&#x27;1&#x27; &amp;&amp; b[j]==&#x27;1&#x27;)&#123;</span><br><span class="line">                curDigit = &quot;0&quot;;</span><br><span class="line">                carry = 1;</span><br><span class="line">            &#125;else if((a[i]==&#x27;1&#x27; &amp;&amp; b[j]==&#x27;0&#x27;) || (a[i]==&#x27;0&#x27; &amp;&amp; b[j]==&#x27;1&#x27;))&#123;</span><br><span class="line">                curDigit = &#x27;1&#x27;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                curDigit = &#x27;0&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(a[i]==&#x27;1&#x27; &amp;&amp; b[j]==&#x27;1&#x27;)&#123;</span><br><span class="line">                curDigit = &quot;1&quot;;</span><br><span class="line">            &#125;else if((a[i]==&#x27;1&#x27; &amp;&amp; b[j]==&#x27;0&#x27;) || (a[i]==&#x27;0&#x27; &amp;&amp; b[j]==&#x27;1&#x27;))&#123;</span><br><span class="line">                curDigit = &#x27;0&#x27;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                curDigit = &#x27;1&#x27;;</span><br><span class="line">                carry = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        endDigital = curDigit + endDigital;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(i&gt;=0)&#123;</span><br><span class="line">        if(carry==1)&#123;</span><br><span class="line">            if(a[i]==&#x27;0&#x27;)&#123;</span><br><span class="line">                endDigital = &#x27;1&#x27; + endDigital;</span><br><span class="line">                carry = 0;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                endDigital = &#x27;0&#x27; + endDigital;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            endDigital = a[i] + endDigital;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    while(j&gt;=0)&#123;</span><br><span class="line">        if(carry==1)&#123;</span><br><span class="line">            if(b[j]==&#x27;0&#x27;)&#123;</span><br><span class="line">                endDigital = &#x27;1&#x27; + endDigital;</span><br><span class="line">                carry = 0;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                endDigital = &#x27;0&#x27; + endDigital;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            endDigital = b[j] + endDigital;</span><br><span class="line">        &#125;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    if(carry == 1)&#123;</span><br><span class="line">        endDigital = &quot;1&quot; + endDigital;</span><br><span class="line">    &#125;</span><br><span class="line">    return endDigital;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实可以在短的前面添0补齐，就会方便一些。而且也可以通过 <code>%2, /2</code> 来得到更简洁的代码（前提是允许使用加减乘除）。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">string addBinary(string a, string b) &#123;  </span><br><span class="line">    string res;</span><br><span class="line">    reverse(a.begin(), a.end());</span><br><span class="line">    reverse(b.begin(), b.end());</span><br><span class="line"></span><br><span class="line">    int n = max(a.size(), b.size()), carry = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        carry += i &lt; a.size() ? (a[i] == &#x27;1&#x27;) : 0;</span><br><span class="line">        carry += i &lt; b.size() ? (b[i] == &#x27;1&#x27;) : 0;</span><br><span class="line">        res.push_back((carry % 2) ? &#x27;1&#x27; : &#x27;0&#x27;);</span><br><span class="line">        carry /= 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (carry) &#123;</span><br><span class="line">        res.push_back(&#x27;1&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(l)。l为最长的位数。<br>空间复杂度O(1)。</p>
</li>
<li><p>先转为10进制运算后再转回来。但是如果有很多位，就会导致溢出。<br>（代码略）</p>
</li>
</ol>
<h1 id="6月24日-16-最接近的三数之和（中等）"><a href="#6月24日-16-最接近的三数之和（中等）" class="headerlink" title="6月24日 16. 最接近的三数之和（中等）"></a>6月24日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum-closest/">16. 最接近的三数之和（中等）</a></h1><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,2,1,-4], target = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</span><br></pre></td></tr></table></figure>

<p>题解：<br>排序+双指针。类似的题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></p>
<p>暴力法的话时间复杂度是O(n^3)。我们需要想办法来降低时间复杂度：先枚举第一个数nums[i]，再剩下<code>nums</code>中找和最接近<code>target-nums[i]</code>。经过排序之后，可以用两数和与<code>target-nums[i]</code>的大小关系来决定两数和的变化趋势。</p>
<p>这样寻找后两个数是，只需遍历一遍，相当于把O(n^2)的时间降到了O(n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    if(nums.size()==3)</span><br><span class="line">        return nums[0] + nums[1] + nums[2];</span><br><span class="line"></span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    int diff = INT_MAX;</span><br><span class="line">    for (int i = 0; i &lt; n-2;i++)&#123;</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) //防止重复元素</span><br><span class="line">            continue;</span><br><span class="line">        int find = target - nums[i];</span><br><span class="line">        int idxL = i + 1, idxR = n - 1;</span><br><span class="line">        while (idxL &lt; idxR)</span><br><span class="line">        &#123;</span><br><span class="line">            int sumLR = nums[idxL] + nums[idxR];</span><br><span class="line">            if(sumLR == find) //如果相等，直接返回target</span><br><span class="line">                return target;</span><br><span class="line">            diff = abs(diff) &lt; abs(sumLR - find) ? diff : (sumLR - find);//更新最小差值</span><br><span class="line">            if (sumLR &gt; find) idxR--;</span><br><span class="line">            else idxL++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return target + diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)。排序需要O(nlogn)，算法主体O(n^2)。<br>空间复杂度：如果nums可以修改，则只需要排序算法的空间复杂度。如果nums不能修改，则需要O(n)来存储nums。</p>
<h1 id="6月25日-139-单词拆分（中等）-https-leetcode-cn-com-problems-word-break"><a href="#6月25日-139-单词拆分（中等）-https-leetcode-cn-com-problems-word-break" class="headerlink" title="6月25日 [139. 单词拆分（中等）(https://leetcode-cn.com/problems/word-break/)"></a>6月25日 [139. 单词拆分（中等）(<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break/">https://leetcode-cn.com/problems/word-break/</a>)</h1><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>存一个首字母map，用递归的方法查找。超时。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">bool wordBreakCore(string s, vector&lt;string&gt;&amp; wordDict, int idx, unordered_map&lt;char, vector&lt;string&gt; &gt; &amp;alphaMap)&#123;</span><br><span class="line">    if(idx==s.size())</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if(alphaMap.find(s[idx])==alphaMap.end())</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    bool find = false;</span><br><span class="line">    int initIdx = idx;</span><br><span class="line">    for (string str : alphaMap[s[idx]])</span><br><span class="line">    &#123;</span><br><span class="line">        idx = initIdx;</span><br><span class="line">        if (idx + str.size() &gt; s.size())</span><br><span class="line">            continue;</span><br><span class="line">        int nxtIdx = idx + str.size();</span><br><span class="line">        for (int i = 0; i &lt; str.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[i]!=s[idx])</span><br><span class="line">                break;</span><br><span class="line">            else</span><br><span class="line">                idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(idx==nxtIdx)</span><br><span class="line">            find = wordBreakCore(s, wordDict, idx, alphaMap);</span><br><span class="line">        if(find)</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return find;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)&#123;</span><br><span class="line">    unordered_map&lt;char, vector&lt;string&gt; &gt; alphaMap;</span><br><span class="line">    for (auto word : wordDict)</span><br><span class="line">        alphaMap[word[0]].push_back(word);</span><br><span class="line"></span><br><span class="line">    return wordBreakCore(s, wordDict, 0, alphaMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>dp。<br><code>dp[i]=dp[j] &amp;&amp; check(s[j..i−1])</code><br>其中 dp[i] 表示字符串 s 前 i 个字符组成的字符串 s[0..i-1] 是否能被空格拆分成若干个字典中出现的单词。check(s[j..i-1]) 表示子串 s[j..i-1] 是否出现在字典中。<br>可以记录<code>set</code>中单词的最大长度和最小长度，缩小<code>j</code>的遍历范围。但是不会减小时间复杂度  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)&#123;</span><br><span class="line">    unordered_set&lt;string&gt; wordSet;</span><br><span class="line">    int minLength = 0, maxLength = INT_MAX;</span><br><span class="line">    for (string word : wordDict)&#123;</span><br><span class="line">        wordSet.insert(word);</span><br><span class="line">        minLength = word.size() &gt; minLength ? minLength : word.size();</span><br><span class="line">        maxLength = word.size() &lt; maxLength ? maxLength : word.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;bool&gt; dp(s.size() + 1);</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    for (int i = 1; i &lt;= s.size();i++)&#123;</span><br><span class="line">        for (int j = max(0,i-maxLength); i-j&gt;=minLength;j++)&#123;</span><br><span class="line">            if(dp[j] &amp;&amp; wordSet.find(s.substr(j,i-j))!=wordSet.end())&#123;</span><br><span class="line">                dp[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n^2)。n为字符串s的长度。<br>空间复杂度：O(max{m,n})。m为<code>wordDict</code>的长度，n为s的长度。</li>
</ol>
<h1 id="6月26日-面试题-02-01-移除重复节点（简单）"><a href="#6月26日-面试题-02-01-移除重复节点（简单）" class="headerlink" title="6月26日 面试题 02.01. 移除重复节点（简单）"></a>6月26日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/">面试题 02.01. 移除重复节点（简单）</a></h1><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<p>示例1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1, 2, 3, 3, 2, 1]</span><br><span class="line">输出：[1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1, 1, 1, 1, 2]</span><br><span class="line">输出：[1, 2]</span><br></pre></td></tr></table></figure>
<p>题解：<br>用一个哈希表(<code>unordered_set</code>)保存已有元素。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ListNode* removeDuplicateNodes(ListNode* head) &#123;</span><br><span class="line">    if(head==nullptr || head-&gt;next==nullptr)</span><br><span class="line">        return head;</span><br><span class="line"></span><br><span class="line">    unordered_set&lt;int&gt; valSet;</span><br><span class="line">    ListNode *lastNode = head;</span><br><span class="line">    ListNode *cur = head-&gt;next;</span><br><span class="line">    valSet.insert(head-&gt;val);</span><br><span class="line">    while (cur != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if(valSet.find(cur-&gt;val) == valSet.end())&#123;//非重复节点</span><br><span class="line">            valSet.insert(cur-&gt;val);</span><br><span class="line">            lastNode-&gt;next = cur;</span><br><span class="line">            lastNode = lastNode-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;else&#123;//重复节点</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lastNode-&gt;next = cur;//nullptr</span><br><span class="line"></span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)  </p>
<p><em>ps. 在不允许用额外空间的情况下，可以用两重循环。时间O(n^2) ，空间o(1)。</em></p>
<h1 id="6月27日-41-缺失的第一个正数"><a href="#6月27日-41-缺失的第一个正数" class="headerlink" title="6月27日 41. 缺失的第一个正数"></a>6月27日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-missing-positive/">41. 缺失的第一个正数</a></h1><p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,0]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,-1,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,8,9,11,12]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>排序之后用二分查找从1开始找，可以达到O(mlogn)的时间复杂度。m是缺失正整数的大小。<br>（代码略）</p>
</li>
<li><p>用O(n)的时间把数组存入<code>unordered_set</code>，在从1开始查找，时间复杂度为O(max{m,n})，m是缺失正整数的大小，n是数组的长度。但是就得用O(n)的空间复杂度。（不符合要求，但是还是通过了哈哈哈）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    if(nums.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    unordered_set&lt;int&gt; numSet;</span><br><span class="line">    int maxNum = INT_MIN;</span><br><span class="line">    for (int n : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        numSet.insert(n);</span><br><span class="line">        maxNum = max(maxNum, n);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; maxNum;i++)&#123;</span><br><span class="line">        if(numSet.find(i)==numSet.end())</span><br><span class="line">            return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxNum &lt; 0 ? 1 : maxNum + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有缺失，数组从1开始存放元素，则<code>nums[i]==i+1</code>。可以在遍历的时候把元素从<code>idx==0</code>开始放正确位置对应的数，再次遍历时第一个元素与位置不对应的索引即是最小的正整数。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    for (int i = 0; i &lt; nums.size();i++)&#123;</span><br><span class="line">        while(nums[i]!=i+1)&#123;</span><br><span class="line">            if(nums[i]&lt;=0 || nums[i]&gt;nums.size() || nums[i] == nums[nums[i] - 1])</span><br><span class="line">                //如果 nums[i] == nums[rightPos] 相等，就会无限交换下去。</span><br><span class="line">                break;</span><br><span class="line">            int rightPos = nums[i] - 1;//这个要在if后面，因为当nums[i]太大时，容易溢出</span><br><span class="line">            nums[i] = nums[rightPos];</span><br><span class="line">            nums[rightPos] = rightPos + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">        if(nums[i] != (i+1))</span><br><span class="line">            return i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.size() + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="第29场双周赛（6月27日）"><a href="#第29场双周赛（6月27日）" class="headerlink" title="第29场双周赛（6月27日）"></a>第29场双周赛（6月27日）</h1><h2 id="5432-去掉最低工资和最高工资后的工资平均值（简单）"><a href="#5432-去掉最低工资和最高工资后的工资平均值（简单）" class="headerlink" title="5432. 去掉最低工资和最高工资后的工资平均值（简单）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/">5432. 去掉最低工资和最高工资后的工资平均值（简单）</a></h2><p>给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。<br>请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：salary = [4000,3000,1000,2000]</span><br><span class="line">输出：2500.00000</span><br><span class="line">解释：最低工资和最高工资分别是 1000 和 4000 。</span><br><span class="line">去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">double average(vector&lt;int&gt;&amp; salary) &#123;</span><br><span class="line">    int maxS = INT_MIN, minS = INT_MAX;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int s:salary)&#123;</span><br><span class="line">        sum += s;</span><br><span class="line">        maxS = max(maxS, s);</span><br><span class="line">        minS = min(minS, s);</span><br><span class="line">    &#125;</span><br><span class="line">    return (double)(sum - maxS - minS) / (salary.size() - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5433-n-的第-k-个因子（中等）"><a href="#5433-n-的第-k-个因子（中等）" class="headerlink" title="5433. n 的第 k 个因子（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/contest/biweekly-contest-29/problems/the-kth-factor-of-n/">5433. n 的第 k 个因子（中等）</a></h2><p>给你两个正整数 n 和 k 。<br>如果正整数 i 满足 n % i &#x3D;&#x3D; 0 ，那么我们就说正整数 i 是整数 n 的因子。<br>考虑整数 n 的所有因子，将它们 升序排列 。请你返回第 k 个因子。如果 n 的因子数少于 k ，请你返回 -1 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12, k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：因子列表包括 [1, 2, 3, 4, 6, 12]，第 3 个因子是 3 。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int kthFactor(int n, int k) &#123;</span><br><span class="line">    vector&lt;int&gt; factors;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n%i==0)</span><br><span class="line">            factors.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    if(factors.size()&lt;k)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    return factors[k - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5434-删掉一个元素以后全为-1-的最长子数组（中等）"><a href="#5434-删掉一个元素以后全为-1-的最长子数组（中等）" class="headerlink" title="5434. 删掉一个元素以后全为 1 的最长子数组（中等）"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element/">5434. 删掉一个元素以后全为 1 的最长子数组（中等）</a></h2><p>给你一个二进制数组 nums ，你需要从中删掉一个元素。<br>请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。<br>如果不存在这样的子数组，请返回 0 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,0,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1,1,0,1,1,0,1]</span><br><span class="line">输出：5</span><br><span class="line">解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：你必须要删除一个元素。</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,0,0,1,1,1,0,1]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<p>示例 5：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p>题解：<br>找到0，之后<strong>双指针</strong>分别往前和往后直到碰到下一个0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int longestSubarray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    if (sum == n)</span><br><span class="line">        return n-1;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nums[i] == 1) continue;</span><br><span class="line">        int L = i, R = i;</span><br><span class="line">        while (L-1 &gt;= 0 &amp;&amp; nums[L-1] == 1) -- L;</span><br><span class="line">        while (R+1 &lt; n &amp;&amp; nums[R+1] == 1) ++ R;</span><br><span class="line">        res = max(res, R-L);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6月28日-209-长度最小的子数组（中等）"><a href="#6月28日-209-长度最小的子数组（中等）" class="headerlink" title="6月28日 209. 长度最小的子数组（中等）"></a>6月28日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组（中等）</a></h1><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。</p>
<p>示例: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</span><br></pre></td></tr></table></figure>
<p>题解：<br>双指针。<code>i</code>是左边的指针，<code>j</code>是右边的指针。<code>sum&lt;s</code>时，<code>j++</code> ，<code>sum&gt;=s</code>时，<code>i++</code>。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    if(nums.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int i = 0, j = 0, sum = nums[0], minSub = INT_MAX;</span><br><span class="line">    while(j&lt;nums.size())&#123;</span><br><span class="line">        if(sum&lt;s)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            if(j&lt;nums.size())</span><br><span class="line">                sum += nums[j];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            minSub = min(minSub, j - i + 1);</span><br><span class="line">            sum -= nums[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(minSub==1)</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return minSub == INT_MAX ? 0 : minSub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)<br>空间复杂度O(1)</p>
<h1 id="6月29日-215-数组中的第K个最大元素（中等）"><a href="#6月29日-215-数组中的第K个最大元素（中等）" class="headerlink" title="6月29日 215. 数组中的第K个最大元素（中等）"></a>6月29日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素（中等）</a></h1><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>排序。时间复杂度O(nlogn)。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int findKthLargest(vector&lt;int&gt; &amp;nums, int k) &#123;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        //默认的升序</span><br><span class="line">        sort(begin(nums), end(nums));</span><br><span class="line">        return nums[size - k];</span><br><span class="line"></span><br><span class="line">        // 降序</span><br><span class="line">        // sort(begin(nums), end(nums), greater&lt;int&gt;());</span><br><span class="line">        // return nums[k-1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>快排的<code>partition</code>函数（可以看这篇<a target="_blank" rel="noopener" href="https://suzhilong.github.io/2020/05/25/algorithm/">博客</a>中的算法类例题——排序）。每次可以找到一个正确的位置i，当<code>k&gt;i</code>时，在 <code>i</code> 的右边找；当<code>k&lt;i</code>时，在 <code>i</code> 的左边找；当<code>k==i时</code>，直接输出<code>nums[i]</code>。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">int Partition(vector&lt;int&gt; &amp;arr, int start, int end)&#123;</span><br><span class="line">    if(arr.size()&lt;2 || start&lt;0 || end&gt;arr.size())</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    int pivot = arr[start];  //除了选择第一个，也可以随机选择一个元素作为pivot</span><br><span class="line">    while (start&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        while(start&lt;end &amp;&amp; arr[end]&gt;=pivot)</span><br><span class="line">            end--;</span><br><span class="line">        arr[start] = arr[end];</span><br><span class="line">        while (start &lt; end &amp;&amp; arr[start] &lt;= pivot)</span><br><span class="line">            start++;</span><br><span class="line">        arr[end] = arr[start];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[start] = pivot;</span><br><span class="line">    return start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">    int len = nums.size();</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = len - 1;</span><br><span class="line">    int target = len - k;</span><br><span class="line"></span><br><span class="line">    while (left&lt;right) &#123;</span><br><span class="line">        int index = Partition(nums, left, right);</span><br><span class="line">        if (index == target) &#123;</span><br><span class="line">            return nums[index];</span><br><span class="line">        &#125; else if (index &lt; target) &#123;</span><br><span class="line">            left = index + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right = index - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n)。证明过程可以参考 <strong>算法导论 9.2：期望为线性的选择算法</strong><br>空间复杂度：O(1)</li>
</ol>
<h1 id="6月30日-剑指-Offer-09-用两个栈实现队列"><a href="#6月30日-剑指-Offer-09-用两个栈实现队列" class="headerlink" title="6月30日 剑指 Offer 09. 用两个栈实现队列"></a>6月30日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h1><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 <code>-1</code> )</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>
<p>题解：<br>一个栈入，一个栈出。当要插入数据时，直接插入入栈；当要取出数据时，如果出栈不为空，则从入栈依次取出放入出栈，直到入栈为空。这样就能保证<strong>后进先出</strong>。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class CQueue &#123;</span><br><span class="line">    stack&lt;int&gt; inputStack, outputStack;</span><br><span class="line">public:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">        while(!inputStack.empty())</span><br><span class="line">            inputStack.pop();</span><br><span class="line">        while(!outputStack.empty())</span><br><span class="line">            outputStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void appendTail(int value) &#123;</span><br><span class="line">        inputStack.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int deleteHead() &#123;</span><br><span class="line">        if(outputStack.empty())&#123;</span><br><span class="line">            while(!inputStack.empty())&#123;</span><br><span class="line">                outputStack.push(inputStack.top());</span><br><span class="line">                inputStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(outputStack.empty())</span><br><span class="line">            return -1;</span><br><span class="line">        else&#123;</span><br><span class="line">            int output = outputStack.top();</span><br><span class="line">            outputStack.pop();</span><br><span class="line">            return output;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Su Zhilong 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Su Zhilong 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Leetcode-daily/" rel="tag"># Leetcode daily</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/29/autonomousDriving/" rel="prev" title="自动驾驶学习笔记">
      <i class="fa fa-chevron-left"></i> 自动驾驶学习笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/05/cppReview/" rel="next" title="C++ Review">
      C++ Review <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%881%E6%97%A5-1431-%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">6月1日 1431. 拥有最多糖果的孩子（简单）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%882%E6%97%A5-%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%9864-%E6%B1%821-2-%E2%80%A6-n"><span class="nav-number">2.</span> <span class="nav-text">6月2日 剑指Offer面试题64. 求1+2+…+n</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%883%E6%97%A5-837-%E6%96%B021%E7%82%B9%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">6月3日 837. 新21点（中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%884%E6%97%A5-238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">6月4日 238. 除自身以外数组的乘积（中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%885%E6%97%A5-%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%9829-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">6月5日 剑指Offer面试题29. 顺时针打印矩阵（简单）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%886%E6%97%A5-128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">6月6日 128. 最长连续序列（困难）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%887%E6%97%A5-126-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-II%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="nav-number">7.</span> <span class="nav-text">6月7日 126. 单词接龙 II（困难）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%888%E6%97%A5-990-%E7%AD%89%E5%BC%8F%E6%96%B9%E7%A8%8B%E7%9A%84%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">8.</span> <span class="nav-text">6月8日 990. 等式方程的可满足性（中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%889%E6%97%A5-%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%9846-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">9.</span> <span class="nav-text">6月9日 剑指Offer面试题46. 把数字翻译成字符串（中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8810%E6%97%A5-%E5%9B%9E%E6%96%87%E6%95%B0%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">10.</span> <span class="nav-text">6月10日 回文数（简单）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8811%E6%97%A5-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">11.</span> <span class="nav-text">6月11日 739. 每日温度（中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8812%E6%97%A5-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">12.</span> <span class="nav-text">6月12日 15. 三数之和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8813%E6%97%A5-70-%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">13.</span> <span class="nav-text">6月13日 70. 爬楼梯（简单）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC28%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-6-13"><span class="nav-number">14.</span> <span class="nav-text">第28场双周赛 6.13</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5420-%E5%95%86%E5%93%81%E6%8A%98%E6%89%A3%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%B7%E6%A0%BC%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">14.1.</span> <span class="nav-text">5420. 商品折扣后的最终价格（简单）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5423-%E6%89%BE%E4%B8%A4%E4%B8%AA%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%94%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">14.2.</span> <span class="nav-text">5423. 找两个和为目标值且不重叠的子数组（中等）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5421-%E5%AE%89%E6%8E%92%E9%82%AE%E7%AD%92%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="nav-number">14.3.</span> <span class="nav-text">5421. 安排邮筒（困难）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC193%E5%9C%BA%E5%91%A8%E8%B5%9B-6-14"><span class="nav-number">15.</span> <span class="nav-text">第193场周赛 6.14</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5436-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">15.1.</span> <span class="nav-text">5436. 一维数组的动态和（简单）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5437-%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%EF%BC%88Medium%EF%BC%89"><span class="nav-number">15.2.</span> <span class="nav-text">5437. 不同整数的最少数目（Medium）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5438-%E5%88%B6%E4%BD%9C-m-%E6%9D%9F%E8%8A%B1%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0%EF%BC%88Medium%EF%BC%89"><span class="nav-number">15.3.</span> <span class="nav-text">5438. 制作 m 束花所需的最少天数（Medium）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5188-%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E7%AC%AC-K-%E4%B8%AA%E7%A5%96%E5%85%88%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="nav-number">15.4.</span> <span class="nav-text">5188. 树节点的第 K 个祖先（困难）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8814%E6%97%A5-1300-%E8%BD%AC%E5%8F%98%E6%95%B0%E7%BB%84%E5%90%8E%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">16.</span> <span class="nav-text">6月14日 1300. 转变数组后最接近目标值的数组和（中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8815%E6%97%A5-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">17.</span> <span class="nav-text">6月15日 14. 最长公共前缀（简单）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8816%E6%97%A5-297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="nav-number">18.</span> <span class="nav-text">6月16日 297. 二叉树的序列化与反序列化（困难）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8817%E6%97%A5-1014-%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">19.</span> <span class="nav-text">6月17日 1014. 最佳观光组合（中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8818%E6%97%A5-1028-%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="nav-number">20.</span> <span class="nav-text">6月18日 1028. 从先序遍历还原二叉树（困难）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8819%E6%97%A5-125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">21.</span> <span class="nav-text">6月19日 125. 验证回文串（简单）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8820%E6%97%A5-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="nav-number">22.</span> <span class="nav-text">6月20日 10. 正则表达式匹配（困难）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8821%E6%97%A5-124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88%E5%9B%B0%E9%9A%BE%EF%BC%89"><span class="nav-number">23.</span> <span class="nav-text">6月21日 124. 二叉树中的最大路径和（困难）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC194%E5%9C%BA%E5%91%A8%E8%B5%9B-6-21"><span class="nav-number">24.</span> <span class="nav-text">第194场周赛 6.21</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5440-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C"><span class="nav-number">24.1.</span> <span class="nav-text">5440. 数组异或操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5441-%E4%BF%9D%E8%AF%81%E6%96%87%E4%BB%B6%E5%90%8D%E5%94%AF%E4%B8%80%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">24.2.</span> <span class="nav-text">5441. 保证文件名唯一（中等）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5442-%E9%81%BF%E5%85%8D%E6%B4%AA%E6%B0%B4%E6%B3%9B%E6%BB%A5%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">24.3.</span> <span class="nav-text">5442. 避免洪水泛滥（中等）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8822%E6%97%A5-%E9%9D%A2%E8%AF%95%E9%A2%98-16-18-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">25.</span> <span class="nav-text">6月22日 面试题 16.18. 模式匹配（中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8823%E6%97%A5-67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">26.</span> <span class="nav-text">6月23日 67. 二进制求和（简单）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8824%E6%97%A5-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">27.</span> <span class="nav-text">6月24日 16. 最接近的三数之和（中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8825%E6%97%A5-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89-https-leetcode-cn-com-problems-word-break"><span class="nav-number">28.</span> <span class="nav-text">6月25日 [139. 单词拆分（中等）(https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;word-break&#x2F;)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8826%E6%97%A5-%E9%9D%A2%E8%AF%95%E9%A2%98-02-01-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">29.</span> <span class="nav-text">6月26日 面试题 02.01. 移除重复节点（简单）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8827%E6%97%A5-41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0"><span class="nav-number">30.</span> <span class="nav-text">6月27日 41. 缺失的第一个正数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC29%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%EF%BC%886%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="nav-number">31.</span> <span class="nav-text">第29场双周赛（6月27日）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5432-%E5%8E%BB%E6%8E%89%E6%9C%80%E4%BD%8E%E5%B7%A5%E8%B5%84%E5%92%8C%E6%9C%80%E9%AB%98%E5%B7%A5%E8%B5%84%E5%90%8E%E7%9A%84%E5%B7%A5%E8%B5%84%E5%B9%B3%E5%9D%87%E5%80%BC%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">31.1.</span> <span class="nav-text">5432. 去掉最低工资和最高工资后的工资平均值（简单）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5433-n-%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E5%9B%A0%E5%AD%90%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">31.2.</span> <span class="nav-text">5433. n 的第 k 个因子（中等）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5434-%E5%88%A0%E6%8E%89%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BB%A5%E5%90%8E%E5%85%A8%E4%B8%BA-1-%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">31.3.</span> <span class="nav-text">5434. 删掉一个元素以后全为 1 的最长子数组（中等）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8828%E6%97%A5-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">32.</span> <span class="nav-text">6月28日 209. 长度最小的子数组（中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8829%E6%97%A5-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">33.</span> <span class="nav-text">6月29日 215. 数组中的第K个最大元素（中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6%E6%9C%8830%E6%97%A5-%E5%89%91%E6%8C%87-Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">34.</span> <span class="nav-text">6月30日 剑指 Offer 09. 用两个栈实现队列</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Su Zhilong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Su Zhilong</p>
  <div class="site-description" itemprop="description">I will always be with you</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/suzhilong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;suzhilong"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Su Zhilong</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">379k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:44</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'uaEz4DL2UqM1jg1eGmpd8vhF-gzGzoHsz',
      appKey     : 'SzL1ETN5dDwbXjnzyJYJkjTb',
      placeholder: "comment",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
