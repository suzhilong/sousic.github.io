<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/apple-touch-icon-next.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="C++基础知识复习总结">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Review">
<meta property="og:url" content="https://github.com/suzhilong/suzhilong.github.io.git/2020/06/05/cppReview/index.html">
<meta property="og:site_name" content="SOUSIC">
<meta property="og:description" content="C++基础知识复习总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/08/05/2eGU6kMy8Xp5v4Y.png">
<meta property="og:image" content="https://i.loli.net/2020/08/27/ZNPO91H7jUeS6Ti.png">
<meta property="og:image" content="https://i.loli.net/2020/10/14/HijrufaCD6Rwebq.png">
<meta property="article:published_time" content="2020-06-05T08:00:00.000Z">
<meta property="article:modified_time" content="2020-10-21T11:48:06.357Z">
<meta property="article:author" content="Su Zhilong">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/08/05/2eGU6kMy8Xp5v4Y.png">

<link rel="canonical" href="https://github.com/suzhilong/suzhilong.github.io.git/2020/06/05/cppReview/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++ Review | SOUSIC</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="SOUSIC" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SOUSIC</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">哈库呐玛塔塔</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/suzhilong/suzhilong.github.io.git/2020/06/05/cppReview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Su Zhilong">
      <meta itemprop="description" content="I will always be with you">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SOUSIC">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ Review
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-05 16:00:00" itemprop="dateCreated datePublished" datetime="2020-06-05T16:00:00+08:00">2020-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-21 19:48:06" itemprop="dateModified" datetime="2020-10-21T19:48:06+08:00">2020-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/06/05/cppReview/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/05/cppReview/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>53k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>48 分钟</span>
            </span>
            <div class="post-description">C++基础知识复习总结</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="C-源文件到可执行文件的过程"><a href="#C-源文件到可执行文件的过程" class="headerlink" title="C++源文件到可执行文件的过程"></a>C++源文件到可执行文件的过程</h1><p>对于C&#x2F;C++编写的程序，从源代码到可执行文件，一般经过下面四个步骤：</p>
<ol>
<li>预处理，产生.ii文件<ul>
<li>对所有的“#define”进行宏展开；</li>
<li>处理所有的条件编译指令，比如“#if”,“#ifdef”，“#elif”，“#else”,“#endif”</li>
<li>处理“#include”指令，这个过程是递归的，也就是说被包含的文件可能还包含其他文件</li>
<li>删除所有的注释“&#x2F;&#x2F;”和“&#x2F;**&#x2F;”</li>
<li>添加行号和文件标识</li>
<li>保留所有的“#pragma”编译器指令</li>
</ul>
</li>
<li>编译，产生汇编文件(.s文件)<br> 编译的过程就是将预处理完的文件进行一系列<strong>词法分析</strong>，<strong>语法分析</strong>，<strong>语义分析</strong>及优化后生成相应的汇编代码文件(.s文件)</li>
<li>汇编，产生目标文件(.o或.obj文件)<br>汇编器是将汇编代码转变成机器可以执行的代码（二进制文件），每一个汇编语句几乎都对应一条机器指令。最终产生目标文件(.o或.obj文件)。</li>
<li>链接,产生可执行文件(.out或.exe文件)<br>链接的过程主要包括了地址和空间分配(Address and Storage Allocation)、符号决议(Symbol Resolution)和重定位(Relocation)</li>
</ol>
<h1 id="Clang-x2F-LLVM-x2F-lldb-x2F-GCC-x2F-gdb"><a href="#Clang-x2F-LLVM-x2F-lldb-x2F-GCC-x2F-gdb" class="headerlink" title="Clang&#x2F;LLVM&#x2F;lldb&#x2F;GCC&#x2F;gdb"></a>Clang&#x2F;LLVM&#x2F;lldb&#x2F;GCC&#x2F;gdb</h1><ul>
<li>Clang 是 LLVM <strong>编译器工具集</strong>的前端（front-end），目的是输出代码对应的抽象语法树（Abstract Syntax Tree, AST），并将代码编译成LLVM Bitcode。接着在后端（back-end）使用LLVM编译成平台相关的机器语言 。Clang支持C、C++、Objective C。</li>
<li>LLVM 提供了完整编译系统的中间层，它会将中间语言（Intermediate form，IF）从编译器取出与最优化，最优化后的 IF 接着被转换及链接到目标平台的汇编语言。LLVM 后端也可以接受来自GCC工具链所编译的 IF。</li>
<li>lldb 是 LLVM 调试器(断点原理)。lldb是个开源的内置于XCode的具有REPL(read-eval-print-loop)特征的Debugger，其可以安装C++或者Python插件。</li>
<li>GCC（GNU Compiler Collection）在所有平台上都使用同一个前端处理程序（支持很多语言），产生一样的中介码，因此此中介码在各个其他平台上使用GCC编译，有很大的机会可得到正确无误的输出程序。</li>
<li>gdb 是 GCC 调试器。UNIX及UNIX-like下的调试工具。</li>
</ul>
<p>ref <a target="_blank" rel="noopener" href="https://note.xianqiao.wang/post/clang-llvm-lldb-gcc-gdb-guan-xi">Clang&#x2F;LLVM&#x2F;lldb&#x2F;GCC&#x2F;gdb 关系</a></p>
<h1 id="头文件中的ifndef-x2F-define-x2F-endif有什么作用"><a href="#头文件中的ifndef-x2F-define-x2F-endif有什么作用" class="headerlink" title="头文件中的ifndef&#x2F;define&#x2F;endif有什么作用"></a>头文件中的ifndef&#x2F;define&#x2F;endif有什么作用</h1><p>这是C++预编译头文件保护符，保证即使文件被多次包含，头文件也只定义一次。</p>
<h1 id="typedef-和-define-有什么区别"><a href="#typedef-和-define-有什么区别" class="headerlink" title="typedef 和 define 有什么区别"></a>typedef 和 define 有什么区别</h1><ul>
<li>用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义常量，以及书写复杂使用频繁的宏。</li>
<li>执行时间不同：typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。</li>
<li>作用域不同：typedef 有作用域限定。define 不受作用域约束，只要是在 define 声明后的引用都是正确的。</li>
<li>对指针的操作不同：typedef 和 define 定义的指针时有很大的区别。</li>
</ul>
<p><em>注意：typedef 定义是语句，因为句尾要加上分号。而 define 不是语句，千万不能在句尾加分号。</em></p>
<h1 id="include-的顺序以及尖叫括号和双引号的区别"><a href="#include-的顺序以及尖叫括号和双引号的区别" class="headerlink" title="#include 的顺序以及尖叫括号和双引号的区别"></a>#include 的顺序以及尖叫括号和双引号的区别</h1><ul>
<li>#include的顺序的区别：<br>头文件的引用顺序对于程序的编译还是有一定影响的。如果要在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误，也就是常见的某行少个“；”符号。</li>
<li>#include尖括号和双引号的区别：  <ol>
<li>#include  &lt;&gt; ，认为该头文件是标准头文件。编译器将会在预定义的位置集查找该头文件，这些预定义的位置可以通过设置查找路径环境变量或者通过命令行选项来修改。使用的查找方式因编译器的不同而差别迥异。</li>
<li>#include “”，认为它是非系统头文件，非系统头文件的查找通常开始于源文件所在的路径。查找范围大于&lt;&gt;。</li>
</ol>
</li>
</ul>
<h1 id="main-函数执行以前，还会执行什么代码？"><a href="#main-函数执行以前，还会执行什么代码？" class="headerlink" title="main 函数执行以前，还会执行什么代码？"></a>main 函数执行以前，还会执行什么代码？</h1><p>全局对象的构造函数会在main 函数之前执行。</p>
<h1 id="内联函数和普通函数的区别"><a href="#内联函数和普通函数的区别" class="headerlink" title="内联函数和普通函数的区别"></a>内联函数和普通函数的区别</h1><ol>
<li>复杂程度不同：<br>内联函数比较简单，在内联函数中不允许使用循环语句和switch结果，带有异常接口声明的函数也不能声明为内联函数。</li>
<li>编译结果不同：<br>内联函数（有时称作在线函数或编译时期展开函数）是一种编程语言结构，用来建议编译器对一些特殊函数进行内联扩展（有时称作在线扩展）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文）。普通函数则会编译为单独的模块。</li>
<li>编译的时间不同：<br>对于基于C的编译系统，内联函数的使用可能大大增加编译时间，因为每个调用该函数的地方都需要替换成函数体，代码量的增加也同时带来了潜在的编译时间的增加。</li>
<li>运行的效率不同：<br>使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。</li>
</ol>
<h1 id="内联函数和宏定义的区别"><a href="#内联函数和宏定义的区别" class="headerlink" title="内联函数和宏定义的区别"></a>内联函数和宏定义的区别</h1><p>内联函数和宏的区别在于：</p>
<ul>
<li>宏是由预处理器对宏进行替代</li>
<li>内联函数是通过编译器控制来实现的</li>
</ul>
<p>而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。</p>
<p>内联函数与带参数的宏定义进行下比较，它们的代码效率是一样，但是内联函数要优于宏定义，因为内联函数遵循的类型和作用域规则，它与一般函数更相近，在一些编译器中，一旦关联上内联扩展，将与一般函数一样进行调用，比较方便。 </p>
<p>另外，宏定义在使用时只是简单的文本替换，并没有做严格的参数检查，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</p>
<p>C++的inline的提出就是为了完全取代宏定义，因为inline函数取消了宏定义的缺点，又很好地继承了宏定义的优点，《Effective C++》中就提到了尽量使用Inline替代宏定义的条款，足以说明inline的作用之大。</p>
<h1 id="定义MAX和MIN宏"><a href="#定义MAX和MIN宏" class="headerlink" title="定义MAX和MIN宏"></a>定义MAX和MIN宏</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define MAX(a,b) ((a) &gt; (b) ? (a) : (b))</span><br><span class="line">#define MIN(a,b) ((a) &lt; (b) ? (a) : (b))</span><br></pre></td></tr></table></figure>

<h1 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h1><p><strong>大端</strong>：高位存在低地址，低位存在高地址。</p>
<p><strong>小端</strong>：高位存在高地址，低位存在低地址。</p>
<p>大小端和CPU有关。</p>
<p>现代PC大多采用小段，所以<strong>小端字节序</strong>又被成为<strong>主机字节序</strong>。而<strong>大端字节序</strong>又被成为<strong>网络字节序</strong>。</p>
<p>判断大小端代码：</p>
<ul>
<li>方法一</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void byteOrder()&#123;</span><br><span class="line">	union</span><br><span class="line">	&#123;</span><br><span class="line">		short val;</span><br><span class="line">		char c_val[sizeof(short)];</span><br><span class="line">	&#125; test;</span><br><span class="line">	test.val = 0x0102;</span><br><span class="line">	if((test.c_val[0]==1) &amp;&amp; (test.c_val[1]==2))</span><br><span class="line">		cout &lt;&lt; &quot;Big endian&quot; &lt;&lt; endl;</span><br><span class="line">	else</span><br><span class="line">		cout &lt;&lt; &quot;Little endian&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void byteOrder()&#123;</span><br><span class="line">	int num = 0x0102;</span><br><span class="line">    char q = *(char *)&amp;num;</span><br><span class="line">    if (q == 0x02)</span><br><span class="line">		cout &lt;&lt; &quot;Little endian&quot; &lt;&lt; endl;</span><br><span class="line">	else</span><br><span class="line">        cout&lt;&lt;&quot;Big endian&quot; &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h1><ul>
<li>左值 (lvalue, locator value)：表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。</li>
<li>右值 (rvalue)：一个表达式不是 左值 就是 右值 。 那么，右值是一个 不 表示内存中某个可识别位置的对象的表达式。</li>
</ul>
<h2 id="左值引用-和-右值引用"><a href="#左值引用-和-右值引用" class="headerlink" title="左值引用 和 右值引用"></a>左值引用 和 右值引用</h2><p>C++11标准添加了右值引用(rvalue reference)，这种引用只能绑定右值，不能绑定左值，它使用两个&amp;&amp;来声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line"></span><br><span class="line">int&amp; b = a; //左值引用</span><br><span class="line">int&amp;&amp; c = 1; //右值引用</span><br><span class="line">int&amp;&amp; b = a; // 编译失败</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/">理解 C&#x2F;C++ 中的左值和右值</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/55229582">右值引用，移动语义，移动构造函数和移动赋值运算符</a></li>
</ul>
<h1 id="面向对象的三个基本特征"><a href="#面向对象的三个基本特征" class="headerlink" title="面向对象的三个基本特征"></a>面向对象的三个基本特征</h1><p>面向对象的三个基本特征是：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。<br><strong>封装</strong>可以隐藏实现细节，使得代码模块化；<strong>继承</strong>可以扩展已存在的代码模块（类）。它们的目的都是<strong>代码重用</strong>；而<strong>多态</strong>则是为了实现另一个目的——<strong>接口重用</strong>。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。</p>
<p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<p>不同的类成员访问修饰符权限：</p>
<table>
<thead>
<tr>
<th>访问修饰符</th>
<th align="center">同一个类</th>
<th align="center">同包</th>
<th align="center">不同包，子类</th>
<th align="center">不同包，非子类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td>public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td>默认</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>使用继承时需要注意：<br>1、子类拥有父类非private的属性和方法。<br>2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。<br>3、子类可以用自己的方式实现父类的方法。</p>
<h3 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h3><p>在C++中 struct和class唯一的区别就在于<strong>默认的继承访问权限</strong>不同。</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class 默认权限为私有</li>
</ul>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class listNode&#123;//链表类</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    listNode *next;</span><br><span class="line">    listNode(int a) : val(a), next(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct biTree&#123;二叉树结构</span><br><span class="line">    int val;</span><br><span class="line">    biTree *lc;</span><br><span class="line">    biTree *rc;</span><br><span class="line">    biTree(int x) : val(x), lc(nullptr), rc(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //链表</span><br><span class="line">	listNode *ln = new listNode(1);</span><br><span class="line">    listNode *cur = ln;</span><br><span class="line">    cur-&gt;next = new listNode(2);</span><br><span class="line">    cur = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = new listNode(3);</span><br><span class="line"></span><br><span class="line">	//二叉树</span><br><span class="line">    biTree parent(1);</span><br><span class="line">	biTree *root = new biTree(1);//也可以只有</span><br><span class="line">    biTree lc(2);</span><br><span class="line">    biTree rc(3);</span><br><span class="line">    parent.lc = &amp;lc;</span><br><span class="line">    parent.rc = &amp;rc;</span><br><span class="line"></span><br><span class="line">    biTree *root = &amp;parent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><p>构造函数和析构函数解决了<strong>对象的初始化和清理</strong>这两个非常重要的安全问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供构造函数和析构函数的空实现。</p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>
<ol>
<li>没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>
<ol>
<li>没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号 ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
<li>public、private、protected等权限控制对析构函数无效</li>
</ol>
<h4 id="构造函数与析构函数的特点"><a href="#构造函数与析构函数的特点" class="headerlink" title="构造函数与析构函数的特点"></a>构造函数与析构函数的特点</h4><ul>
<li>构造函数有如下特点：<ol>
<li>构造函数的名字必须与类名相同；</li>
<li>构造函数可以有任意类型的参数，但不能有返回类型；</li>
<li>定义对象时，编译系统会自动调用构造函数；</li>
<li>构造函数是特殊的成员函数，函数体可以在类体内也可以在类体外；</li>
<li>构造函数被声明为公有函数，但它不能像其他成员函数那样被显式调用，它是在定义对象的同时被调用的。</li>
</ol>
</li>
<li>析构函数有如下特点：<ol>
<li>析构函数的名字必须与类名相同，但它前面必须加一个波浪号；</li>
<li>析构函数没有参数，也没有返回值，而且不能被重载，因此在一个类中只能有一个析构函数；</li>
<li>当撤销对象时，编译系统会自动调用析构函数；</li>
<li>析构函数可以是virtual，而构造函数不能是虚函数。</li>
</ol>
</li>
</ul>
<h4 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h4><p>两种分类方式：</p>
<ul>
<li>按参数分为： 有参构造和无参构造</li>
<li>按类型分为： 普通构造和拷贝构造<br><em>ps. 有参构造有的可能会成为类型转换构造函数，比如在隐式转换调用的时候</em></li>
</ul>
<p>三种调用方式：</p>
<ul>
<li>括号法</li>
<li>显示法</li>
<li>隐式转换法</li>
</ul>
<p>构造函数分类示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span><br><span class="line">// 按照类型分类分为 普通构造和拷贝构造</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	//无参（默认）构造函数</span><br><span class="line">	Person() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	//有参构造函数</span><br><span class="line">	Person(int a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	//拷贝构造函数</span><br><span class="line">	Person(const Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	//析构函数</span><br><span class="line">	~Person() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>构造函数的调用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//调用无参构造函数</span><br><span class="line">void test01() &#123;</span><br><span class="line">	Person p; //调用无参构造函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用有参的构造函数</span><br><span class="line">void test02() &#123;</span><br><span class="line"></span><br><span class="line">	//2.1  括号法，常用</span><br><span class="line">	Person p1(10);</span><br><span class="line">	//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span><br><span class="line">	//Person p2();</span><br><span class="line"></span><br><span class="line">	//2.2 显式法</span><br><span class="line">	Person p2 = Person(10); </span><br><span class="line">	Person p3 = Person(p2);</span><br><span class="line">	//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span><br><span class="line"></span><br><span class="line">	//2.3 隐式转换法</span><br><span class="line">	Person p4 = 10; // Person p4 = Person(10); </span><br><span class="line">	Person p5 = p4; // Person p5 = Person(p4); </span><br><span class="line"></span><br><span class="line">	//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span><br><span class="line">	//Person p5(p4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line">	//test02();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拷贝构造函数和赋值运算符的认识"><a href="#拷贝构造函数和赋值运算符的认识" class="headerlink" title="拷贝构造函数和赋值运算符的认识"></a>拷贝构造函数和赋值运算符的认识</h4><p>拷贝构造函数和赋值运算符重载有以下两个不同之处：</p>
<ul>
<li>拷贝构造函数生成新的类对象，而赋值运算符不能。</li>
<li>由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对象之前不用检验源对象是否和新建对象相同。而赋值运算符则需要这个操作，另外赋值运算中如果原来的对象中有内存分配要先把内存释放掉</li>
</ul>
<p><em>注意：当有类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符，不要使用默认的。</em></p>
<h4 id="构造函数和析构函数可以是虚函数吗？"><a href="#构造函数和析构函数可以是虚函数吗？" class="headerlink" title="构造函数和析构函数可以是虚函数吗？"></a>构造函数和析构函数可以是虚函数吗？</h4><ol>
<li><p>构造函数不能是虚函数</p>
<ul>
<li>存储空间角度<br>虚函数的调用需要 vptr 指针，而该指针存放在对象的内容空间中，需要调用构造函数才可以创建它的值，否则即使开辟了空间，该 vptr 指针为随机值；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有 vptr 地址用来调用虚函数之一的构造函数了。</li>
<li>使用，多态角度<br>虚函数主要是实现多态，在运行时才可以明确调用对象，根据传入的对象类型来调用函数，例如通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。那使用虚函数也没有实际意义。  </li>
<li>从实现角度<br>vtable在构造函数调用后才建立，所以构造函数不能是虚函数。在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，没有必要成为虚函数。</li>
</ul>
</li>
<li><p>析构函数常常是虚函数<br>创建一个对象时我们总是要明白指定对象的类型。虽然我们可能通过基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候假设析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。<br>如果基类的析构函数不是虚函数，派生类的析构函数用不上，会造成资源的泄漏。</p>
</li>
</ol>
<h4 id="构造函数和析构函数，可以调用其他的虚函数吗？"><a href="#构造函数和析构函数，可以调用其他的虚函数吗？" class="headerlink" title="构造函数和析构函数，可以调用其他的虚函数吗？"></a>构造函数和析构函数，可以调用其他的虚函数吗？</h4><p>《Effective C++》条款09：绝不在构造函数或析构函数中调用虚函数。</p>
<p>从语法上讲，调用完全没有问题。</p>
<p>但是从效果上看，往往不能达到需要的目的：派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。同样，进入基类析构函数时，对象也是基类类型。所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。</p>
<h4 id="子类和父类中，构造函数和析构函数的调用顺序是什么？"><a href="#子类和父类中，构造函数和析构函数的调用顺序是什么？" class="headerlink" title="子类和父类中，构造函数和析构函数的调用顺序是什么？"></a>子类和父类中，构造函数和析构函数的调用顺序是什么？</h4><ul>
<li>构造时，先调用父类构造函数，再调用子类构造函数</li>
<li>析构时，先调用子类析构函数，再调用父类析构函数</li>
</ul>
<p><strong>ps.</strong></p>
<ul>
<li>若一个类包含对象成员，在建立该类的对象时，先调用对象成员的构造函数，初始化相应的对象成员，然后才执行该类的构造函数。</li>
<li>如果一个类包含多个对象成员，对象成员的构造函数的调用顺序由它们在该类中的说明顺序决定，而它们在初始化表中的顺序无关。</li>
</ul>
<h4 id="虚析构函数有什么作用？"><a href="#虚析构函数有什么作用？" class="headerlink" title="虚析构函数有什么作用？"></a>虚析构函数有什么作用？</h4><ul>
<li>析构函数的工作方式是：最底层的派生类的析构函数最先被调用，然后调用每一个基类的析构函数；</li>
<li>在C++中，当一个派生类对象通过使用一个基类指针删除，而这个基类有一个非虚的析构函数，则可能导致运行时派生类不能被销毁。然而基类部分很有可能已经被销毁，这就导致“部分析构”现象，造成内存泄漏；</li>
<li>给基类一个虚析构函数，删除一个派生类对象的时候就将销毁整个对象，包括父类和全部的派生类部分。</li>
</ul>
<h4 id="拷贝构造函数在什么情况下会自动被调用"><a href="#拷贝构造函数在什么情况下会自动被调用" class="headerlink" title="拷贝构造函数在什么情况下会自动被调用"></a>拷贝构造函数在什么情况下会自动被调用</h4><ul>
<li>当类的一个对象去初始化该类的另一个对象时；</li>
<li>如果函数的形参是类的对象，调用函数进行形参和实参结合时；</li>
<li>如果函数的返回值是类对象，函数调用完成返回时。</li>
</ul>
<h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><ul>
<li><p>浅拷贝：简单的赋值拷贝操作。使用默认拷贝构造函数，拷贝过程中是按字节复制的，对于指针型成员变量只复制指针本身，而不复制指针所指向的目标，因此涉及堆区开辟内存时，会将两个成员属性指向相同的内存空间，从而在释放时导致内存空间被多次释放。</p>
</li>
<li><p>深拷贝：在堆区重新申请空间，进行拷贝操作。自定义拷贝构造函数，在堆内存中另外申请空间来储存数据，从而解决指针悬挂的问题。需要注意自定义析构函数中应该释放掉申请的内存。</p>
</li>
</ul>
<p>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的重复释放堆区问题。</p>
<p>拷贝构造函数的参数必须加const，因为防止修改，本来就是用现有的对象初始化新的对象。</p>
<p><em>ps. 在定义类或者结构体，这些结构的时候，最后都重写拷贝函数，避免浅拷贝这类不易发现但后果严重的错误产生</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//拷贝构造函数  </span><br><span class="line">Person(const Person&amp; p) &#123;</span><br><span class="line">  cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">  //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span><br><span class="line">  m_age = p.m_age;</span><br><span class="line">  m_height = new int(*p.m_height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//析构函数</span><br><span class="line">~Person() &#123;</span><br><span class="line">  cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">  if (m_height != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    delete m_height;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为<strong>对象成员</strong>。</p>
<p>当类中有对象成员时，构造的顺序是：<strong>先调用对象成员的构造，再调用本类构造。析构顺序与构造相反</strong>。<br>如：B类中有对象A作为成员，A为对象成员。那么当创建B对象时，先调用A的构造，再调用B的构造。结束时先析构B，再析构A。</p>
<h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>成员变量和成员函数前加上关键字static，称为静态成员。<br>静态成员变量：</p>
<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
<p>静态成员函数：</p>
<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
<p>静态成员两种访问方式：</p>
<ol>
<li>通过对象。如：p1.m_A</li>
<li>通过类名。如：Person::m_B（私有权限访问不到）</li>
</ol>
<h4 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h4><ul>
<li>非静态成员变量占对象空间。int mA;</li>
<li>静态成员变量不占对象空间。static int mB; </li>
<li>函数也不占对象空间，所有函数共享一个函数实例。每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">	cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>静态成员函数也不占对象空间</li>
</ul>
<h3 id="对象模型和this指针"><a href="#对象模型和this指针" class="headerlink" title="对象模型和this指针"></a>对象模型和this指针</h3><h4 id="this指针概念"><a href="#this指针概念" class="headerlink" title="this指针概念"></a>this指针概念</h4><p>在类实例化对象时，只有非静态成员变量属于对象本身，剩余的静态成员变量，静态函数，非静态函数都不属于对象本身，因此非静态成员函数只会实例一份，多个同类型对象会共用一块代码。c++通过提供特殊的对象指针——this指针——区分调用自己的对象。this指针指向被调用的成员函数所属的对象。  </p>
<p>this指针的本质是一个指针常量，指针的指向不可修改。this的目的总是指向这个对象，  </p>
<p>this 是一个指向类的实例的一个指针，指向该实例的首地址，但是 this 不是 该对象实例的一部分，即在sizeof（某对象）中不包含this指针的大小。</p>
<h4 id="this指针的作用"><a href="#this指针的作用" class="headerlink" title="this指针的作用"></a>this指针的作用</h4><p>this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来做到这一点，因为this所指的正是这个对象。任何对类成员的直接访问都被看成this的隐式使用。</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用<code>return *this</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Person(int age)</span><br><span class="line">	&#123;</span><br><span class="line">		//1、当形参和成员变量同名时，可用this指针来区分</span><br><span class="line">		this-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person&amp; PersonAddPerson(Person p)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;age += p.age;</span><br><span class="line">		//返回对象本身</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="this-指针需要注意的地方。"><a href="#this-指针需要注意的地方。" class="headerlink" title="this 指针需要注意的地方。"></a>this 指针需要注意的地方。</h4><ul>
<li>this 指针只能用于成员函数，成员变量，对于静态函数和静态变量，是不允许使用this（因为静态函数或变量，都是属于对象本身，即所有实例都可以访问他们，但是this只是指向自身实例的地址，是一个个例。）</li>
<li>友元函数也没有this指针。(友元函数至少需要一个参数)</li>
<li>this引用成员变量用法有二： <code>this-&gt;val</code> 或者 <code>(*this).val.</code> 这就像指针引用类似。</li>
</ul>
<h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>友元的目的就是让一个函数或者类访问另一个类中私有成员（包括属性和方法），会破坏C++的封装性，尽量不使用。</p>
<p>友元的关键字为 <code>friend</code></p>
<p>友元的三种实现：</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。</p>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承方式一共有三种：</p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<h3 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h3><p>继承中，先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
<h3 id="继承同名成员处理方式"><a href="#继承同名成员处理方式" class="headerlink" title="继承同名成员处理方式"></a>继承同名成员处理方式</h3><p>当子类与父类出现同名的成员，通过子类对象访问子类或父类中同名的数据的方法：</p>
<ul>
<li>访问<strong>子类</strong>同名成员：直接访问即可</li>
<li>访问<strong>父类</strong>同名成员：需要加作用域</li>
</ul>
<p><em>ps. 同名静态成员处理方式和非静态处理方式一样</em></p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>C++允许一个类继承多个类<br>语法：<code>class子类：继承方式 父类1，继承方式 父类2...</code></p>
<p><em>ps. 多继承可能会引发父类中有同名成员出现，需要加作用域区分</em></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<p>多态性允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。</p>
<p>简而言之就是用<strong>父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数</strong>。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。</p>
<h3 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h3><ul>
<li>当类中存在虚函数时，编译器会在类中自动生成一个虚函数表</li>
<li>虚函数表是一个存储类成员函数指针的数据结构</li>
<li>虚函数表由编译器自动生成和维护</li>
<li>virtual 修饰的成员函数会被编译器放入虚函数表中</li>
<li>存在虚函数时，编译器会为对象自动生成一个指向虚函数表的指针（通常称之为 vptr 指针）</li>
</ul>
<h3 id="多态实现的三个条件"><a href="#多态实现的三个条件" class="headerlink" title="多态实现的三个条件"></a>多态实现的三个条件</h3><ol>
<li>要有继承</li>
<li>要有虚函数重写</li>
<li>要有父类指针指（父类引用）向子类对象</li>
</ol>
<h3 id="多态分为两类（实现多态的两种方法）"><a href="#多态分为两类（实现多态的两种方法）" class="headerlink" title="多态分为两类（实现多态的两种方法）"></a>多态分为两类（实现多态的两种方法）</h3><ul>
<li>重载——静态多态：<strong>函数重载</strong> 和 <strong>运算符重载</strong> 属于静态多态，复用函数名</li>
<li>重写（覆盖）——动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li>
</ul>
<p>其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。<br>如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。</p>
<p>也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚邦定）。</p>
<p>结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关。</p>
<h3 id="动态多态代码示例"><a href="#动态多态代码示例" class="headerlink" title="动态多态代码示例"></a>动态多态代码示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">		virtual void Print() = 0;</span><br><span class="line">		virtual ~Base()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class child_1 : public Base</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">	void Print()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;child_1 Print function&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~child_1()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;child_1 destructor function&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class child_2: public Base</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">		void Print()</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; &quot;child_2 Print function&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		~child_2()</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; &quot;child_2 destructor function&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Base *p = new child_1; //父类指针指向子类对象</span><br><span class="line">	p-&gt;Print();</span><br><span class="line">	delete p;  //记住释放,否则内存泄露</span><br><span class="line">	p = new child_2;</span><br><span class="line">	p-&gt;Print();</span><br><span class="line">	delete p;</span><br><span class="line">	p = NULL;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态多态代码示例"><a href="#静态多态代码示例" class="headerlink" title="静态多态代码示例"></a>静态多态代码示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//宏多态：a,b可以不同类型</span><br><span class="line">#define  sum(a,b)  ((a) + (b))</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">		void Print() //不需要定义为虚函数</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; &quot;base Print() functions&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		void Print(int val) //重载,根据参数列表不同实现函数多态</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; &quot;base Print(int) functions&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class child : public Base</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">		void Print() //不需要定义为虚函数</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; &quot;child Print() functions&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		void Print(int val) //重载,根据参数列表不同实现函数多态</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; &quot;child Print(int) functions&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	p.Print();</span><br><span class="line">	p.Print(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Base base ;</span><br><span class="line">	child ch;</span><br><span class="line">	int a = 23, b = 19;</span><br><span class="line">	double fa = 13.32, fb = 29.36;</span><br><span class="line">	func(base);</span><br><span class="line">	func(ch);</span><br><span class="line"></span><br><span class="line">	//宏多态：a,b可以不同类型</span><br><span class="line">	cout &lt;&lt; sum(a,b) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; sum(fa,fb) &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><ul>
<li>虚函数的作用主要是实现了多态的机制。</li>
<li>定义一个函数为虚函数，不代表函数为不被实现的函数。定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。</li>
<li>定义一个函数为纯虚函数，才代表函数没有被实现。定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</li>
<li>虚函数的功能是使子类可以用同名的函数对父类函数进行覆盖，并且在通过父类指针调用时，如果有覆盖则自动调用子类覆盖函数，如果没有覆盖则调用父类中的函数，从而实现灵活扩展和多态性；</li>
<li>如果是纯虚函数，则纯粹是为了在子类覆盖时有个统一的命名而已，子类必须覆盖纯虚函数，则否子类也是抽象类；</li>
<li>含有纯虚函数的类称为抽象类，不能实例化对象，主要用作接口类。</li>
</ul>
<p>示例：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void foo()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;A::foo() is called&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B:public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void foo()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;B::foo() is called&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    A *a = new B();</span><br><span class="line">    a-&gt;foo();   // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为<strong>纯虚函数</strong>。<br>当类中有了纯虚函数，这个类也称为<strong>抽象类</strong></p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0;</code></p>
<p>注意：</p>
<ol>
<li>纯虚函数没有函数体</li>
<li>最后的<code>=0</code>并不是表示返回值为0，只是形式上的作用，告诉编译系统<code>这是虚函数</code></li>
<li>这是一个声明，最后有分号</li>
</ol>
<h4 id="抽象类特点："><a href="#抽象类特点：" class="headerlink" title="抽象类特点："></a>抽象类特点：</h4><ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
<li>类中只要有一个纯虚函数就称为抽象类</li>
</ul>
<h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码。<br>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：<br><code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法：<br><code>virtual ~类名() = 0;</code><br><code>类名::~类名()&#123;&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Animal()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void Speak() = 0;</span><br><span class="line"></span><br><span class="line">	//析构函数加上virtual关键字，变成虚析构函数</span><br><span class="line">	//virtual ~Animal()</span><br><span class="line">	//&#123;</span><br><span class="line">	//	cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">	//&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	virtual ~Animal() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~Animal()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚基类和虚继承"><a href="#虚基类和虚继承" class="headerlink" title="虚基类和虚继承"></a>虚基类和虚继承</h3><p>多继承（Multiple Inheritance）是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。</p>
<p>多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是<strong>菱形继承</strong>。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//间接基类A</span><br><span class="line">class A&#123;</span><br><span class="line">protected:</span><br><span class="line">    int m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//直接基类B</span><br><span class="line">class B: public A&#123;</span><br><span class="line">protected:</span><br><span class="line">    int m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//直接基类C</span><br><span class="line">class C: public A&#123;</span><br><span class="line">protected:</span><br><span class="line">    int m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//派生类D</span><br><span class="line">class D: public B, public C&#123;</span><br><span class="line">public:</span><br><span class="line">    void seta(int a)&#123; m_a = a; &#125;  //命名冲突</span><br><span class="line">    void setb(int b)&#123; m_b = b; &#125;  //正确</span><br><span class="line">    void setc(int c)&#123; m_c = c; &#125;  //正确</span><br><span class="line">    void setd(int d)&#123; m_d = d; &#125;  //正确</span><br><span class="line">private:</span><br><span class="line">    int m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    D d;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>虚继承</strong>目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为<strong>虚基类</strong>（Virtual Base Class），继承的时候用关键字<code>virtual</code>声明。</p>
<p><strong>虚继承</strong>主要用来解决继承中的二义性问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//间接基类A</span><br><span class="line">class A&#123;</span><br><span class="line">protected:</span><br><span class="line">    int m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//直接基类B</span><br><span class="line">class B: virtual public A&#123;  //虚继承</span><br><span class="line">protected:</span><br><span class="line">    int m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//直接基类C</span><br><span class="line">class C: virtual public A&#123;  //虚继承</span><br><span class="line">protected:</span><br><span class="line">    int m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//派生类D</span><br><span class="line">class D: public B, public C&#123;</span><br><span class="line">public:</span><br><span class="line">    void seta(int a)&#123; m_a = a; &#125;  //正确</span><br><span class="line">    void setb(int b)&#123; m_b = b; &#125;  //正确</span><br><span class="line">    void setc(int c)&#123; m_c = c; &#125;  //正确</span><br><span class="line">    void setd(int d)&#123; m_d = d; &#125;  //正确</span><br><span class="line">private:</span><br><span class="line">    int m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    D d;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ref. <a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/biancheng/view/238.html">C++虚继承和虚基类</a></p>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>虚函数表是指在每个包含虚函数的类中都存在着一个函数地址的数组。当我们用父类的指针来操作一个子类的时候，这张虚函数表指明了实际所应该调用的函数。</p>
<p>虚函数表指针vptr一般存储在对象实例的最开头，里面又虚函数表vtable的地址。虚函数表vtable在Linux&#x2F;Unix中存放在可执行文件的只读数据段 .<strong>rodata</strong> 中<br><img src="https://i.loli.net/2020/08/05/2eGU6kMy8Xp5v4Y.png" alt="虚函数表的存储"></p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref."></a>ref.</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/afei__/article/details/82142775">多态的实现原理分析</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104605966">C++ 一篇搞懂多态的实现原理</a></li>
<li><a target="_blank" rel="noopener" href="https://songlee24.github.io/2014/09/02/cpp-virtual-table/">C++进阶之虚函数表</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yunlambert/p/9876564.html">C++虚函数表</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jiary5201314/article/details/52627630">虚函数表存放在哪里</a></li>
</ul>
<h3 id="多态用法示例"><a href="#多态用法示例" class="headerlink" title="多态用法示例"></a>多态用法示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//抽象CPU类</span><br><span class="line">class CPU</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//抽象的计算函数</span><br><span class="line">	virtual void calculate() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//抽象显卡类</span><br><span class="line">class VideoCard</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//抽象的显示函数</span><br><span class="line">	virtual void display() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//抽象内存条类</span><br><span class="line">class Memory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//抽象的存储函数</span><br><span class="line">	virtual void storage() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//电脑类</span><br><span class="line">class Computer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Computer(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">	&#123;</span><br><span class="line">		m_cpu = cpu;</span><br><span class="line">		m_vc = vc;</span><br><span class="line">		m_mem = mem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//提供工作的函数</span><br><span class="line">	void work()</span><br><span class="line">	&#123;</span><br><span class="line">		//让零件工作起来，调用接口</span><br><span class="line">		m_cpu-&gt;calculate();</span><br><span class="line"></span><br><span class="line">		m_vc-&gt;display();</span><br><span class="line"></span><br><span class="line">		m_mem-&gt;storage();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//提供析构函数 释放3个电脑零件</span><br><span class="line">	~Computer()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		//释放CPU零件</span><br><span class="line">		if (m_cpu != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			delete m_cpu;</span><br><span class="line">			m_cpu = NULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//释放显卡零件</span><br><span class="line">		if (m_vc != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			delete m_vc;</span><br><span class="line">			m_vc = NULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//释放内存条零件</span><br><span class="line">		if (m_mem != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			delete m_mem;</span><br><span class="line">			m_mem = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">	CPU * m_cpu; //CPU的零件指针</span><br><span class="line">	VideoCard * m_vc; //显卡零件指针</span><br><span class="line">	Memory * m_mem; //内存条零件指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//具体厂商</span><br><span class="line">//Intel厂商</span><br><span class="line">class IntelCPU :public CPU</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void calculate()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IntelVideoCard :public VideoCard</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void display()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IntelMemory :public Memory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void storage()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//Lenovo厂商</span><br><span class="line">class LenovoCPU :public CPU</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void calculate()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LenovoVideoCard :public VideoCard</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void display()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LenovoMemory :public Memory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void storage()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	//第一台电脑零件</span><br><span class="line">	CPU * intelCpu = new IntelCPU;</span><br><span class="line">	VideoCard * intelCard = new IntelVideoCard;</span><br><span class="line">	Memory * intelMem = new IntelMemory;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;</span><br><span class="line">	//创建第一台电脑</span><br><span class="line">	Computer * computer1 = new Computer(intelCpu, intelCard, intelMem);</span><br><span class="line">	computer1-&gt;work();</span><br><span class="line">	delete computer1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;</span><br><span class="line">	//第二台电脑组装</span><br><span class="line">	Computer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;</span><br><span class="line">	computer2-&gt;work();</span><br><span class="line">	delete computer2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;</span><br><span class="line">	//第三台电脑组装</span><br><span class="line">	Computer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;</span><br><span class="line">	computer3-&gt;work();</span><br><span class="line">	delete computer3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>主要用来解决命名冲突的问题</p>
<ul>
<li>必须在全局作用域下声明</li>
<li>命名空间下可以放函数，变量、结构体和类</li>
<li>命名空间可以嵌套命名空间</li>
<li>命名空间是开放的，可以随时加入新成员（添加时只需要再次声明namespace，然后添加新成员即可</li>
</ul>
<h3 id="（作用域运算符）"><a href="#（作用域运算符）" class="headerlink" title="::（作用域运算符）"></a><code>::</code>（作用域运算符）</h3><ul>
<li>全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li>
<li>类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的</li>
<li>命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的</li>
</ul>
<h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><ul>
<li>using声明<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using std::cout;</span><br></pre></td></tr></table></figure></li>
<li>using编译指令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><em>ps. 尽量使用声明而不是编译指令，不同命名空间中可能会有相同的变量名，编译指令执行两个命名空间后，会产生二义性</em></p>
<h2 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h2><p><a href="https://github.com/AnkerLeng/Cpp-0-1-Resource/blob/master/%E7%AC%AC3%E9%98%B6%E6%AE%B5-C%2B%2B%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%20%E8%B5%84%E6%96%99/%E8%AE%B2%E4%B9%89/C%2B%2B%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B.md">C++核心编程</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/ma1kong/article/details/4457044">面向对象的三大特性</a></p>
<h1 id="函数重载（overload）、重写（override，也叫覆盖）和隐藏（也叫重定义）"><a href="#函数重载（overload）、重写（override，也叫覆盖）和隐藏（也叫重定义）" class="headerlink" title="函数重载（overload）、重写（override，也叫覆盖）和隐藏（也叫重定义）"></a>函数重载（overload）、重写（override，也叫覆盖）和隐藏（也叫重定义）</h1><h2 id="重载（overload）"><a href="#重载（overload）" class="headerlink" title="重载（overload）"></a>重载（overload）</h2><p>当函数具有相同的名称，但是参数列表不相同的情形（包括参数的个数不同或参数的类型不同），这样的同名而不同参数的函数之间，互相被称之为重载函数。<br>(函数名相同，参数列表不同，overload只是在类的内部存在)<br>特征：</p>
<ol>
<li>具有相同的作用域（即同一个类定义中）；</li>
<li>函数名字相同；</li>
<li>函数参数 <strong>类型不同</strong> 或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong>；</li>
<li>virtual 关键字可有可无；</li>
<li>返回类型也可以不同。<br><em>ps:函数的访问权限、返回类型、抛出的异常不可以作为函数重载的条件</em></li>
</ol>
<p>函数重载实例判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">以下的集中写法，分别表示了哪些是重载的，哪些不是重载的。</span><br><span class="line">(1) void func1( int arg1);</span><br><span class="line">(2) void func1( double arg1);</span><br><span class="line">(3) void func1( int arg1, int arg2);</span><br><span class="line">(4) bool func1(int arg1, double arg2)</span><br><span class="line">(5) int func1(int arg1);</span><br><span class="line"></span><br><span class="line">在上述的5个函数中，函数名称都是func1，完全相同；但是：</span><br><span class="line">(2)与(1)的参数个数相同，参数类型不同，构成重载；</span><br><span class="line">(3)与(1)和(2)的参数个数不同，构成重载；</span><br><span class="line">(4)与(1)和(2)的参数个数不同，与(3)的参数个数相同，但是第二个参数类型不同，构成重载；</span><br><span class="line">(5)与(1)的参数个数和参数类型均相同，仅返回值的类型不相同，不构成重载；但是(5)与(2),(3)和(4)除返回值不同外，均有参数类型或参数个数不同的情况，因此构成重载关系。</span><br></pre></td></tr></table></figure>

<h2 id="重写（覆盖，override）"><a href="#重写（覆盖，override）" class="headerlink" title="重写（覆盖，override）"></a>重写（覆盖，override）</h2><p>重写（覆盖）是指派生类重新实现（或者改写）基类的成员函数，在继承关系之间。C++利用虚函数实现多态。其特征是：</p>
<ol>
<li>不同的<strong>作用域</strong>（分别位于派生类和基类中）；</li>
<li>完全相同的<strong>函数名</strong>，<strong>参数列表</strong> 和 <strong>返回类型</strong>；</li>
<li>基类函数必须是虚函数。即<strong>必须有virtual</strong>关键字，不能是static；</li>
<li>重写函数的<strong>访问修饰符</strong>可以不同。尽管父类的virtual方法是private的，派生类中重写改写为public、protected也是可以的；</li>
</ol>
<p>重写（override）代码示例：B中fun1重写了A中的fun1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fun1(int, int)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B : class A&#123;</span><br><span class="line">public:</span><br><span class="line">    void fun1(int, int)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="隐藏（重定义）"><a href="#隐藏（重定义）" class="headerlink" title="隐藏（重定义）"></a>隐藏（重定义）</h2><p>子类重新定义父类有相同名称的非虚函数(参数列表可以不同)。</p>
<ol>
<li>不在同一个<strong>作用域</strong>（分别位于派生类与基类） ；</li>
<li>函数<strong>名字相同</strong>，<strong>返回值可以不同</strong>；</li>
<li>函数名相同但<strong>参数不同</strong>。如果派生类的函数和基类的函数同名，但是参数不同，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载以及覆盖混淆）；</li>
<li>函数名相同且<strong>参数相同</strong>，但是基类函数没有 virtual关键字。此时，基类的函数被隐藏（否则就是重写了）。</li>
</ol>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序:"></a>示例程序:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void A(int x)&#123; cout &lt;&lt; &quot;Base::A(int)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    void A(float x)&#123; cout &lt;&lt; &quot;Base::A(float)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B(void)&#123; cout &lt;&lt; &quot;Base::B(void)&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void C(float x)&#123; cout &lt;&lt; &quot;Base::C(float)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void D(float x)&#123; cout &lt;&lt; &quot;Base::D(float)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    void E(float x)&#123; cout &lt;&lt; &quot;Base::E(float) &quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void B(void)&#123; cout &lt;&lt; &quot;Derived::B(void)&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void C(float x)&#123; cout &lt;&lt; &quot;Derived::C(float)&quot; &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void D(int x)&#123; cout &lt;&lt; &quot;Derived::D(int)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    void E(float x)&#123; cout &lt;&lt; &quot;Derived::E(float)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>重载：函数Base::A(int)与Base::A(float)相互重载</li>
<li>重写：函数Derived::B(void)重写了Base::B(void)，函数Derived::C(float)重写了Base::C(float)</li>
<li>隐藏：函数Derived:: D(int)隐藏了Base:: D(float)，函数Derived::E(float)隐藏了Base::E(float)</li>
</ul>
<h2 id="ref-2"><a href="#ref-2" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26437925/article/details/54933326">C++ 类成员函数的重载(overload)，重写&#x2F;覆盖(override)，隐藏</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/-Mr-y/p/8352074.html#_lab2_1_1">函数重载(overload)和函数重写(override)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luxiaoxun/archive/2012/08/09/2630751.html">C++的重载（overload）与重写（override）</a></li>
</ul>
<h1 id="函数模板与函数重载的异同？"><a href="#函数模板与函数重载的异同？" class="headerlink" title="函数模板与函数重载的异同？"></a>函数模板与函数重载的异同？</h1><ul>
<li>函数的重载是指定义了几个名字相同，但参数的类型或参数的个数不同的函数；</li>
<li>模板函数是指的几个函数的具体算法相同，而参数类型不同的函数；</li>
<li>模板函数可以减少重载函数，但也可能引发错误。</li>
</ul>
<h1 id="C-中的空类，默认会产生哪些类成员函数"><a href="#C-中的空类，默认会产生哪些类成员函数" class="headerlink" title="C++中的空类，默认会产生哪些类成员函数"></a>C++中的空类，默认会产生哪些类成员函数</h1><ul>
<li>默认构造函数 </li>
<li>析构函数 </li>
<li>拷贝构造函数 </li>
<li>赋值运算符（operator&#x3D;） </li>
<li>取址运算符（operator&amp;）（一对，一个非const的，一个const的）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Empty</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    Empty(); // 缺省构造函数</span><br><span class="line">    Empty( const Empty&amp; ); // 拷贝构造函数</span><br><span class="line">    ~Empty(); // 析构函数</span><br><span class="line">    Empty&amp; operator=( const Empty&amp; ); // 赋值运算符</span><br><span class="line">    Empty* operator&amp;(); // 取址运算符</span><br><span class="line">    const Empty* operator&amp;() const; // 取址运算符 const</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="类在内存中的存储方式"><a href="#类在内存中的存储方式" class="headerlink" title="类在内存中的存储方式"></a>类在内存中的存储方式</h1><ul>
<li>类的静态成员变量编译时被分配到静态&#x2F;全局区，因此静态成员变量是属于类的，所有对象共用一份，不计入类的内存空间</li>
<li>静态成员函数和非静态成员函数都是存放在代码区的，是属于类的，类可以直接调用静态成员函数，不可以直接调用非静态成员函数，两者主要的区别是有无this指针</li>
<li>派生类对象的存储空间 &#x3D; 基类存储空间 + 派生类特有的非static数据成员的空间<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/103384358">C++类在内存中的存储方式</a></li>
</ul>
<h1 id="类成员变量的初始化顺序"><a href="#类成员变量的初始化顺序" class="headerlink" title="类成员变量的初始化顺序"></a>类成员变量的初始化顺序</h1><p>成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/littleswan/p/12511022.html">C++类成员变量的初始化顺序</a></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><img src="https://i.loli.net/2020/08/27/ZNPO91H7jUeS6Ti.png" alt="数据类型"></p>
<h1 id="sizeof-与-strlen-的区别"><a href="#sizeof-与-strlen-的区别" class="headerlink" title="sizeof 与 strlen 的区别"></a>sizeof 与 strlen 的区别</h1><ul>
<li>sizeof是一个操作符，而strlen是库函数。</li>
<li>sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为’\0’的字符串作参数。</li>
<li>编译器在编译时就计算出了sizeof的结果，而strlen必须在运行时才能计算出来。</li>
<li>sizeof计算数据类型占内存的大小，strlen计算字符串实际长度。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; strlen(&quot;123&quot;) &lt;&lt; endl; //3</span><br><span class="line">cout &lt;&lt; sizeof(&quot;123&quot;) &lt;&lt; endl; //4</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="strcpy-和-memcpy-的区别"><a href="#strcpy-和-memcpy-的区别" class="headerlink" title="strcpy 和 memcpy 的区别"></a>strcpy 和 memcpy 的区别</h1><p>strcpy 和 memcpy 都是标准C库函数</p>
<h2 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h2><p>strcpy提供了字符串的复制。即strcpy只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符。</p>
<p><code>char* strcpy(char* dest, const char* src);</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char * strcpy(char * dest, const char * src) // 实现src到dest的复制</span><br><span class="line">&#123;</span><br><span class="line">　　if ((src == NULL) || (dest == NULL)) //判断参数src和dest的有效性</span><br><span class="line">　　　　　　return NULL;</span><br><span class="line">　　char *strdest = dest;        //保存目标字符串的首地址</span><br><span class="line">　　while ((*strDest++ = *strSrc++)!=&#x27;\0&#x27;); //把src字符串的内容复制到dest下</span><br><span class="line">　　return strdest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h2><p>memcpy提供了一般内存的复制。即memcpy对于需要复制的内容没有限制，因此用途更广。</p>
<p><code>void *memcpy( void *dest, const void *src, size_t count );</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *memTo, const void *memFrom, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">　　if((memTo == NULL) || (memFrom == NULL)) //memTo和memFrom必须有效</span><br><span class="line">         return NULL;</span><br><span class="line">　　char *tempFrom = (char *)memFrom;             //保存memFrom首地址</span><br><span class="line">　　char *tempTo = (char *)memTo;                  //保存memTo首地址      </span><br><span class="line">　　while(size -- &gt; 0)                //循环size次，复制memFrom的值到memTo中</span><br><span class="line">       　　*tempTo++ = *tempFrom++ ;  </span><br><span class="line">　　return memTo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li>
<li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</li>
<li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li>
</ol>
<h1 id="x-amp-x-1"><a href="#x-amp-x-1" class="headerlink" title="x &amp; (x-1)"></a>x &amp; (x-1)</h1><p>相当于消除了 x 从右向左数遇到的第一个1。</p>
<h1 id="short-i-x3D-0-i-x3D-i-1L；这两句有错吗"><a href="#short-i-x3D-0-i-x3D-i-1L；这两句有错吗" class="headerlink" title="short i &#x3D; 0; i &#x3D; i + 1L；这两句有错吗"></a>short i &#x3D; 0; i &#x3D; i + 1L；这两句有错吗</h1><p>代码一是错的，代码二是正确的。</p>
<p><strong>说明</strong>：在数据安全的情况下大类型的数据向小类型的数据转换一定要显示的强制类型转换。</p>
<h1 id="amp-amp-和-amp-、-和-有什么区别"><a href="#amp-amp-和-amp-、-和-有什么区别" class="headerlink" title="&amp;&amp;和&amp;、||和|有什么区别"></a>&amp;&amp;和&amp;、||和|有什么区别</h1><ul>
<li>&amp;和|对操作数进行求值运算，&amp;&amp;和||只是判断逻辑关系。</li>
<li>&amp;&amp;和||在在判断左侧操作数就能确定结果的情况下就不再对右侧操作数求值。</li>
</ul>
<p><em>注意：在编程的时候有些时候将&amp;&amp;或||替换成&amp;或|没有出错，但是其逻辑是错误的，可能会导致不可预想的后果（比如当两个操作数一个是 1 另一个是 2 时。</em></p>
<h1 id="struct定义的四种方法"><a href="#struct定义的四种方法" class="headerlink" title="struct定义的四种方法"></a>struct定义的四种方法</h1><p>第一种</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体名称&#123; </span><br><span class="line">   数据类型 member1； </span><br><span class="line">   数据类型 member2; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>第二种</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct 结构体名称&#123; </span><br><span class="line">   数据类型 member1； </span><br><span class="line">   数据类型 member2; </span><br><span class="line">&#125;结构体名称别名; </span><br></pre></td></tr></table></figure>

<p>第三种</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体名称&#123; </span><br><span class="line">   数据类型 member1； </span><br><span class="line">   数据类型 member2; </span><br><span class="line">&#125;结构体变量;</span><br></pre></td></tr></table></figure>

<p>第四种：此方式是匿名结构体，在定义时同时声明结构体变量，但不能在其它地方声明，因为我们无法得知该结构体的标识符，所以就无法通过标识符来声明变量。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &#123; </span><br><span class="line">   数据类型 member1； </span><br><span class="line">   数据类型 member2; </span><br><span class="line">&#125;结构体变量名;</span><br></pre></td></tr></table></figure>

<h1 id="联合（union）、结构（struct）、类（class）"><a href="#联合（union）、结构（struct）、类（class）" class="headerlink" title="联合（union）、结构（struct）、类（class）"></a>联合（union）、结构（struct）、类（class）</h1><ul>
<li><p>联合<br>在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的。<strong>union变量所占用的内存长度等于最长的成员的内存长度</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">union A</span><br><span class="line">&#123;//sizeof(union A)的值为8</span><br><span class="line">    char mark;</span><br><span class="line">    long num;</span><br><span class="line">    float score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>结构<br>将不同类型的数据组合成一个整体，是自定义类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct B</span><br><span class="line">&#123;//sizeof(struct B)的值为24</span><br><span class="line">    char mark;</span><br><span class="line">    long num;</span><br><span class="line">    float score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体：将不同类型的数据组合成一个整体，是自定义类型</p>
</li>
</ul>
<p>区别：</p>
<ol>
<li><strong>结构体</strong>中的每个成员都有自己独立的地址，它们是同时存在的；<strong>共同体</strong>中的所有成员占用同一段内存，它们不能同时存在；</li>
<li>sizeof(struct)是内存对齐后所有成员长度的总和，sizeof(union)是内存对齐后最长数据成员的长度</li>
</ol>
<h2 id="结构体为什么要内存对齐呢？"><a href="#结构体为什么要内存对齐呢？" class="headerlink" title="结构体为什么要内存对齐呢？"></a>结构体为什么要内存对齐呢？</h2><p>看下面</p>
<h1 id="内存对齐（字节对齐）"><a href="#内存对齐（字节对齐）" class="headerlink" title="内存对齐（字节对齐）"></a>内存对齐（字节对齐）</h1><p><code>#pragma pack(n)</code> 表示的是设置n字节对齐，windows默认是8，linux是4。</p>
<h2 id="内存对齐规则"><a href="#内存对齐规则" class="headerlink" title="内存对齐规则"></a>内存对齐规则</h2><p>对于结构的各个成员，第一个成员位于偏移为0的位置，以后的每个数据成员的偏移量必须是 min(#pragma pack()指定的数,这个数据成员的自身长度)的倍数。</p>
<p>在所有的数据成员完成各自对齐之后，结构或联合体本身也要进行对齐，对齐将按照 #pragam pack指定的数值和结构或者联合体最大数据成员长度中比较小的那个，也就是 min(#pragram pack() , 长度最长的数据成员)。</p>
<h2 id="需要对齐的原因"><a href="#需要对齐的原因" class="headerlink" title="需要对齐的原因"></a>需要对齐的原因</h2><ul>
<li>平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</li>
<li>硬件原因：经过内存对齐之后，CPU的内存访问速度大大提升。访问未对齐的内存，处理器要访问两次（数据先读高位，再读低位），访问对齐的内存，处理器只要访问一次，为了提高处理器读取数据的效率，我们使用内存对齐</li>
</ul>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">    char a;</span><br><span class="line">    int b;</span><br><span class="line">    short c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>char占一个字节，起始偏移为零，int占四个字节，min(8,4)&#x3D;4；所以应该偏移量为4，所以应该在char后面加上三个字节，不存放任何东西，short占两个字节，min(8,2)&#x3D;2;所以偏移量是2的倍数，而short偏移量是8，是2的倍数，所以无需添加任何字节，所以第一个规则对齐之后内存状态为0xxx|0000|00</li>
<li>此时一共占了10个字节，但是还有结构体本身的对齐，min(8,4)&#x3D;4；所以总体应该是4的倍数，所以还需要添加两个字节在最后面，所以内存存储状态变为了 0xxx|0000|00xx，一共占据了12个字节</li>
</ul>
<p>ref. <a target="_blank" rel="noopener" href="https://songlee24.github.io/2014/09/20/memory-alignment/">C&#x2F;C++内存对齐</a></p>
<h1 id="c-资源管理机制"><a href="#c-资源管理机制" class="headerlink" title="c++资源管理机制"></a>c++资源管理机制</h1><h2 id="内存的分类"><a href="#内存的分类" class="headerlink" title="内存的分类"></a>内存的分类</h2><ol>
<li><p><strong>堆（heap）</strong>：指的是动态分配内存的区域。这里的内存，<strong>需要程序员手动分配和释放（new,delete）</strong>，否则，就会造成内存泄漏。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。<br>与之相关的一个概念是<strong>自由存储区(free store)<strong>，特指使用 new 和 delete 来分配和释放内存的区域。一般来说，这是</strong>堆的一个子集</strong>。<br>new 和 delete 操作的区域是 free store<br>malloc 和 free 操作的区域是 heap<br><em>ps: new 和 delete 通常底层使用 malloc 和 free 来实现，所以 free store 也属于 heap</em></p>
</li>
<li><p><strong>栈（stack）</strong>：函数调用过程中产生的本地变量和调用数据的区域。由编译器自动分配和释放。<br>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
</li>
</ol>
<p><em>凡生命周期超出当前函数的，一般需要用堆（或者使用对象移动传递）。反之，生命周期在当前函数内的，就该用栈。</em></p>
<ol start="3">
<li><p><strong>全局&#x2F;静态存储区（static）</strong>：全局变量和静态变量被分配到同一块内存中。<strong>程序结束后由系统释放。</strong><br>它们是在程序编译、链接时完全确定下来的，具有固定的存储位置（暂不考虑某些系统的地址扰乱机制）。堆和栈上的变量则都是动态的，地址无法确定。</p>
</li>
<li><p><strong>常量存储区</strong>：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。<strong>程序结束后由系统释放</strong>。</p>
</li>
<li><p><strong>程序代码区</strong>：存放程序的二进制代码。</p>
</li>
</ol>
<h2 id="栈展开（stack-unwinding）"><a href="#栈展开（stack-unwinding）" class="headerlink" title="栈展开（stack unwinding）"></a>栈展开（stack unwinding）</h2><p>指的是：如果在一个函数内部抛出异常，而此异常并未在该函数内部被捕捉，就将导致该函数的运行在抛出异常处结束，所有已经分配在栈上的局部变量都要被释放。<br><a target="_blank" rel="noopener" href="https://www.dazhuanlan.com/2019/09/29/5d8fb29e775ec/">示例</a></p>
<p>最常见的栈展开就是正常的函数调用，任何一个函数返回都存在栈展开。C++引入异常机制后，当程序抛出异常，在异常向上传递的过程中，其函数调用栈也会展开。</p>
<p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/169225">栈展开演示：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">class Obj &#123;</span><br><span class="line">public:</span><br><span class="line">  Obj() &#123; puts(&quot;Obj()&quot;); &#125;</span><br><span class="line">  ~Obj() &#123; puts(&quot;~Obj()&quot;); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(int n)</span><br><span class="line">&#123;</span><br><span class="line">  Obj obj;</span><br><span class="line">  if (n == 42)</span><br><span class="line">    throw &quot;life, the universe and everything&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    foo(41);</span><br><span class="line">    foo(42);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (const char* s) &#123;</span><br><span class="line">    puts(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码执行结果：不管是否发生了异常，obj 的析构函数都会得到执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Obj()</span><br><span class="line">~Obj()</span><br><span class="line">Obj()</span><br><span class="line">~Obj()</span><br><span class="line">life, the universe and everything</span><br></pre></td></tr></table></figure>

<h2 id="RAII-Resource-Acquisition-Is-Initialization"><a href="#RAII-Resource-Acquisition-Is-Initialization" class="headerlink" title="RAII(Resource Acquisition Is Initialization)"></a>RAII(Resource Acquisition Is Initialization)</h2><p>是 C++ 所特有的资源管理方式。RAII 依托栈和析构函数，来对所有的资源（包括堆内存在内）进行管理。</p>
<p>其原理是在对象析构函数中释放该对象获取的资源，利用栈展开过程栈上对象的析构函数将被自动调用的保证，从而正确地释放先前获取的资源。</p>
<p>RAII只有在栈展开正常执行的前提下才能正常工作。函数调用和正常的C++异常处理流程(异常处于try-catch块)都存在栈展开。</p>
<h2 id="申请后系统的响应"><a href="#申请后系统的响应" class="headerlink" title="申请后系统的响应"></a>申请后系统的响应</h2><p>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。<br>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>
<h2 id="malloc-x2F-free-和-new-x2F-delete-区别："><a href="#malloc-x2F-free-和-new-x2F-delete-区别：" class="headerlink" title="malloc&#x2F;free 和 new&#x2F;delete 区别："></a>malloc&#x2F;free 和 new&#x2F;delete 区别：</h2><ol>
<li><p>属性不同：malloc&#x2F;free是标准库函数，new&#x2F;delete是操作符（运算符）。</p>
</li>
<li><p>申请的内存所在位置：new操作符从<strong>自由存储区（free store）</strong>上为对象动态分配内存空间，而malloc函数从<strong>堆</strong>上动态分配内存。 </p>
</li>
<li><p>内存分配失败时的返回值：new内存分配失败时，会抛出<strong>bad_alloc异常</strong>，它不会返回NULL；malloc分配内存失败时返回<strong>NULL</strong>。</p>
</li>
<li><p>是否需要指定内存大小：new&#x2F;delete分配可以自动计算需要的字节数，malloc&#x2F;free需要人为指定。</p>
</li>
<li><p>是否调用构造函数&#x2F;析构函数：</p>
<ul>
<li>new会先调用operator_new函数，申请足够的内存（通常底层使用malloc实现），然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator_delete函数释放内存（通常底层使用free实现）。  </li>
<li>malloc&#x2F;free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</li>
</ul>
</li>
<li><p>能否重载：new&#x2F;delete允许重载,malloc&#x2F;free不允许重载</p>
</li>
<li><p>已分配内存的扩充：malloc&#x2F;free可以通过realloc函数扩充，new&#x2F;free无法直观地处理</p>
</li>
<li><p>能否相互调用：operator_new&#x2F;operator _delete的实现可以基于malloc&#x2F;free，而malloc的实现不可以去调用new。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//main.cpp</span><br><span class="line">int a = 0; //全局初始化区</span><br><span class="line">char *p1; //全局未初始化区</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">int b; //栈</span><br><span class="line">char s[] = &quot;abc&quot;; //栈</span><br><span class="line">char *p2; //栈</span><br><span class="line">char *p3 = &quot;123456&quot;; //123456\0在常量区，p3在栈上。</span><br><span class="line">static int c =0； //全局（静态）初始化区</span><br><span class="line">p1 = (char *)malloc(10);</span><br><span class="line">p2 = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区。</span><br><span class="line">strcpy(p1, &quot;123456&quot;); //123456\0放在常量区，编译器可能会将它与p3所指的&quot;123456&quot;优化成一个地方</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="malloc实现原理"><a href="#malloc实现原理" class="headerlink" title="malloc实现原理"></a>malloc实现原理</h2><ol>
<li>malloc 函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。</li>
<li>调用 malloc（）函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。 然后，将该内存块一分为二（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节）。 接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块（如果有的话）返回到连接表上。</li>
<li>调用 free 函数时，它将用户释放的内存块连接到空闲链表上。</li>
<li>到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段， 那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc（）函数请求延时，并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。</li>
</ol>
<p>malloc会出现的问题：初始化的问题。没有初始化的内存中内容是随机的，所以如果直接使用的话，就可能造成程序运行结果不正确。</p>
<p><em>ps. malloc 函数可以向程序的虚拟空间申请一块虚拟地址空间，与物理内存没有直接的关系，所以是有可能用malloc函数申请超过该机器物理内存大小的内存块的</em></p>
<p>ref. <a target="_blank" rel="noopener" href="https://blog.csdn.net/mmshixing/article/details/51679571">linux-malloc底层实现原理</a></p>
<h2 id="delete-与-delete-区别"><a href="#delete-与-delete-区别" class="headerlink" title="delete 与 delete[] 区别"></a>delete 与 delete[] 区别</h2><p>delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。delete与new配套，delete []与new []配套。</p>
<p>在More Effective C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator delete来释放内存。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MemTest *mTest1 = new MemTest[10];</span><br><span class="line">MemTest *mTest2 = new MemTest;</span><br><span class="line"></span><br><span class="line">Int *pInt1 = new int [10];</span><br><span class="line">Int *pInt2 = new int;</span><br><span class="line"></span><br><span class="line">delete[] pInt1;   //-1-</span><br><span class="line">delete[] pInt2;   //-2-</span><br><span class="line">delete[] mTest1;  //-3-</span><br><span class="line">delete[] mTest2;  //-4-  在-4-处报错。</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。  </p>
<p>delete[]删除一个数组，delete删除一个指针。</p>
<p>简单来说，用new分配的内存用delete删除；用new[]分配的内存用delete[]删除。delete[]会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。内存泄漏会最终会导致内存溢出。</p>
<p>内存泄漏的原因：</p>
<ol>
<li>异常或分支导致delete未得到执行</li>
<li>分配和释放不在一个函数里导致的遗漏delete</li>
</ol>
<h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，于是就发生了内存溢出。</p>
<h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p>野指针指向一个已删除的对象 或 申请访问受限内存区域的指针。</p>
<p>原因：</p>
<ol>
<li>指针变量未初始化。<strong>解决办法</strong>：指针声明时初始化，可以是具体的地址值，也可让它指向 NULL。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *p;   //此时p为野指针</span><br></pre></td></tr></table></figure></li>
<li>指针释放未置空：指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。<strong>解决办法</strong>：指针指向的内存空间被释放后指针应该指向。NULL。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *p=new char[10];  //指向堆中分配的内存首地址</span><br><span class="line">cin&gt;&gt; p;</span><br><span class="line">delete []p; //p重新变为野指针</span><br></pre></td></tr></table></figure></li>
<li>指针操作超出作用域。返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。<strong>解决办法</strong>：在变量的作用域结束前释放掉变量的地址空间并且让指针指向 NULL。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *p=new char[10];  //指向堆中分配的内存首地址</span><br><span class="line">cin&gt;&gt; p;</span><br><span class="line">cout&lt;&lt;*(p+10);  //可能输出未知数据</span><br></pre></td></tr></table></figure>
<em>ps. “野指针”的解决方法也是编程规范的基本原则，平时使用指针时一定要避免产生“野指针”，在使用指针前一定要检验指针的合法性。</em></li>
</ol>
<h2 id="栈内存与文字常量区"><a href="#栈内存与文字常量区" class="headerlink" title="栈内存与文字常量区"></a>栈内存与文字常量区</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">char str1[] = &quot;abc&quot;;</span><br><span class="line">char str2[] = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">const char str3[] = &quot;abc&quot;;</span><br><span class="line">const char str4[] = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">const char *str5 = &quot;abc&quot;;</span><br><span class="line">const char *str6 = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">char *str7 = &quot;abc&quot;;</span><br><span class="line">char *str8 = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl;//0 分别指向各自的栈内存</span><br><span class="line">cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl;//0 分别指向各自的栈内存</span><br><span class="line">cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl;//1 指向文字常量区地址相同</span><br><span class="line">cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl;//1 指向文字常量区地址相同</span><br></pre></td></tr></table></figure>
<p>str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。</p>
<h2 id="ref-3"><a href="#ref-3" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/169225">极客时间《现代C++实战30讲》：01 | 堆、栈、RAII：C++里该如何管理资源？</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/RAII">RAII(wiki)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qg-whz/p/5060894.html">C++ 自由存储区是否等价于堆？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/281940376">为什么c++中要分为heap（堆）和stack（栈）</a>  </li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/82298443">C&#x2F;C++内存分配</a></li>
<li><a target="_blank" rel="noopener" href="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/">C&#x2F;C++内存管理详解</a></li>
</ul>
<h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><p>声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。</p>
<ol>
<li><strong>引用</strong>只是变量的一个别名，<strong>指针</strong>是变量的地址，有分配内存。</li>
<li><strong>指针</strong>可以指向空值，但是在任何情况下都不能使用指向空值的<strong>引用</strong>。引用在声明时必须初始化。</li>
<li>指针与引用的另一个重要的不同是：<strong>指针</strong>可以被重新赋值以指向另一个不同的对象，但是<strong>引用</strong>则总是指向在初始化时被指定的对象，以后不能改变。  </li>
<li><strong>sizeof的意义</strong>不同：使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小。</li>
<li>指针和引用的<strong>自增运算符意义</strong>不同：指针是对内存地址的自增，引用是对值的自增</li>
<li>没有引用常量，有指针常量</li>
<li>参数传递：作为参数传递时，指针需要被<strong>解引用</strong>才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象</li>
<li>多级指针，一级引用. 指针可以有多级指针（**p），而引用只有一级</li>
<li>作为参数时，引用更安全，因为指针传递时会涉及到形参和实参，会多开辟内存。</li>
</ol>
<p>在以下情况下你应该使用指针：</p>
<ul>
<li>你考虑到存在不指向任何对象的可能(在 这种情况下，你能够设置指针为空)</li>
<li>你需要能够在不同的时刻指向不同的对象(在这种情况下，你能改变指针的指向)。</li>
</ul>
<p>如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。</p>
<p><em>ps: 函数传参时，可以使用引用。<br>&amp;emsp;&amp;emsp;引用也可以作为函数的返回值。但是要注意<code>不要返回局部变量引用</code>。</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//返回局部变量引用</span><br><span class="line">int&amp; test01() &#123;</span><br><span class="line">	int a = 10; //局部变量</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回静态变量引用</span><br><span class="line">int&amp; test02() &#123;</span><br><span class="line">	static int a = 20;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ref-4"><a href="#ref-4" class="headerlink" title="ref"></a>ref</h2><ul>
<li>《more effective C++》 Item M1:指针与引用的区别  </li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weikangc/article/details/49762929">C++中指针和引用的区别</a></li>
<li><a href="https://github.com/twomonkeyclub/BackEnd/tree/master/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">C&#x2F;C++基础知识</a></li>
</ul>
<h1 id="函数参数传递中值传递、地址传递、引用传递有什么区别？"><a href="#函数参数传递中值传递、地址传递、引用传递有什么区别？" class="headerlink" title="函数参数传递中值传递、地址传递、引用传递有什么区别？"></a>函数参数传递中值传递、地址传递、引用传递有什么区别？</h1><ul>
<li>值传递，会为形参重新分配内存空间，将实参的值拷贝给形参，形参的值不会影响实参的值，函数调用结束后形参被释放；</li>
<li>引用传递，不会为形参重新分配内存空间，形参只是实参的别名，形参的改变会影响实参的值，函数调用结束后形参不会被释放；</li>
<li>地址传递，形参为指针变量，将实参的地址传递给函数，可以在函数中改变实参的值，调用时为形参指针变量分配内存，结束时释放指针变量。</li>
</ul>
<h1 id="常量指针，指针常量，常量引用，没有引用常量"><a href="#常量指针，指针常量，常量引用，没有引用常量" class="headerlink" title="常量指针，指针常量，常量引用，没有引用常量"></a>常量指针，指针常量，常量引用，没有引用常量</h1><ul>
<li>常量指针（常指针）：是一个指针，指向一个常量。</li>
<li>指针常量：是一个常量，这个常量的类型是指针</li>
<li>常量引用：是一个引用，是常量的引用</li>
<li>没有引用常量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//常量指针</span><br><span class="line">const int* p = &amp;a;  // *p 为常量，不能通过*p改变它指向的内容 </span><br><span class="line">int const* p = &amp;a;  // *p 为常量，同上</span><br><span class="line"></span><br><span class="line">//指针常量</span><br><span class="line">int* const p = &amp;a;  // p 为常量，初始化后不能再指向其它内容</span><br><span class="line"></span><br><span class="line">//指向常量的 常指针</span><br><span class="line">const int * const p;</span><br><span class="line">int const * const p;</span><br><span class="line"></span><br><span class="line">//常量引用</span><br><span class="line">int a = 10;</span><br><span class="line">const int &amp;r = a;</span><br><span class="line">const int &amp;r = 10;</span><br></pre></td></tr></table></figure>

<h1 id="常引用有什么作用"><a href="#常引用有什么作用" class="headerlink" title="常引用有什么作用"></a>常引用有什么作用</h1><p>常引用的引入主要是为了避免使用变量的引用时，在不知情的情况下改变变量的值。</p>
<p>常引用主要用于定义一个普通变量的只读属性的别名、作为函数的传入形参，避免实参在调用函数中被意外的改变。</p>
<p><strong>说明</strong>：很多情况下，需要用常引用做形参，被引用对象等效于常对象，不能在函数中改变实参的值，这样的好处是有较高的易读性和较小的出错率。</p>
<h1 id="指针常量与常量指针区别"><a href="#指针常量与常量指针区别" class="headerlink" title="指针常量与常量指针区别"></a>指针常量与常量指针区别</h1><ul>
<li><strong>指针常量</strong>是指这个指针的值只能在定义时初始化，其他地方不能改变。（重点在常量）</li>
<li><strong>常量指针</strong>是指这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。（重点在指针）</li>
</ul>
<p>指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。</p>
<p><em>注意：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。</em></p>
<h1 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h1><h2 id="指针和数组的区别"><a href="#指针和数组的区别" class="headerlink" title="指针和数组的区别"></a>指针和数组的区别</h2><ul>
<li><strong>概念不同</strong>。指针相当于一个变量，它存放的是数据在内存中的地址；数组是用于储存多个相同类型数据的集合</li>
<li><strong>赋值不同</strong>。同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝</li>
<li><strong>访问数据不同</strong>。指针是间接访问数据，获取指针，先解引用，再访问指针指向的地址中的内容；数组是直接访问</li>
<li><strong>sizeof意义不同</strong>。数组所占存储空间的内存：sizeof（数组名） 数组的大小：sizeof（数组名）&#x2F;sizeof（数据类型） 在32位平台下，sizeof（指针名）是4，在64位平台下，sizeof（指针名）是8</li>
<li><strong>指针和数组名异同</strong>。指针和数组名都可以表示地址，但指针是变量，可以修改；数组名是常量，不可修改赋值</li>
<li><strong>传参</strong>。数组传参时会退化成指针</li>
</ul>
<h2 id="指针数组和数组指针"><a href="#指针数组和数组指针" class="headerlink" title="指针数组和数组指针"></a>指针数组和数组指针</h2><ul>
<li><p>指针数组：它本质上是一个数组，数组的每个元素存放的是一个指针类型的元素。 int* arr[8];</p>
<ol>
<li>优先级问题：[]的优先级比*高</li>
<li>说明arr是一个数组，而int*是数组里面的内容</li>
<li>这句话的意思就是：arr是一个含有8和int*的数组</li>
</ol>
</li>
<li><p>数组指针：它本质上是一个指针，该指针指向一个数组。 int (*arr)[8];</p>
<ol>
<li>由于[]的优先级比<em>高，因此在写数组指针的时候必须将</em>arr用括号括起来</li>
<li>arr先和*结合，说明p是一个指针变量</li>
<li>这句话的意思就是：指针arr指向一个大小为8个整型的数组。</li>
</ol>
</li>
</ul>
<p><em>ps. 谁优先级高，本质是谁</em></p>
<h2 id="数组名和指针的区别"><a href="#数组名和指针的区别" class="headerlink" title="数组名和指针的区别"></a>数组名和指针的区别</h2><p>数组名并不是真正意义上的指针，它的内涵要比指针丰富的多。但是当数组名当做参数传递给函数后，其失去原来的含义，变作普通的指针。另外要注意 sizeof 不是函数，只是操作符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">	char str[13]=&quot;Hello world!&quot;;</span><br><span class="line">	char *pStr=&quot;Hello world!&quot;;</span><br><span class="line">	cout&lt;&lt;sizeof(str)&lt;&lt;endl; //13</span><br><span class="line">	cout&lt;&lt;sizeof(pStr)&lt;&lt;endl; //4</span><br><span class="line">	cout&lt;&lt;strlen(str)&lt;&lt;endl; //12</span><br><span class="line">	cout&lt;&lt;strlen(pStr)&lt;&lt;endl; //12</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>int a[10]和int* a &#x3D; new int[10]的区别：  </p>
<ul>
<li>int a[10]是静态分配</li>
<li>int* a&#x3D;new int[10]]是动态分配</li>
</ul>
<h2 id="数组的存放"><a href="#数组的存放" class="headerlink" title="数组的存放"></a>数组的存放</h2><ul>
<li>固定数组<ul>
<li>在函数体内分配的（不带static）是在栈中</li>
<li>全局变量&#x2F;带static的局部变量 是在全局数据存储区</li>
<li>类中分配的在堆中</li>
</ul>
</li>
<li>动态数组，都在堆中</li>
</ul>
<p>说明：</p>
<ol>
<li><code>int a[10]</code>使用简单，系统会自动实现内存的分配和回收。<code>int* a = new int[10]</code>需要判断内存是否分配成功，以及在不用时需要使用<code>delete[] a</code>进行内存释放，否则会造成内存泄漏； </li>
<li>如果不是<code>a[10]</code>，而是<code>a[1000000000]</code>或者更大的话，那一般情况下，就只能使用<code>int* a = new</code>这种方式了。这个涉及到内存存放位置的问题，<code>int a[]</code>这种方式，内存是存放在栈上；<code>int* a ＝ new</code>这种方式，内存是存放在堆上，栈的实际内存是连续内存，因此可分配空间较小，堆可以是非连续内存，因此可以分配较大内存。因此，如果需要分配较大内存，需要分配在堆上；（注意，同一个new出来的是连续内存，new一个一维数组确实是连续内存，但多个new出来的就不是连续内存了。）</li>
<li>使用<code>int a[10]</code>这种方式，内存大小需要用常量指定，比如这里的10。不能用<code>int m＝10; int a[m]</code>这种方式。但是<code>int* a= new</code>这种方式可以，因此在动态分配内存上，后者有非常大的优势。</li>
</ol>
<h2 id="ref-5"><a href="#ref-5" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://github.com/twomonkeyclub/BackEnd/tree/master/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">C&#x2F;C++基础知识</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/anycodes/article/details/41087785">C&#x2F;C++ 数组的初始化</a></li>
</ul>
<h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><p>C++另一种编程思想称为<strong>泛型编程</strong>，主要利用的技术就是模板。</p>
<p>C++提供两种模板机制：<strong>函数模板</strong> 和 <strong>类模板</strong></p>
<h2 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h2><p>函数模板作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>
<ul>
<li>template：声明创建模板  </li>
<li>typename：表面其后面的符号是一种数据类型，可以用class代替  </li>
<li>T：通用的数据类型，名称可以替换，通常为大写字母</li>
</ul>
<p>使用函数模板有两种方式：</p>
<ol>
<li>自动类型推导</li>
<li>显示指定类型</li>
</ol>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void mySwap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//利用模板实现交换</span><br><span class="line">//1、自动类型推导</span><br><span class="line">int a = 1, b = 2;</span><br><span class="line">mySwap(a, b);</span><br><span class="line"></span><br><span class="line">//2、显示指定类型</span><br><span class="line">mySwap&lt;int&gt;(a, b);</span><br></pre></td></tr></table></figure>

<h3 id="普通函数与函数模板的区别"><a href="#普通函数与函数模板的区别" class="headerlink" title="普通函数与函数模板的区别"></a>普通函数与函数模板的区别</h3><ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<h3 id="普通函数与函数模板的调用规则"><a href="#普通函数与函数模板的调用规则" class="headerlink" title="普通函数与函数模板的调用规则"></a>普通函数与函数模板的调用规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//普通函数与函数模板调用规则</span><br><span class="line">void myPrint(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void myPrint(T a, T b) </span><br><span class="line">&#123; </span><br><span class="line">	cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void myPrint(T a, T b, T c) </span><br><span class="line">&#123; </span><br><span class="line">	cout &lt;&lt; &quot;调用重载的模板&quot; &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span><br><span class="line">	// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span><br><span class="line">	int a = 10;</span><br><span class="line">	int b = 20;</span><br><span class="line">	myPrint(a, b); //调用普通函数</span><br><span class="line"></span><br><span class="line">	//2、可以通过空模板参数列表来强制调用函数模板</span><br><span class="line">	myPrint&lt;&gt;(a, b); //调用函数模板</span><br><span class="line"></span><br><span class="line">	//3、函数模板也可以发生重载</span><br><span class="line">	int c = 30;</span><br><span class="line">	myPrint(a, b, c); //调用重载的函数模板</span><br><span class="line"></span><br><span class="line">	//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span><br><span class="line">	char c1 = &#x27;a&#x27;;</span><br><span class="line">	char c2 = &#x27;b&#x27;;</span><br><span class="line">	myPrint(c1, c2); //调用函数模板</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数模版实例"><a href="#函数模版实例" class="headerlink" title="函数模版实例"></a>函数模版实例</h3><p><em>转自下方参考1</em></p>
<p>利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序<br>排序规则从大到小，排序算法为选择排序<br>分别利用char数组和int数组进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">//交换的函数模板</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void mySwap(T &amp;a, T&amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;class T&gt; // 也可以替换成typename</span><br><span class="line">//利用选择排序，进行对数组从大到小的排序</span><br><span class="line">void mySort(T arr[], int len)</span><br><span class="line">&#123;</span><br><span class="line">	for (int i = 0; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int max = i; //最大数的下标</span><br><span class="line">		for (int j = i + 1; j &lt; len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (arr[max] &lt; arr[j])</span><br><span class="line">			&#123;</span><br><span class="line">				max = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (max != i) //如果最大数的下标不是i，交换两者</span><br><span class="line">		&#123;</span><br><span class="line">			mySwap(arr[max], arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void printArray(T arr[], int len) &#123;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	//测试char数组</span><br><span class="line">	char charArr[] = &quot;bdcfeagh&quot;;</span><br><span class="line">	int num = sizeof(charArr) / sizeof(char);</span><br><span class="line">	mySort(charArr, num);</span><br><span class="line">	printArray(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	//测试int数组</span><br><span class="line">	int intArr[] = &#123; 7, 5, 8, 1, 3, 9, 2, 4, 6 &#125;;</span><br><span class="line">	int num = sizeof(intArr) / sizeof(int);</span><br><span class="line">	mySort(intArr, num);</span><br><span class="line">	printArray(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line">	test02();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类模版"><a href="#类模版" class="headerlink" title="类模版"></a>类模版</h2><p>类模板作用：建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>
<ul>
<li>template：声明创建模板</li>
<li>typename：表面其后面的符号是一种数据类型，可以用class代替</li>
<li>T：通用的数据类型，名称可以替换，通常为大写字母</li>
</ul>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class NameType, class AgeType&gt; </span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;mName = name;</span><br><span class="line">		this-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	void showPerson()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="类模板与函数模板区别"><a href="#类模板与函数模板区别" class="headerlink" title="类模板与函数模板区别"></a>类模板与函数模板区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">//类模板</span><br><span class="line">template&lt;class NameType, class AgeType = int&gt; </span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;mName = name;</span><br><span class="line">		this-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	void showPerson()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//1、类模板没有自动类型推导的使用方式</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span><br><span class="line">	Person &lt;string ,int&gt;p(&quot;孙悟空&quot;, 1000); //必须使用显示指定类型的方式，使用类模板</span><br><span class="line">	p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2、类模板在模板参数列表中可以有默认参数</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	Person &lt;string&gt; p(&quot;猪八戒&quot;, 999); //类模板中的模板参数列表 可以指定默认参数</span><br><span class="line">	p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	test02();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ref-6"><a href="#ref-6" class="headerlink" title="ref"></a>ref</h2><p><a href="https://github.com/AnkerLeng/Cpp-0-1-Resource/blob/master/%E7%AC%AC5%E9%98%B6%E6%AE%B5-C%2B%2B%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E8%B5%84%E6%96%99/%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E8%B5%84%E6%96%99/%E8%AE%B2%E4%B9%89/C%2B%2B%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B.md">C++提高编程</a></p>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>不可修改</p>
<ul>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针和指针常量；int *const p和const int *p</li>
<li>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量，本质是const this指针。</li>
</ul>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>对外不可见</p>
<ul>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，在整个程序运行期间一直存在，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它，<strong>自动初始化为0</strong>。  <ul>
<li>全局变量作用域：全局静态变量在声明他的文件之外是不可见的，即便是 extern 外部声明也不可以。准确地说是从定义之处开始，到文件结尾。</li>
<li>局部变量作用域：仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</li>
</ul>
</li>
<li>修饰普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用</li>
<li>修饰类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过&lt;类名&gt;::&lt;静态成员&gt;来使用。在 static 函数内不能访问非静态成员</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-static-usage.html">static的用法</a></p>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>修饰变量或函数，表示该函数可以跨文件访问，或者表明该变量在其他文件定义，在此处引用。</p>
<p><strong>extern</strong>关键字的作用是共享代码。</p>
<ol>
<li>在其他文件中定义过的全局变量，在另一个文件中要调用时，只需在声明语句前加关键字extern。</li>
<li>对于常量，要调用其他文件的常量时，做法如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//文件1,定义常量</span><br><span class="line">extern const int i = 1;</span><br><span class="line"></span><br><span class="line">//文件2，声明常量</span><br><span class="line">extern const int i;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意：  </p>
<ul>
<li>定义也是声明，因为当定义变量时我们也向程序表明了它的类型和名字</li>
<li>但声明不是定义，可以通过使用extern关键字声明变量而不定义它。不定义变量的声明包括对象名、对象类型和对象类型前的关键字extern</li>
<li>extern声明不是定义，不分配存储空间</li>
</ul>
<p>ref.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDNwei/article/details/51836182">extern使用方法总结</a></li>
</ul>
<h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifdef _cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">#include &quot;XXX.h&quot;</span><br><span class="line">#ifdef _cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>extern “C”的作用是，告诉C++编译器，下面的代码按照C的方式进行编译，不要对这些函数进行名字重整（function name mangling）。通常在C++程序中使用C函数或者模块时，需要用到这个功能。</p>
<p>ref.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38880380/article/details/80035710">C–变量的存储方式、作用域和生命周期</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/scottly1/article/details/44221157">extern “C”用法总结</a></li>
</ul>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>explicit关键字的作用就是防止对象间实现使用 “&#x3D;” 赋值，防止类构造函数的隐式自动转换,类构造函数默认情况下即声明为implicit(隐式)，另外explicit只用于单参数的构造函数，或者除了第一个参数以外的其他参数都有默认值.</p>
<ul>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换</li>
</ul>
<h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>用于程序中定义内联函数。</p>
<p>内联函数是C++中的一种特殊函数，它可以像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是通过将函数体直接插入调用处来实现的，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。一般来说inline用于定义类的成员函数。</p>
<p>在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。类内声明可以不用加上inline关键字，但是类外定义函数体时必须要加上，这样才能保证编译器能够识别其为内联函数。</p>
<p><em>ps. 内联函数不能包括复杂的控制语句，如循环语句和switch语句</em></p>
<p>示例：使用内联函数来返回两个数中的最大值  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline int Max(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">   return (x &gt; y)? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h2><p>restrict只能修饰指针，restrict修饰的指针是能够访问所指区域的唯一入口，限制多个指针指向同一地址。</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile是给编译器的指示来说明对它所修饰的对象不应该执行优化。volatile的作用就是用来进行多线程编程。在单线程中那就是只能起到限制编译器优化的作用。</p>
<p>如果一个基本变量被volatile修饰，编译器将不会把它保存到寄存器中，而是每一次都去访问内存中实际保存该变量的位置上。这一点就避免了没有volatile修饰的变量在多线程的读写中所产生的由于编译器优化所导致的灾难性问题。所以多线程中必须要共享的基本变量一定要加上volatile修饰符。</p>
<h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><p>C++中4种类型转换为：</p>
<ol>
<li>static_cast<br>完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换，不能用于普通指针的转换（void空指针除外）</li>
<li>dynamic_cast<br>动态类型转换，用于实现RTTI（运行时类型检查）。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常bad_cast</li>
<li>const_cast<br>用于删除 const、volatile特性</li>
<li>reinterpret_cast<br>几乎什么都可以转,不能丢掉 const、volatile特性</li>
</ol>
<h1 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h1><p>多重继承（多继承，Multiple Inheritance，MI）指的是一个类可以同时继承多个类，比如A类继承自B类和C类，这就是多重继承。</p>
<h2 id="ref-7"><a href="#ref-7" class="headerlink" title="ref"></a>ref</h2><ul>
<li>Effective C++ 40：明智地使用多继承</li>
</ul>
<h1 id="变量的声明和定义有什么区别"><a href="#变量的声明和定义有什么区别" class="headerlink" title="变量的声明和定义有什么区别"></a>变量的声明和定义有什么区别</h1><p>为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但是只在一个地方定义。加入 <code>extern</code> 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。</p>
<h1 id="局部变量，静态局部变量，全局变量，静态全局变量的区别"><a href="#局部变量，静态局部变量，全局变量，静态全局变量的区别" class="headerlink" title="局部变量，静态局部变量，全局变量，静态全局变量的区别"></a>局部变量，静态局部变量，全局变量，静态全局变量的区别</h1><h2 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h2><ul>
<li>该变量在全局数据区分配内存；</li>
<li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li>
<li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0；</li>
<li>它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。</li>
</ul>
<h2 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h2><ul>
<li>静态变量都在全局数据区分配内存;</li>
<li>未经初始化的静态全局变量会被程序自动初始化为0（在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为 0）；</li>
<li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。</li>
</ul>
<h2 id="全局变量-和-静态全局变量-的区别"><a href="#全局变量-和-静态全局变量-的区别" class="headerlink" title="全局变量 和 静态全局变量 的区别"></a>全局变量 和 静态全局变量 的区别</h2><ul>
<li>全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。</li>
<li>静态全局变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。</li>
</ul>
<h2 id="存放区别"><a href="#存放区别" class="headerlink" title="存放区别"></a>存放区别</h2><p>全局（静态）存储区：分为 DATA 段和 BSS 段。DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。</p>
<p>全局初始化的变量：.data:<br>全局未初始化变量：.bss<br>全局只读：.rdata</p>
<h2 id="ref-8"><a href="#ref-8" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-static-usage.html">C&#x2F;C++ 中 static 的用法全局变量与局部变量</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bakari/archive/2012/08/05/2623637.html">局部变量，静态局部变量，全局变量，静态全局变量在内存中的存放区别</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/youyou519/article/details/82701083">全局初始化变量&#x2F;全局未初始化变量&#x2F;全局静态变量&#x2F;局部变量的存储位置，作用域，与生命周期</a></li>
</ul>
<h1 id="C-中哪些运算符不可以重载？"><a href="#C-中哪些运算符不可以重载？" class="headerlink" title="C++中哪些运算符不可以重载？"></a>C++中哪些运算符不可以重载？</h1><ol>
<li>.</li>
<li>?:</li>
<li>sizeof</li>
<li>::</li>
<li>*</li>
</ol>
<h1 id="简述C-异常处理方式"><a href="#简述C-异常处理方式" class="headerlink" title="简述C++异常处理方式"></a>简述C++异常处理方式</h1><p>一个典型的C++异常处理包含以下几个步骤：</p>
<ol>
<li>程序执行时发生错误；</li>
<li>以一个异常对象(最简单是一个整数)记录错误的原因及相关信息；</li>
<li>程序监测到这个错误(读取异常对象)；</li>
<li>程序决定如何处理错误；</li>
<li>进行错误处理，并在此后恢复&#x2F;终止程序的执行。</li>
</ol>
<h1 id="STL-Standard-Template-Library-标准模板库"><a href="#STL-Standard-Template-Library-标准模板库" class="headerlink" title="STL(Standard Template Library,标准模板库)"></a>STL(Standard Template Library,标准模板库)</h1><p>STL从广义上分为: <strong>容器(container)<strong>、</strong>算法(algorithm)<strong>、</strong>迭代器(iterator)</strong>  </p>
<p>容器和算法之间通过<strong>迭代器</strong>进行无缝连接。STL几乎所有的代码都采用了模板类或者模板函数。</p>
<p>STL大体分为六大组件，分别是：</p>
<ul>
<li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等</li>
<li>迭代器：扮演了容器与算法之间的胶合剂。</li>
<li>仿函数：行为类似函数，可作为算法的某种策略。</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>空间配置器：负责空间的配置与管理。</li>
</ul>
<h2 id="常用STL容器、算法、迭代器"><a href="#常用STL容器、算法、迭代器" class="headerlink" title="常用STL容器、算法、迭代器"></a>常用STL容器、算法、迭代器</h2><p>请看<a target="_blank" rel="noopener" href="https://suzhilong.github.io/2020/07/12/STL/">「STL常用方法」</a></p>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>重载函数调用操作符的类，其对象常称为<strong>函数对象</strong></p>
<h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><p>函数对象使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong>。函数对象(仿函数)是一个类，不是一个函数。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class Multiply&#123;</span><br><span class="line">public:</span><br><span class="line">    double operator()(double x, double y) const &#123;return x*y;&#125;</span><br><span class="line">    double operator()(double x, int y) const &#123;return x*y;&#125;</span><br><span class="line">    double operator()(int x, double y) const &#123;return x*y;&#125;</span><br><span class="line">    int operator()(int x, int y) const &#123;return x*y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Multiply multiply;</span><br><span class="line">    cout &lt;&lt; &quot; 3.6 * 7 = &quot; &lt;&lt; multiply(3.6,7) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot; 3 * 7 = &quot; &lt;&lt; multiply(3,7) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数对象的特点"><a href="#函数对象的特点" class="headerlink" title="函数对象的特点"></a>函数对象的特点</h3><ul>
<li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul>
<h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>返回bool类型的仿函数称为<strong>谓词</strong>。如果operator()接受一个参数，那么叫做<strong>一元谓词</strong>；如果operator()接受两个参数，那么叫做<strong>二元谓词</strong>。</p>
<ol>
<li>一元谓词<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct GreaterFive&#123;</span><br><span class="line">	bool operator()(int val) &#123;</span><br><span class="line">		return val &gt; 5;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());</span><br></pre></td></tr></table></figure></li>
<li>二元谓词<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyCompare</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator()(int num1, int num2)</span><br><span class="line">	&#123;</span><br><span class="line">		return num1 &gt; num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sort(v.begin(), v.end());//默认从小到大</span><br><span class="line">sort(v.begin(), v.end(), MyCompare());//使用函数对象改变算法策略，排序从大到小</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="STL容器的底层数据结构"><a href="#STL容器的底层数据结构" class="headerlink" title="STL容器的底层数据结构"></a>STL容器的底层数据结构</h2><ol>
<li><p>vector  </p>
<ul>
<li>底层使用数组保存。  </li>
<li>push_back时若已经满了，则会2*n扩展空间，若实际元素数量低于分配空间的1&#x2F;4，则会将空间回收为原来的一半。  </li>
<li>扩容时，先申请新的空间，然后将旧空间的内容拷贝过去，然后再释放旧的空间。  </li>
<li>只适用于快速查找及只在末尾增删，而不适用于动态增删（可能涉及到元素的移动）。对元素进行增删时，可能导致旧的迭代器失效。防止迭代器失效的删除方法： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (vector&lt;int&gt;::iterator it = vec.begin();ite!=vec.end();)</span><br><span class="line">   &#123;</span><br><span class="line">       if(*it % 2 != 0) //删除vec中的奇数</span><br><span class="line">           it = vec.erase(it);</span><br><span class="line">       else</span><br><span class="line">           it++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>clear()可以清空所有元素，但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。可以用swap()来帮助你释放内存，也可以使用erase循环删除第一个。</li>
<li>vector和数组的区别<br> <img src="https://i.loli.net/2020/10/14/HijrufaCD6Rwebq.png" alt="vector和数组的区别"></li>
</ul>
</li>
<li><p>list  </p>
<ul>
<li>底层是双向链表，支持头尾增删，并且是一个环。  </li>
<li>不适用于查找频繁的情况，但适用于动态增删。</li>
</ul>
</li>
<li><p>stack  </p>
<ul>
<li>适配器。默认底层使用deque，适配之后只能从头插入和删除。</li>
</ul>
</li>
<li><p>queue  </p>
<ul>
<li>适配器。默认底层使用deque，适配之后只能从尾插入，从头删除。</li>
</ul>
</li>
<li><p>priority_queue</p>
<ul>
<li>适配器。一般以vector为底层容器，堆heap为处理规则来管理。</li>
</ul>
</li>
<li><p>map、multimap、set、multiset  </p>
<ul>
<li>底层使用红黑树实现，multimap是key值可重复的map。</li>
<li>防止迭代器失效的删除方法 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (auto it = m.begin(); it != m.end();)&#123;</span><br><span class="line">	if(it-&gt;second == 10)//删除val==10的元素</span><br><span class="line">		m.erase(it++);</span><br><span class="line">	else</span><br><span class="line">		it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>hash_map、hash_multimap、hash_set、hash_multiset  </p>
<ul>
<li>底层使用hashtable实现，其中hashtable是采用开链法来防止哈希冲突的。</li>
</ul>
</li>
<li><p>deque：  </p>
<ul>
<li>底层是一个分段的线性表。笼统的说就是使用了一个二维指针，第一维是每段的信息，而第二维就是一个数组了，实际保存的元素就是在这里。  </li>
<li>头尾都支持插入，但是维护麻烦很多。</li>
</ul>
</li>
<li><p>slist  </p>
<ul>
<li>使用单向链表实现的列表。</li>
</ul>
</li>
</ol>
<p><em>ps. queue，priority_queue，stack不是容器，是适配器，是对容器的再封装，没有迭代器</em></p>
<h2 id="vector和list的异同"><a href="#vector和list的异同" class="headerlink" title="vector和list的异同"></a>vector和list的异同</h2><ol>
<li>数据结构上的不同<ul>
<li>vector是用连续数组存储，内存空间连续，随机访问O(1)。内存不足是扩容一倍，申请更大的内存。</li>
<li>list底层是双向链表，不需要连续内存。插入删除O(1)，查找O(n)。</li>
</ul>
</li>
<li>迭代器<ul>
<li>vector中iterator支持”+”,”+&#x3D;”,”&lt;”等操作，list中不支持。</li>
</ul>
</li>
</ol>
<h2 id="push-back-和-emplace-back"><a href="#push-back-和-emplace-back" class="headerlink" title="push_back 和 emplace_back"></a>push_back 和 emplace_back</h2><p>C++11中，针对顺序容器(如vector、deque、list)，新标准引入了三个新成员：emplace_front、emplace和emplace_back，这些操作构造而不是拷贝元素。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定位置之前或容器尾部。</p>
<p>当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。</p>
<p>push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p>
<h2 id="map和unordered-map的区别"><a href="#map和unordered-map的区别" class="headerlink" title="map和unordered_map的区别"></a>map和unordered_map的区别</h2><ul>
<li>排序：map在缺省下，map按照递增的顺序进行排序；unordered_map不排序</li>
<li>内部原理：map内部采用了红黑树（自平衡的二叉搜索树），实现了数据排序；unordered_map内部采用了哈希表</li>
<li>搜索操作时间：map的搜索时间复杂度为O(log(n))；unordered_map平均搜索时间O(1)，最坏情况为O(n)</li>
<li>插入操作时间：map复杂度为log(n)+再平衡时间；unordered_map平均插入时间O(1)，最坏情况为O(n)</li>
<li>删除操作时间：与插入操作时间复杂度一样</li>
</ul>
<h2 id="ref-9"><a href="#ref-9" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://github.com/AnkerLeng/Cpp-0-1-Resource/blob/master/%E7%AC%AC5%E9%98%B6%E6%AE%B5-C%2B%2B%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E8%B5%84%E6%96%99/%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E8%B5%84%E6%96%99/%E8%AE%B2%E4%B9%89/C%2B%2B%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B.md">C++提高编程</a>：后半部分有STL库的常用方法</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/BostonRayAlen/article/details/93041395?utm_medium=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">C&#x2F;C++ 最常见50道面试题</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hsq1596753614/article/details/80249605?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">C&#x2F;C++ 经典面试题（一）之常考概念</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ljh0302/article/details/81098764?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">常见C++笔试面试题整理</a></li>
</ul>
<h1 id="C-11-新特性"><a href="#C-11-新特性" class="headerlink" title="C++ 11 新特性"></a>C++ 11 新特性</h1><ol>
<li>关键字及新语法：auto、nullptr、for</li>
<li>STL容器：std::array、std::forward_list、std::unordered_map、std::unordered_set</li>
<li>多线程：std::thread、std::atomic、std::condition_variable</li>
<li>智能指针内存管理：std::shared_ptr、std::weak_ptr、std::unique_ptr</li>
<li>其他：std::function、std::bind和lamda表达式</li>
<li>C++11中对类(class)新增的特性：<ul>
<li>default&#x2F;delete 控制默认函数</li>
<li>override &#x2F;final 强制重写&#x2F;禁止重写虚函数</li>
<li>委托构造函数 Delegating constructors</li>
<li>继承的构造函数 Inheriting constructors</li>
<li>类内部成员的初始化 Non-static data member initializers</li>
<li>移动构造和移动赋值</li>
</ul>
</li>
</ol>
<h2 id="nullptr常量"><a href="#nullptr常量" class="headerlink" title="nullptr常量"></a>nullptr常量</h2><p>C++中NULL仅仅是define NULL 0的一个宏定义，因此，有时候会产生歧义。<br>    - 比如f（char*）和f（int），参数传NULL的话到底该调用哪个？事实上，在VS下测试这样的函数重载会优先调用f（int），但是f（char *）也是正确的，因此C++引入nullptr来避免这个问题<br>    - nullptr是一个空指针，可以被转换成其他任意指针的类型</p>
<h2 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h2><p>让编译器替我们去分析表达式所属的类型，直接推导。尤其是STL中map的迭代器这种很长的类型，适合用auto。</p>
<h2 id="decltype操作符"><a href="#decltype操作符" class="headerlink" title="decltype操作符"></a>decltype操作符</h2><p>从表达式的类型推断出要定义的变量的类型，跟表达式的类型也就是参数类型紧密相关<br>    - delctype (f()) sum &#x3D; x; 并不实际调用函数f()，只是使用f()的返回值当做sum的类型<br>    - delctype (i) sum &#x3D; x;和delctype ((i)) sum &#x3D; x; 其中i为int类型，前面的为int类型，后面的为int&amp;引用</p>
<h2 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h2><p>多与auto配合使用。如 <code>for(auto n:nums)</code></p>
<h2 id="多线程互斥锁"><a href="#多线程互斥锁" class="headerlink" title="多线程互斥锁"></a>多线程互斥锁</h2><h3 id="pthread-mutex-t"><a href="#pthread-mutex-t" class="headerlink" title="pthread_mutex_t"></a>pthread_mutex_t</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//互斥量的创建</span><br><span class="line">pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); ///attr不写或传入NULL即可</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line">//加锁</span><br><span class="line">pthread_mutex_lock(pthread_mutex_t *mutex); //如果其他线程已经加锁了, 则阻塞让出CPU直到其他线程Unlock</span><br><span class="line">//pthread_mutex_trylock(pthread_mutex_t *mutex); //如果不能加锁立即返回</span><br><span class="line">·</span><br><span class="line">·</span><br><span class="line">·</span><br><span class="line">//解锁</span><br><span class="line">pthread_mutex_unlock(pthread_mutex_t *mutex);</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line">//互斥量的删除</span><br><span class="line">pthread_mutex_destroy(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure>

<h3 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h3><p><code>.lock()</code>、<code>.unlock()</code>、<code>lock_guard</code>、<code>unique_lock</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;mutex&gt;</span><br><span class="line"></span><br><span class="line">std::mutex m_mutex;</span><br><span class="line"></span><br><span class="line">//方法1</span><br><span class="line">m_mutex.lock();</span><br><span class="line">···</span><br><span class="line">m_mutex.unlock();</span><br><span class="line"></span><br><span class="line">//方法2：初始化的时候就是锁的lock操作的时候，超出它的作用域之后析构时unlock</span><br><span class="line">lock_guard&lt;mutex&gt; lock(m_mutex);</span><br><span class="line">···</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="双层vector"><a href="#双层vector" class="headerlink" title="双层vector"></a>双层vector</h2><p>vector&lt;vector<int> &gt;(n, vector<int>(n, 0))</p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>用于实现匿名函数，匿名函数只有函数体，没有函数名。  </p>
<p>用法：<code>[capture](parameters)-&gt;return-type &#123;body&#125;</code></p>
<p><code>[]</code>叫做捕获说明符，表示一个lambda表达式的开始。接下来<code>()</code>是参数列表，即这个匿名的lambda函数的参数，<code>-&gt;return-type</code>表示返回类型，如果没有返回类型，则可以省略这部分。最后<code>&#123;&#125;</code>就是函数体部分了。</p>
<p>lambda函数能够捕获lambda函数外的具有自动存储时期的变量。函数体与这些变量的集合合起来叫闭包。</p>
<ul>
<li>[] 不截取任何变量</li>
<li>[&amp;} 截取外部作用域中所有变量，并作为引用在函数体中使用</li>
<li>[&#x3D;] 截取外部作用域中所有变量，并拷贝一份在函数体中使用</li>
<li>[&#x3D;, &amp;foo] 截取外部作用域中所有变量，并拷贝一份在函数体中使用，但是对foo变量使用引用</li>
<li>[bar] 截取bar变量并且拷贝一份在函数体重使用，同时不截取其他变量</li>
<li>[x, &amp;y] x按值传递，y按引用传递</li>
<li>[this] 截取当前类中的this指针。如果已经使用了&amp;或者&#x3D;就默认添加此选项。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">auto func = [] () &#123; cout &lt;&lt; &quot;hello,world&quot;; &#125;;</span><br><span class="line">func(); //call the function</span><br><span class="line"></span><br><span class="line">auto func2 = [] () &#123; &#125;</span><br><span class="line"></span><br><span class="line">//sort函数的后面可以用lambda函数</span><br><span class="line">sort(vec.begin(), vec.end(), [](int a, int b)-&gt;bool&#123;return a &lt; b&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>放弃了C++98提供了第一个智能指针：<code>auto_ptr</code>。增加了3个新的智能指针：</p>
<ul>
<li>shared_ptr</li>
<li>weak_ptr</li>
<li>unique_ptr</li>
</ul>
<p>智能指针本质上是一个<strong>类</strong>，它将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。智能指针的出现实际上就是为了可以方便的控制对象的生命期，是 RAII 资源管理功能的自然展现。</p>
<p>STL一共给我们提供了四种智能指针：</p>
<ul>
<li>auto_ptr<br>C++98提供的解决方案，C+11已将将其摒弃。原因是避免潜在的内存崩溃问题：<strong>将一个auto_ptr赋值给另一个auto_ptr时，程序将试图删除同一个对象两次</strong>。</li>
<li>unique_ptr<br>当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做。</li>
<li>shared_ptr<br>采用<strong>引用计数</strong>的策略</li>
<li>weak_ptr<br>对于引用计数法实现的计数，总是避免不了循环引用（或环形引用）的问题，shared_ptr也不例外。为了解决类似这样的问题，C++11引入了weak_ptr，来打破这种循环引用。<br>weak_ptr是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是将一个shared_ptr赋值给weak_ptr不会改变shared_ptr的引用计数。不论是否有weak_ptr指向，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。</li>
</ul>
<p><em>ps：将一个智能指针赋值给另一个智能指针时有多种方法：<br>1）定义陚值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本，缺点是浪费空间，所以智能指针都未采用此方案。<br>2）建立所有权（ownership）概念。对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的构造函数会删除该对象。然后让赋值操作转让所有权。这就是用于auto_ptr和uniqiie_ptr 的策略，但unique_ptr的策略更严格。<br>3）创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1,。当减为0时才调用delete。这是shared_ptr采用的策略。</em></p>
<h2 id="ref-10"><a href="#ref-10" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/feng-sc/p/5710724.html">C++11常用特性的使用经验总结</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/me115/p/4777997.html">C++11中对类(class)新增的特性</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/169263">极客时间《现代C++实战30讲》：02 | 自己动手，实现C++的智能指针</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lanxuezaipiao/p/4132096.html">C++智能指针简单剖析</a></li>
</ul>
<h1 id="C-中常用的设计模式"><a href="#C-中常用的设计模式" class="headerlink" title="C++中常用的设计模式"></a>C++中常用的设计模式</h1><p>共有23种设计模式，但真正在开发中常用的模式有：</p>
<ol>
<li><p>Factory Method(工厂模式)；</p>
</li>
<li><p>Strategy(策略模式)；</p>
</li>
<li><p>Singleton(单例模式)；</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sunchaothu/p/10389842.html">C++ 单例模式总结与剖析</a></li>
<li>懒汉模式：不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//普通懒汉</span><br><span class="line">class Singleton</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	Singleton()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;constructor called&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Singleton(Singleton&amp;) = delete;</span><br><span class="line">	Singleton &amp;operator=(const Singleton&amp;) = delete;</span><br><span class="line">	static Singleton *instance_ptr;</span><br><span class="line">public:</span><br><span class="line">	~Singleton()&#123;</span><br><span class="line">		std::cout&lt;&lt;&quot;destructor called&quot;&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static Singleton* get_instance()&#123;</span><br><span class="line">		if(instance_ptr==nullptr)&#123;</span><br><span class="line">			instance_ptr = new Singleton;</span><br><span class="line">		&#125;</span><br><span class="line">		return instance_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance_ptr = nullptr;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	Singleton* instance = Singleton::get_instance();</span><br><span class="line">	Singleton* instance2 = Singleton::get_instance();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//线程安全、内存安全的懒汉式单例（智能指针，锁）</span><br><span class="line">class Singleton&#123;</span><br><span class="line">public:</span><br><span class="line">	typedef shared_ptr&lt;Singleton&gt; Ptr;</span><br><span class="line">	~Singleton()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static Ptr get_instance()&#123;</span><br><span class="line">		if(instance_ptr==nullptr)&#123;// &quot;double checked lock&quot;</span><br><span class="line">			std::lock_guard&lt;mutex&gt; lk(m_mutex);</span><br><span class="line">			if (instance_ptr == nullptr)</span><br><span class="line">				instance_ptr = Ptr(new Singleton);</span><br><span class="line">		&#125;</span><br><span class="line">		return instance_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	Singleton()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Singleton(Singleton &amp;) = delete;</span><br><span class="line">	Singleton &amp;operator=(const Singleton &amp;) = delete;</span><br><span class="line">	static Ptr instance_ptr;</span><br><span class="line">	static mutex m_mutex;//锁</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// initialization static variables out of class</span><br><span class="line">Singleton::Ptr Singleton::instance_ptr = nullptr;</span><br><span class="line">mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	Singleton::Ptr instance = Singleton::get_instance();</span><br><span class="line">	Singleton::Ptr instance1 = Singleton::get_instance();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//局部静态变量懒汉，最推荐</span><br><span class="line">class Singleton&#123;</span><br><span class="line">public:</span><br><span class="line">	~Singleton()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static Singleton&amp; get_instance()&#123;//返回指针而不是返回引用无法避免用户使用 delete instance 导致对象被提前销毁。</span><br><span class="line">		static Singleton instance;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	Singleton()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Singleton(Singleton &amp;) = delete;</span><br><span class="line">	Singleton &amp;operator=(const Singleton &amp;) = delete;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	Singleton&amp; instance = Singleton::get_instance();</span><br><span class="line">	Singleton&amp; instance1 = Singleton::get_instance();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>饿汉：在单例类定义的时候就进行实例化 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">public:</span><br><span class="line">	~Singleton()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static Singleton* get_instance()&#123;</span><br><span class="line">		return instance_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	static Singleton* instance_ptr;</span><br><span class="line">	Singleton()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Singleton(Singleton &amp;) = delete;</span><br><span class="line">	Singleton &amp;operator=(const Singleton &amp;) = delete;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton *Singleton::instance_ptr = new Singleton();</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	Singleton* instance = Singleton::get_instance();</span><br><span class="line">	Singleton* instance1 = Singleton::get_instance();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Iterator(迭代器模式)；</p>
</li>
<li><p>Abstract Factory(抽象工厂模式)；</p>
</li>
<li><p>Builder(建造者模式)；</p>
</li>
<li><p>Adapter(适配器模式)；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Target &#123;  // Target，客户期望的接口，可以使具体或抽象的类，也可以是接口</span><br><span class="line">public:</span><br><span class="line">    virtual void Request() = 0;</span><br><span class="line">    virtual ~Target()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Adaptee &#123; //需适配的类</span><br><span class="line">public:</span><br><span class="line">    void SpecificRequest() &#123; cout &lt;&lt; &quot;Adaptee&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Adapter1 : public Target &#123; //通过内部包装一个Adaptee对象，把源接口转换为目标接口：</span><br><span class="line">private:</span><br><span class="line">    Adaptee* adaptee;</span><br><span class="line">public:</span><br><span class="line">    Adapter1() &#123; adaptee = new Adaptee(); &#125;</span><br><span class="line">    void Request() &#123; adaptee-&gt;SpecificRequest(); &#125;  // 调用Request()方法会转换成调用adaptee.SpecificRequest()</span><br><span class="line">    ~Adapter1() &#123; delete adaptee; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Adapter2 : public Target&#123;</span><br><span class="line">private:</span><br><span class="line">    Adaptee *adaptee;</span><br><span class="line">public:</span><br><span class="line">    Adapter2() &#123; adaptee = new Adaptee(); &#125;</span><br><span class="line">    void Request() &#123; adaptee-&gt;SpecificRequest(); &#125;</span><br><span class="line">    ~Adapter2() &#123; delete adaptee; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Target *target = new Adapter1();</span><br><span class="line">    target-&gt;Request();</span><br><span class="line">    delete target;</span><br><span class="line"></span><br><span class="line">    Target *target2 = new Adapter2();</span><br><span class="line">    target-&gt;Request();</span><br><span class="line">    delete target2;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Bridge(桥接模式)；</p>
</li>
<li><p>Composite(组合模式)；</p>
</li>
<li><p>Interpreter(解释器模式)；</p>
</li>
<li><p>Command(命令模式)；</p>
</li>
<li><p>Mediator(中介者模式)；</p>
</li>
<li><p>Observer(观察者模式)；</p>
</li>
<li><p>State(状态模式)；</p>
</li>
<li><p>Proxy(代理模式)。</p>
</li>
</ol>
<h1 id="设计模式6大原则"><a href="#设计模式6大原则" class="headerlink" title="设计模式6大原则"></a>设计模式6大原则</h1><ol>
<li>单一职责原则(Single Responsibility Principle)</li>
<li>开放封闭原则（Open Close Principle）</li>
<li>里氏替换原则（Liskov Substitution Principle）</li>
<li>依赖倒置原则（Dependence Inversion Principle）</li>
<li>接口隔离原则（InterfaceSegregation Principles）</li>
<li>迪米特原则（Law of Demeter）也称最少知识原则</li>
</ol>
<h1 id="对编程规范的理解或认识"><a href="#对编程规范的理解或认识" class="headerlink" title="对编程规范的理解或认识"></a>对编程规范的理解或认识</h1><p>编程规范可总结为：</p>
<ul>
<li>可行性</li>
<li>可读性</li>
<li>可移植性</li>
<li>可测试性</li>
</ul>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/153444857?utm_source=wechat_session&utm_medium=social&utm_oi=717486596282130432">C++ 继承、多态、重载、友元</a></li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Su Zhilong 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Su Zhilong 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/cpp/" rel="tag"># cpp</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/01/LeetcodeDaily_June/" rel="prev" title="Leetcode每日一题 - 2020年六月">
      <i class="fa fa-chevron-left"></i> Leetcode每日一题 - 2020年六月
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/10/network/" rel="next" title="计算机网络">
      计算机网络 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">C++源文件到可执行文件的过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Clang-x2F-LLVM-x2F-lldb-x2F-GCC-x2F-gdb"><span class="nav-number">2.</span> <span class="nav-text">Clang&#x2F;LLVM&#x2F;lldb&#x2F;GCC&#x2F;gdb</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84ifndef-x2F-define-x2F-endif%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">头文件中的ifndef&#x2F;define&#x2F;endif有什么作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#typedef-%E5%92%8C-define-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">typedef 和 define 有什么区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#include-%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8A%E5%B0%96%E5%8F%AB%E6%8B%AC%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">#include 的顺序以及尖叫括号和双引号的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#main-%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%BB%A5%E5%89%8D%EF%BC%8C%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C%E4%BB%80%E4%B9%88%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">main 函数执行以前，还会执行什么代码？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.</span> <span class="nav-text">内联函数和普通函数的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.</span> <span class="nav-text">内联函数和宏定义的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89MAX%E5%92%8CMIN%E5%AE%8F"><span class="nav-number">9.</span> <span class="nav-text">定义MAX和MIN宏</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%A7%E5%B0%8F%E7%AB%AF"><span class="nav-number">10.</span> <span class="nav-text">大小端</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="nav-number">11.</span> <span class="nav-text">左值和右值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8-%E5%92%8C-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">11.1.</span> <span class="nav-text">左值引用 和 右值引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="nav-number">12.</span> <span class="nav-text">面向对象的三个基本特征</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">12.1.</span> <span class="nav-text">封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#struct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">12.1.1.</span> <span class="nav-text">struct和class的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">12.1.2.</span> <span class="nav-text">构造函数和析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">12.1.2.1.</span> <span class="nav-text">构造函数与析构函数的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E8%B0%83%E7%94%A8"><span class="nav-number">12.1.2.2.</span> <span class="nav-text">构造函数的分类及调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%AE%A4%E8%AF%86"><span class="nav-number">12.1.2.3.</span> <span class="nav-text">拷贝构造函数和赋值运算符的认识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="nav-number">12.1.2.4.</span> <span class="nav-text">构造函数和析构函数可以是虚函数吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="nav-number">12.1.2.5.</span> <span class="nav-text">构造函数和析构函数，可以调用其他的虚函数吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E5%92%8C%E7%88%B6%E7%B1%BB%E4%B8%AD%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">12.1.2.6.</span> <span class="nav-text">子类和父类中，构造函数和析构函数的调用顺序是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">12.1.2.7.</span> <span class="nav-text">虚析构函数有什么作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%A2%AB%E8%B0%83%E7%94%A8"><span class="nav-number">12.1.2.8.</span> <span class="nav-text">拷贝构造函数在什么情况下会自动被调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">12.1.2.9.</span> <span class="nav-text">深拷贝与浅拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-number">12.1.2.10.</span> <span class="nav-text">类对象作为类成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">12.1.2.11.</span> <span class="nav-text">静态成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E5%BC%80%E5%AD%98%E5%82%A8"><span class="nav-number">12.1.2.12.</span> <span class="nav-text">成员变量和成员函数分开存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88"><span class="nav-number">12.1.3.</span> <span class="nav-text">对象模型和this指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#this%E6%8C%87%E9%92%88%E6%A6%82%E5%BF%B5"><span class="nav-number">12.1.3.1.</span> <span class="nav-text">this指针概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">12.1.3.2.</span> <span class="nav-text">this指针的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this-%E6%8C%87%E9%92%88%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9%E3%80%82"><span class="nav-number">12.1.3.3.</span> <span class="nav-text">this 指针需要注意的地方。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8B%E5%85%83"><span class="nav-number">12.1.3.4.</span> <span class="nav-text">友元</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">12.2.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="nav-number">12.2.1.</span> <span class="nav-text">继承方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">12.2.2.</span> <span class="nav-text">继承中构造和析构顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">12.2.3.</span> <span class="nav-text">继承同名成员处理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">12.2.4.</span> <span class="nav-text">多继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">12.3.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">12.3.1.</span> <span class="nav-text">多态的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6"><span class="nav-number">12.3.2.</span> <span class="nav-text">多态实现的三个条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E5%88%86%E4%B8%BA%E4%B8%A4%E7%B1%BB%EF%BC%88%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%89"><span class="nav-number">12.3.3.</span> <span class="nav-text">多态分为两类（实现多态的两种方法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">12.3.4.</span> <span class="nav-text">动态多态代码示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">12.3.5.</span> <span class="nav-text">静态多态代码示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">12.3.6.</span> <span class="nav-text">虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">12.3.7.</span> <span class="nav-text">纯虚函数和抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="nav-number">12.3.7.1.</span> <span class="nav-text">抽象类特点：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84"><span class="nav-number">12.3.8.</span> <span class="nav-text">虚析构和纯虚析构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB%E5%92%8C%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">12.3.9.</span> <span class="nav-text">虚基类和虚继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-number">12.3.10.</span> <span class="nav-text">虚函数表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ref"><span class="nav-number">12.3.11.</span> <span class="nav-text">ref.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="nav-number">12.3.12.</span> <span class="nav-text">多态用法示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7"><span class="nav-number">12.4.</span> <span class="nav-text">符号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#namespace"><span class="nav-number">12.4.1.</span> <span class="nav-text">namespace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89"><span class="nav-number">12.4.2.</span> <span class="nav-text">::（作用域运算符）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#using"><span class="nav-number">12.5.</span> <span class="nav-text">using</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ref-1"><span class="nav-number">12.6.</span> <span class="nav-text">ref</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%88overload%EF%BC%89%E3%80%81%E9%87%8D%E5%86%99%EF%BC%88override%EF%BC%8C%E4%B9%9F%E5%8F%AB%E8%A6%86%E7%9B%96%EF%BC%89%E5%92%8C%E9%9A%90%E8%97%8F%EF%BC%88%E4%B9%9F%E5%8F%AB%E9%87%8D%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="nav-number">13.</span> <span class="nav-text">函数重载（overload）、重写（override，也叫覆盖）和隐藏（也叫重定义）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%EF%BC%88overload%EF%BC%89"><span class="nav-number">13.1.</span> <span class="nav-text">重载（overload）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%86%99%EF%BC%88%E8%A6%86%E7%9B%96%EF%BC%8Coverride%EF%BC%89"><span class="nav-number">13.2.</span> <span class="nav-text">重写（覆盖，override）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%EF%BC%88%E9%87%8D%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="nav-number">13.3.</span> <span class="nav-text">隐藏（重定义）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="nav-number">13.4.</span> <span class="nav-text">示例程序:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ref-2"><span class="nav-number">13.5.</span> <span class="nav-text">ref</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">函数模板与函数重载的异同？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E4%B8%AD%E7%9A%84%E7%A9%BA%E7%B1%BB%EF%BC%8C%E9%BB%98%E8%AE%A4%E4%BC%9A%E4%BA%A7%E7%94%9F%E5%93%AA%E4%BA%9B%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">15.</span> <span class="nav-text">C++中的空类，默认会产生哪些类成员函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">16.</span> <span class="nav-text">类在内存中的存储方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">17.</span> <span class="nav-text">类成员变量的初始化顺序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">18.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sizeof-%E4%B8%8E-strlen-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">19.</span> <span class="nav-text">sizeof 与 strlen 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#strcpy-%E5%92%8C-memcpy-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">20.</span> <span class="nav-text">strcpy 和 memcpy 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#strcpy"><span class="nav-number">20.1.</span> <span class="nav-text">strcpy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memcpy"><span class="nav-number">20.2.</span> <span class="nav-text">memcpy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">20.3.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#x-amp-x-1"><span class="nav-number">21.</span> <span class="nav-text">x &amp; (x-1)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#short-i-x3D-0-i-x3D-i-1L%EF%BC%9B%E8%BF%99%E4%B8%A4%E5%8F%A5%E6%9C%89%E9%94%99%E5%90%97"><span class="nav-number">22.</span> <span class="nav-text">short i &#x3D; 0; i &#x3D; i + 1L；这两句有错吗</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#amp-amp-%E5%92%8C-amp-%E3%80%81-%E5%92%8C-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">23.</span> <span class="nav-text">&amp;&amp;和&amp;、||和|有什么区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#struct%E5%AE%9A%E4%B9%89%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">24.</span> <span class="nav-text">struct定义的四种方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%81%94%E5%90%88%EF%BC%88union%EF%BC%89%E3%80%81%E7%BB%93%E6%9E%84%EF%BC%88struct%EF%BC%89%E3%80%81%E7%B1%BB%EF%BC%88class%EF%BC%89"><span class="nav-number">25.</span> <span class="nav-text">联合（union）、结构（struct）、类（class）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%91%A2%EF%BC%9F"><span class="nav-number">25.1.</span> <span class="nav-text">结构体为什么要内存对齐呢？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%88%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%EF%BC%89"><span class="nav-number">26.</span> <span class="nav-text">内存对齐（字节对齐）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99"><span class="nav-number">26.1.</span> <span class="nav-text">内存对齐规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E5%AF%B9%E9%BD%90%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">26.2.</span> <span class="nav-text">需要对齐的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B"><span class="nav-number">26.3.</span> <span class="nav-text">举例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">27.</span> <span class="nav-text">c++资源管理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">27.1.</span> <span class="nav-text">内存的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%B1%95%E5%BC%80%EF%BC%88stack-unwinding%EF%BC%89"><span class="nav-number">27.2.</span> <span class="nav-text">栈展开（stack unwinding）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RAII-Resource-Acquisition-Is-Initialization"><span class="nav-number">27.3.</span> <span class="nav-text">RAII(Resource Acquisition Is Initialization)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%B3%E8%AF%B7%E5%90%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%93%8D%E5%BA%94"><span class="nav-number">27.4.</span> <span class="nav-text">申请后系统的响应</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc-x2F-free-%E5%92%8C-new-x2F-delete-%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">27.5.</span> <span class="nav-text">malloc&#x2F;free 和 new&#x2F;delete 区别：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">27.6.</span> <span class="nav-text">malloc实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#delete-%E4%B8%8E-delete-%E5%8C%BA%E5%88%AB"><span class="nav-number">27.7.</span> <span class="nav-text">delete 与 delete[] 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">27.8.</span> <span class="nav-text">内存泄漏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-number">27.9.</span> <span class="nav-text">内存溢出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8E%E6%8C%87%E9%92%88"><span class="nav-number">27.10.</span> <span class="nav-text">野指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%8E%E6%96%87%E5%AD%97%E5%B8%B8%E9%87%8F%E5%8C%BA"><span class="nav-number">27.11.</span> <span class="nav-text">栈内存与文字常量区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ref-3"><span class="nav-number">27.12.</span> <span class="nav-text">ref</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">28.</span> <span class="nav-text">指针和引用的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ref-4"><span class="nav-number">28.1.</span> <span class="nav-text">ref</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%AD%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%92%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">29.</span> <span class="nav-text">函数参数传递中值传递、地址传递、引用传递有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%EF%BC%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%EF%BC%8C%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%BC%95%E7%94%A8%E5%B8%B8%E9%87%8F"><span class="nav-number">30.</span> <span class="nav-text">常量指针，指针常量，常量引用，没有引用常量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">31.</span> <span class="nav-text">常引用有什么作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%8C%BA%E5%88%AB"><span class="nav-number">32.</span> <span class="nav-text">指针常量与常量指针区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-number">33.</span> <span class="nav-text">指针和数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">33.1.</span> <span class="nav-text">指针和数组的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="nav-number">33.2.</span> <span class="nav-text">指针数组和数组指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">33.3.</span> <span class="nav-text">数组名和指针的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">34.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">34.1.</span> <span class="nav-text">数组的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E6%94%BE"><span class="nav-number">34.2.</span> <span class="nav-text">数组的存放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ref-5"><span class="nav-number">34.3.</span> <span class="nav-text">ref</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E7%89%88"><span class="nav-number">35.</span> <span class="nav-text">模版</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88"><span class="nav-number">35.1.</span> <span class="nav-text">函数模版</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">35.1.1.</span> <span class="nav-text">普通函数与函数模板的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-number">35.1.2.</span> <span class="nav-text">普通函数与函数模板的调用规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88%E5%AE%9E%E4%BE%8B"><span class="nav-number">35.1.3.</span> <span class="nav-text">函数模版实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88"><span class="nav-number">35.2.</span> <span class="nav-text">类模版</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%8C%BA%E5%88%AB"><span class="nav-number">35.3.</span> <span class="nav-text">类模板与函数模板区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ref-6"><span class="nav-number">35.4.</span> <span class="nav-text">ref</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">36.</span> <span class="nav-text">关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#const"><span class="nav-number">36.1.</span> <span class="nav-text">const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-number">36.2.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extern"><span class="nav-number">36.3.</span> <span class="nav-text">extern</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extern-%E2%80%9CC%E2%80%9D"><span class="nav-number">36.4.</span> <span class="nav-text">extern “C”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#explicit"><span class="nav-number">36.5.</span> <span class="nav-text">explicit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inline"><span class="nav-number">36.6.</span> <span class="nav-text">inline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#restrict"><span class="nav-number">36.7.</span> <span class="nav-text">restrict</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile"><span class="nav-number">36.8.</span> <span class="nav-text">volatile</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">37.</span> <span class="nav-text">强制类型转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-number">38.</span> <span class="nav-text">多重继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ref-7"><span class="nav-number">38.1.</span> <span class="nav-text">ref</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">39.</span> <span class="nav-text">变量的声明和定义有什么区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8C%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%8C%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">40.</span> <span class="nav-text">局部变量，静态局部变量，全局变量，静态全局变量的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">40.1.</span> <span class="nav-text">静态局部变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">40.2.</span> <span class="nav-text">静态全局变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E5%92%8C-%E9%9D%99%E6%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">40.3.</span> <span class="nav-text">全局变量 和 静态全局变量 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E6%94%BE%E5%8C%BA%E5%88%AB"><span class="nav-number">40.4.</span> <span class="nav-text">存放区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ref-8"><span class="nav-number">40.5.</span> <span class="nav-text">ref</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E4%B8%AD%E5%93%AA%E4%BA%9B%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8D%E5%8F%AF%E4%BB%A5%E9%87%8D%E8%BD%BD%EF%BC%9F"><span class="nav-number">41.</span> <span class="nav-text">C++中哪些运算符不可以重载？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">42.</span> <span class="nav-text">简述C++异常处理方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL-Standard-Template-Library-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="nav-number">43.</span> <span class="nav-text">STL(Standard Template Library,标准模板库)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8STL%E5%AE%B9%E5%99%A8%E3%80%81%E7%AE%97%E6%B3%95%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">43.1.</span> <span class="nav-text">常用STL容器、算法、迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">43.2.</span> <span class="nav-text">函数对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="nav-number">43.2.1.</span> <span class="nav-text">仿函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">43.2.2.</span> <span class="nav-text">函数对象的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%93%E8%AF%8D"><span class="nav-number">43.3.</span> <span class="nav-text">谓词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL%E5%AE%B9%E5%99%A8%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">43.4.</span> <span class="nav-text">STL容器的底层数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector%E5%92%8Clist%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">43.5.</span> <span class="nav-text">vector和list的异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#push-back-%E5%92%8C-emplace-back"><span class="nav-number">43.6.</span> <span class="nav-text">push_back 和 emplace_back</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map%E5%92%8Cunordered-map%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">43.7.</span> <span class="nav-text">map和unordered_map的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ref-9"><span class="nav-number">43.8.</span> <span class="nav-text">ref</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-11-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">44.</span> <span class="nav-text">C++ 11 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#nullptr%E5%B8%B8%E9%87%8F"><span class="nav-number">44.1.</span> <span class="nav-text">nullptr常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#auto%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">44.2.</span> <span class="nav-text">auto关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#decltype%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">44.3.</span> <span class="nav-text">decltype操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4for%E8%AF%AD%E5%8F%A5"><span class="nav-number">44.4.</span> <span class="nav-text">范围for语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">44.5.</span> <span class="nav-text">多线程互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-mutex-t"><span class="nav-number">44.5.1.</span> <span class="nav-text">pthread_mutex_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-mutex"><span class="nav-number">44.5.2.</span> <span class="nav-text">std::mutex</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E5%B1%82vector"><span class="nav-number">44.6.</span> <span class="nav-text">双层vector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">44.7.</span> <span class="nav-text">lambda表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">44.8.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ref-10"><span class="nav-number">44.9.</span> <span class="nav-text">ref</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">45.</span> <span class="nav-text">C++中常用的设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="nav-number">46.</span> <span class="nav-text">设计模式6大原则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E7%9A%84%E7%90%86%E8%A7%A3%E6%88%96%E8%AE%A4%E8%AF%86"><span class="nav-number">47.</span> <span class="nav-text">对编程规范的理解或认识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">48.</span> <span class="nav-text">代码示例</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Su Zhilong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Su Zhilong</p>
  <div class="site-description" itemprop="description">I will always be with you</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/suzhilong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;suzhilong"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Su Zhilong</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">380k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:46</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'uaEz4DL2UqM1jg1eGmpd8vhF-gzGzoHsz',
      appKey     : 'SzL1ETN5dDwbXjnzyJYJkjTb',
      placeholder: "comment",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
