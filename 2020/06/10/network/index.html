<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/apple-touch-icon-next.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="计算机网络概念网络协议在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。 计算机网络体系结构计算机网络体系结构是指计算机网络层次结构模型，它是各层的协议以及层次之间的端口的集合。在计算机网络中实现通信必须依靠网络通信协议，目前广泛采用的是国际标准化组织（ISO）1997年提出的开放系统互联（Open Syst">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="https://github.com/suzhilong/suzhilong.github.io.git/2020/06/10/network/index.html">
<meta property="og:site_name" content="SOUSIC">
<meta property="og:description" content="计算机网络概念网络协议在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。 计算机网络体系结构计算机网络体系结构是指计算机网络层次结构模型，它是各层的协议以及层次之间的端口的集合。在计算机网络中实现通信必须依靠网络通信协议，目前广泛采用的是国际标准化组织（ISO）1997年提出的开放系统互联（Open Syst">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/06/09/wvthjWo3nSCx2NP.png">
<meta property="og:image" content="https://i.loli.net/2020/06/09/Heb6Y83xwKsiodr.png">
<meta property="og:image" content="https://i.loli.net/2020/06/09/bgk9DNdcfawv5Fe.png">
<meta property="og:image" content="https://i.loli.net/2020/06/10/RQOy2WUYzfbxtmv.png">
<meta property="og:image" content="https://i.loli.net/2020/06/10/lD6isBec9Oh2zWo.jpg">
<meta property="og:image" content="https://i.loli.net/2020/10/13/WLNRMogAhJYStbO.png">
<meta property="og:image" content="https://i.loli.net/2020/09/25/ZoESaLNlwbrugkv.png">
<meta property="og:image" content="https://i.loli.net/2020/10/14/Ax72pejscZGi5T4.png">
<meta property="og:image" content="https://i.loli.net/2020/08/13/CwRs32gdhp1xfYv.png">
<meta property="og:image" content="https://i.loli.net/2020/08/13/ij4qSdQV8bUFnPy.png">
<meta property="og:image" content="https://i.loli.net/2020/08/13/eNUzQE9g8YIP3H4.png">
<meta property="article:published_time" content="2020-06-10T09:00:00.000Z">
<meta property="article:modified_time" content="2020-10-14T07:29:18.607Z">
<meta property="article:author" content="Su Zhilong">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/06/09/wvthjWo3nSCx2NP.png">

<link rel="canonical" href="https://github.com/suzhilong/suzhilong.github.io.git/2020/06/10/network/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机网络 | SOUSIC</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="SOUSIC" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SOUSIC</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">哈库呐玛塔塔</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/suzhilong/suzhilong.github.io.git/2020/06/10/network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Su Zhilong">
      <meta itemprop="description" content="I will always be with you">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SOUSIC">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-10 17:00:00" itemprop="dateCreated datePublished" datetime="2020-06-10T17:00:00+08:00">2020-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-14 15:29:18" itemprop="dateModified" datetime="2020-10-14T15:29:18+08:00">2020-10-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/06/10/network/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/10/network/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h1><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</p>
<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>计算机网络体系结构是指计算机网络层次结构模型，它是各层的协议以及层次之间的端口的集合。在计算机网络中实现通信必须依靠网络通信协议，目前广泛采用的是国际标准化组织（ISO）1997年提出的开放系统互联（Open System Interconnection，OSI）参考模型，习惯上称为ISO&#x2F;OSI参考模型。</p>
<span id="more"></span>
<h2 id="不同的网络体系结构"><a href="#不同的网络体系结构" class="headerlink" title="不同的网络体系结构"></a>不同的网络体系结构</h2><h3 id="OSI七层协议体系结构"><a href="#OSI七层协议体系结构" class="headerlink" title="OSI七层协议体系结构"></a>OSI七层协议体系结构</h3><p>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。</p>
<p>OSI七层协议模型主要包括是：</p>
<ul>
<li>应用层（Application）</li>
<li>表示层（Presentation）</li>
<li>会话层（Session）</li>
<li>运输层（Transport）</li>
<li>网络层（Network）</li>
<li>数据链路层（Data Link）</li>
<li>物理层（Physical）</li>
</ul>
<h3 id="TCP-x2F-IP四层体系结构"><a href="#TCP-x2F-IP四层体系结构" class="headerlink" title="TCP&#x2F;IP四层体系结构"></a>TCP&#x2F;IP四层体系结构</h3><p>TCP&#x2F;IP 是一个四层体系结构，主要包括：</p>
<ul>
<li>应用层</li>
<li>运输层</li>
<li>网际层（用网际层这个名字是强调这一层是为了解决不同网络的互连问题）</li>
<li>网络接口层</li>
</ul>
<p>不过从实质上讲，TCP&#x2F;IP 只有最上面的三层，因为最下面的网络接口层并没有什么具体内容，因此在学习计算机网络的原理时往往采用折中的办法，即综合 OSI 和 TCP&#x2F;IP 的优点，采用一种只有五层协议的体系结构。</p>
<h3 id="五层协议的体系结构"><a href="#五层协议的体系结构" class="headerlink" title="五层协议的体系结构"></a>五层协议的体系结构</h3><p>五层协议的体系结构主要包括：</p>
<ul>
<li>应用层</li>
<li>运输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<p><img src="https://i.loli.net/2020/06/09/wvthjWo3nSCx2NP.png" alt="不同体系结构对比"></p>
<p><em>ps. 五层协议的体系结构只是为了介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构。</em></p>
<h2 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h2><p><img src="https://i.loli.net/2020/06/09/Heb6Y83xwKsiodr.png" alt="TCP/IP四层协议表示方法举例"></p>
<h2 id="具有五层协议的体系结构"><a href="#具有五层协议的体系结构" class="headerlink" title="具有五层协议的体系结构"></a>具有五层协议的体系结构</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层（application-layer）的任务是通过<strong>应用进程间</strong>的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。</p>
<h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>运输层（transport layer）的主要任务就是负责向<strong>两台主机进程之间</strong>的通信提供<strong>通用的数据传输</strong>服务。应用进程利用该服务传送应用层报文。</p>
<p>运输层主要使用一下两种协议</p>
<ul>
<li>TCP-传输控制协议：提供面向连接的，可靠的数据传输服务</li>
<li>UDP-用户数据协议：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）</li>
</ul>
<h4 id="每一个应用层（TCP-x2F-IP参考模型的最高层）协议一般都会使用到两个传输层协议之一"><a href="#每一个应用层（TCP-x2F-IP参考模型的最高层）协议一般都会使用到两个传输层协议之一" class="headerlink" title="每一个应用层（TCP&#x2F;IP参考模型的最高层）协议一般都会使用到两个传输层协议之一"></a>每一个应用层（TCP&#x2F;IP参考模型的最高层）协议一般都会使用到两个传输层协议之一</h4><p><em>ps. 以下协议是应用层协议：</em></p>
<p>运行在TCP协议上的协议：</p>
<ul>
<li>HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。端口号：80</li>
<li>HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。端口号：443</li>
<li>FTP（File Transfer Protocol，文件传输协议），用于文件传输。端口号：21</li>
<li>POP3（Post Office Protocol, version 3，邮局协议），收邮件用。</li>
<li>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。</li>
<li>TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。端口号：23</li>
<li>SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。</li>
</ul>
<p>运行在UDP协议上的协议：</p>
<ul>
<li>BOOTP（Boot Protocol，启动协议），应用于无盘设备。</li>
<li>NTP（Network Time Protocol，网络时间协议），用于网络同步。</li>
<li>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</li>
</ul>
<p>运行在TCP和UDP协议上：</p>
<ul>
<li>DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。</li>
</ul>
<h3 id="网络层（网际层）"><a href="#网络层（网际层）" class="headerlink" title="网络层（网际层）"></a>网络层（网际层）</h3><p>网络层负责为分组交换网上的不同<strong>主机</strong>提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</p>
<p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>在物理层上所传送的数据单位是比特。</p>
<h3 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h3><p><img src="https://i.loli.net/2020/06/09/bgk9DNdcfawv5Fe.png" alt="数据在各层之间的传递过程"></p>
<h2 id="TCP的三次握手四次挥手"><a href="#TCP的三次握手四次挥手" class="headerlink" title="TCP的三次握手四次挥手"></a>TCP的三次握手四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://i.loli.net/2020/06/10/RQOy2WUYzfbxtmv.png" alt="三次握手"></p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://i.loli.net/2020/06/10/lD6isBec9Oh2zWo.jpg" alt="四次挥手"></p>
<p>MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<ul>
<li><strong>CLOSED</strong>：表示初始状态。</li>
<li><strong>LISTEN</strong>：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</li>
<li><strong>SYN_SENT</strong>：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</li>
<li><strong>SYN_RCVD</strong>: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</li>
<li><strong>ESTABLISHED</strong>：表示连接已经建立。</li>
<li><strong>FIN_WAIT_1</strong>: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。</li>
<li><strong>FIN_WAIT_2</strong>：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。</li>
<li><strong>TIME_WAIT</strong>: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</li>
<li><strong>CLOSING</strong>: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</li>
<li><strong>CLOSE_WAIT</strong>: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。</li>
<li><strong>LAST_ACK</strong>: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。</li>
</ul>
<h3 id="半关闭状态"><a href="#半关闭状态" class="headerlink" title="半关闭状态"></a>半关闭状态</h3><p><img src="https://i.loli.net/2020/10/13/WLNRMogAhJYStbO.png" alt="半关闭状态"></p>
<h3 id="为什么TCP连接的时候是3次，不是2次"><a href="#为什么TCP连接的时候是3次，不是2次" class="headerlink" title="为什么TCP连接的时候是3次，不是2次"></a>为什么TCP连接的时候是3次，不是2次</h3><p>因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。</p>
<p>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。</p>
<h3 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h3><p>因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文（所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次）。</p>
<h3 id="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"><a href="#为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？" class="headerlink" title="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"></a>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h3><p>这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p>
<h2 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h2 id="TCP和UDP对比"><a href="#TCP和UDP对比" class="headerlink" title="TCP和UDP对比"></a>TCP和UDP对比</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">UPD</th>
<th align="center">TCP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否连接</td>
<td align="center">无连接</td>
<td align="center">面向连接（3次握手）</td>
</tr>
<tr>
<td align="center">是否可靠</td>
<td align="center">尽最大努力交付，不保证可靠。不使用流量控制和拥塞控制</td>
<td align="center">使用流量控制和拥塞控制。可靠服务：无差错、不丢失、不重复、按序到达</td>
</tr>
<tr>
<td align="center">传输方式</td>
<td align="center">面向报文</td>
<td align="center">面向字节流</td>
</tr>
<tr>
<td align="center">连接对象个数</td>
<td align="center">一对一，多对多，多对一，一对多</td>
<td align="center">一对一</td>
</tr>
<tr>
<td align="center">首部开销</td>
<td align="center">8字节</td>
<td align="center">首部最小20字节，最大60字节</td>
</tr>
</tbody></table>
<h2 id="TCP怎么保证可靠"><a href="#TCP怎么保证可靠" class="headerlink" title="TCP怎么保证可靠"></a>TCP怎么保证可靠</h2><ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li>校验和：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li>流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li>拥塞控制：当网络拥塞时，减少数据的发送。</li>
<li>ARQ协议：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li>超时重传：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h2 id="拥塞控制和流量控制"><a href="#拥塞控制和流量控制" class="headerlink" title="拥塞控制和流量控制"></a>拥塞控制和流量控制</h2><p>都是保证TCP可靠的方法。</p>
<ul>
<li>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况</li>
<li>流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的</li>
</ul>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><ul>
<li>慢开始：从小到大逐渐增大发送窗口，每个传输轮次后将 cwnd 大小加倍。</li>
<li>拥塞避免：用慢开始门限（ssthresh）的阈值来控制 cwnd 的增长<ul>
<li>cwnd &lt; ssthresh , 使用慢开始算法</li>
<li>cwnd &#x3D; ssthresh , 使用慢开始算法或拥塞避免算法（线性增长，一般是加1）都可以</li>
<li>cwnd &gt; ssthresh , 使用拥塞避免算法。只要发现网络中出现拥塞就<strong>乘法减小</strong>ssthresh并从cwnd&#x3D;1开始重新执行慢开始算法。</li>
</ul>
</li>
<li>快重传：允许发送方再连续收到 3 个重复的确认后就可以开始执行乘法减小过程而不必再等待所设置的重传计时器到时。</li>
<li>快恢复：是与快重传算法配合使用的一个算法。快恢复算法后与原来不同的一点是当发现网络出现拥塞并执行了乘法减小过程后，并不是设置cwnd&#x3D;1并重新开始执行慢开始算法，而是让 cwnd &#x3D;乘法减小后的ssthresh并开始执行拥塞避免算法。</li>
</ul>
<p><img src="https://i.loli.net/2020/09/25/ZoESaLNlwbrugkv.png" alt="拥塞控制"></p>
<p><em>ps. ssthresh的设置：TCP&#x2F;IP 中规定无论是在慢开始阶段还是在拥塞避免阶段，只要发现网络中出现拥塞（没有按时收到确认），就要把ssthresh设置为此时发送窗口的一半大小（不能小于2）</em></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41431406/article/details/97926927">TCP的拥塞控制（详解）</a></li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><ul>
<li>RTT算法</li>
<li>滑动窗口<ul>
<li>发送窗口</li>
<li>接受窗口</li>
</ul>
</li>
</ul>
<h2 id="使UPD可靠的方法"><a href="#使UPD可靠的方法" class="headerlink" title="使UPD可靠的方法"></a>使UPD可靠的方法</h2><ul>
<li>超时重传（定时器）</li>
<li>有序接受 （添加包序号）</li>
<li>应答确认 （Seq&#x2F;Ack应答机制）</li>
<li>滑动窗口流量控制等机制 （滑动窗口协议）</li>
</ul>
<p>已有协议：</p>
<ul>
<li>可靠用户数据报协议（RUDP）：RUDP使用类似于TCP的重发机制和拥塞控制算法</li>
<li>实时协议（RTP）：有效负载识别，序列编号，时间戳和投递监听</li>
<li>基于UDP的数据传输协议（UDT）：序列号、滑动窗口</li>
</ul>
<h2 id="为什么会发生-TCP-粘包、拆包"><a href="#为什么会发生-TCP-粘包、拆包" class="headerlink" title="为什么会发生 TCP 粘包、拆包"></a>为什么会发生 TCP 粘包、拆包</h2><p>粘包问题是由TCP是“字节流”协议，没有消息边界所引起的。</p>
<ol>
<li>应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。</li>
<li>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。</li>
<li>进行 MSS （最大报文长度）大小的 TCP 分段，当 <code>TCP报文长度 - TCP头部长度 &gt; MSS</code> 的时候将发生拆包。</li>
<li>接收方法不及时读取套接字缓冲区数据，这将发生粘包。</li>
</ol>
<h2 id="如何处理粘包、拆包？"><a href="#如何处理粘包、拆包？" class="headerlink" title="如何处理粘包、拆包？"></a>如何处理粘包、拆包？</h2><p>解决粘包的方法就是由应用层进行分包处理，本质上就是由应用层来维护消息和消息的边界。</p>
<ol>
<li>使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。</li>
<li>设置定长消息，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。</li>
<li>设置消息边界，服务端从网络流中按消息编辑分离出消息内容，一般使用‘\n’。</li>
<li>更为复杂的协议。</li>
</ol>
<h2 id="简述Socket通信基本步骤"><a href="#简述Socket通信基本步骤" class="headerlink" title="简述Socket通信基本步骤"></a>简述Socket通信基本步骤</h2><p>具体分成两个部分：</p>
<ol>
<li>服务端<ul>
<li>socket(创建socket) </li>
<li>bind(绑定socket和端口号) </li>
<li>listen(监听该端口号)</li>
<li>accept(等待并接受客户端连接请求)</li>
<li>read,write(读取数据和返回数据) </li>
<li>close(关闭socket)</li>
</ul>
</li>
<li>客户端<ul>
<li>socket(创建socket) </li>
<li>connect(连接指定的端口) </li>
<li>read,write(读取数据和返回数据) </li>
<li>close(关闭socket)</li>
</ul>
</li>
</ol>
<h2 id="GET、POST的区别"><a href="#GET、POST的区别" class="headerlink" title="GET、POST的区别"></a>GET、POST的区别</h2><ul>
<li>作用<br>GET 用于获取资源，而 POST 用于传输数据。</li>
<li>参数<br>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。</li>
<li>安全<br>GET 方法是安全的，而 POST 却不是。安全就是说请求方法不会改变服务器状态，也就是说它只是可读的。因为 POST 的目的是传送数据，这个数据可能是用户上传的表单，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。所以，从这个方面来讲，POST是不安全的。</li>
<li>幂等<br>GET方法都是幂等的，但 POST 方法不是。幂等就是说，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。所以，幂等方法不应该具有副作用。</li>
</ul>
<h2 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h2><ol>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ol>
<p>HTTPS是运行在SSL&#x2F;TLS之上的HTTP协议，SSL&#x2F;TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p>
<h2 id="SSL四次握手"><a href="#SSL四次握手" class="headerlink" title="SSL四次握手"></a>SSL四次握手</h2><p><img src="https://i.loli.net/2020/10/14/Ax72pejscZGi5T4.png" alt="SSL四次握手"></p>
<ol>
<li>客户端请求建立SSL链接，并向服务端发送一个<strong>随机数–Client random</strong>和<strong>客户端支持的加密方法</strong>，比如RSA公钥加密，此时是明文传输。</li>
<li>服务端回复一种客户端<strong>支持的加密方法</strong>、<strong>一个随机数–Server random</strong>、授信的服务器<strong>证书</strong>和<strong>非对称加密的公钥</strong>。</li>
<li>客户端收到服务端的回复后利用服务端的公钥，加上新的<strong>随机数–Premaster secret</strong> 通过服务端下发的公钥及加密方法进行加密，发送给服务器。</li>
<li>服务端收到客户端的回复，利用已知的加解密方式进行解密，同时利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key – session key。</li>
</ol>
<h2 id="什么是对称加密与非对称加密"><a href="#什么是对称加密与非对称加密" class="headerlink" title="什么是对称加密与非对称加密"></a>什么是对称加密与非对称加密</h2><ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等。这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li>
</ul>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/58d7635e5c497d0057fae036">详细解析HTTP 与HTTPS 的区别</a></li>
</ul>
<h2 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h2><ol>
<li>首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；</li>
<li>客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；</li>
<li>消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；</li>
<li>发送给服务端，此时只有服务端（RSA私钥）能解密。</li>
<li>解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。</li>
</ol>
<h2 id="HTTP长连接，短连接是什么？"><a href="#HTTP长连接，短连接是什么？" class="headerlink" title="HTTP长连接，短连接是什么？"></a>HTTP长连接，短连接是什么？</h2><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
<p>在HTTP&#x2F;1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：<code>Connection:keep-alive</code></p>
<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<h2 id="HTTP版本对比"><a href="#HTTP版本对比" class="headerlink" title="HTTP版本对比"></a>HTTP版本对比</h2><h3 id="HTTP1-0版本的特性："><a href="#HTTP1-0版本的特性：" class="headerlink" title="HTTP1.0版本的特性："></a>HTTP1.0版本的特性：</h3><ul>
<li>1.0的HTTP版本，是一种无状态、无连接的应用层协议。</li>
<li>HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</li>
</ul>
<h3 id="HTTP1-1版本新特性"><a href="#HTTP1-1版本新特性" class="headerlink" title="HTTP1.1版本新特性"></a>HTTP1.1版本新特性</h3><ul>
<li>默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</li>
<li>管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应</li>
<li>断点续传原理</li>
</ul>
<h3 id="HTTP2-0版本的特性"><a href="#HTTP2-0版本的特性" class="headerlink" title="HTTP2.0版本的特性"></a>HTTP2.0版本的特性</h3><ul>
<li>二进制分帧（采用二进制格式的编码将其封装）</li>
<li>首部压缩（设置了专门的首部压缩设计的HPACK算法。）</li>
<li>流量控制（设置了接收某个数据流的多少字节一些流量控制）</li>
<li>多路复用（可以在共享TCP链接的基础上同时发送请求和响应）</li>
<li>请求优先级（可以通过优化这些帧的交错和传输顺序进一步优化性能）</li>
<li>服务器推送（就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资 源无需客户端明确的请求。（重大更新））</li>
</ul>
<h3 id="HTTP1-1-和-HTTP2-0-的区别"><a href="#HTTP1-1-和-HTTP2-0-的区别" class="headerlink" title="HTTP1.1 和 HTTP2.0 的区别"></a>HTTP1.1 和 HTTP2.0 的区别</h3><ul>
<li><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li>
<li><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li>
<li><strong>header压缩</strong>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li>
<li><strong>服务端推送</strong>（server push），同SPDY一样，HTTP2.0也具有server push功能。</li>
</ul>
<p>ref. <a target="_blank" rel="noopener" href="https://juejin.im/entry/5981c5df518825359a2b9476">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></p>
<h2 id="输入URL到显示网页的过程"><a href="#输入URL到显示网页的过程" class="headerlink" title="输入URL到显示网页的过程"></a>输入URL到显示网页的过程</h2><ol>
<li>DNS解析：简单地说就是找到URL对应的IP地址。</li>
<li>TCP连接：浏览器与目标服务器建立TCP连接<ul>
<li>HTTP协议建立在TCP协议之上，HTTP请求前，需先进行TCP连接，形成客户端到服务器的稳定的通道。俗称TCP的三次握手。</li>
<li>TCP连接完成后，HTTP请求开始，请求有多种方式，常见的有GET，POST等。</li>
</ul>
</li>
<li>发送HTTP请求<ul>
<li>HTTP请求包含请求头，也可能包含请求体两部分，请求头中包含我们希望对请求文件的操作的信息，请求体中包含传递给后台的参数。</li>
</ul>
</li>
<li>服务器处理请求并返回HTTP报文<ul>
<li>服务器收到HTTP请求后，后台开始工作，如负载平衡，跨域等，这里就是后端的工作了。</li>
<li>文件处理完毕，生成响应数据包，响应也包含两部分，响应头和相应体，响应体就是我们所请求的文件。</li>
<li>经过网络传输，文件被下载到本地客户端，客户端开始加载。</li>
</ul>
</li>
<li>浏览器解析渲染HTML页面<ul>
<li>客户端浏览器加载了HTML文件后，由上到下解析HTML为DOM树（DOM Tree）。</li>
<li>遇到CSS文件，CSS中的url发起HTTP请求。</li>
<li>这是第二次HTTP请求，由于HTTP1.1协议增加了Connection: keep-alive声明，故TCP连接不会关闭，可以复用。</li>
<li>HTTP连接是无状态连接，客户端与服务器端需要重新发起请求–响应。在请求CSS的过程中，解析器继续解析HTML，然后到了script标签。</li>
<li>由于script可能会改变DOM结构，故解析器停止生成DOM树，解析器被js阻塞，等待js文件发起HTTP请求，然后加载。这是第三次HTTP请求。js执行完成后解析器继续解析。</li>
<li>由于CSS文件可能会影响js文件的执行结果，因此需等CSS文件加载完成后再执行。</li>
<li>浏览器收到CSS文件后，开始解析CSS文件为CSSOM树（CSS Rule Tree）。</li>
<li>CSSOM树生成后，DOM Tree与CSS Rule Tree结合生成渲染树（Render Tree）。</li>
<li>Render Tree会被CSS文件阻塞，渲染树生成后，先布局，绘制渲染树中节点的属性(位置，宽度，大小等)，然后渲染，页面就会呈现信息。</li>
<li>继续边解析边渲染，遇到了另一个js文件，js文件执行后改变了DOM树，渲染树从被改变的dom开始再次渲染。</li>
<li>继续向下渲染，碰到一个img标签，浏览器发起HTTP请求，不会等待img加载完成，继续向下渲染，之后再重新渲染此部分。</li>
<li>DOM树遇到HTML结束标签，停止解析，进而渲染结束。</li>
</ul>
</li>
<li>连接结束</li>
</ol>
<p>涉及到的协议：IP(网络)、OSPF(路由)、ARP(本地MAC解析)</p>
<h2 id="ARP，RARP-和-ICMP"><a href="#ARP，RARP-和-ICMP" class="headerlink" title="ARP，RARP 和 ICMP"></a>ARP，RARP 和 ICMP</h2><ul>
<li>ARP协议：属于ipv4协议簇，工作在数据链路层。其功能是把网络层32位的IP转换成数据链路层48位的MAC地址，在这个过程中有一个很重要的表——<strong>ARP缓存表</strong>，<ul>
<li>ARP缓存表中缓存了IP地址和MAC地址的映射关系。如果没有缓存的情况，ARP会广播某一个IP的信息，收到这个广播的设备会回应一个包，表示我是不是这个IP地址。如果是，广播该IP地址的设备会记录对应设备的MAC地址。</li>
</ul>
</li>
<li>RARP协议:(reverse arp，反向arp协议)，和ARP协议做相反的工作，它将48位的MAC地址转换为32位的IP地址。</li>
<li>ICMP协议:（Internet Control Message Protocol，网络控制消息协议），它的功能是报告无法传送的数据包的错误，并帮助对这些错误进行疑难解答。</li>
</ul>
<h2 id="DNS-Domain-Name-System-域名系统-域名解析过程"><a href="#DNS-Domain-Name-System-域名系统-域名解析过程" class="headerlink" title="DNS(Domain Name System, 域名系统) 域名解析过程"></a>DNS(Domain Name System, 域名系统) 域名解析过程</h2><p>域名格式：三级域名.二级域名.顶级域名(<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>)<br><img src="https://i.loli.net/2020/08/13/CwRs32gdhp1xfYv.png" alt="域名"></p>
<p>域名服务器：保存域名到IP地址映射的服务器。<br><img src="https://i.loli.net/2020/08/13/ij4qSdQV8bUFnPy.png" alt="域名服务器"></p>
<ul>
<li>递归查询：主机向本地域名服务器的查询一般都是采用<strong>递归查询</strong>。指的是，当主机所询问的本地域名服务器不知道被查询的域名IP地址时，<strong>本地域名服务器</strong>就以DNS客户的身份，向其他根域名服务器继续查询，而不是让主机自己进行下一步查询，</li>
<li>迭代查询：本地域名服务器向根域名服务器查询通常采用<strong>迭代查询</strong>。指的是，当根域名服务器没有保存本地域名服务器所查询的域名IP地址时，就告诉本地域名服务器下一步应当找哪一个域名服务器查询，而不是根域名服务器以客户身份查询。</li>
</ul>
<p><img src="https://i.loli.net/2020/08/13/eNUzQE9g8YIP3H4.png" alt="DNS查询"></p>
<p>找域名服务器查询之前，会先找缓存中有没有：</p>
<ol>
<li>浏览器缓存：当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）</li>
<li>系统缓存：当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP</li>
<li>路由器缓存：当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查</li>
</ol>
<p>当以上三个缓存中都没有，才会向DNS服务器查询。</p>
<h2 id="NAT-Network-Address-Translation-网络地址转换-协议"><a href="#NAT-Network-Address-Translation-网络地址转换-协议" class="headerlink" title="NAT(Network Address Translation, 网络地址转换)协议"></a>NAT(Network Address Translation, 网络地址转换)协议</h2><p>用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。</p>
<h2 id="cookie和session对于HTTP有什么用？"><a href="#cookie和session对于HTTP有什么用？" class="headerlink" title="cookie和session对于HTTP有什么用？"></a>cookie和session对于HTTP有什么用？</h2><p>HTTP协议本身是无法判断用户身份。所以需要cookie或者session</p>
<h2 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h2><p>cookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信息。客户端向服务器发起请求，就提取浏览器中的用户信息由http发送给服务器</p>
<h2 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h2><p>session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给session。</p>
<p>服务器默认为客户浏览器的cookie中设置 sessionid，这个sessionid就和cookie对应，浏览器在向服务器请求过程中传输的cookie 包含 sessionid ，服务器根据传输cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</p>
<h2 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h2><ul>
<li>cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高</li>
<li>单个cookie保存的数据不能超过4K，session无此限制</li>
<li>session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li>谢希仁. 计算机网络（第7版）. 电子工业出版社</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ThinkWon/article/details/104903925">重学TCP&#x2F;IP协议和三次握手四次挥手</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ls5718/article/details/52141571?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task">TCP&#x2F;UDP区别以及UDP如何实现可靠传输</a></li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Su Zhilong 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Su Zhilong 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Network/" rel="tag"># Network</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/05/cppReview/" rel="prev" title="C++ Review">
      <i class="fa fa-chevron-left"></i> C++ Review
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/20/database/" rel="next" title="数据库">
      数据库 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">计算机网络概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.1.</span> <span class="nav-text">网络协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">计算机网络体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">不同的网络体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OSI%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.1.</span> <span class="nav-text">OSI七层协议体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-x2F-IP%E5%9B%9B%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.2.</span> <span class="nav-text">TCP&#x2F;IP四层体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.3.</span> <span class="nav-text">五层协议的体系结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-x2F-IP"><span class="nav-number">1.4.</span> <span class="nav-text">TCP&#x2F;IP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E6%9C%89%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.</span> <span class="nav-text">具有五层协议的体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">1.5.1.</span> <span class="nav-text">应用层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82"><span class="nav-number">1.5.2.</span> <span class="nav-text">运输层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%88TCP-x2F-IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%9C%80%E9%AB%98%E5%B1%82%EF%BC%89%E5%8D%8F%E8%AE%AE%E4%B8%80%E8%88%AC%E9%83%BD%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%88%B0%E4%B8%A4%E4%B8%AA%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E4%B9%8B%E4%B8%80"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">每一个应用层（TCP&#x2F;IP参考模型的最高层）协议一般都会使用到两个传输层协议之一</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89"><span class="nav-number">1.5.3.</span> <span class="nav-text">网络层（网际层）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-number">1.5.4.</span> <span class="nav-text">数据链路层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="nav-number">1.5.5.</span> <span class="nav-text">物理层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B"><span class="nav-number">1.5.6.</span> <span class="nav-text">数据传输过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.6.</span> <span class="nav-text">TCP的三次握手四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">1.6.1.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.6.2.</span> <span class="nav-text">四次挥手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8A%E5%85%B3%E9%97%AD%E7%8A%B6%E6%80%81"><span class="nav-number">1.6.3.</span> <span class="nav-text">半关闭状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF3%E6%AC%A1%EF%BC%8C%E4%B8%8D%E6%98%AF2%E6%AC%A1"><span class="nav-number">1.6.4.</span> <span class="nav-text">为什么TCP连接的时候是3次，不是2次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%85%B3%E9%97%AD%E7%9A%84%E6%97%B6%E5%80%99%E5%8D%B4%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="nav-number">1.6.5.</span> <span class="nav-text">为什么连接的时候是三次握手，关闭的时候却是四次握手？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E5%87%BA%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E7%A1%AE%E8%AE%A4%E6%8A%A5%E6%96%87%E5%90%8E%E8%A6%81%E7%AD%892MSL%E7%9A%84%E6%97%B6%E9%97%B4%E6%89%8D%E8%83%BD%E9%87%8A%E6%94%BETCP%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="nav-number">1.6.6.</span> <span class="nav-text">为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">1.7.</span> <span class="nav-text">如果已经建立了连接，但是客户端突然出现故障了怎么办？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%92%8CUDP%E5%AF%B9%E6%AF%94"><span class="nav-number">1.8.</span> <span class="nav-text">TCP和UDP对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0"><span class="nav-number">1.9.</span> <span class="nav-text">TCP怎么保证可靠</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">1.10.</span> <span class="nav-text">拥塞控制和流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.10.1.</span> <span class="nav-text">拥塞控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">1.10.2.</span> <span class="nav-text">流量控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BFUPD%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.11.</span> <span class="nav-text">使UPD可靠的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F-TCP-%E7%B2%98%E5%8C%85%E3%80%81%E6%8B%86%E5%8C%85"><span class="nav-number">1.12.</span> <span class="nav-text">为什么会发生 TCP 粘包、拆包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%B2%98%E5%8C%85%E3%80%81%E6%8B%86%E5%8C%85%EF%BC%9F"><span class="nav-number">1.13.</span> <span class="nav-text">如何处理粘包、拆包？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0Socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.14.</span> <span class="nav-text">简述Socket通信基本步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GET%E3%80%81POST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.15.</span> <span class="nav-text">GET、POST的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.16.</span> <span class="nav-text">HTTP与HTTPS的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SSL%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">1.17.</span> <span class="nav-text">SSL四次握手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-number">1.18.</span> <span class="nav-text">什么是对称加密与非对称加密</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ref"><span class="nav-number">1.18.1.</span> <span class="nav-text">ref</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.19.</span> <span class="nav-text">HTTPS工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.20.</span> <span class="nav-text">HTTP长连接，短连接是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94"><span class="nav-number">1.21.</span> <span class="nav-text">HTTP版本对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP1-0%E7%89%88%E6%9C%AC%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="nav-number">1.21.1.</span> <span class="nav-text">HTTP1.0版本的特性：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP1-1%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.21.2.</span> <span class="nav-text">HTTP1.1版本新特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP2-0%E7%89%88%E6%9C%AC%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.21.3.</span> <span class="nav-text">HTTP2.0版本的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP1-1-%E5%92%8C-HTTP2-0-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.21.4.</span> <span class="nav-text">HTTP1.1 和 HTTP2.0 的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%98%BE%E7%A4%BA%E7%BD%91%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.22.</span> <span class="nav-text">输入URL到显示网页的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARP%EF%BC%8CRARP-%E5%92%8C-ICMP"><span class="nav-number">1.23.</span> <span class="nav-text">ARP，RARP 和 ICMP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS-Domain-Name-System-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="nav-number">1.24.</span> <span class="nav-text">DNS(Domain Name System, 域名系统) 域名解析过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NAT-Network-Address-Translation-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.25.</span> <span class="nav-text">NAT(Network Address Translation, 网络地址转换)协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie%E5%92%8Csession%E5%AF%B9%E4%BA%8EHTTP%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">1.26.</span> <span class="nav-text">cookie和session对于HTTP有什么用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFcookie"><span class="nav-number">1.27.</span> <span class="nav-text">什么是cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFsession"><span class="nav-number">1.28.</span> <span class="nav-text">什么是session</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie%E4%B8%8Esession%E5%8C%BA%E5%88%AB"><span class="nav-number">1.29.</span> <span class="nav-text">cookie与session区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">2.</span> <span class="nav-text">Reference</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Su Zhilong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Su Zhilong</p>
  <div class="site-description" itemprop="description">I will always be with you</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/suzhilong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;suzhilong"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Su Zhilong</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">383k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:48</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'uaEz4DL2UqM1jg1eGmpd8vhF-gzGzoHsz',
      appKey     : 'SzL1ETN5dDwbXjnzyJYJkjTb',
      placeholder: "comment",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
