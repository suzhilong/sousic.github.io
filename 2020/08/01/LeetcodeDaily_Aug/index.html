<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/apple-touch-icon-next.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="8月份每日一题">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode每日一题 - 2020年八月">
<meta property="og:url" content="https://github.com/suzhilong/suzhilong.github.io.git/2020/08/01/LeetcodeDaily_Aug/index.html">
<meta property="og:site_name" content="SOUSIC">
<meta property="og:description" content="8月份每日一题">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-08-01T12:00:00.000Z">
<meta property="article:modified_time" content="2020-08-27T02:16:53.524Z">
<meta property="article:author" content="Su Zhilong">
<meta property="article:tag" content="Leetcode daily">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/suzhilong/suzhilong.github.io.git/2020/08/01/LeetcodeDaily_Aug/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Leetcode每日一题 - 2020年八月 | SOUSIC</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="SOUSIC" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SOUSIC</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">哈库呐玛塔塔</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/suzhilong/suzhilong.github.io.git/2020/08/01/LeetcodeDaily_Aug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Su Zhilong">
      <meta itemprop="description" content="I will always be with you">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SOUSIC">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Leetcode每日一题 - 2020年八月
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-01 20:00:00" itemprop="dateCreated datePublished" datetime="2020-08-01T20:00:00+08:00">2020-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-27 10:16:53" itemprop="dateModified" datetime="2020-08-27T10:16:53+08:00">2020-08-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/08/01/LeetcodeDaily_Aug/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/08/01/LeetcodeDaily_Aug/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>
            <div class="post-description">8月份每日一题</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="8月3日-415-字符串相加（简单）"><a href="#8月3日-415-字符串相加（简单）" class="headerlink" title="8月3日 415. 字符串相加（简单）"></a>8月3日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problemset/all/">415. 字符串相加（简单）</a></h1><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p>
<p>注意：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num1 和num2 的长度都小于 5100.</span><br><span class="line">num1 和num2 都只包含数字 0-9.</span><br><span class="line">num1 和num2 都不包含任何前导零。</span><br><span class="line">你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</span><br></pre></td></tr></table></figure>
<p>题解：<br>两个数字位数不同时，在指针当前下标处于负数的时候返回 0，等价于对位数较短的数字进行了补零操作，这样就可以除去两个数字位数不同情况的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">string addStrings(string num1, string num2)&#123;</span><br><span class="line">    int i = num1.length() - 1, j = num2.length() - 1, add = 0;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    while (i &gt;= 0 || j &gt;= 0 || carry != 0) &#123;</span><br><span class="line">        int x = i &gt;= 0 ? num1[i] - &#x27;0&#x27; : 0;</span><br><span class="line">        int y = j &gt;= 0 ? num2[j] - &#x27;0&#x27; : 0;</span><br><span class="line">        int result = x + y + carry;</span><br><span class="line">        res.push_back(&#x27;0&#x27; + result % 10);</span><br><span class="line">        carry = result / 10;</span><br><span class="line">        i -= 1;</span><br><span class="line">        j -= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算完以后的答案需要翻转过来</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(max{n1,n2})<br>空间复杂度：O(1)</p>
<h1 id="8月4日-207-课程表（中等）"><a href="#8月4日-207-课程表（中等）" class="headerlink" title="8月4日 207. 课程表（中等）"></a>8月4日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表（中等）</a></h1><p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p>
<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。</span><br><span class="line">你可以假定输入的先决条件中没有重复的边。</span><br><span class="line">1 &lt;= numCourses &lt;= 10^5</span><br></pre></td></tr></table></figure>

<p>题解：  </p>
<ol>
<li>有向图的dfs遍历。<br><code>visited[i]</code>表示第i和节点的状态，0表示没有被访问过，1表示正在被访问，2表示访问结束的节点。<code>circle</code>表示有向图有环。使用dfs遍历有向图：</li>
</ol>
<ul>
<li>当正在访问的节点（visited[i]&#x3D;1）又被访问时，说明有向图存在环，返回false。</li>
<li>全部节点访问完毕，返回true<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void dfs(int u, vector&lt;vector&lt;int&gt; &gt; &amp;graph, vector&lt;int&gt; &amp;visited)&#123;</span><br><span class="line">    visited[u] = 1;//正在访问该节点</span><br><span class="line">    for(int v:graph[u])&#123;</span><br><span class="line">        if(visited[v]==0)&#123;</span><br><span class="line">            dfs(v, graph, visited);</span><br><span class="line">            if(circle)</span><br><span class="line">                return;</span><br><span class="line">        &#125;else if(visited[v]==1)&#123;</span><br><span class="line">            circle = true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123;</span><br><span class="line">    if(prerequisites.empty())</span><br><span class="line">        return true;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graph(numCourses);</span><br><span class="line">    for (auto course : prerequisites)</span><br><span class="line">    &#123;//build graph</span><br><span class="line">        graph[course[1]].push_back(course[0]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; visited(numCourses);</span><br><span class="line">    for (int i = 0; i &lt; numCourses &amp;&amp; !circle; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visited[i])</span><br><span class="line">            dfs(i, graph, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    return !circle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(m+n)。m是有向图的边，n是有向图的节点。<br>空间复杂度：O(m+n)</li>
</ul>
<ol start="2">
<li>bfs入度为0的点<br>拓扑排序中，起点都是入度为0的点。把所有入度为0的节点放入队列，依次访问队列中的节点。访问的时候把所有从该节点出去的边都删掉，即该节点出发连接的边的入度都减1。再把入度减到0的点加入队列。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123;</span><br><span class="line">    if(prerequisites.empty())</span><br><span class="line">        return true;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graph(numCourses);</span><br><span class="line">    vector&lt;int&gt; inDegree(numCourses, 0);</span><br><span class="line">    for (auto course : prerequisites)</span><br><span class="line">    &#123;//build graph</span><br><span class="line">        graph[course[1]].push_back(course[0]);</span><br><span class="line">        inDegree[course[0]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    for (int i = 0; i &lt; numCourses;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(inDegree[i]==0)</span><br><span class="line">            que.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int visited = 0;</span><br><span class="line">    while (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        visited++;</span><br><span class="line">        int u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int v:graph[u])&#123;</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            if(inDegree[v]==0)</span><br><span class="line">                que.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return visited == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(m+n)。m是有向图的边，n是有向图的节点。<br>空间复杂度：O(m+n)</li>
</ol>
<h1 id="真题"><a href="#真题" class="headerlink" title="真题"></a>真题</h1><h2 id="模版匹配"><a href="#模版匹配" class="headerlink" title="模版匹配"></a>模版匹配</h2><p>前面给一个词做模版，看后面的多个词是否能和前面的模版匹配。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：pattern = &quot;noon&quot;, str = &quot;big star star big&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：pattern = &quot;noon&quot;, str = &quot;big star star not&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool testMatch(string pattern, string str) &#123;</span><br><span class="line">    map&lt;string,char&gt; wordMap;</span><br><span class="line">    char used[128] = &#123;0&#125;;</span><br><span class="line">    string word;</span><br><span class="line">    int pos = 0;</span><br><span class="line">    str.push_back(&#x27; &#x27;);</span><br><span class="line">    for (int i = 0; i &lt; str.size();i++)&#123;</span><br><span class="line">        if(str[i]==&#x27; &#x27;)&#123;</span><br><span class="line">            if(pos==pattern.size())</span><br><span class="line">                return false;</span><br><span class="line">            if(wordMap.find(word)==wordMap.end())&#123;</span><br><span class="line">                if(used[pattern[pos]])</span><br><span class="line">                    return false;</span><br><span class="line">                wordMap[word] = pattern[pos];</span><br><span class="line">                used[pattern[pos]] = 1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(wordMap[word]!=pattern[pos])</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">            word = &quot;&quot;;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            word += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(pos!=pattern.size())</span><br><span class="line">        return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找到最小的排列组合数"><a href="#找到最小的排列组合数" class="headerlink" title="找到最小的排列组合数"></a>找到最小的排列组合数</h2><p>找到比原数字位数排列组合后，比原数字大的，最小的数。没有就输出-1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//80%  比如 2231就不对了</span><br><span class="line">int findGreaterNum(int N) &#123;</span><br><span class="line">    string s = to_string(N);</span><br><span class="line">    for (int i = s.size() - 1; i &gt; 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        if (s[i] &gt; s[i - 1])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(s[i], s[i - 1]);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = atoi(s.c_str());</span><br><span class="line">    if (res == N)</span><br><span class="line">        cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">    else </span><br><span class="line">        cout &lt;&lt; res;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1477-找两个和为目标值且不重叠的子数组"><a href="#1477-找两个和为目标值且不重叠的子数组" class="headerlink" title="1477. 找两个和为目标值且不重叠的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/">1477. 找两个和为目标值且不重叠的子数组</a></h2><p>给你一个整数数组 arr 和一个整数值 target。</p>
<p>请你在 arr 中找两个互不重叠的子数组 且它们的和都等于 target。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。</p>
<p>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。</p>
<p>题解：<br><code>dp[i]</code>表示i后面和等T的最小子数组长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int minSumOfLengths(vector&lt;int&gt;&amp; arr, int target)&#123;</span><br><span class="line">    int sum = 0, r = arr.size() - 1, res = 200000; </span><br><span class="line">    vector&lt;int&gt; dp(arr.size() + 1, 200000);//后面子数组的最小长度</span><br><span class="line">    for (int l = r; l &gt;= 0; --l) &#123; //l,r是滑动区间的左右坐标</span><br><span class="line">        sum += arr[l];</span><br><span class="line">        while (sum &gt; target)</span><br><span class="line">            sum -= arr[r--];</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            int curLen = r - l + 1; //子数组长度</span><br><span class="line">            res = min(res, curLen + dp[r + 1]); //子数组长度 + r后面子数组的最小长度</span><br><span class="line">            dp[l] = min(dp[l + 1], curLen); //更新l后面子数组的最小长度</span><br><span class="line">        &#125;else</span><br><span class="line">            dp[l] = dp[l + 1]; //更新子数组的最小长度</span><br><span class="line">    &#125;</span><br><span class="line">    return res == 200000 ? -1 : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16进制和10进制的互转"><a href="#16进制和10进制的互转" class="headerlink" title="16进制和10进制的互转"></a>16进制和10进制的互转</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">string convert_10_to_16(int num)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; ivec;</span><br><span class="line">    int Num = num;</span><br><span class="line">    while (num != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ivec.push_back(num % 16);</span><br><span class="line">        num = num / 16;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    vector&lt;int&gt;::size_type sz = ivec.size();</span><br><span class="line">    vector&lt;string&gt; ivec2;</span><br><span class="line">    int m = 0;</span><br><span class="line">    string s;</span><br><span class="line">    for (vector&lt;int&gt;::size_type index = 0; index != sz; ++index)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ivec[sz - 1 - index] &gt; 9)</span><br><span class="line">        &#123;   </span><br><span class="line">            m = ivec[sz - 1 - index] + 55;</span><br><span class="line">            s = m+&#x27;0&#x27;-&#x27;0&#x27;;</span><br><span class="line">            ivec2.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            s = ivec[sz - 1 - index] + &#x27;0&#x27;;</span><br><span class="line">            ivec2.push_back(s);</span><br><span class="line"> </span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    for (auto item : ivec2)</span><br><span class="line">        res += item;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double convert_16_to_10(string str)</span><br><span class="line">&#123;</span><br><span class="line">    double sum = 0, times;</span><br><span class="line">    double m;</span><br><span class="line">    string::size_type sz = str.size();</span><br><span class="line">    for (string::size_type index = 0; index != sz; ++index)</span><br><span class="line">    &#123;</span><br><span class="line">        str[index] = tolower(str[index]);</span><br><span class="line">        if (str[index] &gt;= &#x27;a&#x27; &amp;&amp; str[index] &lt;= &#x27;f&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            m = str[index] - &#x27;a&#x27; + 10;</span><br><span class="line">            times = pow(16, (sz - 1 - index));</span><br><span class="line">            sum += m * times;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        else if (isdigit(str[index]))</span><br><span class="line">        &#123;</span><br><span class="line">            m= str[index] - 48;</span><br><span class="line">            times = pow(16, (sz - 1 - index));</span><br><span class="line">            sum += m * times;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8月10日-696-计数二进制子串"><a href="#8月10日-696-计数二进制子串" class="headerlink" title="8月10日 696. 计数二进制子串"></a>8月10日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-binary-substrings/">696. 计数二进制子串</a></h1><p>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</p>
<p>重复出现的子串要计算它们出现的次数。</p>
<p>示例 1 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;00110011&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。</span><br><span class="line"></span><br><span class="line">请注意，一些重复出现的子串要计算它们出现的次数。</span><br><span class="line"></span><br><span class="line">另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。</span><br></pre></td></tr></table></figure>
<p>示例 2 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;10101&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.length 在1到50,000之间。</span><br><span class="line">s 只包含“0”或“1”字符。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>把每个相同的字符分组，比如“00111011” 就可以分为subs&#x3D;{2,3,1,2}，表示2个0，3个1，1个0，2个1。每一对相邻的能有min{subs[i],subs[i+1]}个字串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int countBinarySubstrings(string s) &#123;</span><br><span class="line">    vector&lt;int&gt; subs;</span><br><span class="line">    </span><br><span class="line">    int i = 0;</span><br><span class="line">    while(i&lt;s.size())&#123;</span><br><span class="line">        int mark = i;</span><br><span class="line">        char cur = s[i];</span><br><span class="line">        while(i&lt;s.size() &amp;&amp; s[i]==cur)</span><br><span class="line">            i++;</span><br><span class="line">        subs.push_back(i-mark);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int res = 0;</span><br><span class="line">    for(int i = 0;i&lt;subs.size()-1;i++)&#123;</span><br><span class="line">        res += min(subs[i],subs[i+1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
</li>
<li><p>优化。空间复杂度优化到O(1)。也只用到subs的上一个状态量，所以可以不用保存整个subs数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（代码略）</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="8月11日-130-被围绕的区域（中等）"><a href="#8月11日-130-被围绕的区域（中等）" class="headerlink" title="8月11日 130. 被围绕的区域（中等）"></a>8月11日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域（中等）</a></h1><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p>
<p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br><span class="line">运行你的函数后，矩阵变为：</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p>解释:<br>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。<br>题解：<br>dfs。也可以用bfs，但是需要自己用队列实现，还是递归方便一点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;char&gt; &gt;&amp; board,vector&lt;int&gt; &amp; s,vector&lt;vector&lt;bool&gt; &gt; &amp;marked)&#123;</span><br><span class="line">    int x=s[0],y=s[1];</span><br><span class="line">    if(board[x][y]==&#x27;X&#x27; || marked[x][y])</span><br><span class="line">        return;</span><br><span class="line">    marked[x][y] = true;</span><br><span class="line">    for(auto d:dirs)&#123;</span><br><span class="line">        int next_i = x+d[0], next_j = y+d[1];</span><br><span class="line">        vector&lt;int&gt; tmp = &#123;next_i,next_j&#125;;</span><br><span class="line">        if((next_i &gt; 0 &amp;&amp; next_i &lt; board.size())</span><br><span class="line">        &amp;&amp; (next_j &gt; 0 &amp;&amp; next_j &lt; board[0].size()))</span><br><span class="line">            dfs(board,tmp,marked);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</span><br><span class="line">    if(board.empty())</span><br><span class="line">        return;</span><br><span class="line">    int m = board.size(),n = board[0].size();</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; marked(m,vector&lt;bool&gt;(n, false));</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; side;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        if(board[0][i]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;0,i&#125;);</span><br><span class="line">            //marked[0][i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(board[m-1][i]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;m-1,i&#125;);</span><br><span class="line">            //marked[m-1][i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;m-1;i++)&#123;</span><br><span class="line">        if(board[i][0]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;i,0&#125;);</span><br><span class="line">            //marked[i][0] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(board[i][n-1]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;i,n-1&#125;);</span><br><span class="line">            //marked[i][n-1] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(auto s:side)&#123;</span><br><span class="line">        dfs(board,s,marked);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            if(!marked[i][j] &amp;&amp; board[i][j]==&#x27;O&#x27;)</span><br><span class="line">                board[i][j] = &#x27;X&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m<em>n)<br>空间复杂度：O(m</em>n)</p>
<h1 id="8月12日-133-克隆图（中等）"><a href="#8月12日-133-克隆图（中等）" class="headerlink" title="8月12日 133. 克隆图（中等）"></a>8月12日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/clone-graph/">133. 克隆图（中等）</a></h1><p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p>
<p>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>bfs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Node* cloneGraph(Node* node) &#123;</span><br><span class="line">    if (node == nullptr) &#123;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line"></span><br><span class="line">    // 将题目给定的节点添加到队列</span><br><span class="line">    queue&lt;Node*&gt; que;</span><br><span class="line">    que.push(node);</span><br><span class="line">    // 克隆第一个节点并存储到哈希表中</span><br><span class="line">    visited[node] = new Node(node-&gt;val);</span><br><span class="line"></span><br><span class="line">    // 广度优先搜索</span><br><span class="line">    while (!que.empty()) &#123;</span><br><span class="line">        // 取出队列的头节点</span><br><span class="line">        auto curNode = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        // 遍历该节点的邻居</span><br><span class="line">        for (auto&amp; neighbor: curNode-&gt;neighbors) &#123;</span><br><span class="line">            if (visited.find(neighbor) == visited.end()) &#123;</span><br><span class="line">                // 如果没有被访问过，就克隆并存储在哈希表中</span><br><span class="line">                visited[neighbor] = new Node(neighbor-&gt;val);</span><br><span class="line">                // 将邻居节点加入队列中</span><br><span class="line">                que.push(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新当前节点的邻居列表</span><br><span class="line">            visited[curNode]-&gt;neighbors.emplace_back(visited[neighbor]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return visited[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
</li>
<li><p>dfs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line"></span><br><span class="line">Node* cloneGraph(Node* node) &#123;</span><br><span class="line">    if (node == nullptr) &#123;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(visited.find(node) != visited.end())</span><br><span class="line">        return visited[node];</span><br><span class="line"></span><br><span class="line">    Node *cloneNode = new Node(node-&gt;val);</span><br><span class="line">    visited[node] = cloneNode;</span><br><span class="line"></span><br><span class="line">    for(auto &amp;neighbor:node-&gt;neighbors)&#123;</span><br><span class="line">        cloneNode-&gt;neighbors.push_back(cloneGraph(neighbor));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return visited[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
</li>
</ol>
<h1 id="8月13日-43-字符串相乘（中等）"><a href="#8月13日-43-字符串相乘（中等）" class="headerlink" title="8月13日 43. 字符串相乘（中等）"></a>8月13日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘（中等）</a></h1><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num1 和 num2 的长度小于110。</span><br><span class="line">num1 和 num2 只包含数字 0-9。</span><br><span class="line">num1 和 num2 均不以零开头，除非是数字 0 本身。</span><br><span class="line">不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</span><br></pre></td></tr></table></figure>
<p>题解：<br>大数相乘问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">string multiply(string num1, string num2)&#123;</span><br><span class="line">    int m = num1.size(), n = num2.size();</span><br><span class="line">    vector&lt;long long&gt; num(m + n - 1, 0);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m;i++)&#123;//前面是高位，后面是低位</span><br><span class="line">        int a = num1[i] - &#x27;0&#x27;;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int b = num2[j] - &#x27;0&#x27;;</span><br><span class="line">            num[i + j] += a * b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int carry = 0;</span><br><span class="line">    for (int i = num.size() - 1; i &gt;= 0;i--)&#123;//前面是高位，后面是低位</span><br><span class="line">        int cur = num[i] + carry;</span><br><span class="line">        num[i] = cur % 10;</span><br><span class="line">        carry = cur / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    while(carry!=0)&#123;</span><br><span class="line">        int cur = carry % 10;</span><br><span class="line">        carry /= 10;</span><br><span class="line">        num.insert(num.begin(), cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    for (auto a : num)</span><br><span class="line">    &#123;</span><br><span class="line">        res += to_string(a);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m*n)<br>空间复杂度：O(m+n)</p>
<h1 id="8月19日-647-回文子串（中等）"><a href="#8月19日-647-回文子串（中等）" class="headerlink" title="8月19日 647. 回文子串（中等）"></a>8月19日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串（中等）</a></h1><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure>
<p>题解：<br>枚举每一个字串，再判断是不是回文。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool isPalindrome(string str)&#123;</span><br><span class="line">    int L = 0, R = str.size() - 1;</span><br><span class="line">    while(L&lt;R)&#123;</span><br><span class="line">        if(str[L]!=str[R])</span><br><span class="line">            break;</span><br><span class="line">        L++;</span><br><span class="line">        R--;</span><br><span class="line">    &#125;</span><br><span class="line">    return L&gt;=R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int countSubstrings(string s) &#123;</span><br><span class="line">    int n = s.size();</span><br><span class="line">    if(n==0) return 0;</span><br><span class="line">    int res = n;</span><br><span class="line">    for(int m=2;m&lt;=n;m++)&#123;</span><br><span class="line">        for(int i=0;i&lt;=n-m;i++)&#123;</span><br><span class="line">            string cur_str = s.substr(i,m);</span><br><span class="line">            if(isPalindrome(cur_str))</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p>
<h1 id="8月20日-529-扫雷游戏（中等）"><a href="#8月20日-529-扫雷游戏（中等）" class="headerlink" title="8月20日 529. 扫雷游戏（中等）"></a>8月20日 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minesweeper/">529. 扫雷游戏（中等）</a></h1><p>让我们一起来玩扫雷游戏！</p>
<p>给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，’E’ 代表一个未挖出的空方块，’B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’X’ 则表示一个已挖出的地雷。</p>
<p>现在给出在所有未挖出的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p>
<p>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’。<br>如果一个没有相邻地雷的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的未挖出方块都应该被递归地揭露。<br>如果一个至少与一个地雷相邻的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。<br>如果在此次点击中，若无更多方块可被揭露，则返回面板。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[&#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;],</span><br><span class="line"> [&#x27;E&#x27;, &#x27;E&#x27;, &#x27;M&#x27;, &#x27;E&#x27;, &#x27;E&#x27;],</span><br><span class="line"> [&#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;],</span><br><span class="line"> [&#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;]]</span><br><span class="line"></span><br><span class="line">Click : [3,0]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">[[&#x27;B&#x27;, &#x27;1&#x27;, &#x27;E&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;M&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[&#x27;B&#x27;, &#x27;1&#x27;, &#x27;E&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;M&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]]</span><br><span class="line"></span><br><span class="line">Click : [1,2]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">[[&#x27;B&#x27;, &#x27;1&#x27;, &#x27;E&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;X&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]]</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>dfs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;,&#123;-1,1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;char&gt; &gt; &amp;res, int row, int col, vector&lt;vector&lt;bool&gt; &gt; &amp;hasVisited)&#123;</span><br><span class="line">    if(hasVisited[row][col])</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    //处理当前格子</span><br><span class="line">    int boom = 0;</span><br><span class="line">    for(auto d:dirs)&#123;</span><br><span class="line">        int next_i=row+d[0];</span><br><span class="line">        int next_j=col+d[1];</span><br><span class="line">        if(next_i &lt; 0 || next_i &gt;= res.size() || next_j &lt; 0 || next_j &gt;= res[0].size())</span><br><span class="line">            continue;</span><br><span class="line">        if(res[next_i][next_j]==&#x27;M&#x27;)</span><br><span class="line">            boom++;</span><br><span class="line">    &#125;</span><br><span class="line">    hasVisited[row][col] = true;</span><br><span class="line">    if(boom==0)</span><br><span class="line">        res[row][col] = &#x27;B&#x27;;</span><br><span class="line">    else&#123;</span><br><span class="line">        res[row][col] = to_string(boom)[0];</span><br><span class="line">        // res[cur_i][cur_j] = boom + &#x27;0&#x27;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //处理下一个格子</span><br><span class="line">    for(auto d:dirs)&#123;</span><br><span class="line">        int next_i=row+d[0];</span><br><span class="line">        int next_j=col+d[1];</span><br><span class="line">        if(next_i &lt; 0 || next_i &gt;= res.size() || next_j &lt; 0 || next_j &gt;= res[0].size())</span><br><span class="line">            continue;</span><br><span class="line">        dfs(res,next_i,next_j,hasVisited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;char&gt;&gt; updateBoard(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;int&gt;&amp; click) &#123;</span><br><span class="line">    if(board.empty())</span><br><span class="line">        return board;</span><br><span class="line">    int row = click[0],col=click[1];</span><br><span class="line">    vector&lt;vector&lt;char&gt; &gt; res = board;</span><br><span class="line">    if(board[row][col]==&#x27;M&#x27;)&#123;</span><br><span class="line">        res[row][col] = &#x27;X&#x27;;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; hasVisited(board.size(), vector&lt;bool&gt;(board[0].size(),false));</span><br><span class="line">    dfs(res,row,col,hasVisited);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p>
</li>
<li><p>bfs。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;,&#123;-1,1&#125;&#125;;</span><br><span class="line">void bfs(vector&lt;vector&lt;char&gt; &gt; &amp;res, int row, int col, vector&lt;vector&lt;bool&gt; &gt; &amp;hasVisited)&#123;</span><br><span class="line">    queue&lt;vector&lt;int&gt; &gt; que;</span><br><span class="line">    que.push(&#123;row,col&#125;);</span><br><span class="line">    hasVisited[row][col] = true;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int sizeq = que.size();</span><br><span class="line">        while(sizeq--&gt;0)&#123;</span><br><span class="line">            int cur_i = que.front()[0];</span><br><span class="line">            int cur_j = que.front()[1];</span><br><span class="line">            que.pop();</span><br><span class="line">            </span><br><span class="line">            int boom = 0;</span><br><span class="line">            for(auto d:dirs)&#123;</span><br><span class="line">                int next_i=cur_i+d[0];</span><br><span class="line">                int next_j=cur_j+d[1];</span><br><span class="line">                if(next_i &lt; 0 || next_i &gt;= res.size() || next_j &lt; 0 || next_j &gt;= res[0].size())</span><br><span class="line">                    continue;</span><br><span class="line">                if(res[next_i][next_j]==&#x27;M&#x27;)</span><br><span class="line">                    boom++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(boom==0)&#123;</span><br><span class="line">                //处理当前格子</span><br><span class="line">                res[cur_i][cur_j] = &#x27;B&#x27;;</span><br><span class="line">                //下一个格子</span><br><span class="line">                for(auto d:dirs)&#123;</span><br><span class="line">                    int next_i=cur_i+d[0];</span><br><span class="line">                    int next_j=cur_j+d[1];</span><br><span class="line">                    if(next_i &lt; 0 || next_i &gt;= res.size() || next_j &lt; 0 || next_j &gt;= res[0].size()</span><br><span class="line">                    || hasVisited[next_i][next_j])</span><br><span class="line">                        continue;</span><br><span class="line">                    if(res[next_i][next_j]==&#x27;E&#x27;)&#123;</span><br><span class="line">                        que.push(&#123;next_i,next_j&#125;);</span><br><span class="line">                        hasVisited[next_i][next_j] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                res[cur_i][cur_j] = to_string(boom)[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;char&gt; &gt; updateBoard(vector&lt;vector&lt;char&gt; &gt;&amp; board, vector&lt;int&gt;&amp; click) &#123;</span><br><span class="line">    if(board.empty())</span><br><span class="line">        return board;</span><br><span class="line">    int row = click[0],col=click[1];</span><br><span class="line">    vector&lt;vector&lt;char&gt; &gt; res = board;</span><br><span class="line">    if(board[row][col]==&#x27;M&#x27;)&#123;</span><br><span class="line">        res[row][col] = &#x27;X&#x27;;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; hasVisited(board.size(), vector&lt;bool&gt;(board[0].size(),false));</span><br><span class="line">    bfs(res,row,col,hasVisited);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p>
</li>
</ol>
<h1 id="元素平衡"><a href="#元素平衡" class="headerlink" title="元素平衡"></a>元素平衡</h1><p>A，B，C，D四个数，每次可以任意减少2个单位然后增加1各单位，问当四个数相等时，最大和为多少。</p>
<p>题解：<br>笔试真题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;long&gt; nums(4);</span><br><span class="line">    cin &gt;&gt; nums[0] &gt;&gt; nums[1] &gt;&gt; nums[2] &gt;&gt; nums[3];</span><br><span class="line">    </span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">    long long sumn = nums[0] + nums[1] + nums[2] + nums[3];</span><br><span class="line">    long maxn = sumn / 4;</span><br><span class="line">    while(maxn&gt;0)&#123;</span><br><span class="line">        int sumL = 0, sumR = 0, idx = 0;</span><br><span class="line">        while(idx&lt;4 &amp;&amp; nums[idx]&lt;maxn)&#123;</span><br><span class="line">            sumL += (maxn - nums[idx]);</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        while(idx&lt;4 &amp;&amp; nums[idx]==maxn)</span><br><span class="line">            idx++;</span><br><span class="line">        while(idx&lt;4 &amp;&amp; nums[idx]&gt;maxn)&#123;</span><br><span class="line">            sumR += (nums[idx] - maxn);</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sumL*2 &lt;= sumR)&#123;</span><br><span class="line">            cout &lt;&lt; maxn * 4 &lt;&lt; endl;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        maxn--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Su Zhilong 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Su Zhilong 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Leetcode-daily/" rel="tag"># Leetcode daily</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/12/STL/" rel="prev" title="STL常用方法">
      <i class="fa fa-chevron-left"></i> STL常用方法
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/18/os/" rel="next" title="操作系统">
      操作系统 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#8%E6%9C%883%E6%97%A5-415-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">8月3日 415. 字符串相加（简单）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8%E6%9C%884%E6%97%A5-207-%E8%AF%BE%E7%A8%8B%E8%A1%A8%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">8月4日 207. 课程表（中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9C%9F%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">真题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E7%89%88%E5%8C%B9%E9%85%8D"><span class="nav-number">3.1.</span> <span class="nav-text">模版匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E6%95%B0"><span class="nav-number">3.2.</span> <span class="nav-text">找到最小的排列组合数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1477-%E6%89%BE%E4%B8%A4%E4%B8%AA%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%94%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">3.3.</span> <span class="nav-text">1477. 找两个和为目标值且不重叠的子数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16%E8%BF%9B%E5%88%B6%E5%92%8C10%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BA%92%E8%BD%AC"><span class="nav-number">3.4.</span> <span class="nav-text">16进制和10进制的互转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8%E6%9C%8810%E6%97%A5-696-%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2"><span class="nav-number">4.</span> <span class="nav-text">8月10日 696. 计数二进制子串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8%E6%9C%8811%E6%97%A5-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">8月11日 130. 被围绕的区域（中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8%E6%9C%8812%E6%97%A5-133-%E5%85%8B%E9%9A%86%E5%9B%BE%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">8月12日 133. 克隆图（中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8%E6%9C%8813%E6%97%A5-43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">7.</span> <span class="nav-text">8月13日 43. 字符串相乘（中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8%E6%9C%8819%E6%97%A5-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">8.</span> <span class="nav-text">8月19日 647. 回文子串（中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8%E6%9C%8820%E6%97%A5-529-%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><span class="nav-number">9.</span> <span class="nav-text">8月20日 529. 扫雷游戏（中等）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%83%E7%B4%A0%E5%B9%B3%E8%A1%A1"><span class="nav-number">10.</span> <span class="nav-text">元素平衡</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Su Zhilong"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Su Zhilong</p>
  <div class="site-description" itemprop="description">I will always be with you</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/suzhilong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;suzhilong"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Su Zhilong</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">380k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:46</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'uaEz4DL2UqM1jg1eGmpd8vhF-gzGzoHsz',
      appKey     : 'SzL1ETN5dDwbXjnzyJYJkjTb',
      placeholder: "comment",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
