<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SOUSIC</title>
  
  <subtitle>哈库呐玛塔塔</subtitle>
  <link href="https://github.com/suzhilong/suzhilong.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://github.com/suzhilong/suzhilong.github.io.git/"/>
  <updated>2022-11-27T15:34:08.564Z</updated>
  <id>https://github.com/suzhilong/suzhilong.github.io.git/</id>
  
  <author>
    <name>Su Zhilong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>光流鲁棒性评估</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2022/11/27/optical_flow_evaluation/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2022/11/27/optical_flow_evaluation/</id>
    <published>2022-11-27T13:39:00.000Z</published>
    <updated>2022-11-27T15:34:08.564Z</updated>
    
    <content type="html"><![CDATA[<ol><li>本篇文档对鲁棒性的定义：$$goodPoints&#x2F;allPoints$$ 其中</li><li>goodPoints：跟踪成功的特征点。即，向前-向后追踪回到开始帧，EPE 小于设定的阈值(单位: pixel)。</li><li>allPoints：所有特征点</li><li>使用全部特征点测试鲁棒性，$$Harris \gtrsim Tomasi &gt; Fast$$</li><li>使用我们的均匀化策略后的特征点测试鲁棒性，$$Fast &gt; Tomasi \approx Harris$$</li></ol><span id="more"></span><h1 id="光流评估指标"><a href="#光流评估指标" class="headerlink" title="光流评估指标"></a>光流评估指标</h1><h2 id="误差指标"><a href="#误差指标" class="headerlink" title="误差指标"></a>误差指标</h2><ul><li><p>EPE(Endpoint Error)：估计光流和 ground-truth 光流的欧氏距离<br>$$EPE &#x3D; \sqrt{(u_{est} - u_{gt})^2 + (v_{est} - v_{gt})^2}$$<br><img src="https://s2.loli.net/2022/11/27/gm1UaiBwIoZrnPc.png" alt="EPE.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>AE(Angular Error)：光流向量之间的角度误差。计算角度误差时增加一维，使用的是三维向量 (u, v, 1)<br>$$\mathrm{AE}&#x3D;\arccos \left(\frac{\left(\mathrm{u}<em>{\mathrm{est}}, \mathrm{v}</em>{\text {est }}, 1\right)^{\mathrm{T}} *\left(\mathrm{u}<em>{\mathrm{gt}}, \mathrm{v}</em>{\mathrm{gt}}, 1\right)}{\left.\sqrt{1.0+\mathrm{u}<em>{\mathrm{est}} * \mathrm{u}</em>{\mathrm{est}}+\mathrm{v}<em>{\mathrm{est}} * \mathrm{v}</em>{\mathrm{est}}} \sqrt{1.0+\mathrm{u}<em>{\mathrm{gt}} * \mathrm{u}</em>{\mathrm{gt}}+\mathrm{v}<em>{\mathrm{gt}} * \mathrm{v}</em>{\mathrm{gt}}}\right)}\right)$$<br><img src="https://s2.loli.net/2022/11/27/Pb8hR4dVBoi7cJn.png" alt="AE.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="统计指标"><a href="#统计指标" class="headerlink" title="统计指标"></a>统计指标</h2><ul><li>AEE：平均点误差</li><li>AAE：平均角误差</li></ul><h1 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h1><h2 id="MPI-Sintel"><a href="#MPI-Sintel" class="headerlink" title="MPI Sintel"></a><a href="http://sintel.is.tue.mpg.de/">MPI Sintel</a></h2><p>从人工生成的动画 sintel 中得到光流 ground truth，每一个版本都包含 1041 个可用来训练的图片对，提供的 ground truth 十分密集，大幅度、小幅度的运动都包含。 </p><p>sintel 数据集包括两种版本： </p><ul><li>sintel final：包括运动模糊和一些环境氛围特效，如雾等</li><li>sintel clean：没有 final 的特效</li></ul><h2 id="Crowd-Flow"><a href="#Crowd-Flow" class="headerlink" title="Crowd-Flow"></a><a href="https://github.com/tsenst/CrowdFlow">Crowd-Flow</a></h2><ul><li>序列包含 371 到 1451 个独立运动的个体</li><li>数据集由 10 个长度范围的序列组成，在 300 至 450 帧之间，所有序列均以 25hz 的帧速率和高清分辨率呈现</li><li>与此前光流数据集相比，该数据集除了提高了分辨率和帧的数量之外，还以连续序列而不是单帧对进行组织，允许评估时间一致性，例如以轨迹的形式</li></ul><h2 id="KITTI"><a href="#KITTI" class="headerlink" title="KITTI"></a><a href="https://www.cvlibs.net/datasets/kitti/index.php">KITTI</a></h2><p>只有一种特殊的动作类型（类似行车记录仪），并且位移很大，视频使用一个摄像头，ground-truth 由 3D 激光雷达得出，远距离的物体，如天空没法被捕捉，导致该数据集光流 ground-truth 比较稀疏。</p><ul><li>KITTI 2012：194 组图片</li><li>KITTI 2015：200 组图片</li></ul><h2 id="Flying-Chairs"><a href="#Flying-Chairs" class="headerlink" title="Flying Chairs"></a><a href="https://lmb.informatik.uni-freiburg.de/resources/datasets/FlyingChairs.en.html">Flying Chairs</a></h2><p>软件渲染生成的虚拟数据，包含了 22872 对图像。</p><h2 id="SceneFlow"><a href="#SceneFlow" class="headerlink" title="SceneFlow"></a><a href="https://lmb.informatik.uni-freiburg.de/resources/datasets/SceneFlowDatasets.en.html">SceneFlow</a></h2><p>利用软件渲染生成的虚拟立体数据集，包含 35454 个训练图像（有 ground truth），所有的图片分辨率都是 960x540。<br>主要包含三个子集：</p><ul><li>FlyingThings3D</li><li>Driving</li><li>Monkaa</li></ul><h2 id="Middlebury"><a href="#Middlebury" class="headerlink" title="Middlebury"></a><a href="http://vision.middlebury.edu/flow/eval">Middlebury</a></h2><ul><li>评估使用 1.1 中的 4 个指标</li><li>gray 和 color 都有</li><li>位移很小，通常小于10个像素</li><li>12 个场景的图片流，每个场景图片只有 10 张</li><li>针对的是全图片的光流，ground-truth 只有 1 帧的。需要把跑出来的光流结果保存成指定的数据格式(.flo)，上传到指定地址</li></ul><h2 id="数据集生成工具"><a href="#数据集生成工具" class="headerlink" title="数据集生成工具"></a>数据集生成工具</h2><ul><li><a href="https://microsoft.github.io/AirSim/">AirSim</a>：能够生成无人机视角和公路驾驶视角的两类数据</li><li><a href="http://carla.org/">Carla</a>：高仿真的自动驾驶场景</li></ul><h1 id="不依赖数据集评估方案"><a href="#不依赖数据集评估方案" class="headerlink" title="不依赖数据集评估方案"></a>不依赖数据集评估方案</h1><h2 id="forward-backward"><a href="#forward-backward" class="headerlink" title="forward-backward"></a>forward-backward</h2><p>使用基于奇偶数的 forward-backward：如有 5 幅图像。前向时为 0-2-4，后向时为 4-3-1-0，连起来为 0-2-4-3-1-0。<br>最后使用欧氏距离计算出 0 帧与最后的 0 帧图像之间，特征点位置的漂移 e，即 final drift。设定一个阈值 threshold，计算小于 threshold 的特征点的百分比，为鲁棒性；e 的直方图用于表示稳定性。</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref."></a>Ref.</h1><ul><li><a href="https://blog.csdn.net/catpico/article/details/122890919">optical flow光流估计的评价指标_wrotcat的博客-CSDN博客</a></li><li><a href="https://sourceforge.net/p/emgucv/opencv_contrib/ci/4ec320efe1a04604eee4c024c7b9d9d37ddab80a/tree/modules/optflow/samples/optical_flow_evaluation.cpp#l1">Emgu CV &#x2F; OpenCV Contrib Git clone &#x2F; [4ec320] &#x2F;modules&#x2F;optflow&#x2F;samples&#x2F;optical_flow_evaluation.cpp</a></li><li><a href="https://www.docin.com/p-1461046820.html">图像序列光流计算评估理论及方法研究</a></li><li><a href="https://zhuanlan.zhihu.com/p/548858539">最全自动驾驶数据集分享系列四｜光流数据集</a></li><li><a href="https://opendatalab.com/">Datasets-OpenDataLab</a></li><li><a href="https://github.com/liruoteng/OpticalFlowToolkit">OPTICAL FLOW TOOLKIT</a></li><li><a href="https://blog.csdn.net/qxqxqzzz/article/details/100989893">optical flow数据集KITTI 2012 2015 sintel crowd flow_城俊BLOG的博客-CSDN博客</a></li><li>论文：Evaluation of Endoscopic Image Enhancement for Feature Tracking: A New Validation Framework</li><li><a href="https://blog.csdn.net/u010141025/article/details/15810713">特征点检测和追踪评价:A New Validation Framework</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;本篇文档对鲁棒性的定义：$$goodPoints&amp;#x2F;allPoints$$ 其中&lt;/li&gt;
&lt;li&gt;goodPoints：跟踪成功的特征点。即，向前-向后追踪回到开始帧，EPE 小于设定的阈值(单位: pixel)。&lt;/li&gt;
&lt;li&gt;allPoints：所有特征点&lt;/li&gt;
&lt;li&gt;使用全部特征点测试鲁棒性，$$Harris \gtrsim Tomasi &amp;gt; Fast$$&lt;/li&gt;
&lt;li&gt;使用我们的均匀化策略后的特征点测试鲁棒性，$$Fast &amp;gt; Tomasi \approx Harris$$&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="robot" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/robot/"/>
    
    <category term="SLAM" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/robot/SLAM/"/>
    
    
    <category term="Computer vision" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/Computer-vision/"/>
    
  </entry>
  
  <entry>
    <title>RCAR2021 wiki</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2021/03/30/rcar_wiki/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2021/03/30/rcar_wiki/</id>
    <published>2021-03-30T02:40:00.000Z</published>
    <updated>2021-03-30T03:26:23.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="How-to-register-and-make-payment"><a href="#How-to-register-and-make-payment" class="headerlink" title="How to register and make payment"></a>How to register and make payment</h1><p>Contents:</p><ul><li>How to register</li><li>How to payment</li><li>Confirm whether the payment is successful</li></ul><span id="more"></span><h2 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h2><ol><li>Visit <a href="https://www.softconf.com/l/rcar2021/">IEEE-RCAR2021</a></li><li>Register<ul><li>Finish the registration procedure<img src="https://i.loli.net/2021/03/30/OyKmUotCzkVuNgq.png" alt="normal regist"></li><li>Authors can start to register by login to softconf site<img src="https://i.loli.net/2021/03/30/cTQhvPwzYCZrK2g.png" alt="Authors register"></li></ul></li><li>Fill in your profile in below text-boxes(<strong>* is mandatory</strong>). Then click <code>Continue</code> to next <code>Payment</code> step<br> <img src="https://i.loli.net/2021/03/30/hT2eAmZJgl51qtd.png" alt="fill in"></li></ol><h2 id="Payment"><a href="#Payment" class="headerlink" title="Payment"></a>Payment</h2><ol><li><p>Choose item you need to pay for, then click <code>Checkout</code> button.<br> <strong>Note:</strong> if your paper has more than 6 pages, you also need to pay for the extra pages<br> <img src="https://i.loli.net/2021/03/30/YgQjZ4rOdAtyW85.png" alt="payment"></p></li><li><p>Checkout your bill: Here a Payment information will be shown, and a transaction ID will be generated.<br> Click <code>Pay</code>, you will receive a notification mail about this transaction.<br> <img src="https://i.loli.net/2021/03/30/MNUk6WBxc8SJeIy.png" alt="checkout"></p></li><li><p>Using your PayPal account to pay.</p></li></ol><h2 id="Confirm"><a href="#Confirm" class="headerlink" title="Confirm"></a>Confirm</h2><ol><li><p>Login with your passcode<br> <img src="https://i.loli.net/2021/03/30/yMruJBQaosdGp5P.png" alt="login"></p></li><li><p>Click <code>Processed payment archive</code><br> <img src="https://i.loli.net/2021/03/30/1feyA9R2k7vhxOT.png" alt="archive"></p></li><li><p>Check table list<br> <img src="https://i.loli.net/2021/03/30/9NsvaHkoSL6MBEW.png" alt="list"></p></li></ol><p>We are looking forward to see you at IEEE RCAR 2021!</p><p>Regards,</p><p>The IEEE RCAR 2021 committee.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;How-to-register-and-make-payment&quot;&gt;&lt;a href=&quot;#How-to-register-and-make-payment&quot; class=&quot;headerlink&quot; title=&quot;How to register and make payment&quot;&gt;&lt;/a&gt;How to register and make payment&lt;/h1&gt;&lt;p&gt;Contents:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How to register&lt;/li&gt;
&lt;li&gt;How to payment&lt;/li&gt;
&lt;li&gt;Confirm whether the payment is successful&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="robot" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/robot/"/>
    
    
    <category term="wiki" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/wiki/"/>
    
  </entry>
  
  <entry>
    <title>基于ROS的无人机跟踪：tracking package</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2021/01/21/rotorsTracking/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2021/01/21/rotorsTracking/</id>
    <published>2021-01-21T02:17:00.000Z</published>
    <updated>2021-02-23T06:55:57.287Z</updated>
    
    <content type="html"><![CDATA[<ul><li>无人机仿真：<a href="https://suzhilong.github.io/2021/01/20/rotorsSimulator/">rotors_simulator</a></li><li><a href="https://github.com/suzhilong/uav_tracking">uav_tracking项目代码</a></li></ul><h1 id="下载编译"><a href="#下载编译" class="headerlink" title="下载编译"></a>下载编译</h1><h2 id="克隆-package"><a href="#克隆-package" class="headerlink" title="克隆 package"></a>克隆 package</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/rotors_ws/src/</span><br><span class="line">git clone https://github.com/suzhilong/uav_tracking.git</span><br></pre></td></tr></table></figure><h2 id="复制-world文件："><a href="#复制-world文件：" class="headerlink" title="复制.world文件："></a>复制<code>.world</code>文件：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ~/rotors_ws/src/uav_tracking/worlds/tracking_scen.world ~/rotors_ws/src/rotors_simulator/rotors_gazebo/worlds/</span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/rotors_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>然后<strong>重启终端</strong></p><span id="more"></span><h1 id="tracking-包的使用"><a href="#tracking-包的使用" class="headerlink" title="tracking 包的使用"></a>tracking 包的使用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/rotors_ws</span><br><span class="line">source ./devel/setup.bash</span><br></pre></td></tr></table></figure><h2 id="录制-ros-bag"><a href="#录制-ros-bag" class="headerlink" title="录制 ros bag"></a>录制 ros bag</h2><p>录制需要的话题，就可以避免每次仿真都打开<code>gazebo</code>：</p><h3 id="运行-launch-文件"><a href="#运行-launch-文件" class="headerlink" title="运行 launch 文件"></a>运行 launch 文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch uav_tracking video_record.launch</span><br></pre></td></tr></table></figure><h3 id="录制话题"><a href="#录制话题" class="headerlink" title="录制话题"></a>录制话题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag record -o [BAGNAME] /topic1/xxx /topic2/xxx</span><br></pre></td></tr></table></figure><p>话题可以使用<code>rostopic list</code>查看。例如我要录制相机采集的视频：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag record -o video /firefly/vi_sensor/left/image_raw</span><br></pre></td></tr></table></figure><p>按 <code>ctrl + c</code> 结束录制</p><h3 id="rosbag-回放"><a href="#rosbag-回放" class="headerlink" title="rosbag 回放"></a>rosbag 回放</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play -l [bagNAME]</span><br></pre></td></tr></table></figure><h2 id="rosbag-转-MP4"><a href="#rosbag-转-MP4" class="headerlink" title="rosbag 转 MP4"></a>rosbag 转 MP4</h2><h3 id="1-bag2img-launch"><a href="#1-bag2img-launch" class="headerlink" title="1. bag2img.launch"></a>1. <a href="https://github.com/suzhilong/uav_tracking/blob/main/launch/bag2img.launch">bag2img.launch</a></h3><p>在<code>uav_tracking/launch</code>目录下新建<a href="https://github.com/suzhilong/uav_tracking/blob/main/launch/bag2img.launch">bag2img.launch</a>，写入下面内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">  &lt;node pkg=&quot;rosbag&quot; type=&quot;play&quot; name=&quot;rosbag&quot; args=&quot;-d 2 [BAGPATH]/xx.bag&quot;/&gt;</span><br><span class="line">  &lt;node name=&quot;extract&quot; pkg=&quot;image_view&quot; type=&quot;extract_images&quot; respawn=&quot;false&quot; output=&quot;screen&quot; cwd=&quot;ROS_HOME&quot;&gt;</span><br><span class="line">&lt;remap from=&quot;image&quot; to=&quot;/[your_topic]&quot;/&gt;</span><br><span class="line">  &lt;/node&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>[BAGPATH]&#x2F;xx.bag需要替换成自己的bag路径</li><li><code>remap</code>中的<code>/[your_topic]</code>需要替换为自己图片的话题</li></ul><h3 id="2-运行launch文件"><a href="#2-运行launch文件" class="headerlink" title="2. 运行launch文件"></a>2. 运行launch文件</h3><p><code>source</code> 后运行这个launch文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source ~/rotors_ws/devel/setup.bash</span><br><span class="line">roslaunch bag2img.launch</span><br></pre></td></tr></table></figure><p>成功后会在<code>~/.ros</code>文件夹中生成命名格式为<code>framexxxx.jpg</code>（如<code>frame0000.jpg</code>）的图片</p><h3 id="3-移动图片"><a href="#3-移动图片" class="headerlink" title="3. 移动图片"></a>3. 移动图片</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/rotors_ws/imgs</span><br><span class="line">mv ~/.ros/frame*.jpg ~/rotors_ws/imgs/</span><br></pre></td></tr></table></figure><h3 id="4-图片序列转MP4"><a href="#4-图片序列转MP4" class="headerlink" title="4. 图片序列转MP4"></a>4. 图片序列转MP4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -r 10  -s 752*480 -i frame%04d.jpg uav_record.mp4</span><br></pre></td></tr></table></figure><p><em>ps: -r 后是帧率，-s后是分辨率，-i后是图片名，最后是输出视频名</em></p><h2 id="tracking"><a href="#tracking" class="headerlink" title="tracking"></a>tracking</h2><h3 id="OpenCV-contrib-安装"><a href="#OpenCV-contrib-安装" class="headerlink" title="OpenCV_contrib 安装"></a>OpenCV_contrib 安装</h3><ol><li>安装<a href="https://opencv.org/">OpenCV</a> （已经安装好的使用命令<code>pkg-config opencv --modversion</code>查看安装的OpenCV版本）</li><li>下载对应的 <a href="https://github.com/opencv/opencv_contrib">OpenCV_contrib</a>（点击<code>tag</code>找到所需版本）</li><li>将解压后的<code>OpenCV_contrib</code>文件夹移到<code>opencv</code>根目录下</li><li>安装依赖 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line">sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</span><br></pre></td></tr></table></figure></li><li>进入 <code>opencv/build</code> （如果没有<code>build</code>，就新建一个<code>build</code>文件夹） <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -D CMAKE_INSTALL_PREFIX=/usr/local -D CMAKE_BUILD_TYPE=Release -D OPENCV_EXTRA_MODULES_PATH=../opencv_contrib-3.4.0/modules ..</span><br></pre></td></tr></table></figure> <strong>注意：参数 OPENCV_EXTRA_MODULES_PATH 中的opencv_contrib-3.4.0 就是 opencv_contrib 解压后移动到 opencv 目录下名字</strong></li><li>编译安装 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li></ol><h3 id="img-tracking-cpp"><a href="#img-tracking-cpp" class="headerlink" title="img_tracking.cpp"></a><a href="https://github.com/suzhilong/uav_tracking/blob/main/src/img_tracking.cpp">img_tracking.cpp</a></h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol><li><p>先<code>roslaunch</code> uav 的仿真 或 <code>rosbag play</code>录制好的bag文件</p></li><li><ul><li>可以进入<code>~/rotors_ws/devel/lib/usv_tracking/</code>后使用<code>./img_tracking</code>运行视频目标跟踪程序</li><li>也可以<code>source ~/rotors_ws/devel/setup.bash</code>后直接使用<code>rosrun uav_tracking img_tracking</code>执行视频目标跟踪程序</li></ul></li></ol><h4 id="跟踪目标边框初始化"><a href="#跟踪目标边框初始化" class="headerlink" title="跟踪目标边框初始化"></a>跟踪目标边框初始化</h4><p>在<code>img_tracking.cpp</code>中，有两种方法初始化目标在第一帧的位置和大小：</p><ol><li><p>初始化检测框的坐标和大小</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boundingBox.x = 350;</span><br><span class="line">boundingBox.y = 200;</span><br><span class="line">boundingBox.width = 100;</span><br><span class="line">boundingBox.height = 80;</span><br></pre></td></tr></table></figure></li><li><p>手动框选：<code>1.</code> 中的代码注释掉，使用下面代码：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boundingBox = selectROI(curFrame, false);</span><br></pre></td></tr></table></figure></li></ol><h3 id="test-tracking-cpp"><a href="#test-tracking-cpp" class="headerlink" title="test_tracking.cpp"></a><a href="https://github.com/suzhilong/uav_tracking/blob/main/src/test_tracking.cpp">test_tracking.cpp</a></h3><p>这个文件是用来测试仿真uav录制视频的跟踪的。</p><h4 id="修改跟踪目标文件"><a href="#修改跟踪目标文件" class="headerlink" title="修改跟踪目标文件"></a>修改跟踪目标文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VideoCapture video(&quot;[video_path]/[video_name].mp4&quot;);</span><br></pre></td></tr></table></figure><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><p>新开一个终端，并且source一下，然后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun uav_tracking test_tracking</span><br></pre></td></tr></table></figure><p>接着就会出现视频的第一帧，用鼠标框选出跟踪的目标，按回车就可以看到开始跟踪了。</p><p><img src="https://i.loli.net/2021/01/30/Ulr3SC7Rjd8Pq4u.gif" alt="tracking480.gif"></p><h3 id="uav-tracking-cpp"><a href="#uav-tracking-cpp" class="headerlink" title="uav_tracking.cpp"></a><a href="https://github.com/suzhilong/uav_tracking/blob/main/src/uav_tracking.cpp">uav_tracking.cpp</a></h3><h4 id="打开-gazebo"><a href="#打开-gazebo" class="headerlink" title="打开 gazebo"></a>打开 gazebo</h4><p>随便打开一个有 <code>rotors</code> 的 <code>gazebo</code> 世界，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch uav_tracking video_record.launch</span><br></pre></td></tr></table></figure><h4 id="加载-turtlebot-到-gazebo"><a href="#加载-turtlebot-到-gazebo" class="headerlink" title="加载 turtlebot 到 gazebo"></a>加载 turtlebot 到 gazebo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch uav_tracking add_turtlebot.launch</span><br></pre></td></tr></table></figure><h4 id="使用跟踪"><a href="#使用跟踪" class="headerlink" title="使用跟踪"></a>使用跟踪</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun uav_tracking uav_tracking</span><br></pre></td></tr></table></figure><p>然后选中turtlebot</p><h4 id="键盘控制turtlebot移动"><a href="#键盘控制turtlebot移动" class="headerlink" title="键盘控制turtlebot移动"></a>键盘控制turtlebot移动</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch turtlebot_teleop keyboard_teleop.launch</span><br></pre></td></tr></table></figure><p>就可以看到无人机跟随turtlebot运动了。</p><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul><li><a href="https://www.guyuehome.com/4748">为了实现高效的人体跟踪，我测试了这些开源CV算法</a></li><li><a href="https://www.guyuehome.com/17372">(Python)从零开始,简单快速学机器仿人视觉Opencv—运用五：物体运动跟踪</a></li><li><a href="https://www.guyuehome.com/18855">ROS实现无人机目标跟踪&#x2F;物体跟随&#x2F;循迹</a></li><li><a href="https://www.guyuehome.com/18055">基于ROS搭建简易软件框架实现ROV水下目标跟踪（十四完结）–目标跟踪模块</a></li><li><a href="https://github.com/aws-robotics/aws-robomaker-racetrack-world#aws-robomaker-racetrack-world-ros-package">赛道环境ROS包</a></li><li><a href="https://github.com/leggedrobotics/darknet_ros">YOLO_ROS包</a></li><li><a href="https://blog.csdn.net/LuohenYJ/article/details/89029816">使用OpenCV实现单目标跟踪</a></li><li><a href="https://blog.csdn.net/qq_35781447/article/details/103277509">linux下安装Opencv 和opencv-contrib</a></li><li><a href="https://learnopencv.com/object-tracking-using-opencv-cpp-python/">Object Tracking using OpenCV</a></li><li><a href="https://blog.csdn.net/qq_42589654/article/details/104246083">ROS基础知识学习笔记（1）—数据类型</a></li><li><a href="http://www.voidcn.com/article/p-nexaivrm-uc.html">std_msgs::UInt8MultiArray发布数组</a></li><li><a href="http://blog.leanote.com/post/610167078@qq.com/ROS-%E5%9B%BE%E5%83%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%BA%94%E7%94%A8">ROS 图像相关的命令与应用</a></li><li><a href="https://www.jianshu.com/p/9a5a0433f5e4">ROS的相机节点</a></li><li><a href="https://blog.csdn.net/weixin_40830684/article/details/94054564?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">rosbag转mp4文件</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;无人机仿真：&lt;a href=&quot;https://suzhilong.github.io/2021/01/20/rotorsSimulator/&quot;&gt;rotors_simulator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/suzhilong/uav_tracking&quot;&gt;uav_tracking项目代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;下载编译&quot;&gt;&lt;a href=&quot;#下载编译&quot; class=&quot;headerlink&quot; title=&quot;下载编译&quot;&gt;&lt;/a&gt;下载编译&lt;/h1&gt;&lt;h2 id=&quot;克隆-package&quot;&gt;&lt;a href=&quot;#克隆-package&quot; class=&quot;headerlink&quot; title=&quot;克隆 package&quot;&gt;&lt;/a&gt;克隆 package&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd ~/rotors_ws/src/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git clone https://github.com/suzhilong/uav_tracking.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;复制-world文件：&quot;&gt;&lt;a href=&quot;#复制-world文件：&quot; class=&quot;headerlink&quot; title=&quot;复制.world文件：&quot;&gt;&lt;/a&gt;复制&lt;code&gt;.world&lt;/code&gt;文件：&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cp ~/rotors_ws/src/uav_tracking/worlds/tracking_scen.world ~/rotors_ws/src/rotors_simulator/rotors_gazebo/worlds/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译&quot;&gt;&lt;/a&gt;编译&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd ~/rotors_ws&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;catkin_make&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后&lt;strong&gt;重启终端&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="robot" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/robot/"/>
    
    
    <category term="Drone" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/Drone/"/>
    
  </entry>
  
  <entry>
    <title>基于rotors_simulator和ROS的无人机仿真</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2021/01/20/rotorsSimulator/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2021/01/20/rotorsSimulator/</id>
    <published>2021-01-20T11:35:00.000Z</published>
    <updated>2021-02-23T04:39:01.518Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/suzhilong/uav_tracking">uav_tracking项目代码</a></p><h1 id="安装-rotors-simulator"><a href="#安装-rotors-simulator" class="headerlink" title="安装 rotors_simulator"></a>安装 <a href="(https://github.com/ethz-asl/rotors_simulator)">rotors_simulator</a></h1><h2 id="1-新建工作空间并初始化（有工作空间的跳过此步骤）"><a href="#1-新建工作空间并初始化（有工作空间的跳过此步骤）" class="headerlink" title="1. 新建工作空间并初始化（有工作空间的跳过此步骤）"></a>1. 新建工作空间并初始化（有工作空间的跳过此步骤）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/rotors_ws/src</span><br><span class="line">cd ~/rotors_ws/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure><h2 id="2-克隆源代码"><a href="#2-克隆源代码" class="headerlink" title="2. 克隆源代码"></a>2. 克隆源代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/rotors_ws/src</span><br><span class="line">git clone https://github.com/ethz-asl/rotors_simulator.git</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="3-初始化wstool，并更新所需库"><a href="#3-初始化wstool，并更新所需库" class="headerlink" title="3. 初始化wstool，并更新所需库"></a>3. 初始化wstool，并更新所需库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wstool init</span><br><span class="line">wget https://raw.githubusercontent.com/ethz-asl/rotors_simulator/master/rotors_hil.rosinstall</span><br><span class="line">wstool merge rotors_hil.rosinstall</span><br><span class="line">wstool update</span><br></pre></td></tr></table></figure><h2 id="4-编译"><a href="#4-编译" class="headerlink" title="4. 编译"></a>4. 编译</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/rotors_ws/</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h2 id="5-环境变量"><a href="#5-环境变量" class="headerlink" title="5. 环境变量"></a>5. 环境变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ./devel/setup.bash</span><br></pre></td></tr></table></figure><p>也可以用下面的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source ~/rotors_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="6-测试"><a href="#6-测试" class="headerlink" title="6. 测试"></a>6. 测试</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch rotors_gazebo mav_hovering_example.launch mav_name:=firefly world_name:=basic</span><br></pre></td></tr></table></figure><p>如果安装成功，就能启动<code>gazebo</code>，看到飞机</p><h1 id="切换环境和飞机模型"><a href="#切换环境和飞机模型" class="headerlink" title="切换环境和飞机模型"></a>切换环境和飞机模型</h1><p>可以在启动时指定参数切换飞机和场景，也可以修改<code>launch</code>文件。</p><p>下面以修改<code>mav_hovering_example_with_vi_sensor.launch</code>为例，<code>mav_hovering_example_with_vi_sensor.launch</code>文件位于<code>~/rotors_ws/src/rotors_simulator/rotors_gazebo/launch/</code>路径下：</p><p><code>mav_hovering_example_with_vi_sensor.launch文件</code>：<br><img src="https://i.loli.net/2021/01/20/aTE2lOB9qC6zjAw.png" alt="launch文件"></p><h2 id="修改launch文件中的mav-name切换飞机"><a href="#修改launch文件中的mav-name切换飞机" class="headerlink" title="修改launch文件中的mav_name切换飞机"></a>修改<code>launch</code>文件中的<code>mav_name</code>切换飞机</h2><ol><li><p>打开<code>launch</code>文件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit ~/rotors_ws/src/rotors_simulator/rotors_gazebo/launch/mav_hovering_example_with_vi_sensor.launch</span><br></pre></td></tr></table></figure></li><li><p>第三行参数<code>firefly</code>可以改为<code>~/rotors_ws/src/rotors_simulator/rotors_description/urdf</code>路径中的任意一个飞机名，如<code>iris</code>，<code>ardrone</code>等。</p></li></ol><h2 id="修改launch文件中的world-name切换场景"><a href="#修改launch文件中的world-name切换场景" class="headerlink" title="修改launch文件中的world_name切换场景"></a>修改<code>launch</code>文件中的<code>world_name</code>切换场景</h2><ol><li>打开<code>launch</code>文件 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit ~/rotors_ws/src/rotors_simulator/rotors_gazebo/launch/mav_hovering_example_with_vi_sensor.launch</span><br></pre></td></tr></table></figure></li><li>第四行参数<code>outdoor</code>可以改为<code>~/rotors_ws/src/rotors_simulator/rotors_gazebo/worlds/</code>路径中的任意一个文件名，如<code>outdoor</code>，<code>plane</code>等。</li></ol><p><code>~/rotors_ws/src/rotors_simulator/rotors_gazebo/worlds/</code>路径下的文件如下图<br><img src="https://i.loli.net/2021/01/20/QJHVIyC8GUeKwtZ.png" alt="worlds"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>修改完之后运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch rotors_gazebo mav_hovering_example_with_vi_sensor.launch</span><br></pre></td></tr></table></figure><p>即可查看修改效果</p><p><em>ps. 如果修改的是其他<code>launch</code>文件，则运行对应的文件查看。</em></p><h1 id="创建直接的-ROS-package-来控制飞机"><a href="#创建直接的-ROS-package-来控制飞机" class="headerlink" title="创建直接的 ROS package 来控制飞机"></a>创建直接的 ROS package 来控制飞机</h1><h2 id="1-新建-ROS-package"><a href="#1-新建-ROS-package" class="headerlink" title="1. 新建 ROS package"></a>1. 新建 ROS package</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/rotors_ws/src</span><br><span class="line">catkin_create_pkg [PACKAGE_NAME] std_msgs rospy roscpp</span><br></pre></td></tr></table></figure><p>如：新建跟踪 package: <code>catkin_create_pkg uav_tracking std_msgs rospy roscpp</code></p><h2 id="2-修改-uav-tracking-CMakeLists-txt-添加依赖"><a href="#2-修改-uav-tracking-CMakeLists-txt-添加依赖" class="headerlink" title="2. 修改 uav_tracking/CMakeLists.txt 添加依赖"></a>2. 修改 <code>uav_tracking/CMakeLists.txt</code> 添加依赖</h2><p>修改前</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>修改后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line"></span><br><span class="line">  sensor_msgs</span><br><span class="line">  geometry_msgs</span><br><span class="line">  mav_msgs</span><br><span class="line">  gazebo_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>sensor_msgs,添加对ROS官方sensor_msgs消息的依赖,在包的程序中可以使用sensor_msgs&#x2F;xxx类型的消息;</li><li>geometry_msgs,添加对ROS官方geometry_msgs消息的依赖,在包的程序中可以使用geometry_msgs&#x2F;xxx类型的消息;</li><li>mav_msgs,添加对mav_msgs消息的依赖,在包的程序中可以使用mav_msgs&#x2F;xxx类型的消息,该消息的定义在UAV\src\mav_comm包中定义;</li><li>gazebo_msgs添加对ROS官方gazebo_msgs消息的依赖,在包的程序中可以使用gazebo_msgs&#x2F;xxx类型的消息,主要用于从Gazebo中获取消息.</li></ul><h2 id="3-修改-uav-tracking-package-xml"><a href="#3-修改-uav-tracking-package-xml" class="headerlink" title="3. 修改 uav_tracking/package.xml"></a>3. 修改 <code>uav_tracking/package.xml</code></h2><p>在 <code>&lt;exec_depend&gt;std_msg&lt;/exec_depend&gt;</code> 后添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;depend&gt;gazebo_msgs&lt;/depend&gt;</span><br><span class="line">&lt;depend&gt;gazebo_plugins&lt;/depend&gt;</span><br><span class="line">&lt;depend&gt;geometry_msgs&lt;/depend&gt;</span><br><span class="line">&lt;depend&gt;joy&lt;/depend&gt;</span><br><span class="line">&lt;depend&gt;mav_msgs&lt;/depend&gt;</span><br><span class="line">&lt;depend&gt;rotors_gazebo_plugins&lt;/depend&gt;</span><br><span class="line">&lt;depend&gt;sensor_msgs&lt;/depend&gt;</span><br><span class="line">&lt;depend&gt;xacro&lt;/depend&gt;</span><br></pre></td></tr></table></figure><p>添加后：<br><img src="https://i.loli.net/2021/01/20/PFDWncqtCIsiaJw.png" alt="package.xml"></p><h2 id="4-新建测试-cpp-文件"><a href="#4-新建测试-cpp-文件" class="headerlink" title="4. 新建测试 cpp 文件"></a>4. 新建测试 cpp 文件</h2><p>在<code>uav_tracking/src/</code>中新建<code>control_test.cpp</code>文件并写入下面代码，用于控制飞机：</p><details>  <summary>点击查看代码</summary>  <pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ros/ros.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;geometry_msgs/PointStamped.h&gt;</span><br><span class="line">#include &lt;std_srvs/Empty.h&gt;</span><br><span class="line">#include &lt;Eigen/Core&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;mav_msgs/conversions.h&gt;</span><br><span class="line">#include &lt;mav_msgs/default_topics.h&gt;</span><br><span class="line">#include &lt;trajectory_msgs/MultiDOFJointTrajectory.h&gt;</span><br><span class="line"></span><br><span class="line">ros::Publisher trajectory_pub;</span><br><span class="line">geometry_msgs::PointStamped current_position;</span><br><span class="line"></span><br><span class="line">float linear_smoothing_navigation_step = 2;</span><br><span class="line">bool flag_gps_initialized_OK = false;</span><br><span class="line">bool flag_take_off_OK = false;</span><br><span class="line">int flag_tasks_OK = 0;</span><br><span class="line">Eigen::Vector3d home;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Description: </span><br><span class="line">    updateUavPosition(const geometry_msgs::PointStamped&amp; msg)</span><br><span class="line">    gps数据更新的回调函数.</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">    msg 位置信息</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">    无</span><br><span class="line">*/</span><br><span class="line">void updateUavPosition(const geometry_msgs::PointStamped&amp; msg)</span><br><span class="line">&#123;</span><br><span class="line">    if (!flag_gps_initialized_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        flag_gps_initialized_OK= true;</span><br><span class="line">        home[0] = msg.point.x;</span><br><span class="line">        home[1] = msg.point.y;</span><br><span class="line">        home[2] = msg.point.z;</span><br><span class="line">    &#125;</span><br><span class="line">    current_position = msg;</span><br><span class="line">    // std::cout&lt;&lt;&quot;UAV current position is: &quot;&lt;&lt;msg.point.x&lt;&lt; msg.point.y&lt;&lt; msg.point.z&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Description: </span><br><span class="line">    getDistanceToTarget(const Eigen::Vector3d&amp; target)</span><br><span class="line">    获取当前位置到指定位置位置的距离.</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">    target 需要飞达的位置点</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">    double 当前位置到达目标点的位置</span><br><span class="line">*/</span><br><span class="line">double getDistanceToTarget(const Eigen::Vector3d&amp; target)</span><br><span class="line">&#123;</span><br><span class="line">    double temp = 0;</span><br><span class="line">    temp += pow((target[0] - current_position.point.x), 2);</span><br><span class="line">    temp += pow((target[1] - current_position.point.y), 2);</span><br><span class="line">    temp += pow((target[2] - current_position.point.z), 2);</span><br><span class="line">    temp = sqrt(temp);</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Description: </span><br><span class="line">    reachTargetPosition(const Eigen::Vector3d&amp; target, float max_error)</span><br><span class="line">    判定是否到达指定的目标点.</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">    target 需要飞达的位置点</span><br><span class="line">    max_error 允许的位置误差阈值,当前位置和目标位置小于该阈值时,判定无人机到达目标点</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">    bool 到达目标点时返回 true</span><br><span class="line">         未到达目标点时返回 false</span><br><span class="line">*/</span><br><span class="line">bool reachTargetPosition(const Eigen::Vector3d&amp; target, float max_error)</span><br><span class="line">&#123;</span><br><span class="line">    double temp = getDistanceToTarget(target);</span><br><span class="line"></span><br><span class="line">    if (temp &lt; max_error)</span><br><span class="line">        return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Description: </span><br><span class="line">    linearSmoothingNavigationTask(const Eigen::Vector3d&amp; target)</span><br><span class="line">    控制无人机从当前位置飞向指定位置.</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">    target 需要飞达的位置点</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">    bool 起飞结束后返回 true</span><br><span class="line">         起飞过程中返回 false</span><br><span class="line">*/</span><br><span class="line">bool linearSmoothingNavigationTask(const Eigen::Vector3d&amp; target)</span><br><span class="line">&#123;</span><br><span class="line">    trajectory_msgs::MultiDOFJointTrajectory trajectory_msg;</span><br><span class="line">    trajectory_msg.header.stamp = ros::Time::now();</span><br><span class="line"></span><br><span class="line">    if (reachTargetPosition(target,0.2))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    double dist = getDistanceToTarget(target);</span><br><span class="line">    Eigen::Vector3d next_step;</span><br><span class="line"></span><br><span class="line">    if(dist&lt;linear_smoothing_navigation_step)</span><br><span class="line">    &#123;</span><br><span class="line">        next_step = target;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        next_step[0] = current_position.point.x+(target[0]-current_position.point.x)/dist*linear_smoothing_navigation_step;</span><br><span class="line">        next_step[1] = current_position.point.y+(target[1]-current_position.point.y)/dist*linear_smoothing_navigation_step;</span><br><span class="line">        next_step[2] = current_position.point.z+(target[2]-current_position.point.z)/dist*linear_smoothing_navigation_step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double desired_yaw = 0.0; </span><br><span class="line"></span><br><span class="line">    mav_msgs::msgMultiDofJointTrajectoryFromPositionYaw(next_step, desired_yaw, &amp;trajectory_msg);</span><br><span class="line">    trajectory_pub.publish(trajectory_msg);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Description: </span><br><span class="line">    takeOffTask(float height)</span><br><span class="line">    起飞函数,调用后无人机从起始位置起飞指定高度.</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">    height 指定的起飞高度</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">    bool 起飞结束后返回 true</span><br><span class="line">         起飞过程中返回 false</span><br><span class="line">*/</span><br><span class="line">bool takeOffTask(float height)</span><br><span class="line">&#123;</span><br><span class="line">    trajectory_msgs::MultiDOFJointTrajectory trajectory_msg;</span><br><span class="line">    trajectory_msg.header.stamp = ros::Time::now();</span><br><span class="line"></span><br><span class="line">    static Eigen::Vector3d desired_position(current_position.point.x, current_position.point.y, height);</span><br><span class="line">    double desired_yaw = 0.0;</span><br><span class="line"></span><br><span class="line">    if (reachTargetPosition(desired_position,0.2))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    mav_msgs::msgMultiDofJointTrajectoryFromPositionYaw(desired_position, desired_yaw, &amp;trajectory_msg);</span><br><span class="line">    trajectory_pub.publish(trajectory_msg);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Description: </span><br><span class="line">    gohome()</span><br><span class="line">    反航函数,调用后无人机先沿着当前高度飞到反航点正上方,然后降落.</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">    无</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">    无</span><br><span class="line">*/</span><br><span class="line">void gohome()</span><br><span class="line">&#123;</span><br><span class="line">    static Eigen::Vector3d temp(home[0], home[1], current_position.point.z);</span><br><span class="line">    static bool flag_temp = false;</span><br><span class="line"></span><br><span class="line">    if (!flag_temp)</span><br><span class="line">    &#123;</span><br><span class="line">        flag_temp = linearSmoothingNavigationTask(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        linearSmoothingNavigationTask(home);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    ros::init(argc, argv, &quot;UAV_Controler&quot;);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    // Create a private node handle for accessing node parameters.</span><br><span class="line">    ros::NodeHandle nh_private(&quot;~&quot;);</span><br><span class="line"></span><br><span class="line">    std::string uav_name = &quot;&quot;;  </span><br><span class="line">    ros::param::get(&quot;~mav_name&quot;,uav_name);</span><br><span class="line"></span><br><span class="line">    // 订阅话题</span><br><span class="line">    // /odometry_sensor1/position   无人机位置信息(包含噪声)</span><br><span class="line">    ros::Subscriber position_sub = nh.subscribe(std::string(&quot;/&quot;+uav_name+&quot;/odometry_sensor1/position&quot;).c_str(), 10, &amp;updateUavPosition);</span><br><span class="line"></span><br><span class="line">    trajectory_pub = nh.advertise&lt;trajectory_msgs::MultiDOFJointTrajectory&gt;(mav_msgs::default_topics::COMMAND_TRAJECTORY, 10);</span><br><span class="line"></span><br><span class="line">    // 等待5s,让Gazebo可以成功启动.</span><br><span class="line">    ros::Duration(5.0).sleep();</span><br><span class="line"></span><br><span class="line">    // 创建控制Gazebo自动运行的服务,这里自动运行是指让Gazebo自动Play</span><br><span class="line">    std_srvs::Empty srv;</span><br><span class="line">    bool unpaused = ros::service::call(&quot;/gazebo/unpause_physics&quot;, srv); </span><br><span class="line"></span><br><span class="line">    // 尝试让Gazebo自动运行</span><br><span class="line">    int i=0;</span><br><span class="line">    while (i &lt;= 10 &amp;&amp; !unpaused) &#123;</span><br><span class="line">        ROS_INFO(&quot;Wait for 1 second before trying to unpause Gazebo again.&quot;);</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">        unpaused = ros::service::call(&quot;/gazebo/unpause_physics&quot;, srv);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断Gazebo有没有自动运行,没有成功Play则退出</span><br><span class="line">    if (!unpaused) &#123;</span><br><span class="line">        ROS_FATAL(&quot;Could not wake up Gazebo.&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ROS_INFO(&quot;Unpaused the Gazebo simulation.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Eigen::Vector3d&gt; path;</span><br><span class="line">    path.push_back(Eigen::Vector3d(5.f,5.f,5.f));</span><br><span class="line">    path.push_back(Eigen::Vector3d(-5.f,5.f,5.f));</span><br><span class="line">    path.push_back(Eigen::Vector3d(-5.f,-5.f,5.f));</span><br><span class="line">    path.push_back(Eigen::Vector3d(5.f,-5.f,5.f));</span><br><span class="line">    path.push_back(Eigen::Vector3d(5.f,5.f,5.f));</span><br><span class="line">    std::cout &lt;&lt; path.size() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    ros::Rate loop_rate(10);</span><br><span class="line">    while (ros::ok())</span><br><span class="line">    &#123; </span><br><span class="line">        if(flag_gps_initialized_OK &amp;&amp; !flag_take_off_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            // ROS_INFO(&quot;UAV take off task is running...&quot;);</span><br><span class="line">            flag_take_off_OK = takeOffTask(3);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(flag_take_off_OK &amp;&amp; flag_tasks_OK&lt;path.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(flag_tasks_OK&lt;path.size())</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                bool temp = linearSmoothingNavigationTask(path[flag_tasks_OK]);</span><br><span class="line">                if (temp)</span><br><span class="line">                    flag_tasks_OK ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(flag_tasks_OK &gt;= path.size())</span><br><span class="line">        &#123;</span><br><span class="line">            gohome();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ros::spinOnce();</span><br><span class="line">        loop_rate.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  </code></pre></p></details><h2 id="5-创建launch文件夹并新建control-test-launch文件"><a href="#5-创建launch文件夹并新建control-test-launch文件" class="headerlink" title="5. 创建launch文件夹并新建control_test.launch文件"></a>5. 创建<code>launch</code>文件夹并新建<code>control_test.launch</code>文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/rotors_ws/src/uav_tracking/</span><br><span class="line">mkdir launch &amp;&amp; cd launch</span><br><span class="line">touch control_test.launch</span><br><span class="line">gedit control_test.launch</span><br></pre></td></tr></table></figure><p>在<code>control_test.launch</code>中写入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;arg name=&quot;mav_name&quot; default=&quot;firefly&quot;/&gt;</span><br><span class="line">    &lt;arg name=&quot;world_name&quot; default=&quot;basic&quot;/&gt;</span><br><span class="line">    &lt;arg name=&quot;enable_logging&quot; default=&quot;false&quot; /&gt;</span><br><span class="line">    &lt;arg name=&quot;enable_ground_truth&quot; default=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;arg name=&quot;log_file&quot; default=&quot;$(arg mav_name)&quot; /&gt;</span><br><span class="line">    &lt;arg name=&quot;debug&quot; default=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;arg name=&quot;gui&quot; default=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;arg name=&quot;paused&quot; default=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;!-- The following line causes gzmsg and gzerr messages to be printed to the console</span><br><span class="line">        (even when Gazebo is started through roslaunch) --&gt;</span><br><span class="line">    &lt;arg name=&quot;verbose&quot; default=&quot;false&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--Run Gazebo--&gt;</span><br><span class="line">    &lt;env name=&quot;GAZEBO_MODEL_PATH&quot; value=&quot;$&#123;GAZEBO_MODEL_PATH&#125;:$(find rotors_gazebo)/models&quot;/&gt;</span><br><span class="line">    &lt;env name=&quot;GAZEBO_RESOURCE_PATH&quot; value=&quot;$&#123;GAZEBO_RESOURCE_PATH&#125;:$(find rotors_gazebo)/models&quot;/&gt;</span><br><span class="line">    &lt;include file=&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;&gt;</span><br><span class="line">        &lt;arg name=&quot;world_name&quot; value=&quot;$(find rotors_gazebo)/worlds/$(arg world_name).world&quot; /&gt;</span><br><span class="line">        &lt;arg name=&quot;debug&quot; value=&quot;$(arg debug)&quot; /&gt;</span><br><span class="line">        &lt;arg name=&quot;paused&quot; value=&quot;$(arg paused)&quot; /&gt;</span><br><span class="line">        &lt;arg name=&quot;gui&quot; value=&quot;$(arg gui)&quot; /&gt;</span><br><span class="line">        &lt;arg name=&quot;verbose&quot; value=&quot;$(arg verbose)&quot;/&gt;</span><br><span class="line">    &lt;/include&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--Run UAV model and control node--&gt;</span><br><span class="line">    &lt;group ns=&quot;$(arg mav_name)&quot;&gt;</span><br><span class="line">        &lt;include file=&quot;$(find rotors_gazebo)/launch/spawn_mav.launch&quot;&gt;</span><br><span class="line">        &lt;arg name=&quot;mav_name&quot; value=&quot;$(arg mav_name)&quot; /&gt;</span><br><span class="line">        &lt;arg name=&quot;model&quot; value=&quot;$(find rotors_description)/urdf/mav_generic_odometry_sensor.gazebo&quot; /&gt;</span><br><span class="line">        &lt;arg name=&quot;enable_logging&quot; value=&quot;$(arg enable_logging)&quot; /&gt;</span><br><span class="line">        &lt;arg name=&quot;enable_ground_truth&quot; value=&quot;$(arg enable_ground_truth)&quot; /&gt;</span><br><span class="line">        &lt;arg name=&quot;log_file&quot; value=&quot;$(arg log_file)&quot;/&gt;</span><br><span class="line">        &lt;/include&gt;</span><br><span class="line"></span><br><span class="line">        &lt;node name=&quot;lee_position_controller_node&quot; pkg=&quot;rotors_control&quot; type=&quot;lee_position_controller_node&quot; output=&quot;screen&quot;&gt;</span><br><span class="line">        &lt;rosparam command=&quot;load&quot; file=&quot;$(find rotors_gazebo)/resource/lee_controller_$(arg mav_name).yaml&quot; /&gt;</span><br><span class="line">        &lt;rosparam command=&quot;load&quot; file=&quot;$(find rotors_gazebo)/resource/$(arg mav_name).yaml&quot; /&gt;</span><br><span class="line">        &lt;remap from=&quot;odometry&quot; to=&quot;odometry_sensor1/odometry&quot; /&gt;</span><br><span class="line">        &lt;/node&gt;</span><br><span class="line"></span><br><span class="line">        &lt;node name=&quot;robot_state_publisher&quot; pkg=&quot;robot_state_publisher&quot; type=&quot;robot_state_publisher&quot; /&gt;</span><br><span class="line">        &lt;node name=&quot;joint_state_publisher&quot; pkg=&quot;joint_state_publisher&quot; type=&quot;joint_state_publisher&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--name属性用来定义节点运行的名称。pkg定义节点所在的功能包名称，type定义节点的可执行文件名称，这两个属性等同于在终端中使用rosrun命令执行节点时的输入参数--&gt;</span><br><span class="line">        &lt;node </span><br><span class="line">            name=&quot;control_test&quot; pkg=&quot;uav_tracking&quot; type=&quot;control_test&quot; output=&quot;screen&quot;&gt;</span><br><span class="line">            &lt;param name=&quot;mav_name&quot; type=&quot;string&quot; value=&quot;$(arg mav_name)&quot;/&gt;</span><br><span class="line">         &lt;/node&gt;  </span><br><span class="line">    &lt;/group&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><h2 id="6-在-uav-tracking-CMakeLists-txt-添加编译"><a href="#6-在-uav-tracking-CMakeLists-txt-添加编译" class="headerlink" title="6. 在 uav_tracking/CMakeLists.txt 添加编译"></a>6. 在 <code>uav_tracking/CMakeLists.txt</code> 添加编译</h2><p>在<code>uav_tracking/CMakeLists.txt</code>文件最下方添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_executable(control_test src/control_test.cpp)</span><br><span class="line">target_link_libraries(control_test $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure><h2 id="7-编译"><a href="#7-编译" class="headerlink" title="7. 编译"></a>7. 编译</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/rotors_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h2 id="8-运行"><a href="#8-运行" class="headerlink" title="8. 运行"></a>8. 运行</h2><p>重启终端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source ~/rotors_ws/devel/setup.bash</span><br><span class="line">roslaunch uav_tracking control_test.launch</span><br></pre></td></tr></table></figure><p>如果启动成功，就可以看到程序自动启动仿真，无人机根据<code>control_test.cpp</code>的代码开始自己运动</p><h1 id="tracking-包的使用"><a href="#tracking-包的使用" class="headerlink" title="tracking 包的使用"></a>tracking 包的使用</h1><p><a href="https://suzhilong.github.io/2021/01/21/rotorsTracking/">基于ROS的无人机跟踪：tracking package</a></p><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul><li><a href="https://github.com/ethz-asl/rotors_simulator">rotors_simulator项目</a></li><li><a href="https://github.com/suzhilong/uav_tracking">uav_tracking包</a></li><li><a href="http://wiki.ros.org/rotors_simulator">rotors_simulator ROS wiki</a></li><li><a href="https://www.guyuehome.com/7598">rotors无人机仿真</a></li><li><a href="https://www.guyuehome.com/16351">无人机ROS仿真包 rotors_simulator 编译教程</a></li><li><a href="https://www.guyuehome.com/21614">无人机ROS仿真包 rotors_simulator 使用教程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/suzhilong/uav_tracking&quot;&gt;uav_tracking项目代码&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;安装-rotors-simulator&quot;&gt;&lt;a href=&quot;#安装-rotors-simulator&quot; class=&quot;headerlink&quot; title=&quot;安装 rotors_simulator&quot;&gt;&lt;/a&gt;安装 &lt;a href=&quot;(https://github.com/ethz-asl/rotors_simulator)&quot;&gt;rotors_simulator&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-新建工作空间并初始化（有工作空间的跳过此步骤）&quot;&gt;&lt;a href=&quot;#1-新建工作空间并初始化（有工作空间的跳过此步骤）&quot; class=&quot;headerlink&quot; title=&quot;1. 新建工作空间并初始化（有工作空间的跳过此步骤）&quot;&gt;&lt;/a&gt;1. 新建工作空间并初始化（有工作空间的跳过此步骤）&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir -p ~/rotors_ws/src&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd ~/rotors_ws/src&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;catkin_init_workspace&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;2-克隆源代码&quot;&gt;&lt;a href=&quot;#2-克隆源代码&quot; class=&quot;headerlink&quot; title=&quot;2. 克隆源代码&quot;&gt;&lt;/a&gt;2. 克隆源代码&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd ~/rotors_ws/src&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git clone https://github.com/ethz-asl/rotors_simulator.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="robot" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/robot/"/>
    
    
    <category term="Drone" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/Drone/"/>
    
  </entry>
  
  <entry>
    <title>无人机仿真</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2021/01/19/droneSimulator/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2021/01/19/droneSimulator/</id>
    <published>2021-01-19T11:19:00.000Z</published>
    <updated>2021-01-20T11:47:47.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无人机仿真的几种方法"><a href="#无人机仿真的几种方法" class="headerlink" title="无人机仿真的几种方法"></a>无人机仿真的几种方法</h1><h2 id="在ros环境下无人机的仿真方式有以下几种"><a href="#在ros环境下无人机的仿真方式有以下几种" class="headerlink" title="在ros环境下无人机的仿真方式有以下几种"></a>在ros环境下无人机的仿真方式有以下几种</h2><ul><li><a href="https://github.com/tu-darmstadt-ros-pkg/hector_quadrotor">hector_quadrotor</a></li><li><a href="https://github.com/ethz-asl/rotors_simulator">rotors_simulator</a></li><li><a href="https://www.yuque.com/xtdrone/manual_cn">XTDrone</a>：基于<a href="https://docs.px4.io/master/zh/simulation">PX4</a>的无人机仿真<span id="more"></span></li></ul><h2 id="本教程环境"><a href="#本教程环境" class="headerlink" title="本教程环境"></a>本教程环境</h2><ul><li>系统：ubuntu16.04</li><li>ROS版本：kinetic</li></ul><h1 id="hector-quadrotor"><a href="#hector-quadrotor" class="headerlink" title="hector_quadrotor"></a><a href="https://github.com/tu-darmstadt-ros-pkg/hector_quadrotor">hector_quadrotor</a></h1><p><a href="http://wiki.ros.org/hector_quadrotor">hector_quadrotor wiki</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1-新建工作空间并初始化"><a href="#1-新建工作空间并初始化" class="headerlink" title="1. 新建工作空间并初始化"></a>1. 新建工作空间并初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p hector_quadrotor_catkin/src</span><br><span class="line">cd hector_quadrotor_catkin/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure><h3 id="2-克隆源代码"><a href="#2-克隆源代码" class="headerlink" title="2. 克隆源代码"></a>2. 克隆源代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tu-darmstadt-ros-pkg/hector_quadrotor.git</span><br></pre></td></tr></table></figure><h3 id="3-初始化wstool，并更新所需库"><a href="#3-初始化wstool，并更新所需库" class="headerlink" title="3. 初始化wstool，并更新所需库"></a>3. 初始化wstool，并更新所需库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wstool init</span><br><span class="line">wstool merge tutorials.rosinstall</span><br><span class="line">wstool update</span><br></pre></td></tr></table></figure><h3 id="4-编译"><a href="#4-编译" class="headerlink" title="4. 编译"></a>4. 编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/hector_quadrotor_catkin/</span><br><span class="line">catkin build</span><br></pre></td></tr></table></figure><h3 id="5-环境变量"><a href="#5-环境变量" class="headerlink" title="5. 环境变量"></a>5. 环境变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ./devel/setup.bash</span><br></pre></td></tr></table></figure><p>也可以用下面的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source ~/hector_quadrotor_catkin/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>编译成功后可以运行demo试一下，hector_quadrotor一共有两个demo，indoor和outdoor.</p><h3 id="indoor"><a href="#indoor" class="headerlink" title="indoor"></a>indoor</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch hector_quadrotor_demo indoor_slam_gazebo.launch</span><br></pre></td></tr></table></figure><h3 id="outdoor"><a href="#outdoor" class="headerlink" title="outdoor"></a>outdoor</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch hector_quadrotor_demo outdoor_flight_gazebo.launch</span><br></pre></td></tr></table></figure><h2 id="键盘操控"><a href="#键盘操控" class="headerlink" title="键盘操控"></a>键盘操控</h2><p>使用<code>teleop_twist_keyboard package</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-kinetic-teleop-twist-keyboard</span><br><span class="line">rosrun teleop_twist_keyboard teleop_twist_keyboard.py</span><br></pre></td></tr></table></figure><p><em>ps:需要先按<code>t</code>让飞机先飞起来才能控制</em></p><h1 id="rotors-simulator"><a href="#rotors-simulator" class="headerlink" title="rotors_simulator"></a><a href="https://github.com/ethz-asl/rotors_simulator">rotors_simulator</a></h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><h3 id="1-新建工作空间并初始化-1"><a href="#1-新建工作空间并初始化-1" class="headerlink" title="1. 新建工作空间并初始化"></a>1. 新建工作空间并初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p rotors_ws/src</span><br><span class="line">cd rotors_ws/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure><h3 id="2-克隆源代码-1"><a href="#2-克隆源代码-1" class="headerlink" title="2. 克隆源代码"></a>2. 克隆源代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ethz-asl/rotors_simulator.git</span><br></pre></td></tr></table></figure><h3 id="3-初始化wstool，并更新所需库-1"><a href="#3-初始化wstool，并更新所需库-1" class="headerlink" title="3. 初始化wstool，并更新所需库"></a>3. 初始化wstool，并更新所需库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wstool init</span><br><span class="line">wget https://raw.githubusercontent.com/ethz-asl/rotors_simulator/master/rotors_hil.rosinstall</span><br><span class="line">wstool merge rotors_hil.rosinstall</span><br><span class="line">wstool update</span><br></pre></td></tr></table></figure><h3 id="4-编译-1"><a href="#4-编译-1" class="headerlink" title="4. 编译"></a>4. 编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/rotors_ws/</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h3 id="5-环境变量-1"><a href="#5-环境变量-1" class="headerlink" title="5. 环境变量"></a>5. 环境变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ./devel/setup.bash</span><br></pre></td></tr></table></figure><p>也可以用下面的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source ~/rotors_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch rotors_gazebo mav_hovering_example.launch mav_name:=firefly world_name:=basic</span><br></pre></td></tr></table></figure><h2 id="功能开发"><a href="#功能开发" class="headerlink" title="功能开发"></a>功能开发</h2><p>更多功能的开发请看<a href="https://suzhilong.github.io/2021/01/20/rotorsSimulator/">无人机仿真：rotors_simulator的使用</a></p><h1 id="XTDrone"><a href="#XTDrone" class="headerlink" title="XTDrone"></a><a href="https://github.com/robin-shaun/XTDrone">XTDrone</a></h1><p>其实这是基于<a href="https://docs.px4.io/master/zh/simulation">PX4</a>和ROS的无人机仿真平台，不过有很多已经开发好的项目</p><h2 id="一、PX4的安装"><a href="#一、PX4的安装" class="headerlink" title="一、PX4的安装"></a>一、PX4的安装</h2><p>安装使用PX4可以直接看<a href="https://www.yuque.com/xtdrone/manual_cn">官方文档</a></p><p>也可以照着<a href="https://www.yuque.com/xtdrone/manual_cn/basic_config_1.11">XTDrone</a>的步骤（推荐）</p><h3 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y ninja-build exiftool python-argparse python-empy python-toml python-numpy python-yaml python-dev python-pip ninja-build protobuf-compiler libeigen3-dev genromfs xmlstarlet libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev</span><br><span class="line"></span><br><span class="line">pip2 install pandas jinja2 pyserial cerberus pyulog numpy toml pyquaternion</span><br><span class="line">pip3 install packaging numpy empy toml pyyaml jinja2</span><br><span class="line"></span><br><span class="line">//gazebo</span><br><span class="line">sudo apt install ros-kinetic-gazebo9-*</span><br></pre></td></tr></table></figure><h3 id="2-安装-mavros-以及相关的-geographiclib-dataset"><a href="#2-安装-mavros-以及相关的-geographiclib-dataset" class="headerlink" title="2. 安装 mavros 以及相关的 geographiclib dataset"></a>2. 安装 mavros 以及相关的 geographiclib dataset</h3><p><a href="http://wiki.ros.org/mavros">mavros</a> 是一个飞机固件与ros通信的包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-kinetic-mavros ros-kinetic-mavros-extras</span><br><span class="line">//如果出现443拒绝连接的情况，可能是因为域名污染，在/etc/hosts中加入raw.githubusercontent.com指定ip就行</span><br><span class="line">wget https://raw.githubusercontent.com/mavlink/mavros/master/mavros/scripts/install_geographiclib_datasets.sh</span><br><span class="line">sudo chmod a+x ./install_geographiclib_datasets.sh</span><br><span class="line">sudo ./install_geographiclib_datasets.sh</span><br></pre></td></tr></table></figure><h3 id="3-下载编译px4-Firmware"><a href="#3-下载编译px4-Firmware" class="headerlink" title="3. 下载编译px4 Firmware"></a>3. 下载编译px4 Firmware</h3><h4 id="创建工作空间（已经有工作空间的跳过）"><a href="#创建工作空间（已经有工作空间的跳过）" class="headerlink" title="创建工作空间（已经有工作空间的跳过）"></a>创建工作空间（已经有工作空间的跳过）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/px4_ws/src</span><br><span class="line">cd ~/px4_ws/src/</span><br><span class="line">catkin_init_workspace</span><br><span class="line">cd ..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h4 id="下载编译px4"><a href="#下载编译px4" class="headerlink" title="下载编译px4"></a>下载编译px4</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//一般将固件放在主目录下而不是ros的工作空间中</span><br><span class="line">git clone https://github.com/PX4/PX4-Autopilot.git</span><br><span class="line">mv PX4-Autopilot PX4_Firmware</span><br><span class="line">cd PX4_Firmware</span><br><span class="line">//可以根据需求改变版本号v1.x.x</span><br><span class="line">git checkout v1.11.2</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">//开始编译</span><br><span class="line">make px4_sitl_default gazebo</span><br></pre></td></tr></table></figure><h4 id="编译报错"><a href="#编译报错" class="headerlink" title="编译报错"></a>编译报错</h4><p>编译报错时，可能缺少了必要的依赖，可以在编译前：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/PX4_Firmware</span><br><span class="line">bash</span><br><span class="line">//只是进行ros下开发仿真的话，可以把ubuntu.sh里的INSTALL_NUTTX改为’false’，或是加上参数--no-nuttx</span><br><span class="line">bash ./Tools/setup/ubuntu.sh --no-nuttx</span><br></pre></td></tr></table></figure><p><strong>注意：ubuntu.sh可能安装失败，请务必重新运行ubuntu.sh脚本，直至成功</strong></p><h3 id="4-添加环境变量"><a href="#4-添加环境变量" class="headerlink" title="4. 添加环境变量"></a>4. 添加环境变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//添加工作空间source</span><br><span class="line">echo &quot;source ~/px4_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line">//添加px4路径</span><br><span class="line">echo &quot;source ~/PX4_Firmware/Tools/setup_gazebo.bash\</span><br><span class="line"> ~/PX4_Firmware/\</span><br><span class="line"> ~/PX4_Firmware/build/px4_sitl_default&quot;\</span><br><span class="line"> &gt;&gt; ~/.bashrc</span><br><span class="line">echo &quot;export ROS_PACKAGE_PATH=\$ROS_PACKAGE_PATH:~/PX4_Firmware&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">echo &quot;export ROS_PACKAGE_PATH=\$ROS_PACKAGE_PATH:~/PX4_Firmware/Tools/sitl_gazebo&quot; &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line">//source一下</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="5-运行"><a href="#5-运行" class="headerlink" title="5. 运行"></a>5. 运行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/PX4_Firmware</span><br><span class="line">//此命令同时启动了mavros</span><br><span class="line">roslaunch px4 mavros_posix_sitl.launch</span><br></pre></td></tr></table></figure><h2 id="二、安装无人机的地面站控制软件QGC"><a href="#二、安装无人机的地面站控制软件QGC" class="headerlink" title="二、安装无人机的地面站控制软件QGC"></a>二、安装无人机的地面站控制软件QGC</h2><p><a href="https://dev.px4.cc/v1.8.2/zh/qgc/">QGroundControl</a> 是一个基于PX4自动驾驶仪配置和飞行的应用程序</p><p><a href="https://docs.qgroundcontrol.com/master/en/getting_started/download_and_install.html">官方安装指导教程</a></p><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G dialout $USER</span><br><span class="line">sudo apt-get remove modemmanager -y</span><br><span class="line">sudo apt install gstreamer1.0-plugins-bad gstreamer1.0-libav gstreamer1.0-gl -y</span><br></pre></td></tr></table></figure><h3 id="2-安装QGC"><a href="#2-安装QGC" class="headerlink" title="2. 安装QGC"></a>2. 安装QGC</h3><h4 id="1-下载"><a href="#1-下载" class="headerlink" title="1) 下载"></a>1) 下载</h4><p>前往<a href="https://github.com/mavlink/qgroundcontrol/releases">QCG发布网站</a>下载合适的版本的<code>QGroundControl.AppImage</code></p><p><strong>注意：</strong> ubuntu16.04只能使用4.0以前的版本，4.0（含）以后的版本至少需要18.04，<a href="https://docs.qgroundcontrol.com/master/en/getting_started/download_and_install.html">官方安装指导教程</a>中已经说明</p><h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2) 安装"></a>2) 安装</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./QGroundControl.AppImage</span><br><span class="line">./QGroundControl.AppImage  //或者双击就可以打开QGC</span><br></pre></td></tr></table></figure><h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3) 使用"></a>3) 使用</h4><p><code>roslaunch px4 mavros_posix_sitl.launch</code>之后打开QGC会显示<code>飞机已连接</code>，在里面中添加飞行任务，然后<code>上传</code>，再<code>滑动</code>就可以启动飞行任务。</p><p><strong>———————-PX4与ROS基础配置完成———————–</strong></p><p>各部分间的关系如下图所示：</p><p><img src="https://i.loli.net/2021/01/19/puTiaGwZLjW5QqH.png" alt="PX4架构"></p><h2 id="三、XTDrone部分"><a href="#三、XTDrone部分" class="headerlink" title="三、XTDrone部分"></a>三、XTDrone部分</h2><p>见<a href="https://www.yuque.com/xtdrone/manual_cn/basic_config_1.11">XTDrone使用文档</a></p><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul><li><a href="https://blog.csdn.net/wendox/article/details/52337171">玩转四旋翼无人机（仿真）</a></li><li><a href="https://blog.csdn.net/phenixlou/article/details/78518207">hector_quadrotor 的编译运行</a></li><li><a href="http://www.gkmm.tu-darmstadt.de/publications/files/meyer2012quadrotorsimulation.pdf">hector_quadrotor 的论文：Comprehensive Simulation of Quadrotor UAVs<br>using ROS and Gazebo</a></li><li><a href="https://www.guyuehome.com/7598">rotors无人机仿真</a></li><li><a href="https://www.guyuehome.com/16351">无人机ROS仿真包 rotors_simulator 编译教程</a></li><li><a href="https://www.guyuehome.com/21614">无人机ROS仿真包 rotors_simulator 使用教程</a></li><li><a href="https://www.guyuehome.com/7672">PX4无人机ROS下仿真开发</a></li><li><a href="https://www.guyuehome.com/7699">ROS下基于YOLO的px4无人机目标检测</a></li><li><a href="https://www.guyuehome.com/8983">基于px4的无人机自主导航</a></li><li><a href="https://docs.px4.io/master/en/dev_setup/dev_env_linux_ubuntu.html">px4文档</a></li><li><a href="https://github.com/robin-shaun/XTDrone">开源无人机项目：XTDrone</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;无人机仿真的几种方法&quot;&gt;&lt;a href=&quot;#无人机仿真的几种方法&quot; class=&quot;headerlink&quot; title=&quot;无人机仿真的几种方法&quot;&gt;&lt;/a&gt;无人机仿真的几种方法&lt;/h1&gt;&lt;h2 id=&quot;在ros环境下无人机的仿真方式有以下几种&quot;&gt;&lt;a href=&quot;#在ros环境下无人机的仿真方式有以下几种&quot; class=&quot;headerlink&quot; title=&quot;在ros环境下无人机的仿真方式有以下几种&quot;&gt;&lt;/a&gt;在ros环境下无人机的仿真方式有以下几种&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tu-darmstadt-ros-pkg/hector_quadrotor&quot;&gt;hector_quadrotor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ethz-asl/rotors_simulator&quot;&gt;rotors_simulator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.yuque.com/xtdrone/manual_cn&quot;&gt;XTDrone&lt;/a&gt;：基于&lt;a href=&quot;https://docs.px4.io/master/zh/simulation&quot;&gt;PX4&lt;/a&gt;的无人机仿真</summary>
    
    
    
    <category term="robot" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/robot/"/>
    
    
    <category term="Drone" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/Drone/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu找不到ttyUSB*</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2021/01/17/UbuntuNoUSB/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2021/01/17/UbuntuNoUSB/</id>
    <published>2021-01-17T07:44:00.000Z</published>
    <updated>2021-01-17T07:57:42.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在使用dji妙算（arm架构ubuntu14.04）连接激光雷达（ <a href="https://www.cnblogs.com/wanghuixi/p/6476984.html">ubuntu RPLIDAR A2的使用</a>）时，出现不能调用端口的错误，经过搜索后发现，是因为没有ttyUSB*驱动。</p><span id="more"></span><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>（待补充）</p><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul><li><a href="https://www.cnblogs.com/huang-y-x/p/10747849.html">Ubuntu下找不到ttyUSB*问题解决</a></li><li><a href="https://mlog.club/article/4510928">为您的内核版本构建cp210x</a></li><li><a href="https://www.cnblogs.com/CZM-/p/5985601.html">ubuntu arm妙算加载cp210x驱动</a></li><li><a href="https://elixir.bootlin.com/linux/v4.15/source/drivers/usb/serial">cp210x&#x2F;ch340等驱动地址</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;在使用dji妙算（arm架构ubuntu14.04）连接激光雷达（ &lt;a href=&quot;https://www.cnblogs.com/wanghuixi/p/6476984.html&quot;&gt;ubuntu RPLIDAR A2的使用&lt;/a&gt;）时，出现不能调用端口的错误，经过搜索后发现，是因为没有ttyUSB*驱动。&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/OS/"/>
    
    
    <category term="ubuntu" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用记录</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2021/01/13/Docker/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2021/01/13/Docker/</id>
    <published>2021-01-13T12:47:00.000Z</published>
    <updated>2021-01-18T02:42:24.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h1><span id="more"></span><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul><li><a href="https://yeasy.gitbook.io/docker_practice/">Docker——从入门到实践</a></li><li><a href="https://zhuanlan.zhihu.com/p/85664330">MacOS通过Docker使用ROS</a></li><li><a href="https://hub.docker.com/r/ct2034/vnc-ros-kinetic-full?ref=login">可以通过GUI打开gazebo, rviz, rqt等工具的镜像</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker的安装&quot;&gt;&lt;a href=&quot;#Docker的安装&quot; class=&quot;headerlink&quot; title=&quot;Docker的安装&quot;&gt;&lt;/a&gt;Docker的安装&lt;/h1&gt;</summary>
    
    
    
    <category term="OS" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/OS/"/>
    
    
    <category term="Docker" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu开机失败——ACPI Error</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2021/01/13/acpiError/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2021/01/13/acpiError/</id>
    <published>2021-01-13T12:47:00.000Z</published>
    <updated>2021-01-17T07:44:02.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开机循环进入GNU-GRUB-或者-黑屏"><a href="#开机循环进入GNU-GRUB-或者-黑屏" class="headerlink" title="开机循环进入GNU GRUB 或者 黑屏"></a>开机循环进入GNU GRUB 或者 黑屏</h1><span id="more"></span><p>有提示ACPI Error错误如图：<br><img src="https://i.loli.net/2021/01/13/iOJXvaWPxGmF95Z.jpg" alt="ACPI错误"></p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><h2 id="1）先用下面方法进入系统"><a href="#1）先用下面方法进入系统" class="headerlink" title="1）先用下面方法进入系统"></a>1）先用下面方法进入系统</h2><ul><li>在GUN GRUB界面，选择ubuntu，按<code>e</code>开启编辑；</li><li>在开头为<code>linux</code>的一行最后，加上<code>apci=off</code></li><li>按<code>f10</code>重启</li></ul><h2 id="2）更改grub"><a href="#2）更改grub" class="headerlink" title="2）更改grub"></a>2）更改grub</h2><ul><li>修改<code>grub</code>文件：<code>sudo vim /etc/default/grub</code></li><li>把<code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;</code>改为<code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash acpi=off&quot;</code>(vim的使用方法请自行搜索)</li><li><code>sudo update-grub</code></li></ul><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul><li>这是由于acpi和ubuntu版本不兼容：<a href="https://askubuntu.com/questions/139157/booting-ubuntu-with-acpi-off-grub-parameter">Booting Ubuntu with “acpi&#x3D;off” grub parameter</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;开机循环进入GNU-GRUB-或者-黑屏&quot;&gt;&lt;a href=&quot;#开机循环进入GNU-GRUB-或者-黑屏&quot; class=&quot;headerlink&quot; title=&quot;开机循环进入GNU GRUB 或者 黑屏&quot;&gt;&lt;/a&gt;开机循环进入GNU GRUB 或者 黑屏&lt;/h1&gt;</summary>
    
    
    
    <category term="OS" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/OS/"/>
    
    
    <category term="ubuntu" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>使用NodeJs和VueJs搭建网站</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2020/12/15/vue/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2020/12/15/vue/</id>
    <published>2020-12-15T11:47:00.000Z</published>
    <updated>2021-01-31T16:48:42.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、工具"><a href="#一、工具" class="headerlink" title="一、工具"></a>一、工具</h1><h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><p>Vue是一套用于构建用户界面的渐进式框架。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p><p><a href="https://cn.vuejs.org/">Vue官方网站</a></p><h2 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h2><p>一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。</p><p><a href="https://element.eleme.cn/#/zh-CN/component/installation">ElementUI官网</a></p><p>可以直接去官网的<strong>组件</strong>中，选择想要的组件，复制代码直接使用。</p><h2 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h2><p>Node.js 是能够在服务器端运行JavaScript 的开放源代码、跨平台 JavaScript 运行环境。</p><p>安装：<code>sudo apt-get install nodejs</code></p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>npm 是 Node.js 官方提供的包管理工具，他已经成了 Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。</p><span id="more"></span><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>sudo apt-get install nodejs</code></p><p><em>ps. 安装完后需要使用<code>npm config set registry https://registry.npm.taobao.org</code>切换成淘宝镜像，不然速度很慢。</em></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><code>npm i -g n</code></p><p><code>n latest</code></p><h2 id="安装vue"><a href="#安装vue" class="headerlink" title="安装vue"></a>安装vue</h2><p><code>npm i -g @vue/cli</code></p><h2 id="服务端后台常驻进程"><a href="#服务端后台常驻进程" class="headerlink" title="服务端后台常驻进程"></a>服务端后台常驻进程</h2><p><code>npm i -g nodemon</code></p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>一个数据库</p><p><a href="https://docs.mongodb.com/manual/installation/">官网安装步骤</a></p><p>或</p><p><code>sudo apt-get install mongodb-server</code></p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx是异步框架的网页服务器，也可以用作反向代理、负载平衡器和HTTP缓存。简单来说，就是通过服务器通过Nginx替你找到html文件。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p><code>sudo apt-get install nginx</code></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol><li><p>在线配置nginx：<a href="http://nginxedit.cn/">Go Nginx config</a></p></li><li><p>根据要求依次选择相应的</p><ul><li><strong>网站配置</strong>选项：Preset，域名等等</li><li><strong>全局配置</strong>选项：刚开始基本不用管</li></ul></li><li><p>下载&#x2F;复制config文件</p></li><li><p>把config文件复制到服务器的<code>/etc/nginx/sites-available/</code>文件夹中，再在<code>/etc/nginx/sites-enabled/</code>中创建一个软连接指向<code>/etc/nginx/sites-available/</code>中的config文件</p><p> 例如域名为<code>test.com</code>：<br> <code>cp sites-available/test.com.conf /etc/nginx/sites-available/</code></p><p> <code>cd /etc/nginx/sites-avaible</code></p><p> <code>sudo ln -s ../sites-available/test* /etc/nginx/sites-enabled/</code> </p></li><li><p>Change <a href="mailto:&#x6d;&#101;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;">&#x6d;&#101;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;</a> to your email<br> <code>sudo certbot --non-interactive --redirect --agree-tos --nginx -d test.com -m me@example.com</code></p></li></ol><h1 id="二、搭建项目"><a href="#二、搭建项目" class="headerlink" title="二、搭建项目"></a>二、搭建项目</h1><p><a href="https://github.com/suzhilong/RCAR2021web_frontEnd">示例项目</a></p><h2 id="项目初始化及其框架"><a href="#项目初始化及其框架" class="headerlink" title="项目初始化及其框架"></a>项目初始化及其框架</h2><p>以示例项目为例：</p><ul><li><code>admin</code>是管理员界面项目，可以用<code>vue create admin</code>来创建，里面包含<code>public</code>和<code>src</code>文件夹，<code>src</code>文件夹就是源代码所在文件夹</li><li><code>desktop</code>是pc桌面界面项目，可以用<code>vue create desktop</code>来创建</li><li><code>web</code>是移动端界面项目，可以用<code>vue create web</code>来创建</li><li><code>server</code>是nodejs组成的服务端项目，包括给后台和前端提供的接口。<ul><li>使用<code>mkdir server</code>创建文件夹后<code>cd server</code>，使用<code>npm init -y</code>初始化一个node项目（会生成一个<code>package.json</code>文件）</li><li>再在文件夹里新建一个<code>index.js</code>作为服务端入口文件</li><li>在<code>package.json</code>的<code>scripts</code>中，插入一行<code>&quot;serve&quot;: &quot;nodemon index.js&quot;,</code>。这样就可以在server中使用<code>npm run serve</code>来运行服务器项目</li></ul></li></ul><p>初始化完以后就可以cd进各个文件夹使用<code>npm run serve</code>本地运行，查看每个项目的效果。</p><p><em>ps: 如果提示错误，可以先使用<code>npm i</code>安装依赖</em></p><h2 id="安装elementUI和路由"><a href="#安装elementUI和路由" class="headerlink" title="安装elementUI和路由"></a>安装elementUI和路由</h2><p>在<code>admin</code>和<code>desktop</code>中，使用<code>vue add element</code>安装ElementUI，<code>vue add router</code>安装路由。</p><h2 id="vue项目文件说明"><a href="#vue项目文件说明" class="headerlink" title="vue项目文件说明"></a>vue项目文件说明</h2><p>以<code>admin</code>为例：</p><ul><li><code>public</code>可以先不管</li><li><code>src</code>是项目源代码<ul><li><code>components</code>是组件文件夹</li><li><code>views</code>存放的主要是总体页面的代码，<code>views</code>中新建.vue文件后，需要再<code>../router.js</code>中增加路由</li></ul></li></ul><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><h3 id="服务器系统设置"><a href="#服务器系统设置" class="headerlink" title="服务器系统设置"></a>服务器系统设置</h3><h4 id="Install-Packages"><a href="#Install-Packages" class="headerlink" title="Install Packages"></a>Install Packages</h4><ol><li><p>Install Nodejs </p><p> <code>sudo apt-get install nodejs</code></p></li><li><p>Install npm</p><p> <code>sudo apt-get install npm</code></p></li><li><p>Config Taobao registry</p><p> <code>npm config set registry https://registry.npm.taobao.org</code></p></li><li><p>Update Nodejs</p><p> <code>npm i -g n</code></p><p> <code>n latest</code></p><p> Reload cmd shell</p></li><li><p>Install pm2</p><p> <code>npm i -g pm2</code></p></li><li><p>Install Mongodb</p><p> <code>sudo apt-get install mongodb-server</code></p></li><li><p>Install Nginx</p><p> <code>sudo apt-get install nginx</code></p></li><li><p>Install certbot</p><p> <code>sudo apt install -y nginx certbot python-certbot-nginx</code></p></li></ol><h4 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd desktop</span><br><span class="line">npm i</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><p><code>npm run build</code>可以编译成静态html文件，直接打开</p><p>把<code>npm run build</code>改为<code>npm run server</code>可以在本地测试网站效果</p><p><strong>注意</strong>：<code>build</code>之前需要把对应文件夹里的<code>vue.config.js</code>（如：<code>desktop/vue.config.js</code>）中的<code>publicPath</code>的<code>/</code>改为<code>./</code>。<code>outputDir:</code>可以改为你想要编译到的目的路径</p><p>以示例项目为例，build 后在<code>desktop</code>中生产的<code>dist</code>文件夹就是静态html文件目录，点击<code>dist/index.html</code>就可以打开网站，把生成的<code>dist</code>文件夹里的文件放到服务器的对应文件夹就可以访问了。</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ul><li><a href="https://www.bilibili.com/video/BV1A4411Y7fi">学习视频</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、工具&quot;&gt;&lt;a href=&quot;#一、工具&quot; class=&quot;headerlink&quot; title=&quot;一、工具&quot;&gt;&lt;/a&gt;一、工具&lt;/h1&gt;&lt;h2 id=&quot;Vue-js&quot;&gt;&lt;a href=&quot;#Vue-js&quot; class=&quot;headerlink&quot; title=&quot;Vue.js&quot;&gt;&lt;/a&gt;Vue.js&lt;/h2&gt;&lt;p&gt;Vue是一套用于构建用户界面的渐进式框架。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cn.vuejs.org/&quot;&gt;Vue官方网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;ElementUI&quot;&gt;&lt;a href=&quot;#ElementUI&quot; class=&quot;headerlink&quot; title=&quot;ElementUI&quot;&gt;&lt;/a&gt;ElementUI&lt;/h2&gt;&lt;p&gt;一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://element.eleme.cn/#/zh-CN/component/installation&quot;&gt;ElementUI官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以直接去官网的&lt;strong&gt;组件&lt;/strong&gt;中，选择想要的组件，复制代码直接使用。&lt;/p&gt;
&lt;h2 id=&quot;NodeJs&quot;&gt;&lt;a href=&quot;#NodeJs&quot; class=&quot;headerlink&quot; title=&quot;NodeJs&quot;&gt;&lt;/a&gt;NodeJs&lt;/h2&gt;&lt;p&gt;Node.js 是能够在服务器端运行JavaScript 的开放源代码、跨平台 JavaScript 运行环境。&lt;/p&gt;
&lt;p&gt;安装：&lt;code&gt;sudo apt-get install nodejs&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;npm&quot;&gt;&lt;a href=&quot;#npm&quot; class=&quot;headerlink&quot; title=&quot;npm&quot;&gt;&lt;/a&gt;npm&lt;/h2&gt;&lt;p&gt;npm 是 Node.js 官方提供的包管理工具，他已经成了 Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。&lt;/p&gt;</summary>
    
    
    
    <category term="web前端" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>网络编程笔记</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2020/10/15/%E5%90%8E%E7%AB%AF/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2020/10/15/%E5%90%8E%E7%AB%AF/</id>
    <published>2020-10-15T08:00:00.000Z</published>
    <updated>2020-10-21T09:14:50.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h2><p><strong>大端</strong>：高位存在低地址，低位存在高地址。</p><p><strong>小端</strong>：高位存在高地址，低位存在低地址。</p><p>大小端和CPU有关。</p><p>现代PC大多采用小段，所以<strong>小端字节序</strong>又被成为<strong>主机字节序</strong>。而<strong>大端字节序</strong>又被成为<strong>网络字节序</strong>。</p><span id="more"></span><h2 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h2><p>TCP: recv, send</p><p>UDP: recvfrom, sendto(也可以面向连接)</p><p>通用: recvmsg, sendmsg</p><h2 id="网络I-x2F-O"><a href="#网络I-x2F-O" class="headerlink" title="网络I&#x2F;O"></a>网络I&#x2F;O</h2><ul><li>管道：<code>ini pipi(int fd[2]);</code></li><li>双向管道：<code>ini socketpair(int domain, int type, int protocol, int fd[2]);</code> </li><li>分散读：<code>readv</code>、集中写：<code>writev</code></li><li>两个文件描述符之间传递数据：<code>sendfile</code></li><li>进程间通信共享内存：申请<code>mmap</code>, 释放<code>munmap</code></li><li>两个文件描述符之间移动数据：<code>splice</code></li><li>两个管道文件描述符间复制数据：<code>tee</code></li><li>文件描述符的各种控制：<code>fcntl</code></li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul><li><code>syslog</code></li><li><code>rsyslogd</code></li></ul><h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><ul><li><code>getuid</code>, <code>geteuid</code>, <code>getgid</code>, <code>getegid</code>, <code>getpgid</code>, <code>getsid</code></li><li><code>setuid</code>, <code>seteuid</code>, <code>setgid</code>, <code>setegid</code>, <code>setpgid</code>, <code>setsid</code></li></ul><h2 id="服务器框架"><a href="#服务器框架" class="headerlink" title="服务器框架"></a>服务器框架</h2><h3 id="TCP客户端与服务器工作流程"><a href="#TCP客户端与服务器工作流程" class="headerlink" title="TCP客户端与服务器工作流程"></a>TCP客户端与服务器工作流程</h3><p><img src="https://i.loli.net/2020/10/13/5sLG28gmfFzpJD4.png" alt="TCP客户端与服务器工作流程"></p><h3 id="I-x2F-O模型"><a href="#I-x2F-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h3><ul><li>同步<ul><li>阻塞I&#x2F;O</li><li>I&#x2F;O复用</li><li>信号驱动I&#x2F;O</li></ul></li><li>异步</li></ul><h4 id="I-x2F-O复用"><a href="#I-x2F-O复用" class="headerlink" title="I&#x2F;O复用"></a>I&#x2F;O复用</h4><ul><li><p>select，监听文件描述符。O(n)的无差别轮询，最大连接数1024。</p></li><li><p>poll，轮询文件描述符。也是O(n)的无差别轮询，但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p></li><li><p>epoll。可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I&#x2F;O事件通知我们。复杂度降低到了O(1)。</p><ul><li><strong>LT</strong>模式，<strong>ET</strong>模式</li><li><code>epoll_create</code></li><li><code>epoll_ctl</code></li><li><code>epoll_wait</code></li></ul></li></ul><p>ref. </p><ul><li><a href="https://www.cnblogs.com/aspirant/p/9166944.html">select、poll、epoll之间的区别</a></li><li><a href="https://www.cnblogs.com/anker/p/3265058.html">select、poll、epoll之间的区别总结</a></li></ul><h3 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h3><ul><li>Reactor</li><li>Proactor</li></ul><h3 id="并发模式"><a href="#并发模式" class="headerlink" title="并发模式"></a>并发模式</h3><ul><li>半同步&#x2F;半异步 (变体)&#x3D;&gt; 半同步&#x2F;半反应堆</li><li>领导者&#x2F;追随者</li></ul><h3 id="池"><a href="#池" class="headerlink" title="池"></a>池</h3><ul><li>内存池</li><li>进程池</li><li>线程池</li><li>连接池</li></ul><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><ul><li><code>kill</code></li><li><code>SIG_IGN</code></li><li><code>SIG_DFL</code></li><li><code>SIGHUP</code>, <code>SIGPIPE</code>, <code>SIGGURG</code></li></ul><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="Linux定时方法"><a href="#Linux定时方法" class="headerlink" title="Linux定时方法"></a>Linux定时方法</h3><ol><li>socket方法<ul><li><code>SO_RCVTIMEO</code></li><li><code>SO_SNDTIMEO</code></li></ul></li><li><code>SIGALRM</code></li><li>I&#x2F;O复用系统调用的超时参数</li></ol><h3 id="高性能定时器"><a href="#高性能定时器" class="headerlink" title="高性能定时器"></a>高性能定时器</h3><ol><li>时间轮</li><li>时间堆</li></ol><h2 id="I-x2F-O框架库-Libevent"><a href="#I-x2F-O框架库-Libevent" class="headerlink" title="I&#x2F;O框架库 Libevent"></a>I&#x2F;O框架库 Libevent</h2><h3 id="Linux服务器必须处理的3件事"><a href="#Linux服务器必须处理的3件事" class="headerlink" title="Linux服务器必须处理的3件事"></a>Linux服务器必须处理的3件事</h3><ol><li>I&#x2F;O 时间</li><li>信号</li><li>定时器</li></ol><h3 id="基于Reactor的框架库"><a href="#基于Reactor的框架库" class="headerlink" title="基于Reactor的框架库"></a>基于Reactor的框架库</h3><ol><li>句柄</li><li>事件多路分发器</li><li>事件处理器和具体事件处理器</li><li>Reactor<ul><li>handle_event</li><li>register_handler</li><li>remove_handler</li></ul></li></ol><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><ul><li><code>fork</code></li><li><code>exec</code> 系列</li><li>僵尸进程<ul><li><code>wait</code></li><li><code>waitpid</code></li></ul></li></ul><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><ul><li>管道 (pipe)</li><li>信号量 (Semaphore): P, V.<ul><li><code>semget</code></li><li><code>semop</code></li><li><code>semctl</code></li><li><code>IPC_PRIVATE</code></li></ul></li><li>共享内存<ul><li><code>shmget</code></li><li><code>shmat</code></li><li><code>shmdt</code></li><li><code>shmctl</code></li></ul></li><li>消息队列<ul><li><code>msgget</code></li><li><code>msgsnd</code></li><li><code>msgrcv</code></li><li><code>msgctl</code></li></ul></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ol><li>LinuxThreads</li><li>NPTL</li></ol><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li>pthread_creatr</li><li>pthread_exit</li><li>pthread_join</li><li>pthread_cancel</li></ul><h3 id="线程间同步"><a href="#线程间同步" class="headerlink" title="线程间同步"></a>线程间同步</h3><ul><li>POSIX信号量: <code>sem_xxx</code></li><li>互斥量: <code>pthread_mutex_xxx</code></li><li>条件变量: <code>pthread_cond_xxx</code></li><li>线程同步机制类: <code>locker.h</code></li><li>进程和线程: <code>pthread_atfork</code></li><li>线程和信号: <code>pthread_sigmask</code></li></ul><h2 id="进程池和线程池"><a href="#进程池和线程池" class="headerlink" title="进程池和线程池"></a>进程池和线程池</h2><ul><li>随机算法、Round Robin、工作队列</li><li>半同步&#x2F;半异步进程池实现</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li>游双. Linux高性能服务器编程. 机械工业出版社</li><li>徐晓鑫. 后台开发：核心技术与应用实践. 机械工业出版社</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;网络编程&quot;&gt;&lt;a href=&quot;#网络编程&quot; class=&quot;headerlink&quot; title=&quot;网络编程&quot;&gt;&lt;/a&gt;网络编程&lt;/h1&gt;&lt;h2 id=&quot;大小端&quot;&gt;&lt;a href=&quot;#大小端&quot; class=&quot;headerlink&quot; title=&quot;大小端&quot;&gt;&lt;/a&gt;大小端&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;大端&lt;/strong&gt;：高位存在低地址，低位存在高地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小端&lt;/strong&gt;：高位存在高地址，低位存在低地址。&lt;/p&gt;
&lt;p&gt;大小端和CPU有关。&lt;/p&gt;
&lt;p&gt;现代PC大多采用小段，所以&lt;strong&gt;小端字节序&lt;/strong&gt;又被成为&lt;strong&gt;主机字节序&lt;/strong&gt;。而&lt;strong&gt;大端字节序&lt;/strong&gt;又被成为&lt;strong&gt;网络字节序&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="back-end" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/back-end/"/>
    
    
    <category term="后端" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2020/08/18/os/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2020/08/18/os/</id>
    <published>2020-08-18T05:00:00.000Z</published>
    <updated>2020-09-03T06:10:08.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><h2 id="ubuntu开机的时候系统做了什么"><a href="#ubuntu开机的时候系统做了什么" class="headerlink" title="ubuntu开机的时候系统做了什么"></a>ubuntu开机的时候系统做了什么</h2><ul><li>加载BIOS<br>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做”硬件自检”。硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。</li><li>读取MBR<br>计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。</li><li>Bootloader<br>在这种情况下，计算机读取”主引导记录”前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统。<br>Boot Loader 就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核做好一切准备。<br>Boot Loader有若干种，其中Grub、Lilo和spfdisk是常见的Loader。Linux环境中，目前最流行的启动管理器是Grub。</li><li>加载内核<br>内核的加载，内核加载后，接开始操作系统初始化，根据进程的优先级启动进程。</li></ul><p>ref. <a href="https://blog.csdn.net/u013830021/article/details/72840669">ubuntu启动过程</a></p><h2 id="内核态（管态）和用户态（目态）"><a href="#内核态（管态）和用户态（目态）" class="headerlink" title="内核态（管态）和用户态（目态）"></a>内核态（管态）和用户态（目态）</h2><p>用户态（User Mode）：处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的。</p><p>内核态（Kernel Mode）：处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。</p><p>三种会导致用户态到内核态切换的情况：</p><ol><li>系统调用：应用程序主动向操作系统发出的服务请求</li><li>异常：非法指令或者其他原因导致当前指令执行失败。(如：内存出错)后的处理请求</li><li>外围设备的中断：来自硬件设备的处理请求</li></ol><p><img src="https://i.loli.net/2020/08/17/HfIPMVh8gSzKe5O.png" alt="中断，异常，系统调用的比较"></p><p><a href="https://www.cnblogs.com/gizing/p/10925286.html">用户态和内核态的区别</a></p><h2 id="什么的系统调用"><a href="#什么的系统调用" class="headerlink" title="什么的系统调用"></a>什么的系统调用</h2><p><strong>用户态</strong>调用操作系统提供的<strong>内核态</strong>级别的子功能。</p><p>系统调用按功能大致可分为如下几类：</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li></ul><h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><p><img src="https://i.loli.net/2020/08/18/zvqBnlW8fGQrgHK.png" alt="计算机系统存储层次"></p><h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><ul><li>最先匹配(First-fit)</li><li>最佳匹配(Best-fit)</li><li>最差匹配(Worst-fit)</li></ul><h3 id="伙伴算法-Buddy-system"><a href="#伙伴算法-Buddy-system" class="headerlink" title="伙伴算法(Buddy system)"></a>伙伴算法(Buddy system)</h3><p>Buddy（伙伴的定义）：<br>这里给出伙伴的概念，满足以下三个条件的称为伙伴：</p><ol><li>两个块大小相同；</li><li>两个块地址连续；</li><li>两个块必须是同一个大块中分离出来的；</li></ol><ul><li>伙伴算法分配内存:<br>若申请的内存大小为n则将n向上取整为2的幂设次数为s,则需要分配s大小的内存块,定位大相应数组：<ol><li>如果该数组有剩余内存块,则分配出去；</li><li>若没有剩余内存块就沿数组向上查找,然后再将该内存块分割出来s并将剩余的内存块放入相应大小的数组中。</li></ol></li></ul><p>例如分配5大小的内存块：定位到大小为8的链表中。若该链表中之中没有空余元素,则定位到16的链表中,16中有剩余元素,则取出该元素,并分割出大小为8的内存块供用户使用,然后将剩余的8连接到大小为8的数组中。</p><ul><li>伙伴算法的内存合并:<br>当用户用完内存后会归还,然后根据该内存块实际大小(向上取整为2的幂)归入链表中,在归入之前,<ol><li>我们还要检测他的伙伴内存块是否空闲,</li><li>如果空闲就合并在一起,合并后转到1,继续执行.</li><li>若果不是空闲的就直接归入链表中.</li></ol></li></ul><p>一般来说,伙伴算法实现中会用位图记录内存块是否被使用,用于伙伴内存的合并。</p><p>伙伴算法的特点:</p><ul><li>伙伴算法会浪费大量的内存，(如果需要大小为9的内存块必须分配大小为16的内存块)</li><li>优点也是明显的，分配和合并算法都很简单易行。</li></ul><p><img src="https://i.loli.net/2020/08/18/xpFWL6JzBkbtm8n.png" alt="伙伴系统的分配"></p><p><img src="https://i.loli.net/2020/08/18/8OasIUVAMXqhNHe.png" alt="伙伴系统的回收合并"></p><p><em>ps. 对于小块内存的分配和回收,伙伴算法效果不好，一般采用slab算法,或者叫做slab机制</em></p><h2 id="什么是内存碎片，怎么解决"><a href="#什么是内存碎片，怎么解决" class="headerlink" title="什么是内存碎片，怎么解决"></a>什么是内存碎片，怎么解决</h2><p>空闲的内存不但是能被利用</p><ul><li>外部碎片：分配单元之间的未被使用内存</li><li>内部碎片：<ul><li>分配单元内部的未被使用内存 </li><li>取决于分配单元大小是否要取整</li></ul></li></ul><p>解决：使用<strong>非连续内存分配</strong>：段、页、段页式</p><h2 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h2><h3 id="段式存储管理系统"><a href="#段式存储管理系统" class="headerlink" title="段式存储管理系统"></a>段式存储管理系统</h3><p>进程的段地址空间由多个段组成</p><ul><li>主代码段</li><li>子模块代码段</li><li>公用库代码段</li><li>堆栈段(stack)</li><li>堆数据(heap)</li><li>初始化数据段</li><li>符号表等</li></ul><p><img src="https://i.loli.net/2020/08/18/pmko41dCPxjAh7X.png" alt="段访问的硬件实现"></p><h3 id="页式存储管理系统"><a href="#页式存储管理系统" class="headerlink" title="页式存储管理系统"></a>页式存储管理系统</h3><p>分页就是说，将磁盘或者硬盘分为大小固定的数据块，叫做页，然后内存也分为同样大小的块，叫做页框。当进程执行的时候，会将磁盘的页载入内存的某些页框中，并且正在执行的进程如果发生缺页中断也会发生这个过程。页和页框都是由两个部分组成的，一个是页号或者页框号，一个是偏移量。分页一般是有硬件来完成的，每个页都对应一个页框，它们的对应关系存放在一个叫做页表的数据结构中，页号作为这个页表的索引，页框号作为页表的值。操作系统负责维护这个页表。</p><h4 id="帧（物理页面）"><a href="#帧（物理页面）" class="headerlink" title="帧（物理页面）"></a>帧（物理页面）</h4><p>把物理地址空间划分为大小相同的基本分配单位，大小为2的n次方，如512, 4096, 8192。</p><p>内存物理地址的表示：二元组 (f, o) </p><ul><li>f：帧号 (F 位, 共有2^F个帧) </li><li>o：帧内偏移 (S 位, 每帧有2^S字节) </li><li>物理地址 &#x3D;  f * 2^S + o</li></ul><p><img src="https://i.loli.net/2020/08/18/PJlxGQvrIZ82RAC.png" alt="帧到物理地址的转换"></p><h4 id="页（逻辑页面）"><a href="#页（逻辑页面）" class="headerlink" title="页（逻辑页面）"></a>页（逻辑页面）</h4><p>把逻辑地址空间也划分为相同大小的基本分配单位，帧和页的大小必须是相同的。</p><ul><li>页内偏移 &#x3D; 帧内偏移</li><li>通常：页号大小 ≠ 帧号大小</li></ul><p>进程逻辑地址的表示：二元组 (p, o)</p><ul><li>p：页号 (P 位, 2P 个页)</li><li>o：页内偏移 (S 位, 每页有2S 字节) </li><li>虚拟地址 &#x3D; p * 2S + o</li></ul><p><img src="https://i.loli.net/2020/08/18/3PGJVqbRfWTBwXO.png" alt="页到帧的映射"></p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p><img src="https://i.loli.net/2020/08/18/mbcz3MByi8nV5UQ.png" alt="页表"></p><p>页表项的组成：</p><ul><li>帧号 f</li><li>页表项标志<ul><li>存在位</li><li>引用位</li><li>修改位</li></ul></li></ul><h4 id="快表（TLB）"><a href="#快表（TLB）" class="headerlink" title="快表（TLB）"></a>快表（TLB）</h4><p>缓存近期访问的页表项。TLB 使用关联存储(associative memory)实现，具备快速访问性能。</p><ul><li>如果TLB命中，物理页号可以很快被获取</li><li>如果TLB未命中，对应的表项被更新到TLB中</li></ul><p><img src="https://i.loli.net/2020/08/18/gfuIHvNdwM6Pb3R.png" alt="快表"></p><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p><img src="https://i.loli.net/2020/08/18/cFJD3ZoraAMPEfd.png" alt="多级页表"></p><p><img src="https://i.loli.net/2020/08/18/79GCmsaUNcoPbW3.png" alt="二级页表示例"></p><h3 id="分页和分段有什区别？"><a href="#分页和分段有什区别？" class="headerlink" title="分页和分段有什区别？"></a>分页和分段有什区别？</h3><ul><li>分页对程序员是透明的，但是分段需要程序员显式划分每个段。</li><li>分页的地址空间是一维地址空间，分段是二维的。</li><li>页的大小不可变，段的大小可以动态改变。</li><li>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul><p><img src="https://i.loli.net/2020/08/18/lqM8dCZ3ti9vR7B.png" alt="分页和分段有什区别"></p><h3 id="段页式存储管理系统"><a href="#段页式存储管理系统" class="headerlink" title="段页式存储管理系统"></a>段页式存储管理系统</h3><p>在段式存储管理基础上，给每个段加一级页表</p><p><img src="https://i.loli.net/2020/08/18/OxEH6koDQ4Y3MzU.png" alt="段页式"></p><p>段页式存储管理中的内存共享：<br><img src="https://i.loli.net/2020/08/18/6ECwKXGhANcmr9Q.png" alt="段页式存储管理中的内存共享"></p><h2 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h2><p>虚拟存储就是说，让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。虚拟内存使用部分加载的技术，让一个进程或者资源的某些页面加载进内存，从而能够加载更多的进程，甚至能加载比内存大的进程，这样看起来好像内存变大了，这部分内存其实包含了磁盘或者硬盘，并且就叫做虚拟内存。</p><p><img src="https://i.loli.net/2020/08/17/NrkonUwiHXluMte.png" alt="地址生成过程"></p><p><img src="https://i.loli.net/2020/08/17/tcJQk3Gf7hAaIPx.png" alt="地址检查"></p><h3 id="虚拟页式存储管理"><a href="#虚拟页式存储管理" class="headerlink" title="虚拟页式存储管理"></a>虚拟页式存储管理</h3><p>在页式存储管理的基础上，增加请求调页和页面置换。</p><ul><li>当用户程序要装载到内存运行时，只装入部分页面，就启动程序运行</li><li>进程在运行中发现有需要的代码或数据不在内存时，则向系统发出缺页异常请求</li><li>操作系统在处理缺页异常时，将外存中相应的页面调入内存，使得进程能继续运行</li></ul><p><img src="https://i.loli.net/2020/08/18/uReoCxG91ZXEDn7.png" alt="虚拟页式存储中地址转换"></p><h3 id="虚拟段式存储管理"><a href="#虚拟段式存储管理" class="headerlink" title="虚拟段式存储管理"></a>虚拟段式存储管理</h3><p>在段式存储管理的基础上，以分段为单位进行换入换出。</p><h3 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h3><p><img src="https://i.loli.net/2020/08/18/7cR4ansgeVQNuCM.png" alt="缺页异常"></p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>当出现缺页异常，需调入新页面而内存已满时，置换算法选择被置换的物理页面</p><h4 id="局部置换"><a href="#局部置换" class="headerlink" title="局部置换"></a>局部置换</h4><p>置换页面的选择范围仅限于当前进程占用的物理页面内</p><ul><li>最优置换算法<br>选择的被换出的页面是<strong>未来最长时间内不再被访问的页面</strong>，通常可以保证获得最低的缺页率。这是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</li><li>先进先出<br>选择换出的页面是最先进入的页面。该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。</li><li>最近最久未使用(Least Recently Used, LRU)<br>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。<br>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</li><li>时钟算法(Clock)<br>页面装入内存时，访问位初始化为0。访问页面（读&#x2F;写)时，置访问位置为1。缺页时，从指针当前位置顺序检查环形链表：<ul><li>访问位为0，则置换该页</li><li>访问位为1，则访问位置0，并指针移动到下一个页面，直到找到可置换的页面</li></ul></li><li>最不常用算法(Least Frequently Used, LFU)<br>缺页时，置换访问次数最少的页面。每个页面设置一个访问计数，访问页面时，访问计数加1，缺页时，置换计数最小的页面。</li></ul><h4 id="全局置换"><a href="#全局置换" class="headerlink" title="全局置换"></a>全局置换</h4><p>置换页面的选择范围是所有可换出的物理页面。</p><ul><li>工作集置换算法：换出不在工作集中的页面。当前时刻前τ个内存访问的页引用是工作集，τ被称为窗口大小。</li><li>缺页率算法：通过调节常驻集大小，使每个进程的缺页率保持在一个合理的范围内。</li></ul><h4 id="Belady现象"><a href="#Belady现象" class="headerlink" title="Belady现象"></a>Belady现象</h4><p>采用FIFO等算法时，可能出现分配的物理页面数增加，缺页次数反而升高的异常现象</p><ul><li>FIFO算法的置换特征与进程访问内存的动态特征矛盾</li><li>被它置换出去的页面并不一定是进程近期不会访问的</li></ul><p><strong>LRU算法没有Belady现象</strong></p><h4 id="抖动-thrashing"><a href="#抖动-thrashing" class="headerlink" title="抖动(thrashing)"></a>抖动(thrashing)</h4><p>进程物理页面太少，不能包含工作集，造成大量缺页，频繁置换，进程运行速度变慢。</p><p>原因：随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升。</p><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>Linux 下创建新进程的系统调用是<code>fork</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t fork(void);</span><br><span class="line"></span><br><span class="line">//处理僵尸进程</span><br><span class="line">pid_t waitpid(pid_t pid, int* stat_loc, int options);</span><br></pre></td></tr></table></figure><h3 id="进程有哪几种状态-他们的转换方式"><a href="#进程有哪几种状态-他们的转换方式" class="headerlink" title="进程有哪几种状态?他们的转换方式"></a>进程有哪几种状态?他们的转换方式</h3><ul><li>创建状态(new)：进程正在被创建，尚未到就绪状态。</li><li>就绪状态(ready)：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li><li>运行状态(running)：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li><li>阻塞状态(waiting)：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li><li>结束状态(terminated)：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li></ul><p><img src="https://i.loli.net/2020/07/26/qWaBZCesYmz5GQT.jpg" alt="系统状态转换图"></p><h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><ol><li>管道&#x2F;匿名管道(Pipes)：速度慢，容量有限，只用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li><li>命名管道(Names Pipes&#x2F;FIFO)：任何进程间都能通讯，但速度慢，严格遵循先进先出(first in first out)。</li><li>消息队列(Message Queuing)：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。</li><li>信号量(Semaphores)：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。不能传递复杂消息，只能用来同步。</li><li>共享内存(Shared memory)：能够很容易控制容量，速度快，但需要依靠某种同步操作，如互斥锁和信号量等。比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。</li><li>套接字(Sockets)：此方法主要用于在客户端和服务器之间通过网络进行通信，也可以用于同一主机上的socket通信。</li><li>信号(Signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li></ol><p><a href="https://www.cnblogs.com/zgq0/p/8780893.html">进程间的五种通信方式介绍</a></p><h3 id="进程控制块（process-control-block，PCB）"><a href="#进程控制块（process-control-block，PCB）" class="headerlink" title="进程控制块（process control block，PCB）"></a>进程控制块（process control block，PCB）</h3><p>PCB 是进程存在的唯一标识，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。</p><h4 id="进程描述信息："><a href="#进程描述信息：" class="headerlink" title="进程描述信息："></a>进程描述信息：</h4><ul><li>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</li><li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</li></ul><h4 id="进程控制和管理信息："><a href="#进程控制和管理信息：" class="headerlink" title="进程控制和管理信息："></a>进程控制和管理信息：</h4><ul><li>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</li><li>进程优先级：进程抢占 CPU 时的优先级；</li></ul><h4 id="资源分配清单："><a href="#资源分配清单：" class="headerlink" title="资源分配清单："></a>资源分配清单：</h4><ul><li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I&#x2F;O 设备信息。</li></ul><h4 id="CPU-相关信息："><a href="#CPU-相关信息：" class="headerlink" title="CPU 相关信息："></a>CPU 相关信息：</h4><ul><li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。</li></ul><h4 id="每个-PCB-是如何组织的呢？"><a href="#每个-PCB-是如何组织的呢？" class="headerlink" title="每个 PCB 是如何组织的呢？"></a>每个 PCB 是如何组织的呢？</h4><p>通常是通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。比如：</p><ul><li>将所有处于就绪状态的进程链在一起，称为就绪队列；</li><li>把所有因等待某事件而处于等待状态的进程链在一起就组成各种阻塞队列；</li><li>另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。</li></ul><h3 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h3><ul><li><strong>先到先服务</strong>(FCFS)调度算法：从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><strong>短作业优先</strong>(SJF)的调度算法：从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><strong>时间片轮转</strong>调度算法：时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li><li><strong>多级反馈队列</strong>调度算法：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。</li><li><strong>优先级</strong>调度：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li></ul><h3 id="孤儿进程，僵尸进程，守护进程"><a href="#孤儿进程，僵尸进程，守护进程" class="headerlink" title="孤儿进程，僵尸进程，守护进程"></a>孤儿进程，僵尸进程，守护进程</h3><p>孤儿进程：父进程退出后子进程还在运行。这些子进程就叫做孤儿进程。孤儿进程被init进程收养。</p><p>僵尸进程：子进程结束后，内核不会立即释放该进程的进程表表项，以满足父进程后续对该子进程的信息查询。子进程退出之后，父进程读取其退出状态（调用waitpid获取子进程状态信息）之前，就是僵尸进程。</p><p>守护进程：在后台运行不受终端控制的进程。如输入，输出，网络服务等。</p><h4 id="创建守护进程"><a href="#创建守护进程" class="headerlink" title="创建守护进程"></a>创建守护进程</h4><ol><li>创建子进程，父进程退出</li><li>在子进程中创建新的会话（脱离控制终端）：使用系统函数setsid()来创建。</li><li>改变当前目录为根目录</li><li>重设文件权限掩码，关闭文件描述符</li></ol><h4 id="处理孤儿进程，僵尸进程"><a href="#处理孤儿进程，僵尸进程" class="headerlink" title="处理孤儿进程，僵尸进程"></a>处理孤儿进程，僵尸进程</h4><p>孤儿进程没有什么危害，所以并不需要怎么处理。</p><p>如果父进程一直不调用wait&#x2F;waitpid处理以及退出的子进程，子进程就会一直在系统里占用资源。</p><p>僵尸进程的处理方式为：当一个进程结束时，它会给父进程发送一个<code>SIGCHLD</code>信号，我们在父进程中捕获<code>SIGCHLD</code>信号，并在信号处理函数中调用<code>waitpid</code>函数来处理退出的子进程。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>Linux 系统中，线程的基础API都定义在 <code>pthread.h</code> 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthead.h&gt;</span><br><span class="line">int pthread_create(pthread_t* thread, const pthread_attr_r* attr,</span><br><span class="line">                   void* (*start_routine)(void*), void* arg);</span><br><span class="line"></span><br><span class="line">void pthread_exit(void* retval);</span><br></pre></td></tr></table></figure><h3 id="线程间的同步的方式"><a href="#线程间的同步的方式" class="headerlink" title="线程间的同步的方式"></a>线程间的同步的方式</h3><ol><li>锁机制<ul><li>互斥锁：互斥锁提供了以排他方式防止数据结构被并发修改的方法</li><li>读写锁：读写锁允许多个线程同时读共享数据，而对写操作是互斥的</li><li>条件变量：条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用</li><li>自旋锁</li></ul></li><li>信号量(Semphares)：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li><li>信号机制(Signal)：类似进程间的信号处理</li></ol><p>互斥锁与信号量的区别：</p><ul><li>互斥锁用户线程互斥，信号量用于线程同步。</li><li>互斥锁仅用于线程，信号量还可以用于进程。</li></ul><h3 id="线程安全怎么实现"><a href="#线程安全怎么实现" class="headerlink" title="线程安全怎么实现"></a>线程安全怎么实现</h3><p><strong>线程安全定义</strong>：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。</p><p>线程安全的实现方式：</p><ol><li>互斥同步：指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用。常见的互斥实现方式有：临界区(critical selection)，互斥量(mutex)和信号量(semaphore)。互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种实现方式也叫阻塞同步。从处理问题的方式上来说，互斥同步属于一种悲观的并发策略。</li><li>非阻塞同步：随着硬件指令集的发展，我们有了另外的一个选择：基于冲突检测的乐观并发策略。也就是先进行操作，如果没有其它线程使用共享数据，那就操作成功；如果有，那就再采取补偿措施。这种方式不需要把线程挂起，因此称为：非阻塞同步(Non-Blocking Synchronization)。</li><li>无同步方案：<ul><li>可重入代码</li><li>线程本地存储：如果一段代码中所需要的数据都完全包含在同一个线程中，如果能保证这一点，那就不会因为跟其它线程争抢修改资源而导致数据不一致，也就没有线程风险，是线程安全的。</li></ul></li></ol><p>ref.</p><ul><li><a href="https://www.cnblogs.com/nevermorewang/p/9614092.html">线程安全的实现方式</a></li></ul><h2 id="进程和线程的差别"><a href="#进程和线程的差别" class="headerlink" title="进程和线程的差别"></a>进程和线程的差别</h2><p>线程是指进程内的一个执行单元，也是进程内的可调度实体。线程与进程的区别：</p><ul><li>调度：线程作为CPU调度的基本单位，进程作为拥有资源的基本单位；</li><li>拥有资源：进程是拥有资源的一个独立单元，进程拥有一个完整的资源平台；线程只独享必不可少的资源，如寄存器和栈，不拥有系统资源但可以访问隶属于进程的资源</li><li>并发性：不仅进程之间可以并发执行，同一个进程的多个线程也可以并发执行；</li><li>线程的状态：线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li><li>系统开销：在创建或撤销进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤销线程时的开销；</li></ul><h2 id="进程上下文切换，线程上下文切换，中断上下文切换"><a href="#进程上下文切换，线程上下文切换，中断上下文切换" class="headerlink" title="进程上下文切换，线程上下文切换，中断上下文切换"></a>进程上下文切换，线程上下文切换，中断上下文切换</h2><h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>进程上下文包括计算机系统中与执行该进程有关的各种<strong>寄存器</strong>（例如<strong>通用寄存器</strong>，<strong>程序计数器PC</strong>，<strong>程序状态字寄存器PS</strong>等）的值，程序段在经过编译过后形成的<strong>机器指令代码集</strong>，数据集及<strong>各种堆栈值</strong>PCB结构。</p><p>当切换进程时，需要保存当前进程的所有状态，即当前进程的<strong>进程上下文</strong>，以便再次执行该进程时，能够恢复切换时的状态，继续执行。</p><h3 id="发生进程上下文切换有哪些场景？"><a href="#发生进程上下文切换有哪些场景？" class="headerlink" title="发生进程上下文切换有哪些场景？"></a>发生进程上下文切换有哪些场景？</h3><p>在进程状态发生改变时，且进程基本都属于进程上下文切换的场景：</p><ul><li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；</li><li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；</li><li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；</li><li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；</li></ul><h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>线程上下文：当进程只有一个线程时，可以认为进程就等于线程；当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的；另外，线程也有自己的私有数据，比如<strong>栈和寄存器</strong>等，这些在上下文切换时也是需要保存的。</p><p>线程的上下文切换：</p><ul><li>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；</li><li>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；</li></ul><h3 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h3><p>中断上下文：中断时需要保存的参数和进程环境。</p><h3 id="线程有自己的堆，栈吗"><a href="#线程有自己的堆，栈吗" class="headerlink" title="线程有自己的堆，栈吗"></a>线程有自己的堆，栈吗</h3><p>与线程“绑定”的是栈，用于存储自动变量。每一个线程建立的时候，都会新建一个默认栈与之配合。堆则是通常与进程相关，用于存储全局性的变量，进程建立的时候，会建立默认堆。于是，每一个线程都有自己的栈，然后访问共同的堆。当然，你可以通过OsApi建立其他堆栈。</p><ul><li>堆：是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。</li><li>栈：是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是　thread safe的。操作系统在切换线程的时候会自动的切换栈，就是切换　ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放。</li></ul><h2 id="并发，同步，异步，互斥，阻塞，非阻塞"><a href="#并发，同步，异步，互斥，阻塞，非阻塞" class="headerlink" title="并发，同步，异步，互斥，阻塞，非阻塞"></a>并发，同步，异步，互斥，阻塞，非阻塞</h2><p>并发：多个程序同时运行即并发。并发可分为<strong>同步</strong>和<strong>互斥</strong>。</p><h3 id="同步，互斥"><a href="#同步，互斥" class="headerlink" title="同步，互斥"></a>同步，互斥</h3><p>互斥：同一时间只能有一个访问者访问资源，无序的</p><p>同步：必须按照某种顺序运行。在互斥的基础上通过其他机制实现资源的有序访问。</p><p>同步时一种更复杂的互斥，互斥是一种特殊的同步。</p><h3 id="同步，异步"><a href="#同步，异步" class="headerlink" title="同步，异步"></a>同步，异步</h3><p>同步：顺序执行，需要等待、协调运作。</p><p>异步：彼此独立，在等待某事件的过程中继续做自己的事，不需要等待。</p><ul><li>线程是实现异步的一个方式</li><li>异步 不等于 多线程。异步是最终目的，多线程只是实现异步的一种手段</li></ul><h3 id="阻塞，非阻塞"><a href="#阻塞，非阻塞" class="headerlink" title="阻塞，非阻塞"></a>阻塞，非阻塞</h3><p>经常访问数据时，根据IO操作的就绪状态不同采取的不同处理方式。比如读取文件内容，阻塞方式下主程序会等到函数读取完再继续，非阻塞方式下主程序不等待文件读取完就继续往下执行。</p><p>一般可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞</p><h3 id="同步阻塞，同步非阻塞，异步阻塞，异步非阻塞"><a href="#同步阻塞，同步非阻塞，异步阻塞，异步非阻塞" class="headerlink" title="同步阻塞，同步非阻塞，异步阻塞，异步非阻塞"></a>同步阻塞，同步非阻塞，异步阻塞，异步非阻塞</h3><p>以发送方发出请求要接收方读取文件内容为例。</p><ul><li>同步阻塞：发送方发出请求后一直等待（同步）。接受方开始读取，如果不能马上读到就一直等待，直到读取后响应发送方，等待期间不能做其他操作（阻塞）。</li><li>同步非阻塞：发送方发出请求后一直等待（同步）。接受方开始读取，如果不能马上读到就立即返回继续做其他事情（非阻塞），并未响应发送方。直到IO完成才响应。</li><li>异步阻塞：发送方发出请求后不等待响应，继续其他工作（异步）。接受方开始读取，如果不能马上读到就一直等待，直到读取后响应发送方，等待期间不能做其他操作（阻塞）。</li><li>异步非阻塞：发送方发出请求后不等待响应，继续其他工作（异步）。接受方开始读取，如果不能马上读到就立即返回继续做其他事情（非阻塞），并未响应发送方。直到IO完成才响应。（效率最高）</li></ul><p><em>ps. 发送方等待就是同步，不等待就是异步；接收方等待就是阻塞，不等待就是非阻塞。</em></p><p>总结：</p><ul><li>同步异步是两个线程之间的关系，两个线程之间要么是同步的，要么是异步的。</li><li>阻塞与非阻塞是对同一个线程来说。某个时刻，线程处于阻塞或非阻塞</li></ul><h2 id="多进程、多线程的优缺点"><a href="#多进程、多线程的优缺点" class="headerlink" title="多进程、多线程的优缺点"></a>多进程、多线程的优缺点</h2><ul><li>多进程更鲁棒，一个进程死了不影响其他进程，子进程死了不影响主进程。多线程比较脆弱，一个线程崩溃可能会影响整个程序。</li><li>进程性能大于线程，但是创建进程花销大于线程。</li><li>进程通讯需要跨越进程边界，不适合大量数据传送，更适合小数据活着密集数据。线程可以共享内存和变量，适合大量数据的传送。</li><li>多进程逻辑空控制比多线程复杂</li><li>多线程虽然逻辑控制比较简单，但是需要复杂的同步和加锁控制等机制</li><li>可以通过增加CPU数量来增加进程的数量，但是不能通过增加CPU来增加线程的数量，线程的数量由进程的空间资源和线程本身栈大小确定。</li></ul><h2 id="为什么要使用线程？与进程相比有哪些好处"><a href="#为什么要使用线程？与进程相比有哪些好处" class="headerlink" title="为什么要使用线程？与进程相比有哪些好处"></a>为什么要使用线程？与进程相比有哪些好处</h2><ol><li>资源<br>和进程相比，它是一种非常”节俭”的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。</li><li>切换效率<br>运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。（但是进程性能大于线程）</li><li>通信<br>线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。</li><li>使多CPU系统更加有效。<br>操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。(CPU设计保证）</li><li>改善程序结构。<br>一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。（代码易维护）</li></ol><h2 id="什么时候用进程，什么时候用线程"><a href="#什么时候用进程，什么时候用线程" class="headerlink" title="什么时候用进程，什么时候用线程"></a>什么时候用进程，什么时候用线程</h2><p>进程用来“做大事”，线程用来“各自做小事”：</p><ul><li>创建和销毁较频繁，用线程</li><li>需要大量数据传送，用线程</li><li>并行操作，用线程</li><li><strong>总结</strong>：安全稳定用进程，快速频繁用线程</li></ul><h2 id="Linux查看-x2F-杀死-x2F-重启进程"><a href="#Linux查看-x2F-杀死-x2F-重启进程" class="headerlink" title="Linux查看&#x2F;杀死&#x2F;重启进程"></a>Linux查看&#x2F;杀死&#x2F;重启进程</h2><ul><li>查看：<code>ps -aux</code> 或 <code>ps -ef</code></li><li>杀死：<code>kill -PID</code> 或强制杀死<code>kill -KILL PID</code></li><li>重启：<code>kill -HUP PID</code></li></ul><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="https://www.nowcoder.com/discuss/450511?type=all&order=time&pos=&page=1&channel=666&source_id=search_all">进程、线程基础知识全家桶</a></p><h2 id="有哪些锁？"><a href="#有哪些锁？" class="headerlink" title="有哪些锁？"></a>有哪些锁？</h2><ul><li>互斥锁：同一时间只能有一个线程获得互斥锁，其他线程阻塞进入休眠态</li><li>读写锁：同一时间可以有多个线程获得读锁，适用于读操作频繁的场景</li><li>自旋锁：同一时间只能有一个线程获得自旋锁，其他线程会一直等待锁并且不会进入休眠态，如果不加限制，某个线程申请已经锁定的自旋锁，就会导致其他线程卡死，所以自旋锁适用于锁拥有者保持锁时间很短的场景</li></ul><p><a href="https://www.nowcoder.com/questionTerminal/554355eea5aa44d697a3a4bc99795207">C++有哪些锁</a></p><h2 id="什么是可重入和不可重入函数？"><a href="#什么是可重入和不可重入函数？" class="headerlink" title="什么是可重入和不可重入函数？"></a>什么是可重入和不可重入函数？</h2><ul><li>可重入函数可以由多个任务并发使用，而不必担心数据错误。<br>可重入函数可以在任意时刻被中断，稍后继续运行，不会丢失数据，可重入函数要么使用本地变量，要么使用全局变量时保护自己的数据。</li><li>不可重入函数不能由多个任务共享，除非能确保函数的互斥。</li></ul><p>特点：</p><ul><li>可重入函数  <ul><li>不可连续的调用持有静态数据；</li><li>不返回指向静态数据的指针，所有数据都是由函数的调用者提供；</li><li>使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据；</li><li>如果必须访问全局变量，记住利用互斥信号量来保护全局变量；</li><li>绝不调用任何不可重入函数。</li></ul></li><li>不可重入函数  <ul><li>函数中使用了静态变量，无论是全局静态变量还是局部静态变量；</li><li>函数返回静态变量；</li><li>函数中调用了不可重入函数；</li><li>函数体内使用了静态的数据结构；</li><li>函数体内调用了malloc()或者free()函数；</li><li>函数体内调用了其他标准I&#x2F;O函数；</li></ul></li></ul><p>总之，如果一个函数在重入条件下使用了未受保护的共享资源，那么就是不可重入的。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>死锁</strong>是指两个或多个进程在执行的过程中，因为竞争资源而造成互相等待的现象，若无外力作用，它们都无法推进下去。</p><h3 id="死锁的处理方法"><a href="#死锁的处理方法" class="headerlink" title="死锁的处理方法"></a>死锁的处理方法</h3><ul><li>预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。</li><li>避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。</li><li>检测死锁：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。</li><li>解除死锁：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来。</li></ul><h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><ol><li>因为系统资源不足。</li><li>进程运行推进的顺序不合适。</li><li>资源分配不当等。</li></ol><h3 id="死锁的4个必要条件"><a href="#死锁的4个必要条件" class="headerlink" title="死锁的4个必要条件"></a>死锁的4个必要条件</h3><ol><li>互斥：一个资源每次只能被一个进程使用。</li><li>请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺：进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><h3 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h3><p>我们可以通过破坏产生死锁的四个必要条件来预防死锁，但是<strong>资源互斥</strong>是固有特性无法改变的。</p><ol><li>破坏“请求与保持”条件<ul><li>静态分配，每个进程在开始执行时就申请他所需要的全部资源。</li><li>动态分配，每个进程在申请所需要的资源时他本身不占用系统资源。</li></ul></li><li>破坏“不可剥夺”条件<br>一个进程不可获得其所需要的全部资源便处于等待状态，等待期间他占用的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。</li><li>破坏“循环等待”条件<br>采用资源有序分配的基本思想。将系统中的资源顺序进行编号，将紧缺的、稀少的资源采用较大的编号，申请资源时必须按照编号的顺序执行，一个进程只有较小编号的进程才能申请较大编号的进程。</li></ol><h3 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h3><ul><li>有序资源分配法：源按某种规则系统中的所有资源统一编号，申请时必须以上升的次序。</li><li><a href="https://zh.wikipedia.org/wiki/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95">银行家算法</a></li></ul><h3 id="ref-1"><a href="#ref-1" class="headerlink" title="ref."></a>ref.</h3><ul><li><a href="https://blog.csdn.net/wljliujuan/article/details/79614019?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">死锁</a></li></ul><h2 id="进程占用率过高怎么排查"><a href="#进程占用率过高怎么排查" class="headerlink" title="进程占用率过高怎么排查"></a>进程占用率过高怎么排查</h2><ul><li>jstack：适用于java进程，可以取到所以线程的堆栈dump；</li><li>pstack：适用于所有linux进程，是对gdb的功能封装。<br>此命令可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID。</li></ul><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>文件描述符是打开文件的标识，操作系统在打开文件表中维护的打开文件状态和信息。</p><ul><li>文件指针</li><li>文件打开计数</li><li>文件的磁盘位置</li><li>访问权限</li></ul><h2 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h2><p>Linux文件系统里面有文件和目录，组成一个树状的结构，树的每一个叶子节点表示文件或者空目录。每个文件基本上都由两部分组成：</p><ul><li>inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；</li><li>block：记录文件的内容，文件太大时，会占用多个 block。</li></ul><p>除此之外还包括：</p><ul><li>superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li><li>block bitmap：记录 block 是否被使用的位图。</li></ul><p>当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。</p><p><a href="https://www.cnblogs.com/huxiao-tee/p/4657851.html">从内核文件系统看文件读写过程</a></p><h2 id="什么是-inode"><a href="#什么是-inode" class="headerlink" title="什么是 inode"></a>什么是 inode</h2><p>理解inode，要从文件储存说起。</p><p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</p><p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p><p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p><p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p><h2 id="Linux-文件系统通过-i-节点把文件的逻辑结构和物理结构转换的工作过程"><a href="#Linux-文件系统通过-i-节点把文件的逻辑结构和物理结构转换的工作过程" class="headerlink" title="Linux 文件系统通过 i 节点把文件的逻辑结构和物理结构转换的工作过程"></a>Linux 文件系统通过 i 节点把文件的逻辑结构和物理结构转换的工作过程</h2><p>Linux 通过 inode 节点表将文件的逻辑结构和物理结构进行转换。</p><p>inode 节点是一个 64 字节长的表，表中包含了文件的相关信息，其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息。在 inode 节点表中最重要的内容是磁盘地址表。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。<br>Linux 文件系统通过把 inode 节点和文件名进行连接，当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的 inode 节点号，通过该 inode 节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构。</p><h2 id="硬链接和软链接有什么区别"><a href="#硬链接和软链接有什么区别" class="headerlink" title="硬链接和软链接有什么区别"></a>硬链接和软链接有什么区别</h2><ul><li><p>硬链接：由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1。<br>不足：</p><ul><li>不可以在不同文件系统的文件间建立链接；</li><li>只有超级用户才可以为目录创建硬链接。</li></ul></li><li><p>软链接：软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。<br>不足：</p><ul><li>因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。</li></ul></li><li><p>实际场景下，基本是使用软链接。总结区别如下：</p><ul><li>硬链接不可以跨分区，软件链可以跨分区。</li><li>硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点。</li><li>删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。</li></ul></li></ul><p><img src="https://i.loli.net/2020/09/03/5HGam2yJM8VLACu.jpg" alt="软硬链接的区别"></p><h2 id="文件的分配"><a href="#文件的分配" class="headerlink" title="文件的分配"></a>文件的分配</h2><ul><li>连续分配</li><li>链式分配</li><li>索引分配</li></ul><h2 id="操作系统读写文件的过程"><a href="#操作系统读写文件的过程" class="headerlink" title="操作系统读写文件的过程"></a>操作系统读写文件的过程</h2><p><a href="https://github.com/justtreee/blog/issues/18">从Linux文件系统看文件读写过程</a><br><a href="https://www.cnblogs.com/huxiao-tee/p/4657851.html">从内核文件系统看文件读写过程</a></p><h1 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><h2 id="三种I-x2F-O操作"><a href="#三种I-x2F-O操作" class="headerlink" title="三种I&#x2F;O操作"></a>三种I&#x2F;O操作</h2><ul><li>阻塞I&#x2F;O：读写数据时，进程将进入等待状态</li><li>非阻塞I&#x2F;O：立即从read或write系统调用返回，返回值为成功传输字节数</li><li>异步I&#x2F;O：使用指针标记好用户缓冲区，立即返回；稍后内核再处理并通知用户</li></ul><h2 id="I-x2F-O请求生存周期"><a href="#I-x2F-O请求生存周期" class="headerlink" title="I&#x2F;O请求生存周期"></a>I&#x2F;O请求生存周期</h2><p><img src="https://i.loli.net/2020/08/18/ytkB6C9Nzed8MlH.png" alt="I/O请求生存周期"></p><h2 id="CPU与设备控制器的数据传输"><a href="#CPU与设备控制器的数据传输" class="headerlink" title="CPU与设备控制器的数据传输"></a>CPU与设备控制器的数据传输</h2><h3 id="程序控制I-x2F-O-PIO-Programmed-I-x2F-O"><a href="#程序控制I-x2F-O-PIO-Programmed-I-x2F-O" class="headerlink" title="程序控制I&#x2F;O(PIO, Programmed I&#x2F;O)"></a>程序控制I&#x2F;O(PIO, Programmed I&#x2F;O)</h3><p>通过CPU的in&#x2F;out或者load&#x2F;store传输所有数据。</p><p><img src="https://i.loli.net/2020/08/18/pKiDgIs43dXkS25.png" alt="直接IO读取磁盘步骤"></p><h3 id="直接内存访问-DMA"><a href="#直接内存访问-DMA" class="headerlink" title="直接内存访问(DMA)"></a>直接内存访问(DMA)</h3><p>设备控制器可直接访问系统总线，控制器直接与内存互相传输数据。</p><h2 id="I-x2F-O设备如何通知操作系统"><a href="#I-x2F-O设备如何通知操作系统" class="headerlink" title="I&#x2F;O设备如何通知操作系统"></a>I&#x2F;O设备如何通知操作系统</h2><ul><li>CPU主动轮询：I&#x2F;O 设备在特定的状态寄存器中放置状态和错误信息，操作系统定期检测状态寄存器。</li><li>设备中断：CPU在I&#x2F;O之前设置任务参数；CPU发出I&#x2F;O请求后，继续执行其他任务；I&#x2F;O设备处理I&#x2F;O请求；I&#x2F;O设备处理完成时，触发CPU中断请求；CPU接收中断，分发到相应中断处理例程。<br><img src="https://i.loli.net/2020/08/18/39Buzsox264Z7GN.png" alt="设备中断处理流程"></li></ul><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><ul><li>先来先服务(FIFO)<ul><li>按照磁盘请求的顺序进行调度。</li><li>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</li></ul></li><li>最短寻道时间优先(SSTF)<ul><li>优先调度与当前磁头所在磁道距离最近的磁道。</li><li>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。一般来说，两端的磁道请求更容易出现饥饿现象。</li></ul></li><li>电梯算法(SCAN扫描算法)<ul><li>电梯算法就是说读写磁头总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li><li>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了最短寻道时间优先的饥饿问题。</li></ul></li><li>循环扫描算法(C-SCAN)<ul><li>限制了仅在一个方向上扫描</li><li>当最后一个磁道也被访问过了后，磁臂返回到磁盘的另外一端再次进行</li></ul></li><li>C-LOOK算法<ul><li>磁臂先到达该方向上最后一个请求处，然后立即反转，而不是先到最后点路径上的所有请求</li></ul></li><li>N步扫描(N-step-SCAN)算法<ul><li>磁头粘着(Arm Stickiness)现象：SSTF、SCAN及CSCAN等算法中，可能出现磁头停留在某处不动的情况</li><li>N步扫描算法将磁盘请求队列分成长度为N的子队列，按FIFO算法依次处理所有子队列，扫描算法处理每个队列</li></ul></li><li>双队列扫描(FSCAN)算法<ul><li>FSCAN算法是N步扫描算法的简化，FSCAN只将磁盘请求队列分成两个子队列</li><li>把磁盘I&#x2F;O请求分成两个队列，交替使用扫描算法处理一个队列，新生成的磁盘I&#x2F;O请求放入另一队列中，所有的新请求都将被推迟到下一次扫描时处理。</li></ul></li></ul><h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><ul><li>单缓存<br><img src="https://i.loli.net/2020/08/18/qrHuvCbRY7TkeXP.png" alt="单缓存"></li><li>双缓存<br><img src="https://i.loli.net/2020/08/18/p8TtFbZy4HimRBQ.png" alt="双缓存"></li></ul><h1 id="ref-2"><a href="#ref-2" class="headerlink" title="ref"></a>ref</h1><ul><li><a href="http://os.cs.tsinghua.edu.cn/oscourse/OS2019spring">清华大学操作系统课程</a></li></ul>]]></content>
    
    
    <summary type="html">操作系统笔记</summary>
    
    
    
    <category term="CS" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/CS/"/>
    
    
    <category term="OS" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 - 2020年八月</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2020/08/01/LeetcodeDaily_Aug/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2020/08/01/LeetcodeDaily_Aug/</id>
    <published>2020-08-01T12:00:00.000Z</published>
    <updated>2020-08-27T02:16:53.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="8月3日-415-字符串相加（简单）"><a href="#8月3日-415-字符串相加（简单）" class="headerlink" title="8月3日 415. 字符串相加（简单）"></a>8月3日 <a href="https://leetcode-cn.com/problemset/all/">415. 字符串相加（简单）</a></h1><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p><p>注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num1 和num2 的长度都小于 5100.</span><br><span class="line">num1 和num2 都只包含数字 0-9.</span><br><span class="line">num1 和num2 都不包含任何前导零。</span><br><span class="line">你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</span><br></pre></td></tr></table></figure><p>题解：<br>两个数字位数不同时，在指针当前下标处于负数的时候返回 0，等价于对位数较短的数字进行了补零操作，这样就可以除去两个数字位数不同情况的处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">string addStrings(string num1, string num2)&#123;</span><br><span class="line">    int i = num1.length() - 1, j = num2.length() - 1, add = 0;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    while (i &gt;= 0 || j &gt;= 0 || carry != 0) &#123;</span><br><span class="line">        int x = i &gt;= 0 ? num1[i] - &#x27;0&#x27; : 0;</span><br><span class="line">        int y = j &gt;= 0 ? num2[j] - &#x27;0&#x27; : 0;</span><br><span class="line">        int result = x + y + carry;</span><br><span class="line">        res.push_back(&#x27;0&#x27; + result % 10);</span><br><span class="line">        carry = result / 10;</span><br><span class="line">        i -= 1;</span><br><span class="line">        j -= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算完以后的答案需要翻转过来</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(max{n1,n2})<br>空间复杂度：O(1)</p><h1 id="8月4日-207-课程表（中等）"><a href="#8月4日-207-课程表（中等）" class="headerlink" title="8月4日 207. 课程表（中等）"></a>8月4日 <a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表（中等）</a></h1><p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p><p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。</span><br><span class="line">你可以假定输入的先决条件中没有重复的边。</span><br><span class="line">1 &lt;= numCourses &lt;= 10^5</span><br></pre></td></tr></table></figure><p>题解：  </p><ol><li>有向图的dfs遍历。<br><code>visited[i]</code>表示第i和节点的状态，0表示没有被访问过，1表示正在被访问，2表示访问结束的节点。<code>circle</code>表示有向图有环。使用dfs遍历有向图：</li></ol><ul><li>当正在访问的节点（visited[i]&#x3D;1）又被访问时，说明有向图存在环，返回false。</li><li>全部节点访问完毕，返回true<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void dfs(int u, vector&lt;vector&lt;int&gt; &gt; &amp;graph, vector&lt;int&gt; &amp;visited)&#123;</span><br><span class="line">    visited[u] = 1;//正在访问该节点</span><br><span class="line">    for(int v:graph[u])&#123;</span><br><span class="line">        if(visited[v]==0)&#123;</span><br><span class="line">            dfs(v, graph, visited);</span><br><span class="line">            if(circle)</span><br><span class="line">                return;</span><br><span class="line">        &#125;else if(visited[v]==1)&#123;</span><br><span class="line">            circle = true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123;</span><br><span class="line">    if(prerequisites.empty())</span><br><span class="line">        return true;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graph(numCourses);</span><br><span class="line">    for (auto course : prerequisites)</span><br><span class="line">    &#123;//build graph</span><br><span class="line">        graph[course[1]].push_back(course[0]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; visited(numCourses);</span><br><span class="line">    for (int i = 0; i &lt; numCourses &amp;&amp; !circle; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visited[i])</span><br><span class="line">            dfs(i, graph, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    return !circle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>时间复杂度：O(m+n)。m是有向图的边，n是有向图的节点。<br>空间复杂度：O(m+n)</li></ul><ol start="2"><li>bfs入度为0的点<br>拓扑排序中，起点都是入度为0的点。把所有入度为0的节点放入队列，依次访问队列中的节点。访问的时候把所有从该节点出去的边都删掉，即该节点出发连接的边的入度都减1。再把入度减到0的点加入队列。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123;</span><br><span class="line">    if(prerequisites.empty())</span><br><span class="line">        return true;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graph(numCourses);</span><br><span class="line">    vector&lt;int&gt; inDegree(numCourses, 0);</span><br><span class="line">    for (auto course : prerequisites)</span><br><span class="line">    &#123;//build graph</span><br><span class="line">        graph[course[1]].push_back(course[0]);</span><br><span class="line">        inDegree[course[0]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    for (int i = 0; i &lt; numCourses;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(inDegree[i]==0)</span><br><span class="line">            que.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int visited = 0;</span><br><span class="line">    while (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        visited++;</span><br><span class="line">        int u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int v:graph[u])&#123;</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            if(inDegree[v]==0)</span><br><span class="line">                que.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return visited == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>时间复杂度：O(m+n)。m是有向图的边，n是有向图的节点。<br>空间复杂度：O(m+n)</li></ol><h1 id="真题"><a href="#真题" class="headerlink" title="真题"></a>真题</h1><h2 id="模版匹配"><a href="#模版匹配" class="headerlink" title="模版匹配"></a>模版匹配</h2><p>前面给一个词做模版，看后面的多个词是否能和前面的模版匹配。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：pattern = &quot;noon&quot;, str = &quot;big star star big&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：pattern = &quot;noon&quot;, str = &quot;big star star not&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool testMatch(string pattern, string str) &#123;</span><br><span class="line">    map&lt;string,char&gt; wordMap;</span><br><span class="line">    char used[128] = &#123;0&#125;;</span><br><span class="line">    string word;</span><br><span class="line">    int pos = 0;</span><br><span class="line">    str.push_back(&#x27; &#x27;);</span><br><span class="line">    for (int i = 0; i &lt; str.size();i++)&#123;</span><br><span class="line">        if(str[i]==&#x27; &#x27;)&#123;</span><br><span class="line">            if(pos==pattern.size())</span><br><span class="line">                return false;</span><br><span class="line">            if(wordMap.find(word)==wordMap.end())&#123;</span><br><span class="line">                if(used[pattern[pos]])</span><br><span class="line">                    return false;</span><br><span class="line">                wordMap[word] = pattern[pos];</span><br><span class="line">                used[pattern[pos]] = 1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(wordMap[word]!=pattern[pos])</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">            word = &quot;&quot;;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            word += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(pos!=pattern.size())</span><br><span class="line">        return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找到最小的排列组合数"><a href="#找到最小的排列组合数" class="headerlink" title="找到最小的排列组合数"></a>找到最小的排列组合数</h2><p>找到比原数字位数排列组合后，比原数字大的，最小的数。没有就输出-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//80%  比如 2231就不对了</span><br><span class="line">int findGreaterNum(int N) &#123;</span><br><span class="line">    string s = to_string(N);</span><br><span class="line">    for (int i = s.size() - 1; i &gt; 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        if (s[i] &gt; s[i - 1])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(s[i], s[i - 1]);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = atoi(s.c_str());</span><br><span class="line">    if (res == N)</span><br><span class="line">        cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">    else </span><br><span class="line">        cout &lt;&lt; res;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1477-找两个和为目标值且不重叠的子数组"><a href="#1477-找两个和为目标值且不重叠的子数组" class="headerlink" title="1477. 找两个和为目标值且不重叠的子数组"></a><a href="https://leetcode-cn.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/">1477. 找两个和为目标值且不重叠的子数组</a></h2><p>给你一个整数数组 arr 和一个整数值 target。</p><p>请你在 arr 中找两个互不重叠的子数组 且它们的和都等于 target。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。</p><p>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。</p><p>题解：<br><code>dp[i]</code>表示i后面和等T的最小子数组长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int minSumOfLengths(vector&lt;int&gt;&amp; arr, int target)&#123;</span><br><span class="line">    int sum = 0, r = arr.size() - 1, res = 200000; </span><br><span class="line">    vector&lt;int&gt; dp(arr.size() + 1, 200000);//后面子数组的最小长度</span><br><span class="line">    for (int l = r; l &gt;= 0; --l) &#123; //l,r是滑动区间的左右坐标</span><br><span class="line">        sum += arr[l];</span><br><span class="line">        while (sum &gt; target)</span><br><span class="line">            sum -= arr[r--];</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            int curLen = r - l + 1; //子数组长度</span><br><span class="line">            res = min(res, curLen + dp[r + 1]); //子数组长度 + r后面子数组的最小长度</span><br><span class="line">            dp[l] = min(dp[l + 1], curLen); //更新l后面子数组的最小长度</span><br><span class="line">        &#125;else</span><br><span class="line">            dp[l] = dp[l + 1]; //更新子数组的最小长度</span><br><span class="line">    &#125;</span><br><span class="line">    return res == 200000 ? -1 : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16进制和10进制的互转"><a href="#16进制和10进制的互转" class="headerlink" title="16进制和10进制的互转"></a>16进制和10进制的互转</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">string convert_10_to_16(int num)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; ivec;</span><br><span class="line">    int Num = num;</span><br><span class="line">    while (num != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ivec.push_back(num % 16);</span><br><span class="line">        num = num / 16;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    vector&lt;int&gt;::size_type sz = ivec.size();</span><br><span class="line">    vector&lt;string&gt; ivec2;</span><br><span class="line">    int m = 0;</span><br><span class="line">    string s;</span><br><span class="line">    for (vector&lt;int&gt;::size_type index = 0; index != sz; ++index)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ivec[sz - 1 - index] &gt; 9)</span><br><span class="line">        &#123;   </span><br><span class="line">            m = ivec[sz - 1 - index] + 55;</span><br><span class="line">            s = m+&#x27;0&#x27;-&#x27;0&#x27;;</span><br><span class="line">            ivec2.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            s = ivec[sz - 1 - index] + &#x27;0&#x27;;</span><br><span class="line">            ivec2.push_back(s);</span><br><span class="line"> </span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    for (auto item : ivec2)</span><br><span class="line">        res += item;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double convert_16_to_10(string str)</span><br><span class="line">&#123;</span><br><span class="line">    double sum = 0, times;</span><br><span class="line">    double m;</span><br><span class="line">    string::size_type sz = str.size();</span><br><span class="line">    for (string::size_type index = 0; index != sz; ++index)</span><br><span class="line">    &#123;</span><br><span class="line">        str[index] = tolower(str[index]);</span><br><span class="line">        if (str[index] &gt;= &#x27;a&#x27; &amp;&amp; str[index] &lt;= &#x27;f&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            m = str[index] - &#x27;a&#x27; + 10;</span><br><span class="line">            times = pow(16, (sz - 1 - index));</span><br><span class="line">            sum += m * times;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        else if (isdigit(str[index]))</span><br><span class="line">        &#123;</span><br><span class="line">            m= str[index] - 48;</span><br><span class="line">            times = pow(16, (sz - 1 - index));</span><br><span class="line">            sum += m * times;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8月10日-696-计数二进制子串"><a href="#8月10日-696-计数二进制子串" class="headerlink" title="8月10日 696. 计数二进制子串"></a>8月10日 <a href="https://leetcode-cn.com/problems/count-binary-substrings/">696. 计数二进制子串</a></h1><p>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</p><p>重复出现的子串要计算它们出现的次数。</p><p>示例 1 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;00110011&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。</span><br><span class="line"></span><br><span class="line">请注意，一些重复出现的子串要计算它们出现的次数。</span><br><span class="line"></span><br><span class="line">另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。</span><br></pre></td></tr></table></figure><p>示例 2 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;10101&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.length 在1到50,000之间。</span><br><span class="line">s 只包含“0”或“1”字符。</span><br></pre></td></tr></table></figure><p>题解：  </p><ol><li><p>把每个相同的字符分组，比如“00111011” 就可以分为subs&#x3D;{2,3,1,2}，表示2个0，3个1，1个0，2个1。每一对相邻的能有min{subs[i],subs[i+1]}个字串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int countBinarySubstrings(string s) &#123;</span><br><span class="line">    vector&lt;int&gt; subs;</span><br><span class="line">    </span><br><span class="line">    int i = 0;</span><br><span class="line">    while(i&lt;s.size())&#123;</span><br><span class="line">        int mark = i;</span><br><span class="line">        char cur = s[i];</span><br><span class="line">        while(i&lt;s.size() &amp;&amp; s[i]==cur)</span><br><span class="line">            i++;</span><br><span class="line">        subs.push_back(i-mark);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int res = 0;</span><br><span class="line">    for(int i = 0;i&lt;subs.size()-1;i++)&#123;</span><br><span class="line">        res += min(subs[i],subs[i+1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p></li><li><p>优化。空间复杂度优化到O(1)。也只用到subs的上一个状态量，所以可以不用保存整个subs数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（代码略）</span><br></pre></td></tr></table></figure></li></ol><h1 id="8月11日-130-被围绕的区域（中等）"><a href="#8月11日-130-被围绕的区域（中等）" class="headerlink" title="8月11日 130. 被围绕的区域（中等）"></a>8月11日 <a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域（中等）</a></h1><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p><p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br><span class="line">运行你的函数后，矩阵变为：</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure><p>解释:<br>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。<br>题解：<br>dfs。也可以用bfs，但是需要自己用队列实现，还是递归方便一点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;char&gt; &gt;&amp; board,vector&lt;int&gt; &amp; s,vector&lt;vector&lt;bool&gt; &gt; &amp;marked)&#123;</span><br><span class="line">    int x=s[0],y=s[1];</span><br><span class="line">    if(board[x][y]==&#x27;X&#x27; || marked[x][y])</span><br><span class="line">        return;</span><br><span class="line">    marked[x][y] = true;</span><br><span class="line">    for(auto d:dirs)&#123;</span><br><span class="line">        int next_i = x+d[0], next_j = y+d[1];</span><br><span class="line">        vector&lt;int&gt; tmp = &#123;next_i,next_j&#125;;</span><br><span class="line">        if((next_i &gt; 0 &amp;&amp; next_i &lt; board.size())</span><br><span class="line">        &amp;&amp; (next_j &gt; 0 &amp;&amp; next_j &lt; board[0].size()))</span><br><span class="line">            dfs(board,tmp,marked);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</span><br><span class="line">    if(board.empty())</span><br><span class="line">        return;</span><br><span class="line">    int m = board.size(),n = board[0].size();</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; marked(m,vector&lt;bool&gt;(n, false));</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; side;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        if(board[0][i]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;0,i&#125;);</span><br><span class="line">            //marked[0][i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(board[m-1][i]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;m-1,i&#125;);</span><br><span class="line">            //marked[m-1][i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;m-1;i++)&#123;</span><br><span class="line">        if(board[i][0]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;i,0&#125;);</span><br><span class="line">            //marked[i][0] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(board[i][n-1]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;i,n-1&#125;);</span><br><span class="line">            //marked[i][n-1] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(auto s:side)&#123;</span><br><span class="line">        dfs(board,s,marked);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            if(!marked[i][j] &amp;&amp; board[i][j]==&#x27;O&#x27;)</span><br><span class="line">                board[i][j] = &#x27;X&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(m<em>n)<br>空间复杂度：O(m</em>n)</p><h1 id="8月12日-133-克隆图（中等）"><a href="#8月12日-133-克隆图（中等）" class="headerlink" title="8月12日 133. 克隆图（中等）"></a>8月12日 <a href="https://leetcode-cn.com/problems/clone-graph/">133. 克隆图（中等）</a></h1><p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p><p>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题解：  </p><ol><li><p>bfs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Node* cloneGraph(Node* node) &#123;</span><br><span class="line">    if (node == nullptr) &#123;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line"></span><br><span class="line">    // 将题目给定的节点添加到队列</span><br><span class="line">    queue&lt;Node*&gt; que;</span><br><span class="line">    que.push(node);</span><br><span class="line">    // 克隆第一个节点并存储到哈希表中</span><br><span class="line">    visited[node] = new Node(node-&gt;val);</span><br><span class="line"></span><br><span class="line">    // 广度优先搜索</span><br><span class="line">    while (!que.empty()) &#123;</span><br><span class="line">        // 取出队列的头节点</span><br><span class="line">        auto curNode = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        // 遍历该节点的邻居</span><br><span class="line">        for (auto&amp; neighbor: curNode-&gt;neighbors) &#123;</span><br><span class="line">            if (visited.find(neighbor) == visited.end()) &#123;</span><br><span class="line">                // 如果没有被访问过，就克隆并存储在哈希表中</span><br><span class="line">                visited[neighbor] = new Node(neighbor-&gt;val);</span><br><span class="line">                // 将邻居节点加入队列中</span><br><span class="line">                que.push(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新当前节点的邻居列表</span><br><span class="line">            visited[curNode]-&gt;neighbors.emplace_back(visited[neighbor]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return visited[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p></li><li><p>dfs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line"></span><br><span class="line">Node* cloneGraph(Node* node) &#123;</span><br><span class="line">    if (node == nullptr) &#123;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(visited.find(node) != visited.end())</span><br><span class="line">        return visited[node];</span><br><span class="line"></span><br><span class="line">    Node *cloneNode = new Node(node-&gt;val);</span><br><span class="line">    visited[node] = cloneNode;</span><br><span class="line"></span><br><span class="line">    for(auto &amp;neighbor:node-&gt;neighbors)&#123;</span><br><span class="line">        cloneNode-&gt;neighbors.push_back(cloneGraph(neighbor));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return visited[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p></li></ol><h1 id="8月13日-43-字符串相乘（中等）"><a href="#8月13日-43-字符串相乘（中等）" class="headerlink" title="8月13日 43. 字符串相乘（中等）"></a>8月13日 <a href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘（中等）</a></h1><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num1 和 num2 的长度小于110。</span><br><span class="line">num1 和 num2 只包含数字 0-9。</span><br><span class="line">num1 和 num2 均不以零开头，除非是数字 0 本身。</span><br><span class="line">不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</span><br></pre></td></tr></table></figure><p>题解：<br>大数相乘问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">string multiply(string num1, string num2)&#123;</span><br><span class="line">    int m = num1.size(), n = num2.size();</span><br><span class="line">    vector&lt;long long&gt; num(m + n - 1, 0);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m;i++)&#123;//前面是高位，后面是低位</span><br><span class="line">        int a = num1[i] - &#x27;0&#x27;;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int b = num2[j] - &#x27;0&#x27;;</span><br><span class="line">            num[i + j] += a * b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int carry = 0;</span><br><span class="line">    for (int i = num.size() - 1; i &gt;= 0;i--)&#123;//前面是高位，后面是低位</span><br><span class="line">        int cur = num[i] + carry;</span><br><span class="line">        num[i] = cur % 10;</span><br><span class="line">        carry = cur / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    while(carry!=0)&#123;</span><br><span class="line">        int cur = carry % 10;</span><br><span class="line">        carry /= 10;</span><br><span class="line">        num.insert(num.begin(), cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    for (auto a : num)</span><br><span class="line">    &#123;</span><br><span class="line">        res += to_string(a);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(m*n)<br>空间复杂度：O(m+n)</p><h1 id="8月19日-647-回文子串（中等）"><a href="#8月19日-647-回文子串（中等）" class="headerlink" title="8月19日 647. 回文子串（中等）"></a>8月19日 <a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串（中等）</a></h1><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p>题解：<br>枚举每一个字串，再判断是不是回文。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool isPalindrome(string str)&#123;</span><br><span class="line">    int L = 0, R = str.size() - 1;</span><br><span class="line">    while(L&lt;R)&#123;</span><br><span class="line">        if(str[L]!=str[R])</span><br><span class="line">            break;</span><br><span class="line">        L++;</span><br><span class="line">        R--;</span><br><span class="line">    &#125;</span><br><span class="line">    return L&gt;=R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int countSubstrings(string s) &#123;</span><br><span class="line">    int n = s.size();</span><br><span class="line">    if(n==0) return 0;</span><br><span class="line">    int res = n;</span><br><span class="line">    for(int m=2;m&lt;=n;m++)&#123;</span><br><span class="line">        for(int i=0;i&lt;=n-m;i++)&#123;</span><br><span class="line">            string cur_str = s.substr(i,m);</span><br><span class="line">            if(isPalindrome(cur_str))</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h1 id="8月20日-529-扫雷游戏（中等）"><a href="#8月20日-529-扫雷游戏（中等）" class="headerlink" title="8月20日 529. 扫雷游戏（中等）"></a>8月20日 <a href="https://leetcode-cn.com/problems/minesweeper/">529. 扫雷游戏（中等）</a></h1><p>让我们一起来玩扫雷游戏！</p><p>给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，’E’ 代表一个未挖出的空方块，’B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’X’ 则表示一个已挖出的地雷。</p><p>现在给出在所有未挖出的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p><p>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’。<br>如果一个没有相邻地雷的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的未挖出方块都应该被递归地揭露。<br>如果一个至少与一个地雷相邻的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。<br>如果在此次点击中，若无更多方块可被揭露，则返回面板。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[&#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;],</span><br><span class="line"> [&#x27;E&#x27;, &#x27;E&#x27;, &#x27;M&#x27;, &#x27;E&#x27;, &#x27;E&#x27;],</span><br><span class="line"> [&#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;],</span><br><span class="line"> [&#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;]]</span><br><span class="line"></span><br><span class="line">Click : [3,0]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">[[&#x27;B&#x27;, &#x27;1&#x27;, &#x27;E&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;M&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[&#x27;B&#x27;, &#x27;1&#x27;, &#x27;E&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;M&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]]</span><br><span class="line"></span><br><span class="line">Click : [1,2]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">[[&#x27;B&#x27;, &#x27;1&#x27;, &#x27;E&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;X&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]]</span><br></pre></td></tr></table></figure><p>题解：  </p><ol><li><p>dfs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;,&#123;-1,1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;char&gt; &gt; &amp;res, int row, int col, vector&lt;vector&lt;bool&gt; &gt; &amp;hasVisited)&#123;</span><br><span class="line">    if(hasVisited[row][col])</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    //处理当前格子</span><br><span class="line">    int boom = 0;</span><br><span class="line">    for(auto d:dirs)&#123;</span><br><span class="line">        int next_i=row+d[0];</span><br><span class="line">        int next_j=col+d[1];</span><br><span class="line">        if(next_i &lt; 0 || next_i &gt;= res.size() || next_j &lt; 0 || next_j &gt;= res[0].size())</span><br><span class="line">            continue;</span><br><span class="line">        if(res[next_i][next_j]==&#x27;M&#x27;)</span><br><span class="line">            boom++;</span><br><span class="line">    &#125;</span><br><span class="line">    hasVisited[row][col] = true;</span><br><span class="line">    if(boom==0)</span><br><span class="line">        res[row][col] = &#x27;B&#x27;;</span><br><span class="line">    else&#123;</span><br><span class="line">        res[row][col] = to_string(boom)[0];</span><br><span class="line">        // res[cur_i][cur_j] = boom + &#x27;0&#x27;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //处理下一个格子</span><br><span class="line">    for(auto d:dirs)&#123;</span><br><span class="line">        int next_i=row+d[0];</span><br><span class="line">        int next_j=col+d[1];</span><br><span class="line">        if(next_i &lt; 0 || next_i &gt;= res.size() || next_j &lt; 0 || next_j &gt;= res[0].size())</span><br><span class="line">            continue;</span><br><span class="line">        dfs(res,next_i,next_j,hasVisited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;char&gt;&gt; updateBoard(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;int&gt;&amp; click) &#123;</span><br><span class="line">    if(board.empty())</span><br><span class="line">        return board;</span><br><span class="line">    int row = click[0],col=click[1];</span><br><span class="line">    vector&lt;vector&lt;char&gt; &gt; res = board;</span><br><span class="line">    if(board[row][col]==&#x27;M&#x27;)&#123;</span><br><span class="line">        res[row][col] = &#x27;X&#x27;;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; hasVisited(board.size(), vector&lt;bool&gt;(board[0].size(),false));</span><br><span class="line">    dfs(res,row,col,hasVisited);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p></li><li><p>bfs。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;,&#123;-1,1&#125;&#125;;</span><br><span class="line">void bfs(vector&lt;vector&lt;char&gt; &gt; &amp;res, int row, int col, vector&lt;vector&lt;bool&gt; &gt; &amp;hasVisited)&#123;</span><br><span class="line">    queue&lt;vector&lt;int&gt; &gt; que;</span><br><span class="line">    que.push(&#123;row,col&#125;);</span><br><span class="line">    hasVisited[row][col] = true;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int sizeq = que.size();</span><br><span class="line">        while(sizeq--&gt;0)&#123;</span><br><span class="line">            int cur_i = que.front()[0];</span><br><span class="line">            int cur_j = que.front()[1];</span><br><span class="line">            que.pop();</span><br><span class="line">            </span><br><span class="line">            int boom = 0;</span><br><span class="line">            for(auto d:dirs)&#123;</span><br><span class="line">                int next_i=cur_i+d[0];</span><br><span class="line">                int next_j=cur_j+d[1];</span><br><span class="line">                if(next_i &lt; 0 || next_i &gt;= res.size() || next_j &lt; 0 || next_j &gt;= res[0].size())</span><br><span class="line">                    continue;</span><br><span class="line">                if(res[next_i][next_j]==&#x27;M&#x27;)</span><br><span class="line">                    boom++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(boom==0)&#123;</span><br><span class="line">                //处理当前格子</span><br><span class="line">                res[cur_i][cur_j] = &#x27;B&#x27;;</span><br><span class="line">                //下一个格子</span><br><span class="line">                for(auto d:dirs)&#123;</span><br><span class="line">                    int next_i=cur_i+d[0];</span><br><span class="line">                    int next_j=cur_j+d[1];</span><br><span class="line">                    if(next_i &lt; 0 || next_i &gt;= res.size() || next_j &lt; 0 || next_j &gt;= res[0].size()</span><br><span class="line">                    || hasVisited[next_i][next_j])</span><br><span class="line">                        continue;</span><br><span class="line">                    if(res[next_i][next_j]==&#x27;E&#x27;)&#123;</span><br><span class="line">                        que.push(&#123;next_i,next_j&#125;);</span><br><span class="line">                        hasVisited[next_i][next_j] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                res[cur_i][cur_j] = to_string(boom)[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;char&gt; &gt; updateBoard(vector&lt;vector&lt;char&gt; &gt;&amp; board, vector&lt;int&gt;&amp; click) &#123;</span><br><span class="line">    if(board.empty())</span><br><span class="line">        return board;</span><br><span class="line">    int row = click[0],col=click[1];</span><br><span class="line">    vector&lt;vector&lt;char&gt; &gt; res = board;</span><br><span class="line">    if(board[row][col]==&#x27;M&#x27;)&#123;</span><br><span class="line">        res[row][col] = &#x27;X&#x27;;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; hasVisited(board.size(), vector&lt;bool&gt;(board[0].size(),false));</span><br><span class="line">    bfs(res,row,col,hasVisited);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p></li></ol><h1 id="元素平衡"><a href="#元素平衡" class="headerlink" title="元素平衡"></a>元素平衡</h1><p>A，B，C，D四个数，每次可以任意减少2个单位然后增加1各单位，问当四个数相等时，最大和为多少。</p><p>题解：<br>笔试真题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;long&gt; nums(4);</span><br><span class="line">    cin &gt;&gt; nums[0] &gt;&gt; nums[1] &gt;&gt; nums[2] &gt;&gt; nums[3];</span><br><span class="line">    </span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">    long long sumn = nums[0] + nums[1] + nums[2] + nums[3];</span><br><span class="line">    long maxn = sumn / 4;</span><br><span class="line">    while(maxn&gt;0)&#123;</span><br><span class="line">        int sumL = 0, sumR = 0, idx = 0;</span><br><span class="line">        while(idx&lt;4 &amp;&amp; nums[idx]&lt;maxn)&#123;</span><br><span class="line">            sumL += (maxn - nums[idx]);</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        while(idx&lt;4 &amp;&amp; nums[idx]==maxn)</span><br><span class="line">            idx++;</span><br><span class="line">        while(idx&lt;4 &amp;&amp; nums[idx]&gt;maxn)&#123;</span><br><span class="line">            sumR += (nums[idx] - maxn);</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sumL*2 &lt;= sumR)&#123;</span><br><span class="line">            cout &lt;&lt; maxn * 4 &lt;&lt; endl;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        maxn--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">8月份每日一题</summary>
    
    
    
    <category term="Algorithm" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/Algorithm/"/>
    
    
    <category term="Leetcode daily" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/Leetcode-daily/"/>
    
  </entry>
  
  <entry>
    <title>STL常用方法</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2020/07/12/STL/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2020/07/12/STL/</id>
    <published>2020-07-12T06:30:00.000Z</published>
    <updated>2020-08-21T08:45:34.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用STL库的使用方法"><a href="#常用STL库的使用方法" class="headerlink" title="常用STL库的使用方法"></a>常用STL库的使用方法</h1><p>记录了常用的STL使用方法</p><span id="more"></span><h2 id="vector：数组"><a href="#vector：数组" class="headerlink" title="vector：数组"></a>vector：数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;  </span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; a(10);//初始化10个默认为0的数  </span><br><span class="line">vector&lt;int&gt; a(10,1);//初始化10个默认为1的数  </span><br><span class="line">vector&lt;int&gt; a;  </span><br><span class="line"></span><br><span class="line">//初始化二维数组  </span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; 2dVec(m ,vector&lt;int&gt;(n)); //m*n的二维vector，注意两个 &quot;&gt; &quot;之间要有空格</span><br><span class="line">2dVec.push_back(&#123;1, 2, 3&#125;);//可以这样加vector  </span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; 2dVec(m ,vector&lt;int&gt;(n,0)); //m*n的二维vector，所有元素初始化为0  </span><br><span class="line">a.push_back()  </span><br><span class="line">a[0]  </span><br><span class="line">a.front() //首元素  </span><br><span class="line">a.back() //尾元素  </span><br><span class="line">a.size()  </span><br><span class="line">a.pop_back()//删除不输出  </span><br><span class="line">it = a.begin()+1  </span><br><span class="line">a.erase(it)  </span><br><span class="line">it2 = a.begin()+3  </span><br><span class="line">a.erase(it,it2)//删除[it1,it2)  </span><br><span class="line">a.clear()  </span><br><span class="line">a.empty()  </span><br><span class="line">a.insert(it,-1)  </span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator itDele;</span><br><span class="line">it = find(a.begin(), a.end(), 3);//查找3</span><br><span class="line">if(it!=a.end())//如果找到了</span><br><span class="line"></span><br><span class="line">//pair  make_pair</span><br><span class="line">vector&lt;pair&lt;int ,int&gt; &gt; vp;</span><br><span class="line">vp.push_back(&#123;1, 0&#125;);</span><br><span class="line">vp.push_back(make_pair(0, 1));</span><br><span class="line">vector&lt;pair&lt;int, int&gt; &gt; vp2 = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">vp2.push_back(make_pair&lt;int, int&gt;(5, 6));</span><br></pre></td></tr></table></figure><h2 id="list：数组"><a href="#list：数组" class="headerlink" title="list：数组"></a>list：数组</h2><p>Lists将元素按顺序储存在链表中. 与向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;list&gt;</span><br><span class="line">pop_back() 删除最后一个元素 </span><br><span class="line">pop_front() 删除第一个元素 </span><br><span class="line">push_back() 在list的末尾添加一个元素 </span><br><span class="line">push_front() 在list的头部添加一个元素 </span><br><span class="line">back() 返回最后一个元素 </span><br><span class="line">front() 返回第一个元素 </span><br><span class="line">begin() 返回指向第一个元素的迭代器 </span><br><span class="line">end() 返回末尾的迭代器 </span><br><span class="line">size() 返回list中的元素个数 </span><br><span class="line">clear() 删除所有元素 </span><br><span class="line">empty() 如果list是空的则返回true</span><br><span class="line">a.sort() 给list排序</span><br><span class="line">erase() 删除一个元素 </span><br><span class="line">assign() 给list赋值 </span><br><span class="line">get_allocator() 返回list的配置器 </span><br><span class="line">insert() 插入一个元素到list中 </span><br><span class="line">max_size() 返回list能容纳的最大元素数量 </span><br><span class="line">merge() 合并两个list </span><br><span class="line">rbegin() 返回指向第一个元素的逆向迭代器 </span><br><span class="line">remove() 从list删除元素 </span><br><span class="line">remove_if() 按指定条件删除元素 </span><br><span class="line">rend() 指向list末尾的逆向迭代器 </span><br><span class="line">resize() 改变list的大小 </span><br><span class="line">reverse() 把list的元素倒转 </span><br><span class="line">splice() 合并两个list </span><br><span class="line">swap() 交换两个list </span><br><span class="line">unique() 删除list中重复的元素</span><br></pre></td></tr></table></figure><h2 id="stack：栈"><a href="#stack：栈" class="headerlink" title="stack：栈"></a>stack：栈</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stack&gt;</span><br><span class="line"></span><br><span class="line">stack&lt;int&gt; a;</span><br><span class="line">a.push()</span><br><span class="line">a.top()</span><br><span class="line">a.pop()</span><br><span class="line">a.empty()</span><br><span class="line">a.size()</span><br></pre></td></tr></table></figure><h2 id="queue：队列"><a href="#queue：队列" class="headerlink" title="queue：队列"></a>queue：队列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt; a;</span><br><span class="line">a.push()</span><br><span class="line">a.front()</span><br><span class="line">a.back()</span><br><span class="line">a.pop()</span><br><span class="line">a.empty()</span><br><span class="line">a.size()</span><br></pre></td></tr></table></figure><h2 id="priority-queue：堆"><a href="#priority-queue：堆" class="headerlink" title="priority_queue：堆"></a>priority_queue：堆</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">//priority_queue&lt;type,container,function&gt;</span><br><span class="line">//小根堆，a&gt;b</span><br><span class="line">priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; </span><br><span class="line">//大根堆，a&lt;b</span><br><span class="line">priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; q;</span><br><span class="line">//默认是大根堆</span><br><span class="line">priority_queue &lt;int&gt; q ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//自定义堆的比较方式</span><br><span class="line">//方法1，用类</span><br><span class="line">class cmp</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    bool operator()(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b)&#123;</span><br><span class="line">        return a.second &gt; b.second; //a&gt;b = greater&lt;int&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//方法2，用struct</span><br><span class="line">struct cmp</span><br><span class="line">&#123;</span><br><span class="line">    bool operator()(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b)&#123;</span><br><span class="line">        return a.second &gt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;int, int&gt;,vector&lt;pair&lt;int,int&gt; &gt;, cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">//注意！没有front和back</span><br><span class="line">q.push()</span><br><span class="line">q.pop()</span><br><span class="line">q.top()</span><br><span class="line">q.empty()</span><br><span class="line">q.size()</span><br></pre></td></tr></table></figure><h2 id="map-x2F-unordered-map"><a href="#map-x2F-unordered-map" class="headerlink" title="map&#x2F;unordered_map"></a>map&#x2F;unordered_map</h2><p>哈希表的实现：STL中，<code>map/set</code> 对应的数据结构是红黑树。红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 O(logN)。而 <code>unordered_map/unordered_set</code> 对应 哈希表，哈希表的特点就是查找效率高，时间复杂度为常数级别 O(1)， 而额外空间复杂度则要高出许多而且无序。所以对于需要高效率查询的情况，使用 <code>unordered_map</code> 容器。而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用 <code>map</code> 容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">std:map&lt;int,int&gt; mapA;</span><br><span class="line">//插入</span><br><span class="line">mapA.insert(std::pair&lt;int,int&gt;(0,1));</span><br><span class="line">mapA.insert(map&lt;int,int&gt;::value_type (0,1));</span><br><span class="line">mapA[0] = 1;</span><br><span class="line">mapA.at(0)</span><br><span class="line">mapA.size()</span><br><span class="line">map&lt;int, int&gt;::iterator iter;//迭代器</span><br><span class="line">mapA.erase(key/iter)</span><br><span class="line">mapA.clear()</span><br><span class="line">mapA.empty()</span><br><span class="line">mapA.count() //由于map不包含重复的key，因此m.count(key)取值为0，或者1，表示是否包含。</span><br><span class="line">mapA.find(key)//返回迭代器，判断是否存在。</span><br><span class="line">mapA.find(key) != mapA.end() //为真说明存在</span><br><span class="line"></span><br><span class="line">#include &lt;unordered_map&gt; //和map差不多</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/06/15/2eMDTN3HXOPt9oK.png" alt="map的用法"></p><h3 id="map的注意事项："><a href="#map的注意事项：" class="headerlink" title="map的注意事项："></a>map的注意事项：</h3><ul><li>在map中，由key查找value时，首先要判断map中是否包含key。</li><li>如果不检查，直接返回map[key]，可能会出现意想不到的行为。如果map包含key，没有问题，如果map不包含key，使用下标有一个危险的副作用，会在map中插入一个key的元素，value取默认值，返回value。也就是说，map[key]不可能返回null。</li></ul><p>比如：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string, int&gt; mapA;</span><br><span class="line">cout &lt;&lt; mapA.size() &lt;&lt; endl; //这时为0</span><br><span class="line">int a = mapA[&quot;aa&quot;] //本来是空map，但是调用mapA[&quot;aa&quot;]之后，会自动插入mapA[&quot;aa&quot;]=0，返回0</span><br><span class="line">cout &lt;&lt; mapA.size() &lt;&lt; endl; //这使为1</span><br></pre></td></tr></table></figure><h2 id="set-x2F-multiset-x2F-unordered-set"><a href="#set-x2F-multiset-x2F-unordered-set" class="headerlink" title="set&#x2F;multiset&#x2F;unordered_set"></a>set&#x2F;multiset&#x2F;unordered_set</h2><p>set和multiset的区别：</p><ul><li>set不可以有重复的元素</li><li>multiset可以有重复的元素</li></ul><p>和map&#x2F;unordered_map一样，也是set&#x2F;multiset使用红黑树实现，unordered_set使用哈希表实现。unordered_set和unordered_map内部实现的公共接口大致相同。</p><ol><li>set是按照一定的次序存储元素的容器，set遍历后有序，默认按照小于排序</li><li>set中只放value，但是底层存放的是&lt;value, value&gt;的键值对。每个value必须是惟一的</li><li>set允许插入和删除，不允许修改</li><li>set按照内部比较对象（类型比较）所指示的特定严格弱排序准则进行排序</li><li>set在底层用二叉搜索树（红黑树）实现</li><li>set中查找、插入、删除元素的复杂度为O(logn)，unordered_set为O(1)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;int&gt; us;</span><br><span class="line">us.insert(2);//插入</span><br><span class="line">unordered_set&lt;int&gt; us1(us);//us1=us</span><br><span class="line">unordered_set&lt;int&gt; us2(us1.begin(),us1.end());</span><br><span class="line"></span><br><span class="line">us.erase(6); //删除键值为6的元素</span><br><span class="line">set&lt;int&gt;::iterator it;  </span><br><span class="line">it = us.find(6); //查找键值为6的元素</span><br><span class="line">int n = us.count(6);//也能判断一个数是否在集合中。n=0不在，n=在</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; s = &#123;3,8,12,15&#125;</span><br><span class="line">s.lower_bound(8); //表示查找 &gt;= 8 的元素中最小的一个(8)，并返回指向该元素的迭代器</span><br><span class="line">s.upper_bound(8); //表示查找 &gt;8 的元素中最小的一个(12)，并返回指向该元素的迭代器</span><br><span class="line"></span><br><span class="line">s.lower_bound(9); //12</span><br><span class="line">s.upper_bound(9); //12</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">begin()         //返回指向第一个元素的迭代器</span><br><span class="line">clear()         //清除所有元素</span><br><span class="line">count()         //返回某个值元素的个数</span><br><span class="line">empty()         //如果集合为空，返回true</span><br><span class="line">end()           //返回指向最后一个元素的迭代器</span><br><span class="line">equal_range()   //返回集合中与给定值相等的上下限的两个迭代器</span><br><span class="line">erase()         //删除集合中的元素</span><br><span class="line">find()          //返回一个指向被查找到元素的迭代器</span><br><span class="line">get_allocator() //返回集合的分配器</span><br><span class="line">insert()        //在集合中插入元素</span><br><span class="line">lower_bound()   //返回指向大于（或等于）某值的第一个元素的迭代器</span><br><span class="line">key_comp()      //返回一个用于元素间值比较的函数</span><br><span class="line">max_size()      //返回集合能容纳的元素的最大限值</span><br><span class="line">rbegin()        //返回指向集合中最后一个元素的反向迭代器</span><br><span class="line">rend()          //返回指向集合中第一个元素的反向迭代器</span><br><span class="line">size()          //集合中元素的数目</span><br><span class="line">swap()          //交换两个集合变量</span><br><span class="line">upper_bound()   //返回大于某个值元素的迭代器</span><br><span class="line">value_comp()    //返回一个用于比较元素间的值的函数</span><br></pre></td></tr></table></figure><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">string s;</span><br><span class="line">s.find()//在s当中查找第一个出现</span><br><span class="line">s.rfind()//在s当中查找最后一个出现</span><br><span class="line">int is = stoi(val) //把string val转换成int。stoi()会做范围检查，默认范围是在int的范围内的，如果超出范围的话则会runtime error</span><br><span class="line">int is = atoi(val.c_str()) //atoi()不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界</span><br><span class="line"></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">reverse(s.begin(),s.end()); //反转字符串</span><br><span class="line"></span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">//s1 s2需要c风格字符串char</span><br><span class="line">//如果是string，需要s1.c_str()</span><br><span class="line">strcmp(s1,s2) //相等返回0；s1-s2大于0，则返回1，小于0则返回-1</span><br><span class="line">strncmp(s1,s2,n) //比较前n个</span><br><span class="line">strcpy(s1,s2) //s2复制到s1,注意s2不要比s1长</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/06/15/gkiTrRs2O5WL9qU.png" alt="string和char的对比"></p><h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><p><img src="https://i.loli.net/2020/06/19/DtlTnEAUK7qQRFc.jpg" alt="ASCII表"></p><ol><li><strong>对应大小写字母之间相差32</strong></li><li>transform函数：直接处理<code>string</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = &quot;aBc&quot;;</span><br><span class="line"></span><br><span class="line">transform(s.begin(), s.end(), s.begin(), ::tolower);//::toupper转大写</span><br></pre></td></tr></table></figure></li><li>toupper, tolower：处理<code>char</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cctype&gt;</span><br><span class="line"></span><br><span class="line">char s = &#x27;a&#x27;;</span><br><span class="line">char sl = tolower(s);</span><br><span class="line">char su = toupper(sl);</span><br></pre></td></tr></table></figure></li></ol><h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p><code>sort</code>并非只是普通的<strong>快速排序</strong>，除了对普通的快速排序进行优化，它还结合了<strong>插入排序</strong>和<strong>堆排序</strong>。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">//nums必须是线性容器</span><br><span class="line">//降序排序</span><br><span class="line">sort(nums.begin(),nums.end(),greater&lt;int&gt;());</span><br><span class="line">//升序（默认是升序）</span><br><span class="line">sort(nums.begin(),nums.end(),less&lt;int&gt;());</span><br><span class="line">sort(nums.begin(),nums.end());</span><br><span class="line"></span><br><span class="line">//自定义排序函数</span><br><span class="line">vector&lt;vecotr&lt;int&gt; &gt; nums2d;</span><br><span class="line">bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123;</span><br><span class="line">    //注意！这个函数要在类外面定义</span><br><span class="line">    return a[1] &gt; b[1];//按第二维降序</span><br><span class="line">&#125;</span><br><span class="line">sort(nums2d.begin(),nums2d.end(),cmp);</span><br><span class="line"></span><br><span class="line">//稳定排序</span><br><span class="line">stable_sort(nums.begin(),nums.end(),greater&lt;int&gt;());</span><br><span class="line">stable_sort(nums.begin(),nums.end(),less&lt;int&gt;());</span><br></pre></td></tr></table></figure><p>sort算法有个限制，利用sort算法只能对<strong>序列容器</strong>进行排序，就是线性的，如<strong>vector，list，deque</strong>。map也是一个集合容器，但它里面存储的元素是pair，不是线性存储的（前面提过，像红黑树），所以利用sort不能直接和map结合进行排序。</p><p>如果想对map进行排序，可以把map放到vector中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 将map中的内容转存到vector中</span><br><span class="line">vector&lt;pair&lt;string, int&gt; &gt; vec(map.begin(), map.end());</span><br><span class="line"></span><br><span class="line">bool cmp(const pair&lt;string, int&gt;&amp; a, const pair&lt;string, int&gt;&amp; b) &#123;</span><br><span class="line">        return a.second &lt; b.second;</span><br><span class="line">&#125;</span><br><span class="line">//对线性的vector进行排序</span><br><span class="line">sort(vec.begin(), vec.end(), cmp);</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>支持随机存取迭代器（连续存储空间）的<code>vector</code>，<code>deque</code> （双向存取的vector）可以使用sort；</li><li>支持随机存取迭代器（链式非连续存储空间）的<code>list</code>（双向链表）和<code>slist</code>（单向链表forward_list），不能使用STL的sort，但是类中有自定义的sort()成员函数；</li><li>关系型容器中基于红黑树的<code>set</code>，<code>multiset</code>，<code>map</code>，<code>multimap</code>，本身就有自动排序的功能，不需要sort函数。如果有特殊排序需求的话，可以放入vector中；</li><li><code>stack</code>，<code>queue</code>没有迭代器，入口出口固定，不能进行排序；</li><li>基于哈希表的<code>unordered_map</code>等都是为排序的，也不需要排序。</li></ol><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; nums = &#123;100,100,100,101&#125;;</span><br><span class="line">int num = count(nums.begin(),nums.end(),100);//统计100出现的次数</span><br></pre></td></tr></table></figure><h3 id="lower-bound、upper-bound、binary-search"><a href="#lower-bound、upper-bound、binary-search" class="headerlink" title="lower_bound、upper_bound、binary_search"></a>lower_bound、upper_bound、binary_search</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">lower_bound(起始地址，结束地址，要查找的数值) //返回的是数值 第一个 出现的位置。</span><br><span class="line">upper_bound(起始地址，结束地址，要查找的数值) //返回的是数值 最后一个 出现的位置。</span><br><span class="line">binary_search(起始地址，结束地址，要查找的数值)  //返回的是是否存在这么一个数，是一个bool值。</span><br></pre></td></tr></table></figure><h2 id="一些数学运算"><a href="#一些数学运算" class="headerlink" title="一些数学运算"></a>一些数学运算</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cmath&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/06/15/iLAdQTJq3j19CH5.png" alt="cmath"></p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iterator&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/06/15/lqItjZGhRkmMwPf.png" alt="iter"></p><h2 id="cctype"><a href="#cctype" class="headerlink" title="cctype"></a>cctype</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cctype&gt;</span><br><span class="line"></span><br><span class="line">isalnum(c)//当c是字母或数字时为真</span><br><span class="line">isalpha(c)//当c是字母时为真</span><br><span class="line">isdigit(c)//当c是数字时为真</span><br><span class="line">islower(c)//当c是小写字母时为真</span><br><span class="line">isupper(c)//当c是大写字母时为真</span><br><span class="line">isspace(c)//当c是空白时为真（即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符）</span><br><span class="line">iscntrl(c)//当c是控制字符时为真</span><br><span class="line">isgraph(c)//当c不是空格但可打印时为真</span><br><span class="line">isprint(c)//当c是可打印字符时为真（即c是空格或c具有可视形式）</span><br><span class="line">ispunct(c)//当c是标点符号时为真</span><br><span class="line">isxdigit(c)//当c是十六进制数字时为真</span><br><span class="line">tolower(c)//如果c是大写字母，输出对应的小写字母，否则原样输出c</span><br><span class="line">toupper(c)//如果c是小写字母，输出对应的大写字母，否则原样输出c</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;常用STL库的使用方法&quot;&gt;&lt;a href=&quot;#常用STL库的使用方法&quot; class=&quot;headerlink&quot; title=&quot;常用STL库的使用方法&quot;&gt;&lt;/a&gt;常用STL库的使用方法&lt;/h1&gt;&lt;p&gt;记录了常用的STL使用方法&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/Algorithm/"/>
    
    
    <category term="cpp" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>笔试输入输出总结</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2020/07/11/cin_cout/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2020/07/11/cin_cout/</id>
    <published>2020-07-11T13:10:00.000Z</published>
    <updated>2020-08-31T01:42:45.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见输入"><a href="#常见输入" class="headerlink" title="常见输入"></a>常见输入</h1><p>常见机试输入</p><span id="more"></span><h2 id="输入一个数字再加上空格间隔的数组，并且给了数组元素个数n"><a href="#输入一个数字再加上空格间隔的数组，并且给了数组元素个数n" class="headerlink" title="输入一个数字再加上空格间隔的数组，并且给了数组元素个数n"></a>输入一个数字再加上空格间隔的数组，并且给了数组元素个数n</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">vector&lt;int&gt; input(n);</span><br><span class="line">for(int i = 0; i &lt; n; i++)</span><br><span class="line">    cin &gt;&gt; input[i];</span><br></pre></td></tr></table></figure><h2 id="输入一个数字再加上空格间隔的数组，但是没有给数组元素个数n"><a href="#输入一个数字再加上空格间隔的数组，但是没有给数组元素个数n" class="headerlink" title="输入一个数字再加上空格间隔的数组，但是没有给数组元素个数n"></a>输入一个数字再加上空格间隔的数组，但是没有给数组元素个数n</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line">vector&lt;int&gt; input;</span><br><span class="line">while(cin &gt;&gt; a)&#123;</span><br><span class="line">    input.push_back(a);</span><br><span class="line">    if(cin.get() == &#x27;\n&#x27;)</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给你输入的数据组数t，和很多组数据。这些数据有换行，但是数组元素个数都没有给"><a href="#给你输入的数据组数t，和很多组数据。这些数据有换行，但是数组元素个数都没有给" class="headerlink" title="给你输入的数据组数t，和很多组数据。这些数据有换行，但是数组元素个数都没有给"></a>给你输入的数据组数t，和很多组数据。这些数据有换行，但是数组元素个数都没有给</h2><p>比如：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3            //有3组数据</span><br><span class="line">1 2 3 4 5    //第一组数据A</span><br><span class="line">2 4 5 3 6    //第一组数据B</span><br><span class="line">3 4 6        //第二组数据A</span><br><span class="line">2 2 5        //第二组数据B</span><br><span class="line">1            //第三组数据A</span><br><span class="line">0            //第三组数据B</span><br></pre></td></tr></table></figure><p>因为没有给每行数据的个数，所以一行数据输入完成时需要识别<strong>换行符</strong>。<br>输入方法：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int t, a;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">vector&lt;int&gt; A, B;</span><br><span class="line">for(int i = 0; i &lt; 2*t; i++)&#123;</span><br><span class="line">    while(cin &gt;&gt; a)&#123;</span><br><span class="line">        A.push_back(a);</span><br><span class="line">        if (cin.get() == &#x27;\n&#x27;) </span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    while(cin &gt;&gt; a)&#123;</span><br><span class="line">        B.push_back(a);</span><br><span class="line">        if (cin.get() == &#x27;\n&#x27;) </span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不存在空格的字符数组"><a href="#不存在空格的字符数组" class="headerlink" title="不存在空格的字符数组"></a>不存在空格的字符数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br></pre></td></tr></table></figure><h2 id="输入带有空格的字符数组"><a href="#输入带有空格的字符数组" class="headerlink" title="输入带有空格的字符数组"></a>输入带有空格的字符数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">getline(cin, s);</span><br></pre></td></tr></table></figure><h2 id="输入多个整数"><a href="#输入多个整数" class="headerlink" title="输入多个整数"></a>输入多个整数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a,b,c,d;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br></pre></td></tr></table></figure><h1 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h1><h2 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h2><ul><li><code>getline(istream&amp; is, string&amp; str);</code> 把is传到str中</li><li><code>getline(istream&amp; is, string&amp; str, char delim);</code> delim是截断字符，可以用来分割字符串<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sstream&gt;</span><br><span class="line"></span><br><span class="line">string s = &quot;alice,20,800,sz&quot;;</span><br><span class="line"></span><br><span class="line">istringstream is(s);</span><br><span class="line">string str;</span><br><span class="line">std::getline(is, str); //str: alice,20,800,sz</span><br><span class="line">std::getline(is, str, &#x27;,&#x27;); //str: alice</span><br></pre></td></tr></table></figure></li></ul><p>输入：<code>[1,1,1,1,2,1,1],[5,2,5,4,5,1,6]</code>。要求提取出数字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    string sw, sh;</span><br><span class="line">    getline(cin, sw, &#x27;]&#x27;);</span><br><span class="line">    getline(cin, sh, &#x27;]&#x27;);</span><br><span class="line"></span><br><span class="line">    istringstream isw(sw.substr(1)), ish(sh.substr(2));</span><br><span class="line">    </span><br><span class="line">    string tmp;</span><br><span class="line">    vector&lt;int&gt; width, height;</span><br><span class="line">    while (getline(isw, tmp, &#x27;,&#x27;))</span><br><span class="line">        width.push_back(stoi(tmp));</span><br><span class="line">    while (getline(ish, tmp, &#x27;,&#x27;))</span><br><span class="line">        height.push_back(stoi(tmp));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输出精度控制"><a href="#输出精度控制" class="headerlink" title="输出精度控制"></a>输出精度控制</h1><p>如：输出保留2位小数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">double d = 1.666666;</span><br><span class="line">//c++</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">cout &lt;&lt; setprecision(3) &lt;&lt; d &lt;&lt; endl; //1.67</span><br><span class="line">//c</span><br><span class="line">printf(&quot;%.2f\n&quot;, d); //1.67</span><br></pre></td></tr></table></figure><h1 id="OJ练习"><a href="#OJ练习" class="headerlink" title="OJ练习"></a>OJ练习</h1><p><a href="https://ac.nowcoder.com/acm/contest/320#question">牛客</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;常见输入&quot;&gt;&lt;a href=&quot;#常见输入&quot; class=&quot;headerlink&quot; title=&quot;常见输入&quot;&gt;&lt;/a&gt;常见输入&lt;/h1&gt;&lt;p&gt;常见机试输入&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/Algorithm/"/>
    
    
    <category term="cpp" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>光流法</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2020/07/05/OpticalFlow/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2020/07/05/OpticalFlow/</id>
    <published>2020-07-05T11:00:00.000Z</published>
    <updated>2020-08-17T07:30:34.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="光流法"><a href="#光流法" class="headerlink" title="光流法"></a>光流法</h1><p>光流法是利用图像序列中的像素强度数据的时域变化和相关性来确定各自像素位置的“运动”。简单说来说，光流法的目的是找到灰度图中各像素在连续图像中的移动方向和速度。</p><p>光流法的实现要求满足几个基本假设：  </p><ol><li>相邻帧之间的亮度恒定；</li><li>相邻视频帧的取帧时间连续，或者，相邻帧之间物体的运动比较“微小”；</li><li>保持空间一致性；即，同一子图像的像素点具有相同的运动。</li></ol><span id="more"></span><h2 id="光流法的分类"><a href="#光流法的分类" class="headerlink" title="光流法的分类"></a>光流法的分类</h2><h3 id="基于梯度（微分法）"><a href="#基于梯度（微分法）" class="headerlink" title="基于梯度（微分法）"></a>基于梯度（微分法）</h3><h4 id="Horn-Schunck光流法"><a href="#Horn-Schunck光流法" class="headerlink" title="Horn-Schunck光流法"></a>Horn-Schunck光流法</h4><p>Horn-Schunck光流法基于全局平滑假设，即运动物体内部的光流场是相同的，因此物体内部光流场的梯度应该为零，也就是说物体内部的光流场应当是平滑的，故得到一个二阶梯度为0的约束方程。</p><p><strong>特点</strong>：稠密光流，二阶导，计算量大</p><p><strong>论文</strong>：Horn B K P, Schunck B G. Determining optical flow[J]. Artificial intelligence, 1981, 17(1-3): 185-203</p><h4 id="Lucas-Kanade光流法"><a href="#Lucas-Kanade光流法" class="headerlink" title="Lucas-Kanade光流法"></a>Lucas-Kanade光流法</h4><p>Lucas-Kanade算法认为：一个像素周围的相邻像素的光流场应该和中心的像素光流场一致。因此可以得到一系列等式，可以用最小二乘法求解。</p><p><strong>特点</strong>：稀疏光流</p><p><strong>论文</strong>：Baker S, Matthews I. Lucas-kanade 20 years on: A unifying framework[J]. International journal of computer vision, 2004, 56(3): 221-255.</p><h4 id="基于图像金字塔的Lucas-Kanade光流法"><a href="#基于图像金字塔的Lucas-Kanade光流法" class="headerlink" title="基于图像金字塔的Lucas-Kanade光流法"></a>基于图像金字塔的Lucas-Kanade光流法</h4><p>普通的光流算法有一个问题——<strong>孔径问题</strong>。</p><p>同时，LK算法的约束条件——小速度，亮度不变以及区域一致性——都是较强的假设，并不很容易得到满足。如当物体运动速度较快时，假设不成立，那么后续的假设就会有较大的偏差，使得最终求出的光流值有较大的误差。</p><p>图像金字塔可以解决这个问题。</p><p><strong>特点</strong>：稀疏光流</p><p><strong>论文</strong>：Pyramidal Implementation of the Lucas Kanade Feature TrackerDescription of the algorithm</p><h3 id="基于块匹配"><a href="#基于块匹配" class="headerlink" title="基于块匹配"></a>基于块匹配</h3><p>先找出原图中的<strong>特征点</strong>，再在待匹配的图中的同一个位置附近区域使用<strong>块匹配</strong>的方法寻找最匹配的块。</p><h4 id="块匹配的主要方法："><a href="#块匹配的主要方法：" class="headerlink" title="块匹配的主要方法："></a>块匹配的主要方法：</h4><ul><li>SAD（绝对误差和）</li><li>MAD（平均绝对差)</li><li>SSD（误差平方和）</li><li>MSD（平均误差平方和）</li></ul><h1 id="OpenCV中的光流法函数"><a href="#OpenCV中的光流法函数" class="headerlink" title="OpenCV中的光流法函数"></a>OpenCV中的光流法函数</h1><p>具体API可以查看<a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowfarneback">OpenCV官方文档</a></p><h2 id="CalcOpticalFlowHS"><a href="#CalcOpticalFlowHS" class="headerlink" title="CalcOpticalFlowHS"></a>CalcOpticalFlowHS</h2><p>HS光流法的实现</p><h2 id="calcOpticalFlowPyrLK"><a href="#calcOpticalFlowPyrLK" class="headerlink" title="calcOpticalFlowPyrLK"></a>calcOpticalFlowPyrLK</h2><p>基于图像金字塔的Lucas-Kanade光流法的实现</p><h2 id="CalcOpticalFlowBM"><a href="#CalcOpticalFlowBM" class="headerlink" title="CalcOpticalFlowBM"></a>CalcOpticalFlowBM</h2><p>通过块匹配的方法来计算光流</p><h2 id="calcOpticalFlowFarneback"><a href="#calcOpticalFlowFarneback" class="headerlink" title="calcOpticalFlowFarneback"></a>calcOpticalFlowFarneback</h2><p>用Gunnar Farneback 的算法计算稠密光流（即图像上所有像素点的光流都计算出来）。</p><p><strong>论文</strong>：Two-Frame Motion Estimation Based on PolynomialExpansion</p><h2 id="calcOpticalFlowSF"><a href="#calcOpticalFlowSF" class="headerlink" title="calcOpticalFlowSF"></a>calcOpticalFlowSF</h2><p><strong>论文</strong>：SimpleFlow: A Non-iterative, Sublinear Optical FlowAlgorithm</p><h1 id="px4flow源码笔记"><a href="#px4flow源码笔记" class="headerlink" title="px4flow源码笔记"></a>px4flow源码笔记</h1><p><a href="https://github.com/PX4/Flow/blob/master/src/modules/flow/flow.c">flow.c文件地址</a></p><p><a href="https://github.com/PX4/OpticalFlow">px4flow cpp项目地址</a></p><h2 id="只用图像信息"><a href="#只用图像信息" class="headerlink" title="只用图像信息"></a>只用图像信息</h2><p><a href="https://github.com/suzhilong/Optical-Flow/tree/master/flow_c_test">c代码</a>：去掉角速度，用随机生成的二维矩阵测试</p><h2 id="compute-flow函数"><a href="#compute-flow函数" class="headerlink" title="compute_flow函数"></a>compute_flow函数</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>参数：*image1,*image2,x_rate,y_rate,z_rate,*pixel_flow_x, *pixel_flow_y</p><p>意义：图像1，图像2，绕x轴旋旋转速度，绕y轴旋转速度，绕z轴旋转速度，x轴像素移动，y轴像素移动</p><h3 id="加了备注"><a href="#加了备注" class="headerlink" title="加了备注"></a>加了备注</h3><ul><li><p><a href="https://github.com/suzhilong/Optical-Flow/blob/master/flow.c">c代码</a></p></li><li><p><a href="https://github.com/suzhilong/Optical-Flow/blob/master/flow.cpp">cpp代码</a></p></li></ul><h3 id="函数伪码："><a href="#函数伪码：" class="headerlink" title="函数伪码："></a>函数伪码：</h3><details>  <summary>点击查看伪码</summary>  <pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">def compute_flow():</span><br><span class="line">    for block_mid_pix in img1://步长为block的大小</span><br><span class="line">        diff = compute_diff()</span><br><span class="line">        if(diff&lt;THRESHOLD): continue</span><br><span class="line">    </span><br><span class="line">    for pix_in_win in img2:</span><br><span class="line">        temp_dist = ABSDIFF()</span><br><span class="line">        if(temp_dist&lt;dist):</span><br><span class="line">        sumx = x偏移量</span><br><span class="line">        sumy = y偏移量</span><br><span class="line">        dist = temp_dist</span><br><span class="line"></span><br><span class="line">    if(dist&lt;MIN_SAD):</span><br><span class="line">        meanflowx += sumx</span><br><span class="line">        meanflowy += sumy</span><br><span class="line">        compute_subpixel();//计算半像素</span><br><span class="line">        得到具有最小SAD的半像素方向mindir</span><br><span class="line">        dirsx[meancount] = sumx</span><br><span class="line">        dirsy[meancount] = sumy</span><br><span class="line">        subdirs[meancount] = mindir</span><br><span class="line">        meancount++</span><br><span class="line">        统计4个方向（类似坐标系的4个象限）的直方图</span><br><span class="line">        </span><br><span class="line">    if(meancount&gt;10)://特征点超过10个点</span><br><span class="line">        meanflowx /= meancount</span><br><span class="line">        meanflowy /= meancount</span><br><span class="line">        从直方图中找到4个方向中出现最多的方向</span><br><span class="line"></span><br><span class="line">    if(滤波)：</span><br><span class="line">        滤波法</span><br><span class="line">    else：</span><br><span class="line">        平均法</span><br><span class="line"></span><br><span class="line">    //NUM_BLOCKS是一个维度被分成了几块</span><br><span class="line">    计算qual=meancount * 255 / (NUM_BLOCKS*NUM_BLOCKS) </span><br></pre></td></tr></table></figure><p>  </code></pre></p></details><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>计算特征点使用了<code>compute_diff</code>函数，计算光流用的是SAD块匹配。</p><h4 id="compute-diff-image-offX-offY-row-size"><a href="#compute-diff-image-offX-offY-row-size" class="headerlink" title="compute_diff(*image, offX, offY, row_size)"></a>compute_diff(*image, offX, offY, row_size)</h4><p>参数：图像，图像左上角像素的x坐标，图像左上角像素的y坐标</p><h4 id="compute-subpixelcompute-subpixel-image1-image2-off1X-off1Y-off2X-off2Y-acc-row-size"><a href="#compute-subpixelcompute-subpixel-image1-image2-off1X-off1Y-off2X-off2Y-acc-row-size" class="headerlink" title="compute_subpixelcompute_subpixel(*image1,*image2,off1X,off1Y,off2X, off2Y,*acc,row_size)"></a>compute_subpixelcompute_subpixel(*image1,*image2,off1X,off1Y,off2X, off2Y,*acc,row_size)</h4><p>参数：图像1，图像2，图像1左上角像素的x坐标，图像1左上角像素的y坐标，图像2左上角像素的x坐标，图像2左上角像素的y坐标，</p><h4 id="计算流程"><a href="#计算流程" class="headerlink" title="计算流程"></a>计算流程</h4><ul><li>重要参数含义<br><img src="https://i.loli.net/2020/07/05/Jdl7qp3uvegcB6F.png" alt="参数含义"></li><li>筛选特征点<br><img src="https://i.loli.net/2020/07/05/9zsJfOIGwWDE7Ag.png" alt="compute_diff"></li><li>在附近搜索“距离”最近的块<br><img src="https://i.loli.net/2020/07/05/xhJoKFy2OAuZeBa.png" alt="块匹配"></li><li>半像素增加精度<br><img src="https://i.loli.net/2020/07/05/SKXiEp8h27TmjqN.png" alt="compute_subpixel"></li><li>直方图统计<br><img src="https://i.loli.net/2020/07/05/IKe4kJVFCzR6aGn.png" alt="直方图统计"></li><li>进一步计算：直方图法用统计数量峰值的前后两个像素数据（共5个）来取平均；平均法全部加起来取平均。<br><img src="https://i.loli.net/2020/07/05/eVqPZx6KTILCEaU.png" alt="meancount大于10"></li><li>角速度补偿<br><img src="https://i.loli.net/2020/07/05/sHc83t2OoK57kXg.png" alt="角速度补偿"></li></ul><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul><li><a href="https://blog.csdn.net/ReadAir/article/details/88073068">光流法的过去，现在和发展趋势</a></li><li><a href="https://blog.csdn.net/qq_41368247/article/details/82562165">计算机视觉–光流法(optical flow)简介</a></li><li><a href="https://blog.csdn.net/hujingshuang/article/details/47759579">基于灰度的模板匹配算法（一）：MAD、SAD、SSD、MSD、NCC、SSDA、SATD算法</a></li><li><a href="https://blog.csdn.net/crzy_sparrow/article/details/7407604">Opencv学习笔记（九）光流法</a></li><li><a href="https://blog.csdn.net/zouxy09/article/details/8683859">光流Optical Flow介绍与OpenCV实现</a></li><li><a href="https://blog.csdn.net/zhashuiguangzi/article/details/75788010">ABSDIFF和USADA8的汇编代码</a></li><li><a href="https://blog.csdn.net/Zhaohui1995_Yang/article/details/51346695">Px4 flow分析</a></li><li><a href="https://blog.csdn.net/qq_25394511/article/details/79437850">PX4FLOW flow.c函数流程详细解析</a></li><li><a href="https://blog.csdn.net/sev_en77/article/details/70226083">px4flow源码分析</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;光流法&quot;&gt;&lt;a href=&quot;#光流法&quot; class=&quot;headerlink&quot; title=&quot;光流法&quot;&gt;&lt;/a&gt;光流法&lt;/h1&gt;&lt;p&gt;光流法是利用图像序列中的像素强度数据的时域变化和相关性来确定各自像素位置的“运动”。简单说来说，光流法的目的是找到灰度图中各像素在连续图像中的移动方向和速度。&lt;/p&gt;
&lt;p&gt;光流法的实现要求满足几个基本假设：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;相邻帧之间的亮度恒定；&lt;/li&gt;
&lt;li&gt;相邻视频帧的取帧时间连续，或者，相邻帧之间物体的运动比较“微小”；&lt;/li&gt;
&lt;li&gt;保持空间一致性；即，同一子图像的像素点具有相同的运动。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="robot" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/robot/"/>
    
    
    <category term="Computer vision" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/Computer-vision/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 - 2020年七月</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2020/07/01/LeetcodeDaily_July/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2020/07/01/LeetcodeDaily_July/</id>
    <published>2020-07-01T12:00:00.000Z</published>
    <updated>2020-08-17T07:39:45.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7月1日-718-最长重复子数组（中等）"><a href="#7月1日-718-最长重复子数组（中等）" class="headerlink" title="7月1日 718. 最长重复子数组（中等）"></a>7月1日 <a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组（中等）</a></h1><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">A: [1,2,3,2,1]</span><br><span class="line">B: [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">长度最长的公共子数组是 [3, 2, 1] 。</span><br></pre></td></tr></table></figure><p>题解：  </p><ol><li><p>滑动窗口。主串从第一个开始，滑动匹配串直到与主串的当前元素相等，再看后面一共有几个元素相等。分别以 A 为主串和 B 为主串匹配一次取最大。比如A &#x3D; {0,0,0,0,0,0,1,0,0,0}, B &#x3D; {0,0,0,0,0,0,0,1,0,0}，以 A 为主串会得到6。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int findCore(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B)&#123;</span><br><span class="line">    int maxLen = 0;</span><br><span class="line">    for (int i = 0; i &lt; A.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int j = 0;</span><br><span class="line"></span><br><span class="line">        while (j &lt; B.size())</span><br><span class="line">        &#123;</span><br><span class="line">            while(j&lt;B.size() &amp;&amp; B[j]!=A[i])//判断边界的一定要在前面</span><br><span class="line">                j++;</span><br><span class="line">            if(j==B.size())</span><br><span class="line">                break;</span><br><span class="line">            int cur = i;</span><br><span class="line">            while(cur&lt;A.size() &amp;&amp; j&lt;B.size() &amp;&amp; A[cur]==B[j])&#123;</span><br><span class="line">                cur++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = max(maxLen, cur - i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;</span><br><span class="line">    if(A.empty() || B.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int a = findCore(A, B);</span><br><span class="line">    int b = findCore(B, A);</span><br><span class="line">    return max(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O((m+n) * min{n,m})。m、n为数组的长度。<br>空间复杂度：O(1)</p></li><li><p>二维dp。dp[i][j]表示A[0:i) 和 B[0:i)最长公共字串长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;</span><br><span class="line">    if(A.empty() || B.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int a = A.size(), b = B.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(a + 1, vector&lt;int&gt;(b + 1, 0));</span><br><span class="line">    int maxLen = 0;</span><br><span class="line">    for (int i = 1; i &lt;= a; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= b;j++)&#123;</span><br><span class="line">            if(A[i - 1] == B[j - 1])</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">            maxLen = max(maxLen, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p></li><li><p>一维dp。<br>因为只用到了上一行的dp，所以可以只用一维dp来做，但是j的更新就需要从后往前，因为更新当前的值需要上一行的前面的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;</span><br><span class="line">    if(A.empty() || B.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int a = A.size(), b = B.size();</span><br><span class="line">    vector&lt;int&gt; dp(b + 1, 0);</span><br><span class="line">    int maxLen = 0;</span><br><span class="line">    for (int i = 1; i &lt;= a; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = b; j &gt; 0;j--)&#123;</span><br><span class="line">            if(A[i - 1] == B[j - 1])</span><br><span class="line">                dp[j] = dp[j - 1] + 1;</span><br><span class="line">            else</span><br><span class="line">                dp[j] = 0;</span><br><span class="line">            maxLen = max(maxLen, dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(mn)<br>空间复杂度：O(m)</p></li></ol><h1 id="7月2日-378-有序矩阵中第K小的元素（中等）"><a href="#7月2日-378-有序矩阵中第K小的元素（中等）" class="headerlink" title="7月2日 378. 有序矩阵中第K小的元素（中等）"></a>7月2日 <a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第K小的元素（中等）</a></h1><p>给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。<br>请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">   [ 1,  5,  9],</span><br><span class="line">   [10, 11, 13],</span><br><span class="line">   [12, 13, 15]</span><br><span class="line">],</span><br><span class="line">k = 8,</span><br><span class="line"></span><br><span class="line">返回 13。</span><br></pre></td></tr></table></figure><p>题解：  </p><ol><li><p>把二维拉成一维，然后排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    for(int i=0;i&lt;matrix.size();i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;matrix[0].size();j++)&#123;</span><br><span class="line">            vec.push_back(matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(vec.begin(),vec.end());</span><br><span class="line">    return vec[k-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n^2 * log(n^2))<br>空间复杂度：O(n^2)</p></li><li><p>类似与归并排序。到第k个就结束。本代码每次都遍历每一行的首位元素，找到最小值弹出。（其实可以用一个小根堆来求最小值，可以减少时间复杂度为O(k * logn)）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int kthSmallest(vector&lt;vector&lt;int&gt; &gt;&amp; matrix, int k) &#123;</span><br><span class="line">    int n = matrix.size();</span><br><span class="line">    for (int i = 0; i &lt; k;i++)&#123;</span><br><span class="line">        int min = 0;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            while (matrix[min].empty())</span><br><span class="line">                min++;</span><br><span class="line">            if (matrix[j].empty())</span><br><span class="line">                continue;</span><br><span class="line">            min = matrix[min][0] &lt;= matrix[j][0] ? min : j;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i==k-1)</span><br><span class="line">            return matrix[min][0];</span><br><span class="line">        matrix[min].erase(matrix[min].begin(), matrix[min].begin() + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(k * n)<br>空间复杂度：O(1)</p></li></ol><h1 id="7月3日-108-将有序数组转换为二叉搜索树（简单）"><a href="#7月3日-108-将有序数组转换为二叉搜索树（简单）" class="headerlink" title="7月3日 108. 将有序数组转换为二叉搜索树（简单）"></a>7月3日 <a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树（简单）</a></h1><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><p>题解：<br>递归。中序遍历，总是选择中间位置左边的数字作为根节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeNode *buildTree(vector&lt;int&gt;&amp; nums, int left, int right)&#123;</span><br><span class="line">    if (left &gt; right) &#123;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    // 总是选择中间位置左边的数字作为根节点</span><br><span class="line">    int mid = (left + right) / 2;</span><br><span class="line"></span><br><span class="line">    TreeNode* root = new TreeNode(nums[mid]);</span><br><span class="line">    root-&gt;left = buildTree(nums, left, mid - 1);</span><br><span class="line">    root-&gt;right = buildTree(nums, mid + 1, right);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int L = 0, R = nums.size()-1;</span><br><span class="line">    TreeNode *res = buildTree(nums, L, R);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(logn)</p><h1 id="7月4日-32-最长有效括号（困难）"><a href="#7月4日-32-最长有效括号（困难）" class="headerlink" title="7月4日 32. 最长有效括号（困难）"></a>7月4日 <a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号（困难）</a></h1><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></figure><p>示例3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()(())&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释，都是有效的。</span><br></pre></td></tr></table></figure><p>题解：  </p><ol><li><p>栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int longestValidParentheses(string s) &#123;</span><br><span class="line">    stack&lt;int&gt; st1;</span><br><span class="line">    st1.push(-1);</span><br><span class="line">    int longest = 0;</span><br><span class="line">    for (int i = 0; i &lt; s.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]==&#x27;(&#x27;)</span><br><span class="line">            st1.push(i);</span><br><span class="line">        else&#123;</span><br><span class="line">            st1.pop();</span><br><span class="line">            if(st1.empty())</span><br><span class="line">                st1.push(i);</span><br><span class="line">            else</span><br><span class="line">                longest = max(longest, i - st1.top());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p></li><li><p>dp。</p></li></ol><ul><li>s[i]&#x3D;‘)’ 且 s[i−1]&#x3D;‘(’，也就是字符串形如 “……()”“……()”，我们可以推出：<code>dp[i]=dp[i-2]+2</code></li><li>s[i]&#x3D;‘)’ 且 s[i−1]&#x3D;‘)’，也就是字符串形如 “……))”“……))”，我们可以推出：如果s[i−dp[i−1]−1]&#x3D;‘(’，那么：<code>dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2</code>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（代码略）</span><br></pre></td></tr></table></figure></li></ul><h1 id="7月5日-44-通配符匹配（困难）"><a href="#7月5日-44-通配符匹配（困难）" class="headerlink" title="7月5日 44. 通配符匹配（困难）"></a>7月5日 <a href="https://leetcode-cn.com/problems/wildcard-matching/">44. 通配符匹配（困难）</a></h1><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p><ol><li>‘?’ 可以匹配任何单个字符。</li><li>‘*’ 可以匹配任意字符串（包括空字符串）。</li></ol><p>两个字符串完全匹配才算匹配成功。</p><p>说明:</p><ol><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</li></ol><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &#x27;*&#x27; 可以匹配任意字符串。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;cb&quot;</span><br><span class="line">p = &quot;?a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &#x27;?&#x27; 可以匹配 &#x27;c&#x27;, 但第二个 &#x27;a&#x27; 无法匹配 &#x27;b&#x27;。</span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;adceb&quot;</span><br><span class="line">p = &quot;*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 第一个 &#x27;*&#x27; 可以匹配空字符串, 第二个 &#x27;*&#x27; 可以匹配字符串 &quot;dce&quot;.</span><br></pre></td></tr></table></figure><p>示例 5:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;acdcb&quot;</span><br><span class="line">p = &quot;a*c?b&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>题解：  </p><ol><li><p>递归。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool matchCore(string s, string p, int idxS, int idxP)&#123;</span><br><span class="line">    if(idxS == s.size() &amp;&amp; idxP == p.size())</span><br><span class="line">        return true;</span><br><span class="line">    if(idxS &gt;= s.size())&#123;</span><br><span class="line">        if(p[idxP] != &#x27;*&#x27;)</span><br><span class="line">            return false;</span><br><span class="line">        else</span><br><span class="line">            return matchCore(s, p, idxS, idxP + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(p[idxP]==&#x27;*&#x27;)&#123;</span><br><span class="line">        if(idxP==p.size()-1)</span><br><span class="line">            return true;</span><br><span class="line">        while(p[idxP]==&#x27;*&#x27;)//匹配连续的&#x27;*&#x27;</span><br><span class="line">            idxP++;</span><br><span class="line">        return matchCore(s, p, idxS + 1, idxP - 1) || matchCore(s, p, idxS, idxP);</span><br><span class="line">    &#125;</span><br><span class="line">    if(p[idxP]==&#x27;?&#x27; || s[idxS]==p[idxP])</span><br><span class="line">        return matchCore(s, p, idxS + 1, idxP + 1);</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isMatch(string s, string p) &#123;</span><br><span class="line">    return matchCore(s, p, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(2^k)。k是‘*’串的个数。超时，941 &#x2F; 1809 个通过测试用例。<br>空间复杂度：O(2^k)，递归调用需要用到栈</p></li><li><p>dp。<br><code>dp[i][j]</code>表示字符串s的前i个字符p的前j个字符是否能匹配。</p></li></ol><ul><li>注意：s和p下标是从 0 开始的。</li><li>当<code>s[i-1]==p[j-1]</code>或<code>p[j-1]==&#39;?&#39;</code>时：<code>dp[i][j] = dp[i - 1][j - 1]</code>。</li><li>当<code>p[j-1]==&#39;*&#39;</code>时：如果使用’*‘，则<code>dp[i][j] = dp[i-1][j]</code>；如果不使用’*‘，则<code>dp[i][j] = dp[i][j-1]</code>。</li><li>初始状态：<code>dp[0][0] = true</code>；<code>dp[i][0] = false</code>；如果直到<code>p[i]</code>前面都是”*“，<code>dp[0][0～i] = true</code>。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bool isMatch(string s, string p) &#123;</span><br><span class="line">    int m = s.size(), n = p.size();</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; dp(m + 1, vector&lt;bool&gt;(n + 1, false));</span><br><span class="line"></span><br><span class="line">    dp[0][0] = true;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if (p[i - 1] == &#x27;*&#x27;)</span><br><span class="line">            dp[0][i] = true;</span><br><span class="line">        else</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n;j++)&#123;</span><br><span class="line">            if(p[j-1]==&#x27;?&#x27; || p[j-1]==s[i-1])</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">            else if(p[j-1]==&#x27;*&#x27;)</span><br><span class="line">                dp[i][j] = dp[i][j - 1] || dp[i - 1][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>时间复杂度：O(mn)<br>空间复杂度：O(mn)</li></ul><p><em>ps. 以后碰到这种题，直接用dp，递归基本都是时间复杂度比较高的。</em></p><h1 id="7月6日-63-不同路径-II（中等）"><a href="#7月6日-63-不同路径-II（中等）" class="headerlink" title="7月6日 63. 不同路径 II（中等）"></a>7月6日 <a href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II（中等）</a></h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>说明：m 和 n 的值均不超过 100。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p>题解：  </p><ol><li>二维dp。<br><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></li></ol><p>注意初始化：</p><ul><li>当obstacleGrid[i][j]&#x3D;&#x3D;1时dp[i][j] &#x3D; 0；</li><li>第一行和第一列，obstacleGrid[0][j]&#x3D;&#x3D;1和obstacleGrid[i][0]&#x3D;&#x3D;1之前初始化为1。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt; &gt;&amp; obstacleGrid) &#123;</span><br><span class="line">    int m = obstacleGrid.size(), n = obstacleGrid[0].size();</span><br><span class="line">    if(m==0 || obstacleGrid[0][0]==1)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(m,vector&lt;int&gt;(n,0));</span><br><span class="line"></span><br><span class="line">    dp[0][0] = 1;</span><br><span class="line">    for (int i = 1; i &lt; m; i++)&#123;</span><br><span class="line">        if(obstacleGrid[i][0]==1)</span><br><span class="line">            break;</span><br><span class="line">        dp[i][0] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int j = 1; j &lt; n;j++)&#123;</span><br><span class="line">        if(obstacleGrid[0][j]==1)</span><br><span class="line">            break;</span><br><span class="line">        dp[0][j] = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt; n;j++)&#123;</span><br><span class="line">            if(obstacleGrid[i][j]==1)</span><br><span class="line">                continue;</span><br><span class="line">            dp[i][j] = dp[i-1][j] + dp[i][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m-1][n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>一维dp。<br>因为只会用到上一行j之后（含j）的数据，所以可以优化为只用一维dp。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt; &gt;&amp; obstacleGrid) &#123;</span><br><span class="line">    int m = obstacleGrid.size(), n = obstacleGrid[0].size();</span><br><span class="line">    if(m==0 || obstacleGrid[0][0]==1)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; dp(n+1,0);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    for (int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">        if(obstacleGrid[0][i]==1)</span><br><span class="line">            break;</span><br><span class="line">        dp[i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(dp[0]==1 &amp;&amp; obstacleGrid[i][0]==0)</span><br><span class="line">            dp[0] = 1;</span><br><span class="line">        else</span><br><span class="line">            dp[0] = 0;</span><br><span class="line">        for (int j = 1; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(obstacleGrid[i][j]==1)</span><br><span class="line">                dp[j] = 0;</span><br><span class="line">            else</span><br><span class="line">                dp[j] = dp[j] + dp[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="7月7日-112-路径总和（简单）"><a href="#7月7日-112-路径总和（简单）" class="headerlink" title="7月7日 112. 路径总和（简单）"></a>7月7日 <a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和（简单）</a></h1><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p><strong>说明</strong>: 叶子节点是指没有子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">              5</span><br><span class="line">             / \</span><br><span class="line">            4   8</span><br><span class="line">           /   / \</span><br><span class="line">          11  13  4</span><br><span class="line">         /  \      \</span><br><span class="line">        7    2      1</span><br><span class="line">返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</span><br></pre></td></tr></table></figure><p>题解：  </p><ol><li><p>dfs（递归）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool hasPathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return false;</span><br><span class="line">    if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)&#123;</span><br><span class="line">        return root-&gt;val==sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int curVal = root-&gt;val;</span><br><span class="line">    return hasPathSum(root-&gt;left,sum-curVal) || hasPathSum(root-&gt;right,sum-curVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(h)。h为树的高度，最坏情况下h &#x3D; n。</p></li><li><p>bfs。队列实现。时空复杂度都是O(n)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（代码略）</span><br></pre></td></tr></table></figure></li></ol><h1 id="7月8日-程序员面试金典-面试题-16-11-跳水板（简单）"><a href="#7月8日-程序员面试金典-面试题-16-11-跳水板（简单）" class="headerlink" title="7月8日 程序员面试金典 面试题 16.11. 跳水板（简单）"></a>7月8日 <a href="https://leetcode-cn.com/problems/diving-board-lcci/">程序员面试金典 面试题 16.11. 跳水板（简单）</a></h1><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。<br>返回的长度需要从小到大排列。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">shorter = 1</span><br><span class="line">longer = 2</span><br><span class="line">k = 3</span><br><span class="line">输出： &#123;3,4,5,6&#125;</span><br></pre></td></tr></table></figure><p>题解：<br>shorter的使用次数分别为0-k。<br>注意返回需要从小到大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; divingBoard(int shorter, int longer, int k) &#123;</span><br><span class="line">    if(k==0)</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    if (shorter == longer) &#123;</span><br><span class="line">        return &#123;shorter * k&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for(int i=0;i&lt;=k;i++)&#123;</span><br><span class="line">        res.push_back(shorter*(k-i)+longer*i);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(k)<br>空间复杂度：O(k)</p><h1 id="7月9日-程序员面试金典-面试题-17-13-恢复空格（中等）"><a href="#7月9日-程序员面试金典-面试题-17-13-恢复空格（中等）" class="headerlink" title="7月9日 程序员面试金典 面试题 17.13. 恢复空格（中等）"></a><a href="https://leetcode-cn.com/problems/re-space-lcci/">7月9日 程序员面试金典 面试题 17.13. 恢复空格（中等）</a></h1><p>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子”I reset the computer. It still didn’t boot!”已经变成了”iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</p><p><strong>注意</strong>：本题相对原题稍作改动，只需返回未识别的字符数</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">dictionary = [&quot;looked&quot;,&quot;just&quot;,&quot;like&quot;,&quot;her&quot;,&quot;brother&quot;]</span><br><span class="line">sentence = &quot;jesslookedjustliketimherbrother&quot;</span><br><span class="line">输出： 7</span><br><span class="line">解释： 断句后为&quot;jess looked just like tim her brother&quot;，共7个未识别字符。</span><br></pre></td></tr></table></figure><p>题解：<br>dp。<br><code>dp[i]</code> 表示第 <code>i</code> 个之前字母（含i）之前未识别的最少字符数。</p><ul><li>当s[i-d:d)与字典中某一字符串匹配时： dp[i] &#x3D; min(dp[i - d],dp[i])。需要枚举每一个字典中的字符串。</li><li>当与所有不重合时： dp[i] &#x3D; dp[i -1] + 1， 把 s[i-1] 当作一个未识别字符。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int respace(vector&lt;string&gt;&amp; dictionary, string sentence) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(sentence.size() + 1,sentence.size());</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    for (int i = 1; i &lt;= sentence.size(); i++) &#123;</span><br><span class="line">        for (string dict : dictionary) &#123;</span><br><span class="line">            int d = dict.size();</span><br><span class="line">            if (i &gt;= d &amp;&amp; sentence.substr(i - d, d) == dict)</span><br><span class="line">                dp[i] = min(dp[i - d], dp[i]);</span><br><span class="line">            else dp[i] = min(dp[i - 1] + 1,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[sentence.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>时间复杂度：O(n*k)。n 为字符串 s 的长度，k为字典的长度。<br>空间复杂度：O(n)</li></ul><h1 id="7月10日-309-最佳买卖股票时机含冷冻期（中等）"><a href="#7月10日-309-最佳买卖股票时机含冷冻期（中等）" class="headerlink" title="7月10日 309. 最佳买卖股票时机含冷冻期（中等）"></a>7月10日 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi-4/">309. 最佳买卖股票时机含冷冻期（中等）</a></h1><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><p>题解：<br>dp。<br>dp[i] 表示第 i 天结束之后的累计最大收益。<br>一共有三个状态：A观望，B持股，C冷却</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">状态转移图：A-(观望)-&gt;A,</span><br><span class="line">        A-(买入｜-price)-&gt;B,</span><br><span class="line">        B-(观望)-&gt;B,</span><br><span class="line">        B-(卖出|+price)-&gt;C,</span><br><span class="line">        C-(冷却)-&gt;A</span><br></pre></td></tr></table></figure><ul><li>持有：用dp[i][0]表示</li><li>冷却：用dp[i][1]表示</li><li>观望：用dp[i][2]表示</li></ul><p>根据状态转移图可以写出dp[i][j]的状态转移方程：</p><ul><li>dp[i][0] &#x3D; max(dp[i - 1][2] - prices[i], dp[i - 1][0]);</li><li>dp[i][1] &#x3D; dp[i - 1][0] + prices[i];</li><li>dp[i][2] &#x3D; max(dp[i - 1][1], dp[i - 1][2]);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if(prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(prices.size(), vector&lt;int&gt;(3));</span><br><span class="line">    dp[0][0] = -prices[0];</span><br><span class="line">    for (int i = 1; i &lt; prices.size();i++)&#123;</span><br><span class="line">        dp[i][0] = max(dp[i - 1][2] - prices[i], dp[i - 1][0]);</span><br><span class="line">        dp[i][1] = dp[i - 1][0] + prices[i];</span><br><span class="line">        dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]);</span><br><span class="line">    &#125;</span><br><span class="line">    return max(dp[prices.size() - 1][1], dp[prices.size() - 1][2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>时间复杂度：O(n)<br>空间复杂度：O(n)</li></ul><h1 id="7月11日-315-计算右侧小于当前元素的个数（困难）"><a href="#7月11日-315-计算右侧小于当前元素的个数（困难）" class="headerlink" title="7月11日 315. 计算右侧小于当前元素的个数（困难）"></a>7月11日 <a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数（困难）</a></h1><p>给定一个整数数组 nums，按要求返回一个新数组 *counts。数组 *counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。</p><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [5,2,6,1]</span><br><span class="line">输出: [2,1,1,0] </span><br><span class="line">解释:</span><br><span class="line">5 的右侧有 2 个更小的元素 (2 和 1).</span><br><span class="line">2 的右侧仅有 1 个更小的元素 (1).</span><br><span class="line">6 的右侧有 1 个更小的元素 (1).</span><br><span class="line">1 的右侧有 0 个更小的元素.</span><br></pre></td></tr></table></figure><p>题解：</p><ol><li>暴力。O(n^2)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;int&gt; res(nums.size());</span><br><span class="line">    for(int i = 0;i&lt;nums.size();i++)&#123;</span><br><span class="line">        int greater = 0;</span><br><span class="line">        for(int j=i+1;j&lt;nums.size();j++)&#123;</span><br><span class="line">            if(nums[j]&lt;nums[i])</span><br><span class="line">                greater++;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = greater;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>从后往前，维护一个升序数组。插入的序号就是比它小数字的个数。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int insertNums(vector&lt;int&gt; &amp;sorted, int num)&#123;</span><br><span class="line">    if(sorted.size()==1)&#123;</span><br><span class="line">        if(num&gt;sorted[0])&#123;</span><br><span class="line">            sorted.push_back(num);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            sorted.insert(sorted.begin(),num);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int l = 0, r = sorted.size()-1;</span><br><span class="line">    int mid = (l + r) / 2;</span><br><span class="line">    while (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        if(sorted[mid]&lt;num)</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        else</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        mid = (l+r)/2;</span><br><span class="line">    &#125;</span><br><span class="line">    sorted.insert(sorted.begin()+l, num);</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    if(nums.empty())</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    vector&lt;int&gt; sorted;</span><br><span class="line">    vector&lt;int&gt; res(nums.size());</span><br><span class="line">    sorted.push_back(nums[nums.size()-1]);</span><br><span class="line">    for(int i=nums.size()-2;i&gt;=0;i--)&#123;</span><br><span class="line">        int idx = insertNums(sorted, nums[i]);</span><br><span class="line">        res[i] = idx;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>时间复杂度：O(nlogn)。每次插入二分查找需要O(logn)的复杂度。<br>空间复杂度：O(n)</li></ol><h1 id="真题"><a href="#真题" class="headerlink" title="真题"></a>真题</h1><p>给定两个长度为n，值不重复的数列 A &amp; B ，将 A 这个数列进行入栈出栈操作，请问能否得到 B。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">A = [0,1,2,3,4]</span><br><span class="line">B = [2,1,0,4,3]</span><br><span class="line"></span><br><span class="line">输出： Y</span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">A = [0]</span><br><span class="line">B = [1]</span><br><span class="line"></span><br><span class="line">输出： N</span><br></pre></td></tr></table></figure><p>题解：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">bool canGetB(vector&lt;int&gt; A, vector&lt;int&gt; B)&#123;</span><br><span class="line">    stack&lt;int&gt; st;</span><br><span class="line">    int idxA = 0, idxB = 0;</span><br><span class="line">    for (; idxB &lt; B.size(); idxB++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(idxA&lt;A.size() &amp;&amp; !st.empty() &amp;&amp; st.top()==B[idxB])&#123;</span><br><span class="line">            st.pop();</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        while (idxA&lt;A.size() &amp;&amp; A[idxA]!=B[idxB])</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(A[idxA]);</span><br><span class="line">            idxA++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(idxA&lt;A.size())&#123;</span><br><span class="line">            idxA++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!st.empty() &amp;&amp; idxB&lt;B.size())&#123;</span><br><span class="line">        if(B[idxB]==st.top())&#123;</span><br><span class="line">            idxB++;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(idxA &lt; A.size() || idxB &lt; B.size())</span><br><span class="line">        return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><h1 id="7月12日-174-地下城游戏（困难）"><a href="#7月12日-174-地下城游戏（困难）" class="headerlink" title="7月12日 174. 地下城游戏（困难）"></a>7月12日 <a href="https://leetcode-cn.com/problems/dungeon-game/">174. 地下城游戏（困难）</a></h1><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p><p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p><p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p><p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p><p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p><p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-2(K)  -3    3</span><br><span class="line">-5  -10    1</span><br><span class="line">10   30   -5(P)</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>骑士的健康点数没有上限。</li><li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li></ul><p>题解：<br>反向dp。<br>因为正向dp需要维护两个重要变量：当 前HP 和 最大伤害。没办法做到<strong>无后效性</strong>。<br><code>dp[i][j]</code> 表示从坐标 <code>(i,j)</code> 到终点所需的最小初始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int calculateMinimumHP(vector&lt;vector&lt;int&gt; &gt;&amp; dungeon) &#123;</span><br><span class="line">    if(dungeon.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int M = dungeon.size(), N = dungeon[0].size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(M+1, vector&lt;int&gt;(N+1, INT_MAX));</span><br><span class="line">    dp[M][N - 1] = dp[M - 1][N] = 1;</span><br><span class="line">    for (int i = M - 1; i &gt;= 0;i--)&#123;</span><br><span class="line">        for (int j = N - 1; j &gt;= 0;j--)&#123;</span><br><span class="line">            int minn = min(dp[i + 1][j], dp[i][j + 1]);</span><br><span class="line">            dp[i][j] = max(minn - dungeon[i][j], 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[0][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(MN)<br>空间复杂度：O(MN)</p><h1 id="7月13日-350-两个数组的交集-II（简单）"><a href="#7月13日-350-两个数组的交集-II（简单）" class="headerlink" title="7月13日 350. 两个数组的交集 II（简单）"></a>7月13日 <a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II（简单）</a></h1><p>给定两个数组，编写一个函数来计算它们的交集。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2,2]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[4,9]</span><br></pre></td></tr></table></figure><p>题解：   </p><ol><li><p>双指针。但是需要先排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">    sort(nums1.begin(),nums1.end());</span><br><span class="line">    sort(nums2.begin(),nums2.end());</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    int idx1=0,idx2=0;</span><br><span class="line">    while(idx1&lt;nums1.size() &amp;&amp; idx2&lt;nums2.size())&#123;</span><br><span class="line">        if(nums1[idx1]==nums2[idx2])&#123;</span><br><span class="line">            res.push_back(nums1[idx1]);</span><br><span class="line">            idx1++;</span><br><span class="line">            idx2++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(nums1[idx1]&lt;nums2[idx2])</span><br><span class="line">                idx1++;</span><br><span class="line">            else</span><br><span class="line">                idx2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(mlogm<em>nlogn)。 排序需要 O(nlogn</em>mlogm)。<br>空间复杂度：O(min{m,n})。</p></li><li><p>哈希表。遍历其中一个数组，存入哈希表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">    if(nums2.size()&lt;nums1.size())</span><br><span class="line">        return intersect(nums2, nums1);</span><br><span class="line">    unordered_map&lt;int,int&gt; numMap;</span><br><span class="line">    for (int n : nums1)</span><br><span class="line">        numMap[n]++;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for (int n : nums2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(numMap.count(n))&#123;</span><br><span class="line">            res.push_back(n);</span><br><span class="line">            numMap[n]--;</span><br><span class="line">            if(numMap[n]==0)</span><br><span class="line">                numMap.erase(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(m+n)。<br>空间复杂度：O(min{m,n})。</p></li></ol><h1 id="7月14日-120-三角形最小路径和（中等）"><a href="#7月14日-120-三角形最小路径和（中等）" class="headerlink" title="7月14日 120. 三角形最小路径和（中等）"></a>7月14日 <a href="https://leetcode-cn.com/problems/triangle/">120. 三角形最小路径和（中等）</a></h1><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p><p>例如，给定三角形：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</p><p><strong>说明</strong>：<br>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p><p>题解：</p><ol><li>普通dp。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int minimumTotal(vector&lt;vector&lt;int&gt; &gt;&amp; triangle) &#123;</span><br><span class="line">    if(triangle.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int n = triangle.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(n,vector&lt;int&gt;(n));</span><br><span class="line">    dp[0][0] = triangle[0][0];</span><br><span class="line">    for (int i = 1; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][0] = dp[i - 1][0] + triangle[i][0];</span><br><span class="line">        for (int j = 1; j &lt; i;j++)&#123;</span><br><span class="line">            dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][i] = dp[i - 1][i - 1] + triangle[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    return *min_element(dp[n - 1].begin(), dp[n - 1].end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>时间复杂度：O(n^2)。<br>空间复杂度：O(n^2)。</li></ol><h1 id="7月15日-96-不同的二叉搜索树（中等）"><a href="#7月15日-96-不同的二叉搜索树（中等）" class="headerlink" title="7月15日 96. 不同的二叉搜索树（中等）"></a>7月15日 <a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树（中等）</a></h1><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><p>题解：</p><ol><li>dp。<br>设需要求 n 个节点。以一个节点为根节点，左子树的数量加右子树的数量就是以这个节点为根节点的数量。遍历不同的根节点（0~n）累加。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int numTrees(int n) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(n + 1, 0);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    dp[1] = 1;</span><br><span class="line"></span><br><span class="line">    for (int i = 2; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= i; ++j) &#123;</span><br><span class="line">            dp[i] += dp[j - 1] * dp[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>数学。<br>数学上被称为卡塔兰数。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nt numTrees(int n) &#123;</span><br><span class="line">    long long C = 1;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        C = C * 2 * (2 * i + 1) / (i + 2);</span><br><span class="line">    &#125;</span><br><span class="line">    return (int)C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="7月16日-785-判断二分图（中等）"><a href="#7月16日-785-判断二分图（中等）" class="headerlink" title="7月16日 785. 判断二分图（中等）"></a>7月16日 <a href="https://leetcode-cn.com/problems/is-graph-bipartite/">785. 判断二分图（中等）</a></h1><p>给定一个无向图graph，当这个图为二分图时返回true。</p><p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p><p>graph将会以邻接表方式给出，<code>graph[i]</code>表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： <code>graph[i]</code> 中不存在i，并且<code>graph[i]</code>中没有重复的值。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">输出: true</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">输出: false</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">我们不能将节点分割成两个独立的子集。</span><br></pre></td></tr></table></figure><p>题解：<br>bfs或者dfs，把经过的点分别标上交替的记号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（代码待补全）</span><br></pre></td></tr></table></figure><h1 id="7月17日-35-搜索插入位置（简单）"><a href="#7月17日-35-搜索插入位置（简单）" class="headerlink" title="7月17日 35. 搜索插入位置（简单）"></a>7月17日 <a href="">35. 搜索插入位置（简单）</a></h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>题解：<br>二分查找。可以用O(n)的复杂度顺序遍历。但是一看到排好序，就想到了二分查找。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    if(nums.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int L=0,R=nums.size()-1;</span><br><span class="line">    int mid;</span><br><span class="line">    while(L&lt;=R)&#123;</span><br><span class="line">        mid = (L+R)/2;</span><br><span class="line">        if(nums[mid]&gt;target)</span><br><span class="line">            R = mid - 1;</span><br><span class="line">        else if(nums[mid]&lt;target)</span><br><span class="line">            L = mid + 1;</span><br><span class="line">        else</span><br><span class="line">            return mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(logn)。<br>空间复杂度：O(1)。</p><h1 id="7月18日-97-交错字符串（困难）"><a href="#7月18日-97-交错字符串（困难）" class="headerlink" title="7月18日 97. 交错字符串（困难）"></a>7月18日 <a href="https://leetcode-cn.com/problems/interleaving-string/">97. 交错字符串（困难）</a></h1><p>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>题解：</p><ol><li>双指针递归。（超时）99 &#x2F; 101 个通过测试用例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bool isInterleaveCore(string s1,string s2,string s3,int idx1,int idx2,int idx3)&#123;</span><br><span class="line">    if(idx1==s1.size())</span><br><span class="line">        return s2.substr(idx2,s2.size()-idx2+1)==s3.substr(idx3,s3.size()-idx3+1);</span><br><span class="line">    if(idx2==s2.size())</span><br><span class="line">        return s1.substr(idx1,s1.size()-idx1+1)==s3.substr(idx3,s3.size()-idx3+1);</span><br><span class="line">    if(s1[idx1]==s3[idx3])&#123;</span><br><span class="line">        if(s2[idx2]==s3[idx3])</span><br><span class="line">            return isInterleaveCore(s1,s2,s3,idx1+1,idx2,idx3+1) || isInterleaveCore(s1,s2,s3,idx1,idx2+1,idx3+1);</span><br><span class="line">        else</span><br><span class="line">            return isInterleaveCore(s1,s2,s3,idx1+1,idx2,idx3+1);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if(s2[idx2]==s3[idx3])</span><br><span class="line">            return isInterleaveCore(s1,s2,s3,idx1,idx2+1,idx3+1);</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isInterleave(string s1, string s2, string s3) &#123;</span><br><span class="line">    if(s3.size() != s1.size()+s2.size())</span><br><span class="line">        return false;</span><br><span class="line">    return isInterleaveCore(s1,s2,s3,0,0,0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>二维dp。<br>dp[i][j] 表示字符串 s3[0:i+j] 能否由 s1[0:i] 和 s2[0:j] 组成。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool isInterleave(string s1, string s2, string s3) &#123;</span><br><span class="line">    if(s3.size() != s1.size()+s2.size())</span><br><span class="line">        return false;</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; dp(s1.size()+1,vector&lt;bool&gt;(s2.size()+1,false));</span><br><span class="line"></span><br><span class="line">    dp[0][0] = true;</span><br><span class="line">    for(int i=1;i&lt;=s1.size();i++)&#123;</span><br><span class="line">        if(s1[i-1]==s3[i-1])</span><br><span class="line">            dp[i][0] = true;</span><br><span class="line">        else</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=s2.size();i++)&#123;</span><br><span class="line">        if(s2[i-1]==s3[i-1])</span><br><span class="line">            dp[0][i] = true;</span><br><span class="line">        else</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=s1.size();i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=s2.size();j++)&#123;</span><br><span class="line">            dp[i][j] = (s1[i-1]==s3[i+j-1] &amp;&amp; dp[i-1][j]) || (s2[j-1]==s3[i+j-1] &amp;&amp; dp[i][j-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s1.size()][s2.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>时间复杂度：O(mn)。m 为s1的长度，n 为s2的长度。<br>空间复杂度：O(mn)。</li></ol><p>ref. <a href="https://leetcode-cn.com/problems/interleaving-string/solution/lei-si-lu-jing-wen-ti-zhao-zhun-zhuang-tai-fang-ch/">leetcode题解</a></p><ol start="3"><li>一维dp。<br>因为dp在计算时只用到了上一行，所以可以优化为只用一维数组。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码略</span><br></pre></td></tr></table></figure></li></ol><h1 id="7月19日-312-戳气球（困难）"><a href="#7月19日-312-戳气球（困难）" class="headerlink" title="7月19日 312. 戳气球（困难）"></a>7月19日 <a href="https://leetcode-cn.com/problems/burst-balloons/">312. 戳气球（困难）</a></h1><p>有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。如果你戳破气球 i ，就可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的 <code>left</code> 和 <code>right</code> 代表和 <code>i</code> 相邻的两个气球的序号。注意当你戳破了气球 <code>i</code> 后，气球 <code>left</code> 和气球 <code>right</code> 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p>说明:</p><ul><li>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; 1，但注意它们不是真实存在的所以并不能被戳破。</li><li>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</li></ul><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,5,8]</span><br><span class="line">输出: 167 </span><br><span class="line">解释: nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span><br><span class="line">     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</span><br></pre></td></tr></table></figure><p>题解：<br>dp。<br><code>dp[i][j]</code>表示<code>(i:j)</code>开区间内所能得到的最大值。外层循环要倒序，因为子问题<code>dp[k][j]</code>要在父问题<code>dp[i][j]</code>（i&lt;&#x3D;k&lt;&#x3D;j）之前。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int maxCoins(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(n + 2, vector&lt;int&gt;(n + 2, 0));</span><br><span class="line">    nums.insert(nums.begin(), 1);</span><br><span class="line">    nums.push_back(1);</span><br><span class="line">    for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        for (int j = i + 2; j &lt;= n + 1; j++) &#123;</span><br><span class="line">            for (int k = i + 1; k &lt; j; k++) &#123;</span><br><span class="line">                dp[i][j] = max(</span><br><span class="line">                        dp[i][j],</span><br><span class="line">                        (dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[0][n + 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n^3)。<br>空间复杂度：O(n^2)。</p><h1 id="7月20日-167-两数之和-II-输入有序数组（简单）"><a href="#7月20日-167-两数之和-II-输入有序数组（简单）" class="headerlink" title="7月20日 167. 两数之和 II - 输入有序数组（简单）"></a>7月20日 <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组（简单）</a></h1><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:</p><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span><br></pre></td></tr></table></figure><p>题解：</p><ol><li><p>哈希表。<br>哈希表保存每个元素，再遍历一次即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">    unordered_map&lt;int, int&gt; numMap;</span><br><span class="line">    for (int i = 0; i &lt; numbers.size();i++)</span><br><span class="line">        numMap[numbers[i]] = i;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; numbers.size();i++)&#123;</span><br><span class="line">        auto it = numMap.find(target - numbers[i]);</span><br><span class="line">        if (it != numMap.end())</span><br><span class="line">            return &#123;i + 1, it-&gt;second+1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)。<br>空间复杂度：O(n)。</p></li><li><p>二分查找。时间复杂度：O(nlogn)。空间复杂度：O(1)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码略</span><br></pre></td></tr></table></figure></li><li><p>双指针。<br>初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">    int L = 0, R = numbers.size() - 1;</span><br><span class="line">    while (L &lt; R) &#123;</span><br><span class="line">        int sum = numbers[L] + numbers[R];</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            return &#123;L + 1, R + 1&#125;;</span><br><span class="line">        &#125; else if (sum &lt; target) &#123;</span><br><span class="line">            ++L;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            --R;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;-1, -1&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)。<br>空间复杂度：O(1)。</p></li></ol><h1 id="7月21日-95-不同的二叉搜索树-II（中等）"><a href="#7月21日-95-不同的二叉搜索树-II（中等）" class="headerlink" title="7月21日 95. 不同的二叉搜索树 II（中等）"></a>7月21日 <a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II（中等）</a></h1><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><p><strong>提示</strong>：0 &lt;&#x3D; n &lt;&#x3D; 8</p><p>题解：<br>递归。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;TreeNode*&gt; generateSubTree(int L, int R)&#123;</span><br><span class="line">    if(L&gt;R)</span><br><span class="line">        return &#123;nullptr&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;TreeNode*&gt; Trees;</span><br><span class="line">    for(int i=L;i&lt;=R;i++)&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; leftTree = generateSubTree(L,i-1);</span><br><span class="line">        vector&lt;TreeNode*&gt; rightTree = generateSubTree(i+1,R);</span><br><span class="line"></span><br><span class="line">        for(auto lTree:leftTree)&#123;</span><br><span class="line">            for(auto rTree:rightTree)&#123;</span><br><span class="line">                TreeNode* root = new TreeNode(i);</span><br><span class="line">                root-&gt;left = lTree;</span><br><span class="line">                root-&gt;right = rTree;</span><br><span class="line">                Trees.push_back(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Trees;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;TreeNode*&gt; generateTrees(int n) &#123;</span><br><span class="line">    if(n==0)</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    return generateSubTree(1,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7月22日-剑指-Offer-11-旋转数组的最小数字（简单）"><a href="#7月22日-剑指-Offer-11-旋转数组的最小数字（简单）" class="headerlink" title="7月22日 剑指 Offer 11. 旋转数组的最小数字（简单）"></a>7月22日 <a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字（简单）</a></h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>题解：  </p><ol><li><p>暴力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int minArray(vector&lt;int&gt;&amp; numbers) &#123;</span><br><span class="line">    if(numbers.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    for(int i=1;i&lt;numbers.size();i++)&#123;</span><br><span class="line">        if(numbers[i]&lt;numbers[i-1])</span><br><span class="line">            return numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return numbers[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p></li><li><p>二分。<br>注意：当<code>numbers[mid]==numbers[R]</code>时，由于重复元素的存在，我们并不能确定<code>numbers[mid]</code>究竟在最小值的左侧还是右侧，因此我们不能忽略某一部分的元素。但是由于它们的值相同，所以可以忽略二分查找区间的右端点<code>numbers[R]</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int minArray(vector&lt;int&gt;&amp; numbers) &#123;</span><br><span class="line">    if(numbers.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int L=0,R=numbers.size()-1;</span><br><span class="line">    while(L&lt;R)&#123;</span><br><span class="line">        int mid = (L+R)/2;</span><br><span class="line">        if(numbers[mid]&lt;numbers[R])</span><br><span class="line">            R=mid;</span><br><span class="line">        else if(numbers[mid]&gt;numbers[R])</span><br><span class="line">            L=mid+1;</span><br><span class="line">        else&#123;</span><br><span class="line">            R--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return numbers[R];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p></li></ol><h1 id="7月23日-64-最小路径和（中等）"><a href="#7月23日-64-最小路径和（中等）" class="headerlink" title="7月23日 64. 最小路径和（中等）"></a>7月23日 <a href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和（中等）</a></h1><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明</strong>：每次只能向下或者向右移动一步。</p><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><p>题解：</p><ol><li><p>二维dp。<br><code>dp[i][j]</code>表示走到第i行第j列格子时的最小值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    if(grid.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int m = grid.size(),n=grid[0].size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(m+1,vector&lt;int&gt;(n+1,INT_MAX));</span><br><span class="line">    dp[1][1] = grid[0][0];</span><br><span class="line">    for(int i = 1;i&lt;=m;i++)&#123;</span><br><span class="line">        for(int j = 1;j&lt;=n;j++)&#123;</span><br><span class="line">            if(i==1&amp;&amp;j==1)</span><br><span class="line">                continue;</span><br><span class="line">            dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p></li><li><p>一维dp。<br>因为只用到了上一行的dp，所以二维dp可以优化为一维。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    if(grid.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int m = grid.size(),n=grid[0].size();</span><br><span class="line">    vector&lt;int&gt; dp(n,0);</span><br><span class="line">    </span><br><span class="line">    dp[0] = grid[0][0];</span><br><span class="line">    for(int i = 1;i&lt;n;i++)</span><br><span class="line">        dp[i] = grid[0][i]+dp[i-1];</span><br><span class="line">    </span><br><span class="line">    for(int i = 1;i&lt;m;i++)&#123;</span><br><span class="line">        for(int j = 0;j&lt;n;j++)&#123;</span><br><span class="line">            if(j==0)</span><br><span class="line">                dp[j] = dp[j]+grid[i][0];</span><br><span class="line">            else</span><br><span class="line">                dp[j] = min(dp[j-1],dp[j])+grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(mn)<br>空间复杂度：O(n)</p></li></ol><h1 id="7月24日-1025-除数博弈（简单）"><a href="#7月24日-1025-除数博弈（简单）" class="headerlink" title="7月24日 1025. 除数博弈（简单）"></a>7月24日 <a href="https://leetcode-cn.com/problems/divisor-game/">1025. 除数博弈（简单）</a></h1><p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</p><p>最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：</p><p>选出任一 x，满足 0 &lt; x &lt; N 且 N % x &#x3D;&#x3D; 0 。<br>用 N - x 替换黑板上的数字 N 。<br>如果玩家无法执行这些操作，就会输掉游戏。</p><p>只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：true</span><br><span class="line">解释：爱丽丝选择 1，鲍勃无法进行操作。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：false</span><br><span class="line">解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</span><br></pre></td></tr></table></figure><p>题解：</p><ol><li><p>dp。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool divisorGame(int N) &#123;</span><br><span class="line">    vector&lt;bool&gt; dp(N+1,false);</span><br><span class="line">    dp[1] = false;</span><br><span class="line">    dp[2]= true;</span><br><span class="line">    int n=N;</span><br><span class="line">    for(int i=3;i&lt;=N;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;i;j++)&#123;</span><br><span class="line">            if(i % j == 0 &amp;&amp; !dp[i - j])&#123;</span><br><span class="line">                dp[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N^2)<br>空间复杂度：O(N)</p></li><li><p>归纳法。N 为奇数的时候 Alice（先手）必败，N 为偶数的时候 Alice 必胜。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool divisorGame(int N) &#123;</span><br><span class="line">    return N % 2 == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)<br>空间复杂度：O(1)</p></li></ol><h1 id="7月25日-410-分割数组的最大值（困难）"><a href="#7月25日-410-分割数组的最大值（困难）" class="headerlink" title="7月25日 410. 分割数组的最大值（困难）"></a>7月25日 <a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值（困难）</a></h1><p>给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。</p><p><strong>注意</strong>:<br>数组长度 n 满足以下条件:</p><ul><li>1 ≤ n ≤ 1000</li><li>1 ≤ m ≤ min(50, n)</li></ul><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums = [7,2,5,10,8]</span><br><span class="line">m = 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">一共有四种方法将nums分割为2个子数组。</span><br><span class="line">其中最好的方式是将其分为[7,2,5] 和 [10,8]，</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br></pre></td></tr></table></figure><p>题解：</p><ol><li>dp。<code>dp[i][j]</code>表示前i个数被分成j段的答案。<code>dp[i][j]</code>的状态转移方程为：<ul><li><code>dp[i][j] = min(max(dp[k][j-1],subSum(k+1,i)))</code></li></ul></li></ol><p>其中<code>min</code>里需要枚举k&#x3D;[0,i)，subSum(k+1,i)表示nums[k+1]到nums[i]的和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int splitArray(vector&lt;int&gt;&amp; nums, int m) &#123;</span><br><span class="line">    vector&lt;vector&lt;long long&gt; &gt; dp(nums.size() + 1, vector&lt;long long&gt;(m + 1, LLONG_MAX));</span><br><span class="line"></span><br><span class="line">    vector&lt;long long&gt; preSum(nums.size() + 1, 0);</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= nums.size();i++)</span><br><span class="line">        preSum[i] = preSum[i - 1] + nums[i-1];</span><br><span class="line"></span><br><span class="line">    dp[0][0] = 0;</span><br><span class="line">    for (int i = 1; i &lt;= nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= min(m, i); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int k = 0; k &lt; i; k++)</span><br><span class="line">                dp[i][j] = min(dp[i][j], max(dp[k][j - 1], preSum[i] - preSum[k]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (int)dp[nums.size()][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(m * n^2)<br>空间复杂度：O(mn)</p><h1 id="7月26日-329-矩阵中的最长递增路径（困难）"><a href="#7月26日-329-矩阵中的最长递增路径（困难）" class="headerlink" title="7月26日 329. 矩阵中的最长递增路径（困难）"></a>7月26日 <a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径（困难）</a></h1><p>给定一个整数矩阵，找出最长递增路径的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = </span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure><p>题解：<br>有记忆的dfs。<br>普通dfs会超时，所以加了二位矩阵来记录已经得到的最长序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">int dfs(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int i, int j, vector&lt;vector&lt;int&gt; &gt; &amp;memo)&#123;</span><br><span class="line">    if(memo[i][j]!=0)</span><br><span class="line">        return memo[i][j];</span><br><span class="line">    memo[i][j] = 1;</span><br><span class="line">    for(auto d:dirs)&#123;</span><br><span class="line">        if (i + d[0] &gt;= 0 &amp;&amp; i + d[0] &lt; matrix.size() </span><br><span class="line">            &amp;&amp; j + d[1] &gt;= 0 &amp;&amp; j + d[1] &lt; matrix[0].size() </span><br><span class="line">            &amp;&amp; matrix[i + d[0]][j + d[1]] &gt; matrix[i][j])</span><br><span class="line">            memo[i][j] = max(memo[i][j], dfs(matrix, i + d[0], j + d[1], memo) + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return memo[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int longestIncreasingPath(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123;</span><br><span class="line">    if(matrix.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int m = matrix.size(), n = matrix[0].size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; memo(m, vector&lt;int&gt;(n, 0));</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            res = max(res, dfs(matrix, i, j, memo));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p><h1 id="7月27日-392-判断子序列（简单）"><a href="#7月27日-392-判断子序列（简单）" class="headerlink" title="7月27日 392. 判断子序列（简单）"></a>7月27日 <a href="https://leetcode-cn.com/problems/is-subsequence/">392. 判断子序列（简单）</a></h1><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p><p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~&#x3D; 500,000），而 s 是个短字符串（长度 &lt;&#x3D;100）。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">返回 true.</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;axc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">返回 false.</span><br></pre></td></tr></table></figure><p>后续挑战：<br>如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p><p>题解：<br>双指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool isSubsequence(string s, string t) &#123;</span><br><span class="line">    if(t.empty())&#123;</span><br><span class="line">        if(s.empty())</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int idxS=0,idxT=0;</span><br><span class="line">    while(idxS&lt;s.size() &amp;&amp; idxT&lt;t.size())&#123;</span><br><span class="line">        if(s[idxS]==t[idxT])</span><br><span class="line">            idxS++;</span><br><span class="line">        idxT++;</span><br><span class="line">    &#125;</span><br><span class="line">    return idxS==s.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(m+n)<br>空间复杂度：O(1)</p><h1 id="7月28日-104-二叉树的最大深度（简单）"><a href="#7月28日-104-二叉树的最大深度（简单）" class="headerlink" title="7月28日 104. 二叉树的最大深度（简单）"></a>7月28日 <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度（简单）</a></h1><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明</strong>: 叶子节点是指没有子节点的节点。</p><p>示例：<br><code>给定二叉树 [3,9,20,null,null,15,7]，     3    / \   9  20     /  \    15   7 返回它的最大深度 3 。</code></p><p>题解：</p><ol><li><p>层序遍历（BFS）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int maxDepth(TreeNode* root)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return 0;</span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">    que.push(root);</span><br><span class="line">    int hight = 0;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        hight++;</span><br><span class="line">        int n = que.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *curNode = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            if(curNode-&gt;left!=nullptr)</span><br><span class="line">                que.push(curNode-&gt;left);</span><br><span class="line">            if(curNode-&gt;right!=nullptr)</span><br><span class="line">                que.push(curNode-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return hight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p></li><li><p>递归。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int maxDepth(TreeNode* root)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return 0;</span><br><span class="line">    return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(hight)</p></li></ol><h1 id="7月29日-LCP-13-寻宝（困难）"><a href="#7月29日-LCP-13-寻宝（困难）" class="headerlink" title="7月29日 LCP 13. 寻宝（困难）"></a>7月29日 <a href="https://leetcode-cn.com/problems/xun-bao/">LCP 13. 寻宝（困难）</a></h1><p>我们得到了一副藏宝图，藏宝图显示，在一个迷宫中存在着未被世人发现的宝藏。</p><p>迷宫是一个二维矩阵，用一个字符串数组表示。它标识了唯一的入口（用 ‘S’ 表示），和唯一的宝藏地点（用 ‘T’ 表示）。但是，宝藏被一些隐蔽的机关保护了起来。在地图上有若干个机关点（用 ‘M’ 表示），只有所有机关均被触发，才可以拿到宝藏。</p><p>要保持机关的触发，需要把一个重石放在上面。迷宫中有若干个石堆（用 ‘O’ 表示），每个石堆都有无限个足够触发机关的重石。但是由于石头太重，我们一次只能搬一个石头到指定地点。</p><p>迷宫中同样有一些墙壁（用 ‘#’ 表示），我们不能走入墙壁。剩余的都是可随意通行的点（用 ‘.’ 表示）。石堆、机关、起点和终点（无论是否能拿到宝藏）也是可以通行的。</p><p>我们每步可以选择向上&#x2F;向下&#x2F;向左&#x2F;向右移动一格，并且不能移出迷宫。搬起石头和放下石头不算步数。那么，从起点开始，我们最少需要多少步才能最后拿到宝藏呢？如果无法拿到宝藏，返回 -1 。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： [&quot;S#O&quot;, &quot;M..&quot;, &quot;M.T&quot;]</span><br><span class="line"></span><br><span class="line">输出：16</span><br><span class="line"></span><br><span class="line">解释：最优路线为： S-&gt;O, cost = 4, 去搬石头 O-&gt;第二行的M, cost = 3, M机关触发 第二行的M-&gt;O, cost = 3, 我们需要继续回去 O 搬石头。 O-&gt;第三行的M, cost = 4, 此时所有机关均触发 第三行的M-&gt;T, cost = 2，去T点拿宝藏。 总步数为16。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： [&quot;S#O&quot;, &quot;M.#&quot;, &quot;M.T&quot;]</span><br><span class="line"></span><br><span class="line">输出：-1</span><br><span class="line"></span><br><span class="line">解释：我们无法搬到石头触发机关</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： [&quot;S#O&quot;, &quot;M.T&quot;, &quot;M..&quot;]</span><br><span class="line"></span><br><span class="line">输出：17</span><br><span class="line"></span><br><span class="line">解释：注意终点也是可以通行的。</span><br></pre></td></tr></table></figure><p>限制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= maze.length &lt;= 100</span><br><span class="line">1 &lt;= maze[i].length &lt;= 100</span><br><span class="line">maze[i].length == maze[j].length</span><br><span class="line">S 和 T 有且只有一个</span><br><span class="line">0 &lt;= M的数量 &lt;= 16</span><br><span class="line">0 &lt;= O的数量 &lt;= 40，题目保证当迷宫中存在 M 时，一定存在至少一个 O 。</span><br></pre></td></tr></table></figure><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">int dx[4] = &#123;1, -1, 0, 0&#125;;</span><br><span class="line">int dy[4] = &#123;0, 0, 1, -1&#125;;</span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">bool inBound(int x, int y) &#123;</span><br><span class="line">    return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; bfs(int x, int y, vector&lt;string&gt;&amp; maze) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ret(n, vector&lt;int&gt;(m, -1));</span><br><span class="line">    ret[x][y] = 0;</span><br><span class="line">    queue&lt;pair&lt;int, int&gt;&gt; Q;</span><br><span class="line">    Q.push(&#123;x, y&#125;);</span><br><span class="line">    while (!Q.empty()) &#123;</span><br><span class="line">        auto p = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        int x = p.first, y = p.second;</span><br><span class="line">        for (int k = 0; k &lt; 4; k++) &#123;</span><br><span class="line">            int nx = x + dx[k], ny = y + dy[k];</span><br><span class="line">            if (inBound(nx, ny) &amp;&amp; maze[nx][ny] != &#x27;#&#x27; &amp;&amp; ret[nx][ny] == -1) &#123;</span><br><span class="line">                ret[nx][ny] = ret[x][y] + 1;</span><br><span class="line">                Q.push(&#123;nx, ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int minimalSteps(vector&lt;string&gt;&amp; maze) &#123;</span><br><span class="line">    n = maze.size(), m = maze[0].size();</span><br><span class="line">    // 机关 &amp; 石头</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; buttons, stones;</span><br><span class="line">    // 起点 &amp; 终点</span><br><span class="line">    int sx, sy, tx, ty;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (maze[i][j] == &#x27;M&#x27;) &#123;</span><br><span class="line">                buttons.push_back(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (maze[i][j] == &#x27;O&#x27;) &#123;</span><br><span class="line">                stones.push_back(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (maze[i][j] == &#x27;S&#x27;) &#123;</span><br><span class="line">                sx = i, sy = j;</span><br><span class="line">            &#125;</span><br><span class="line">            if (maze[i][j] == &#x27;T&#x27;) &#123;</span><br><span class="line">                tx = i, ty = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int nb = buttons.size();</span><br><span class="line">    int ns = stones.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; start_dist = bfs(sx, sy, maze);</span><br><span class="line"></span><br><span class="line">    // 边界情况：没有机关</span><br><span class="line">    if (nb == 0) &#123;</span><br><span class="line">        return start_dist[tx][ty];</span><br><span class="line">    &#125;</span><br><span class="line">    // 从某个机关到其他机关 / 起点与终点的最短距离。</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dist(nb, vector&lt;int&gt;(nb + 2, -1));</span><br><span class="line">    // 中间结果</span><br><span class="line">    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dd(nb);</span><br><span class="line">    for (int i = 0; i &lt; nb; i++) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; d = bfs(buttons[i].first, buttons[i].second, maze);</span><br><span class="line">        dd[i] = d;</span><br><span class="line">        // 从某个点到终点不需要拿石头</span><br><span class="line">        dist[i][nb + 1] = d[tx][ty];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nb; i++) &#123;</span><br><span class="line">        int tmp = -1;</span><br><span class="line">        for (int k = 0; k &lt; ns; k++) &#123;</span><br><span class="line">            int mid_x = stones[k].first, mid_y = stones[k].second;</span><br><span class="line">            if (dd[i][mid_x][mid_y] != -1 &amp;&amp; start_dist[mid_x][mid_y] != -1) &#123;</span><br><span class="line">                if (tmp == -1 || tmp &gt; dd[i][mid_x][mid_y] + start_dist[mid_x][mid_y]) &#123;</span><br><span class="line">                    tmp = dd[i][mid_x][mid_y] + start_dist[mid_x][mid_y];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dist[i][nb] = tmp;</span><br><span class="line">        for (int j = i + 1; j &lt; nb; j++) &#123;</span><br><span class="line">            int mn = -1;</span><br><span class="line">            for (int k = 0; k &lt; ns; k++) &#123;</span><br><span class="line">                int mid_x = stones[k].first, mid_y = stones[k].second;</span><br><span class="line">                if (dd[i][mid_x][mid_y] != -1 &amp;&amp; dd[j][mid_x][mid_y] != -1) &#123;</span><br><span class="line">                    if (mn == -1 || mn &gt; dd[i][mid_x][mid_y] + dd[j][mid_x][mid_y]) &#123;</span><br><span class="line">                        mn = dd[i][mid_x][mid_y] + dd[j][mid_x][mid_y];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dist[i][j] = mn;</span><br><span class="line">            dist[j][i] = mn;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 无法达成的情形</span><br><span class="line">    for (int i = 0; i &lt; nb; i++) &#123;</span><br><span class="line">        if (dist[i][nb] == -1 || dist[i][nb + 1] == -1) return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // dp 数组， -1 代表没有遍历到</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp(1 &lt;&lt; nb, vector&lt;int&gt;(nb, -1));</span><br><span class="line">    for (int i = 0; i &lt; nb; i++) &#123;</span><br><span class="line">        dp[1 &lt;&lt; i][i] = dist[i][nb];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 由于更新的状态都比未更新的大，所以直接从小到大遍历即可</span><br><span class="line">    for (int mask = 1; mask &lt; (1 &lt;&lt; nb); mask++) &#123;</span><br><span class="line">        for (int i = 0; i &lt; nb; i++) &#123;</span><br><span class="line">            // 当前 dp 是合法的</span><br><span class="line">            if (mask &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">                for (int j = 0; j &lt; nb; j++) &#123;</span><br><span class="line">                    // j 不在 mask 里</span><br><span class="line">                    if (!(mask &amp; (1 &lt;&lt; j))) &#123;</span><br><span class="line">                        int next = mask | (1 &lt;&lt; j);</span><br><span class="line">                        if (dp[next][j] == -1 || dp[next][j] &gt; dp[mask][i] + dist[i][j]) &#123;</span><br><span class="line">                            dp[next][j] = dp[mask][i] + dist[i][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ret = -1;</span><br><span class="line">    int final_mask = (1 &lt;&lt; nb) - 1;</span><br><span class="line">    for (int i = 0; i &lt; nb; i++) &#123;</span><br><span class="line">        if (ret == -1 || ret &gt; dp[final_mask][i] + dist[i][nb + 1]) &#123;</span><br><span class="line">            ret = dp[final_mask][i] + dist[i][nb + 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7月30日-343-整数拆分（中等）"><a href="#7月30日-343-整数拆分（中等）" class="headerlink" title="7月30日 343. 整数拆分（中等）"></a>7月30日 <a href="https://leetcode-cn.com/problems/integer-break/">343. 整数拆分（中等）</a></h1><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</span><br></pre></td></tr></table></figure><p><strong>说明</strong>: 你可以假设 n 不小于 2 且不大于 58。</p><p>题解：</p><ol><li>dp。<br><code>dp[i]</code>表示数字i分解后能达到的最大积。可以分为两种情况：</li></ol><ul><li>1）i分解为j和i-j两个数；</li><li>2）i分解为j和i-j后，i-j还可以再分解，其最大积为<code>dp[i-j]</code>。</li><li>枚举1~i-1每一个点，看哪个点分解后的积最大<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int integerBreak(int n) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(n+1,0);</span><br><span class="line">    for (int i = 2; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>时间复杂度：O(n^2)<br>空间复杂度：O(n)</li></ul><h1 id="7月31日-程序员面试金典-面试题-08-03-魔术索引（简单）"><a href="#7月31日-程序员面试金典-面试题-08-03-魔术索引（简单）" class="headerlink" title="7月31日 程序员面试金典 面试题 08.03. 魔术索引（简单）"></a>7月31日 <a href="https://leetcode-cn.com/problems/magic-index-lcci/">程序员面试金典 面试题 08.03. 魔术索引（简单）</a></h1><p>魔术索引。 在数组<code>A[0…n-1]</code>中，有所谓的魔术索引，满足条件<code>A[i] = i</code>。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。</p><p>示例1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0, 2, 3, 4, 5]</span><br><span class="line">输出：0</span><br><span class="line">说明: 0下标的元素为0</span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1, 1, 1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示</strong>: nums长度在[1, 1000000]之间</p><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int findMagicIndex(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">        if(nums[i]==i)</span><br><span class="line">            return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>]]></content>
    
    
    <summary type="html">7月份每日一题</summary>
    
    
    
    <category term="Algorithm" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/Algorithm/"/>
    
    
    <category term="Leetcode daily" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/Leetcode-daily/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2020/06/20/dataStructure/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2020/06/20/dataStructure/</id>
    <published>2020-06-19T16:30:00.000Z</published>
    <updated>2020-08-19T14:41:24.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表和数组的区别在哪里？"><a href="#链表和数组的区别在哪里？" class="headerlink" title="链表和数组的区别在哪里？"></a>链表和数组的区别在哪里？</h1><p>链表和数组都可以叫线性表，数组又叫顺序表，主要区别在于：</p><ul><li>存储形式：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间，长度可变，每个结点要保存相邻结点指针。</li><li>数据查找：数组的线性查找速度快，查找操作直接使用偏移地址。链表需要按顺序检索结点，效率低。</li><li>数据插入或删除：链表可以快速插入和删除结点，而数组则可能需要大量数据移动。</li><li>越界问题：链表不存在越界问题，数组有越界问题。</li></ul><p><em>说明：在选择数组或链表数据结构时，一定要根据实际需要进行选择。数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。</em></p><h1 id="hash冲突怎么办"><a href="#hash冲突怎么办" class="headerlink" title="hash冲突怎么办"></a>hash冲突怎么办</h1><ol><li>开放地址法<ul><li>线性探测</li><li>二次探测：左右左右…</li><li>伪随机数</li></ul></li><li>再哈希法</li><li>链地址法</li><li>建立公共溢出区</li></ol><h1 id="HashMap扩容机制"><a href="#HashMap扩容机制" class="headerlink" title="HashMap扩容机制"></a>HashMap扩容机制</h1><p>HashMap的容量是有限的。当经过多次元素插入的时候，使得HashMap达到一定的饱和度，Key映射位置的几率不断变大。这个时候（扩容因子&#x3D;0.75），HashMap就需要扩容了，也就是Resize。一般是增加1倍。</p><p><em>扩容因子：数组中元素的个数&#x2F;数组容量</em></p><h1 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h1><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树是一颗多路平衡查找树。</p><ul><li>每个节点最多有m-1个关键字（可以存有的键值对）。</li><li>根节点最少可以只有1个关键字。</li><li>非根节点至少有m&#x2F;2个关键字。</li><li>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li><li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。</li><li>每个节点都存有索引和数据，也就是对应的key和value。</li></ul><p>所以，根节点的关键字数量范围：1 &lt;&#x3D; k &lt;&#x3D; m-1，非根节点的关键字数量范围：m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m-1。</p><p>另外，我们需要注意一个概念，描述一颗B树时需要指定它的阶数，阶数表示了一个节点最多有多少个孩子节点，一般用字母m表示阶数。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树其实和B树是非常相似的。</p><p>相同点：</p><ul><li>根节点至少一个元素</li><li>非根节点元素范围：m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m-1</li></ul><p>不同点：</p><ul><li>B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。</li><li>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。</li><li>每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。</li><li>父节点存有右孩子的第一个元素的索引。</li></ul><h2 id="B-树相对于B树的优势"><a href="#B-树相对于B树的优势" class="headerlink" title="B+树相对于B树的优势"></a>B+树相对于B树的优势</h2><p>可以归结为下面几点：</p><ul><li>单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。</li><li>所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。</li><li>所有的叶子节点形成了一个有序链表，更加便于查找。</li><li>叶子结点连起来还可以范围查询。</li></ul><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p><strong>平衡二叉树</strong>就是为了解决<strong>二叉查找树</strong>退化成一颗链表而诞生。</p><p>虽然<strong>平衡树</strong>解决了<strong>二叉查找树</strong>退化为近似链表的缺点，能够把查找时间控制在 O(logn)，不过却不是最佳的，因为平衡树要求每个节点的左子树和右子树的高度差至多等于1，这个要求实在是太严了，导致每次进行插入&#x2F;删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的<strong>平衡树</strong>。</p><p>显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了<strong>红黑树</strong>，<strong>红黑树</strong>具有如下特点：</p><ol><li>具有二叉查找树的特点；</li><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据；</li><li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的(但是黑色节点可以相连)；</li><li>每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。</li></ol><h2 id="红黑树和AVL树的区别："><a href="#红黑树和AVL树的区别：" class="headerlink" title="红黑树和AVL树的区别："></a>红黑树和AVL树的区别：</h2><p>AVL 和 RBT 都是二叉查找树的优化。其性能要远远好于二叉查找树。他们之间都有自己的优势，其应用上也有不同。</p><ul><li>结构对比：AVL的结构高度平衡，RBT的结构基本平衡。平衡度AVL &gt; RBT.</li><li>查找对比：AVL 查找时间复杂度最好，最坏情况都是O(logN)。RBT 查找时间复杂度最好为O(logN)，最坏情况下比AVL略差。</li><li>插入删除对比：<ol><li>AVL的插入和删除结点很容易造成树结构的不平衡，而RBT的平衡度要求较低。因此在大量数据插入的情况下，RBT需要通过旋转变色操作来重新达到平衡的频度要小于AVL。</li><li>如果需要平衡处理时，RBT比AVL多一种变色操作，而且变色的时间复杂度在O(logN)数量级上。但是由于操作简单，所以在实践中这种变色仍然是非常快速的。</li><li>当插入一个结点都引起了树的不平衡，AVL和RBT都最多需要2次旋转操作。但删除一个结点引起不平衡后，AVL最多需要logN 次旋转操作，而RBT最多只需要3次。因此两者插入一个结点的代价差不多，但删除一个结点的代价RBT要低一些。</li><li>AVL和RBT的插入删除代价主要还是消耗在查找待操作的结点上。因此时间复杂度基本上都是与O(logN) 成正比的。</li></ol></li></ul><h1 id="3老鼠确定8瓶子原理"><a href="#3老鼠确定8瓶子原理" class="headerlink" title="3老鼠确定8瓶子原理"></a>3老鼠确定8瓶子原理</h1><ol><li>二分法：每次取一半混合给小鼠喝。但是瓶子太多就不好混合了。</li><li>二进制：每只老鼠代表一位，n只老鼠可以检测2^n个瓶子。</li></ol>]]></content>
    
    
    <summary type="html">数据结构笔记</summary>
    
    
    
    <category term="CS" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/CS/"/>
    
    
    <category term="data structure" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2020/06/20/database/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2020/06/20/database/</id>
    <published>2020-06-19T16:30:00.000Z</published>
    <updated>2020-08-18T09:27:15.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h1><ul><li><p>1NF(第一范式)<br>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。1NF是所有关系型数据库的最基本要求 ，也就是说关系型数据库中创建的表一定满足第一范式。</p></li><li><p>2NF(第二范式)<br>2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p></li><li><p>3NF(第三范式)<br>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖 。符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系R(学号 ,姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合3NF的要求。</p></li><li><p>总结</p><ul><li>1NF：属性不可再分。</li><li>2NF：1NF的基础之上，消除了非主属性对于码的部分函数依赖。</li><li>3NF：3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖 。</li></ul></li></ul><p>ref.</p><ul><li><a href="https://blog.csdn.net/Wenco1/article/details/88077279?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase">详解第一范式、第二范式、第三范式、BCNF范式</a></li><li><a href="https://blog.csdn.net/wyh7280/article/details/83350722?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.nonecase">范式通俗理解：1NF、2NF、3NF和BNCF</a></li></ul><h1 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h1><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p>关系型数据库，是指采用了<strong>关系模型</strong>来组织数据的数据库。</p><p>主要代表：SQL Server, Oracle, Mysql, PostgreSQL</p><p>关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。关系模型中常用的概念：</p><ul><li>关系：可以理解为一张二维表，每个关系都具有一个关系名，就是通常说的表名</li><li>元组：可以理解为二维表中的一行，在数据库中经常被称为记录</li><li>属性：可以理解为二维表中的一列，在数据库中经常被称为字段</li><li>域：属性的取值范围，也就是数据库中某一列的取值限制</li><li>关键字：一组可以唯一标识元组的属性，数据库中常称为主键，由一个或多个列组成</li><li>关系模式：指对关系的描述。其格式为：关系名(属性1，属性2， … … ，属性N)，在数据库中成为表结构</li><li>码：码就是能唯一标识实体的属性，对应表中的列。</li><li>候选码： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li><li>主码：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li><li>外码：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li><li>主属性：候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）.显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li><li>非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li></ul><p>关系型数据库的优点：</p><ul><li>容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解</li><li>使用方便：通用的SQL语言使得操作关系型数据库非常方便</li><li>易于维护：数据库的ACID属性，大大减低了数据冗余和数据不一致的概率</li></ul><p>关系型数据库的瓶颈：</p><ul><li>海量数据的读写效率：对于网站的并发量高，往往达到每秒上万次的请求，对于传统关系型数据库来说，硬盘I&#x2F;o是一个很大的挑战。</li><li>高扩展性和可用性：在基于web的结构中，数据库是最难以横向拓展的，当一个应用系统的用户量和访问量与日俱增的时候，数据库没有办法像web Server那样简单的通过添加更多的硬件和服务节点来拓展性能和负载能力。</li></ul><h2 id="主键和外键有什么区别"><a href="#主键和外键有什么区别" class="headerlink" title="主键和外键有什么区别"></a>主键和外键有什么区别</h2><ul><li>主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li><li>外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li></ul><h2 id="非关系型数据库-NoSQL"><a href="#非关系型数据库-NoSQL" class="headerlink" title="非关系型数据库 NoSQL"></a>非关系型数据库 NoSQL</h2><p>主要指那些非关系型的、分布式的，且一般不保证ACID的数据存储系统。依据结构化方法以及应用场合的不同，主要分为以下几类：</p><ol><li>面向高性能并发读写的key-value数据库：key-value数据库的主要特点即使具有极高的并发读写性能，Redis,Tokyo Cabinet,Flare就是这类的代表</li><li>面向海量数据访问的面向文档数据库：这类数据库的特点是，可以在海量的数据中快速的查询数据，典型代表为MongoDB以及CouchDB</li><li>面向可扩展性的分布式数据库：这类数据库想解决的问题就是传统数据库存在可扩展性上的缺陷，这类数据库可以适应数据量的增加以及数据结构的变化</li></ol><p>缺点：但是由于Nosql约束少，所以也不能够像sql那样提供where字段属性的查询。因此适合存储较为简单的数据。有一些不能够持久化数据，所以需要和关系型数据库结合。</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul><li><a href="https://blog.csdn.net/oChangWen/article/details/53423301">关系型数据库和非关系型数据库区别、oracle与mysql的区别</a></li><li><a href="https://blog.csdn.net/lzj3462144/article/details/70973368?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param">关系型数据库 VS 非关系型数据库</a></li></ul><h1 id="主键索引和唯一索引区别"><a href="#主键索引和唯一索引区别" class="headerlink" title="主键索引和唯一索引区别"></a>主键索引和唯一索引区别</h1><p>唯一索引的值可以为null吗<br>主键索引的值可以为null吗<br>一个表有几个主键<br>一个表可以有多个唯一索引吗</p><h1 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h1><h1 id="数据库事务的4个特征（ACID特性）"><a href="#数据库事务的4个特征（ACID特性）" class="headerlink" title="数据库事务的4个特征（ACID特性）"></a>数据库事务的4个特征（ACID特性）</h1><ul><li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li><li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li><li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li>持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</li></ul><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>隔离级别越高，性能越低</p><ol><li>Serializable（串行化）：可避免脏读、不可重复读、虚读情况的发生；</li><li>Reapeatable read（可重复读）：可避免脏读、不可重复读的情况的发生；</li><li>Read Committed（读已提交）：可避免脏读的情况</li><li>Read uncommitted（读未提交）：最低级别，任何情况均无法保证；</li></ol><h1 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h1><ul><li><a href="https://www.nowcoder.com/discuss/468424?source_id=profile_create&channel=1011">面试题之数据库</a></li></ul>]]></content>
    
    
    <summary type="html">数据库笔记</summary>
    
    
    
    <category term="CS" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/CS/"/>
    
    
    <category term="database" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2020/06/10/network/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2020/06/10/network/</id>
    <published>2020-06-10T09:00:00.000Z</published>
    <updated>2020-10-14T07:29:18.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h1><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>计算机网络体系结构是指计算机网络层次结构模型，它是各层的协议以及层次之间的端口的集合。在计算机网络中实现通信必须依靠网络通信协议，目前广泛采用的是国际标准化组织（ISO）1997年提出的开放系统互联（Open System Interconnection，OSI）参考模型，习惯上称为ISO&#x2F;OSI参考模型。</p><span id="more"></span><h2 id="不同的网络体系结构"><a href="#不同的网络体系结构" class="headerlink" title="不同的网络体系结构"></a>不同的网络体系结构</h2><h3 id="OSI七层协议体系结构"><a href="#OSI七层协议体系结构" class="headerlink" title="OSI七层协议体系结构"></a>OSI七层协议体系结构</h3><p>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。</p><p>OSI七层协议模型主要包括是：</p><ul><li>应用层（Application）</li><li>表示层（Presentation）</li><li>会话层（Session）</li><li>运输层（Transport）</li><li>网络层（Network）</li><li>数据链路层（Data Link）</li><li>物理层（Physical）</li></ul><h3 id="TCP-x2F-IP四层体系结构"><a href="#TCP-x2F-IP四层体系结构" class="headerlink" title="TCP&#x2F;IP四层体系结构"></a>TCP&#x2F;IP四层体系结构</h3><p>TCP&#x2F;IP 是一个四层体系结构，主要包括：</p><ul><li>应用层</li><li>运输层</li><li>网际层（用网际层这个名字是强调这一层是为了解决不同网络的互连问题）</li><li>网络接口层</li></ul><p>不过从实质上讲，TCP&#x2F;IP 只有最上面的三层，因为最下面的网络接口层并没有什么具体内容，因此在学习计算机网络的原理时往往采用折中的办法，即综合 OSI 和 TCP&#x2F;IP 的优点，采用一种只有五层协议的体系结构。</p><h3 id="五层协议的体系结构"><a href="#五层协议的体系结构" class="headerlink" title="五层协议的体系结构"></a>五层协议的体系结构</h3><p>五层协议的体系结构主要包括：</p><ul><li>应用层</li><li>运输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><p><img src="https://i.loli.net/2020/06/09/wvthjWo3nSCx2NP.png" alt="不同体系结构对比"></p><p><em>ps. 五层协议的体系结构只是为了介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构。</em></p><h2 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h2><p><img src="https://i.loli.net/2020/06/09/Heb6Y83xwKsiodr.png" alt="TCP/IP四层协议表示方法举例"></p><h2 id="具有五层协议的体系结构"><a href="#具有五层协议的体系结构" class="headerlink" title="具有五层协议的体系结构"></a>具有五层协议的体系结构</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层（application-layer）的任务是通过<strong>应用进程间</strong>的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。</p><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>运输层（transport layer）的主要任务就是负责向<strong>两台主机进程之间</strong>的通信提供<strong>通用的数据传输</strong>服务。应用进程利用该服务传送应用层报文。</p><p>运输层主要使用一下两种协议</p><ul><li>TCP-传输控制协议：提供面向连接的，可靠的数据传输服务</li><li>UDP-用户数据协议：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）</li></ul><h4 id="每一个应用层（TCP-x2F-IP参考模型的最高层）协议一般都会使用到两个传输层协议之一"><a href="#每一个应用层（TCP-x2F-IP参考模型的最高层）协议一般都会使用到两个传输层协议之一" class="headerlink" title="每一个应用层（TCP&#x2F;IP参考模型的最高层）协议一般都会使用到两个传输层协议之一"></a>每一个应用层（TCP&#x2F;IP参考模型的最高层）协议一般都会使用到两个传输层协议之一</h4><p><em>ps. 以下协议是应用层协议：</em></p><p>运行在TCP协议上的协议：</p><ul><li>HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。端口号：80</li><li>HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。端口号：443</li><li>FTP（File Transfer Protocol，文件传输协议），用于文件传输。端口号：21</li><li>POP3（Post Office Protocol, version 3，邮局协议），收邮件用。</li><li>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。</li><li>TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。端口号：23</li><li>SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。</li></ul><p>运行在UDP协议上的协议：</p><ul><li>BOOTP（Boot Protocol，启动协议），应用于无盘设备。</li><li>NTP（Network Time Protocol，网络时间协议），用于网络同步。</li><li>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</li></ul><p>运行在TCP和UDP协议上：</p><ul><li>DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。</li></ul><h3 id="网络层（网际层）"><a href="#网络层（网际层）" class="headerlink" title="网络层（网际层）"></a>网络层（网际层）</h3><p>网络层负责为分组交换网上的不同<strong>主机</strong>提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</p><p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>在物理层上所传送的数据单位是比特。</p><h3 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h3><p><img src="https://i.loli.net/2020/06/09/bgk9DNdcfawv5Fe.png" alt="数据在各层之间的传递过程"></p><h2 id="TCP的三次握手四次挥手"><a href="#TCP的三次握手四次挥手" class="headerlink" title="TCP的三次握手四次挥手"></a>TCP的三次握手四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://i.loli.net/2020/06/10/RQOy2WUYzfbxtmv.png" alt="三次握手"></p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://i.loli.net/2020/06/10/lD6isBec9Oh2zWo.jpg" alt="四次挥手"></p><p>MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><ul><li><strong>CLOSED</strong>：表示初始状态。</li><li><strong>LISTEN</strong>：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</li><li><strong>SYN_SENT</strong>：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</li><li><strong>SYN_RCVD</strong>: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</li><li><strong>ESTABLISHED</strong>：表示连接已经建立。</li><li><strong>FIN_WAIT_1</strong>: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。</li><li><strong>FIN_WAIT_2</strong>：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。</li><li><strong>TIME_WAIT</strong>: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</li><li><strong>CLOSING</strong>: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</li><li><strong>CLOSE_WAIT</strong>: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。</li><li><strong>LAST_ACK</strong>: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。</li></ul><h3 id="半关闭状态"><a href="#半关闭状态" class="headerlink" title="半关闭状态"></a>半关闭状态</h3><p><img src="https://i.loli.net/2020/10/13/WLNRMogAhJYStbO.png" alt="半关闭状态"></p><h3 id="为什么TCP连接的时候是3次，不是2次"><a href="#为什么TCP连接的时候是3次，不是2次" class="headerlink" title="为什么TCP连接的时候是3次，不是2次"></a>为什么TCP连接的时候是3次，不是2次</h3><p>因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。</p><p>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。</p><h3 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h3><p>因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文（所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次）。</p><h3 id="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"><a href="#为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？" class="headerlink" title="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"></a>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h3><p>这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p><h2 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h2 id="TCP和UDP对比"><a href="#TCP和UDP对比" class="headerlink" title="TCP和UDP对比"></a>TCP和UDP对比</h2><table><thead><tr><th align="center"></th><th align="center">UPD</th><th align="center">TCP</th></tr></thead><tbody><tr><td align="center">是否连接</td><td align="center">无连接</td><td align="center">面向连接（3次握手）</td></tr><tr><td align="center">是否可靠</td><td align="center">尽最大努力交付，不保证可靠。不使用流量控制和拥塞控制</td><td align="center">使用流量控制和拥塞控制。可靠服务：无差错、不丢失、不重复、按序到达</td></tr><tr><td align="center">传输方式</td><td align="center">面向报文</td><td align="center">面向字节流</td></tr><tr><td align="center">连接对象个数</td><td align="center">一对一，多对多，多对一，一对多</td><td align="center">一对一</td></tr><tr><td align="center">首部开销</td><td align="center">8字节</td><td align="center">首部最小20字节，最大60字节</td></tr></tbody></table><h2 id="TCP怎么保证可靠"><a href="#TCP怎么保证可靠" class="headerlink" title="TCP怎么保证可靠"></a>TCP怎么保证可靠</h2><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li>校验和：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li>流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li>拥塞控制：当网络拥塞时，减少数据的发送。</li><li>ARQ协议：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li>超时重传：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h2 id="拥塞控制和流量控制"><a href="#拥塞控制和流量控制" class="headerlink" title="拥塞控制和流量控制"></a>拥塞控制和流量控制</h2><p>都是保证TCP可靠的方法。</p><ul><li>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况</li><li>流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的</li></ul><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><ul><li>慢开始：从小到大逐渐增大发送窗口，每个传输轮次后将 cwnd 大小加倍。</li><li>拥塞避免：用慢开始门限（ssthresh）的阈值来控制 cwnd 的增长<ul><li>cwnd &lt; ssthresh , 使用慢开始算法</li><li>cwnd &#x3D; ssthresh , 使用慢开始算法或拥塞避免算法（线性增长，一般是加1）都可以</li><li>cwnd &gt; ssthresh , 使用拥塞避免算法。只要发现网络中出现拥塞就<strong>乘法减小</strong>ssthresh并从cwnd&#x3D;1开始重新执行慢开始算法。</li></ul></li><li>快重传：允许发送方再连续收到 3 个重复的确认后就可以开始执行乘法减小过程而不必再等待所设置的重传计时器到时。</li><li>快恢复：是与快重传算法配合使用的一个算法。快恢复算法后与原来不同的一点是当发现网络出现拥塞并执行了乘法减小过程后，并不是设置cwnd&#x3D;1并重新开始执行慢开始算法，而是让 cwnd &#x3D;乘法减小后的ssthresh并开始执行拥塞避免算法。</li></ul><p><img src="https://i.loli.net/2020/09/25/ZoESaLNlwbrugkv.png" alt="拥塞控制"></p><p><em>ps. ssthresh的设置：TCP&#x2F;IP 中规定无论是在慢开始阶段还是在拥塞避免阶段，只要发现网络中出现拥塞（没有按时收到确认），就要把ssthresh设置为此时发送窗口的一半大小（不能小于2）</em></p><ul><li><a href="https://blog.csdn.net/qq_41431406/article/details/97926927">TCP的拥塞控制（详解）</a></li></ul><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><ul><li>RTT算法</li><li>滑动窗口<ul><li>发送窗口</li><li>接受窗口</li></ul></li></ul><h2 id="使UPD可靠的方法"><a href="#使UPD可靠的方法" class="headerlink" title="使UPD可靠的方法"></a>使UPD可靠的方法</h2><ul><li>超时重传（定时器）</li><li>有序接受 （添加包序号）</li><li>应答确认 （Seq&#x2F;Ack应答机制）</li><li>滑动窗口流量控制等机制 （滑动窗口协议）</li></ul><p>已有协议：</p><ul><li>可靠用户数据报协议（RUDP）：RUDP使用类似于TCP的重发机制和拥塞控制算法</li><li>实时协议（RTP）：有效负载识别，序列编号，时间戳和投递监听</li><li>基于UDP的数据传输协议（UDT）：序列号、滑动窗口</li></ul><h2 id="为什么会发生-TCP-粘包、拆包"><a href="#为什么会发生-TCP-粘包、拆包" class="headerlink" title="为什么会发生 TCP 粘包、拆包"></a>为什么会发生 TCP 粘包、拆包</h2><p>粘包问题是由TCP是“字节流”协议，没有消息边界所引起的。</p><ol><li>应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。</li><li>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。</li><li>进行 MSS （最大报文长度）大小的 TCP 分段，当 <code>TCP报文长度 - TCP头部长度 &gt; MSS</code> 的时候将发生拆包。</li><li>接收方法不及时读取套接字缓冲区数据，这将发生粘包。</li></ol><h2 id="如何处理粘包、拆包？"><a href="#如何处理粘包、拆包？" class="headerlink" title="如何处理粘包、拆包？"></a>如何处理粘包、拆包？</h2><p>解决粘包的方法就是由应用层进行分包处理，本质上就是由应用层来维护消息和消息的边界。</p><ol><li>使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。</li><li>设置定长消息，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。</li><li>设置消息边界，服务端从网络流中按消息编辑分离出消息内容，一般使用‘\n’。</li><li>更为复杂的协议。</li></ol><h2 id="简述Socket通信基本步骤"><a href="#简述Socket通信基本步骤" class="headerlink" title="简述Socket通信基本步骤"></a>简述Socket通信基本步骤</h2><p>具体分成两个部分：</p><ol><li>服务端<ul><li>socket(创建socket) </li><li>bind(绑定socket和端口号) </li><li>listen(监听该端口号)</li><li>accept(等待并接受客户端连接请求)</li><li>read,write(读取数据和返回数据) </li><li>close(关闭socket)</li></ul></li><li>客户端<ul><li>socket(创建socket) </li><li>connect(连接指定的端口) </li><li>read,write(读取数据和返回数据) </li><li>close(关闭socket)</li></ul></li></ol><h2 id="GET、POST的区别"><a href="#GET、POST的区别" class="headerlink" title="GET、POST的区别"></a>GET、POST的区别</h2><ul><li>作用<br>GET 用于获取资源，而 POST 用于传输数据。</li><li>参数<br>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。</li><li>安全<br>GET 方法是安全的，而 POST 却不是。安全就是说请求方法不会改变服务器状态，也就是说它只是可读的。因为 POST 的目的是传送数据，这个数据可能是用户上传的表单，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。所以，从这个方面来讲，POST是不安全的。</li><li>幂等<br>GET方法都是幂等的，但 POST 方法不是。幂等就是说，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。所以，幂等方法不应该具有副作用。</li></ul><h2 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h2><ol><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><p>HTTPS是运行在SSL&#x2F;TLS之上的HTTP协议，SSL&#x2F;TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p><h2 id="SSL四次握手"><a href="#SSL四次握手" class="headerlink" title="SSL四次握手"></a>SSL四次握手</h2><p><img src="https://i.loli.net/2020/10/14/Ax72pejscZGi5T4.png" alt="SSL四次握手"></p><ol><li>客户端请求建立SSL链接，并向服务端发送一个<strong>随机数–Client random</strong>和<strong>客户端支持的加密方法</strong>，比如RSA公钥加密，此时是明文传输。</li><li>服务端回复一种客户端<strong>支持的加密方法</strong>、<strong>一个随机数–Server random</strong>、授信的服务器<strong>证书</strong>和<strong>非对称加密的公钥</strong>。</li><li>客户端收到服务端的回复后利用服务端的公钥，加上新的<strong>随机数–Premaster secret</strong> 通过服务端下发的公钥及加密方法进行加密，发送给服务器。</li><li>服务端收到客户端的回复，利用已知的加解密方式进行解密，同时利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key – session key。</li></ol><h2 id="什么是对称加密与非对称加密"><a href="#什么是对称加密与非对称加密" class="headerlink" title="什么是对称加密与非对称加密"></a>什么是对称加密与非对称加密</h2><ul><li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等。这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li></ul><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul><li><a href="https://juejin.im/entry/58d7635e5c497d0057fae036">详细解析HTTP 与HTTPS 的区别</a></li></ul><h2 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h2><ol><li>首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；</li><li>客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；</li><li>消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；</li><li>发送给服务端，此时只有服务端（RSA私钥）能解密。</li><li>解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。</li></ol><h2 id="HTTP长连接，短连接是什么？"><a href="#HTTP长连接，短连接是什么？" class="headerlink" title="HTTP长连接，短连接是什么？"></a>HTTP长连接，短连接是什么？</h2><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><p>在HTTP&#x2F;1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：<code>Connection:keep-alive</code></p><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><h2 id="HTTP版本对比"><a href="#HTTP版本对比" class="headerlink" title="HTTP版本对比"></a>HTTP版本对比</h2><h3 id="HTTP1-0版本的特性："><a href="#HTTP1-0版本的特性：" class="headerlink" title="HTTP1.0版本的特性："></a>HTTP1.0版本的特性：</h3><ul><li>1.0的HTTP版本，是一种无状态、无连接的应用层协议。</li><li>HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</li></ul><h3 id="HTTP1-1版本新特性"><a href="#HTTP1-1版本新特性" class="headerlink" title="HTTP1.1版本新特性"></a>HTTP1.1版本新特性</h3><ul><li>默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</li><li>管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应</li><li>断点续传原理</li></ul><h3 id="HTTP2-0版本的特性"><a href="#HTTP2-0版本的特性" class="headerlink" title="HTTP2.0版本的特性"></a>HTTP2.0版本的特性</h3><ul><li>二进制分帧（采用二进制格式的编码将其封装）</li><li>首部压缩（设置了专门的首部压缩设计的HPACK算法。）</li><li>流量控制（设置了接收某个数据流的多少字节一些流量控制）</li><li>多路复用（可以在共享TCP链接的基础上同时发送请求和响应）</li><li>请求优先级（可以通过优化这些帧的交错和传输顺序进一步优化性能）</li><li>服务器推送（就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资 源无需客户端明确的请求。（重大更新））</li></ul><h3 id="HTTP1-1-和-HTTP2-0-的区别"><a href="#HTTP1-1-和-HTTP2-0-的区别" class="headerlink" title="HTTP1.1 和 HTTP2.0 的区别"></a>HTTP1.1 和 HTTP2.0 的区别</h3><ul><li><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li><li><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li><li><strong>header压缩</strong>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li><strong>服务端推送</strong>（server push），同SPDY一样，HTTP2.0也具有server push功能。</li></ul><p>ref. <a href="https://juejin.im/entry/5981c5df518825359a2b9476">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></p><h2 id="输入URL到显示网页的过程"><a href="#输入URL到显示网页的过程" class="headerlink" title="输入URL到显示网页的过程"></a>输入URL到显示网页的过程</h2><ol><li>DNS解析：简单地说就是找到URL对应的IP地址。</li><li>TCP连接：浏览器与目标服务器建立TCP连接<ul><li>HTTP协议建立在TCP协议之上，HTTP请求前，需先进行TCP连接，形成客户端到服务器的稳定的通道。俗称TCP的三次握手。</li><li>TCP连接完成后，HTTP请求开始，请求有多种方式，常见的有GET，POST等。</li></ul></li><li>发送HTTP请求<ul><li>HTTP请求包含请求头，也可能包含请求体两部分，请求头中包含我们希望对请求文件的操作的信息，请求体中包含传递给后台的参数。</li></ul></li><li>服务器处理请求并返回HTTP报文<ul><li>服务器收到HTTP请求后，后台开始工作，如负载平衡，跨域等，这里就是后端的工作了。</li><li>文件处理完毕，生成响应数据包，响应也包含两部分，响应头和相应体，响应体就是我们所请求的文件。</li><li>经过网络传输，文件被下载到本地客户端，客户端开始加载。</li></ul></li><li>浏览器解析渲染HTML页面<ul><li>客户端浏览器加载了HTML文件后，由上到下解析HTML为DOM树（DOM Tree）。</li><li>遇到CSS文件，CSS中的url发起HTTP请求。</li><li>这是第二次HTTP请求，由于HTTP1.1协议增加了Connection: keep-alive声明，故TCP连接不会关闭，可以复用。</li><li>HTTP连接是无状态连接，客户端与服务器端需要重新发起请求–响应。在请求CSS的过程中，解析器继续解析HTML，然后到了script标签。</li><li>由于script可能会改变DOM结构，故解析器停止生成DOM树，解析器被js阻塞，等待js文件发起HTTP请求，然后加载。这是第三次HTTP请求。js执行完成后解析器继续解析。</li><li>由于CSS文件可能会影响js文件的执行结果，因此需等CSS文件加载完成后再执行。</li><li>浏览器收到CSS文件后，开始解析CSS文件为CSSOM树（CSS Rule Tree）。</li><li>CSSOM树生成后，DOM Tree与CSS Rule Tree结合生成渲染树（Render Tree）。</li><li>Render Tree会被CSS文件阻塞，渲染树生成后，先布局，绘制渲染树中节点的属性(位置，宽度，大小等)，然后渲染，页面就会呈现信息。</li><li>继续边解析边渲染，遇到了另一个js文件，js文件执行后改变了DOM树，渲染树从被改变的dom开始再次渲染。</li><li>继续向下渲染，碰到一个img标签，浏览器发起HTTP请求，不会等待img加载完成，继续向下渲染，之后再重新渲染此部分。</li><li>DOM树遇到HTML结束标签，停止解析，进而渲染结束。</li></ul></li><li>连接结束</li></ol><p>涉及到的协议：IP(网络)、OSPF(路由)、ARP(本地MAC解析)</p><h2 id="ARP，RARP-和-ICMP"><a href="#ARP，RARP-和-ICMP" class="headerlink" title="ARP，RARP 和 ICMP"></a>ARP，RARP 和 ICMP</h2><ul><li>ARP协议：属于ipv4协议簇，工作在数据链路层。其功能是把网络层32位的IP转换成数据链路层48位的MAC地址，在这个过程中有一个很重要的表——<strong>ARP缓存表</strong>，<ul><li>ARP缓存表中缓存了IP地址和MAC地址的映射关系。如果没有缓存的情况，ARP会广播某一个IP的信息，收到这个广播的设备会回应一个包，表示我是不是这个IP地址。如果是，广播该IP地址的设备会记录对应设备的MAC地址。</li></ul></li><li>RARP协议:(reverse arp，反向arp协议)，和ARP协议做相反的工作，它将48位的MAC地址转换为32位的IP地址。</li><li>ICMP协议:（Internet Control Message Protocol，网络控制消息协议），它的功能是报告无法传送的数据包的错误，并帮助对这些错误进行疑难解答。</li></ul><h2 id="DNS-Domain-Name-System-域名系统-域名解析过程"><a href="#DNS-Domain-Name-System-域名系统-域名解析过程" class="headerlink" title="DNS(Domain Name System, 域名系统) 域名解析过程"></a>DNS(Domain Name System, 域名系统) 域名解析过程</h2><p>域名格式：三级域名.二级域名.顶级域名(<a href="http://www.baidu.com/">www.baidu.com</a>)<br><img src="https://i.loli.net/2020/08/13/CwRs32gdhp1xfYv.png" alt="域名"></p><p>域名服务器：保存域名到IP地址映射的服务器。<br><img src="https://i.loli.net/2020/08/13/ij4qSdQV8bUFnPy.png" alt="域名服务器"></p><ul><li>递归查询：主机向本地域名服务器的查询一般都是采用<strong>递归查询</strong>。指的是，当主机所询问的本地域名服务器不知道被查询的域名IP地址时，<strong>本地域名服务器</strong>就以DNS客户的身份，向其他根域名服务器继续查询，而不是让主机自己进行下一步查询，</li><li>迭代查询：本地域名服务器向根域名服务器查询通常采用<strong>迭代查询</strong>。指的是，当根域名服务器没有保存本地域名服务器所查询的域名IP地址时，就告诉本地域名服务器下一步应当找哪一个域名服务器查询，而不是根域名服务器以客户身份查询。</li></ul><p><img src="https://i.loli.net/2020/08/13/eNUzQE9g8YIP3H4.png" alt="DNS查询"></p><p>找域名服务器查询之前，会先找缓存中有没有：</p><ol><li>浏览器缓存：当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）</li><li>系统缓存：当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP</li><li>路由器缓存：当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查</li></ol><p>当以上三个缓存中都没有，才会向DNS服务器查询。</p><h2 id="NAT-Network-Address-Translation-网络地址转换-协议"><a href="#NAT-Network-Address-Translation-网络地址转换-协议" class="headerlink" title="NAT(Network Address Translation, 网络地址转换)协议"></a>NAT(Network Address Translation, 网络地址转换)协议</h2><p>用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。</p><h2 id="cookie和session对于HTTP有什么用？"><a href="#cookie和session对于HTTP有什么用？" class="headerlink" title="cookie和session对于HTTP有什么用？"></a>cookie和session对于HTTP有什么用？</h2><p>HTTP协议本身是无法判断用户身份。所以需要cookie或者session</p><h2 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h2><p>cookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信息。客户端向服务器发起请求，就提取浏览器中的用户信息由http发送给服务器</p><h2 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h2><p>session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给session。</p><p>服务器默认为客户浏览器的cookie中设置 sessionid，这个sessionid就和cookie对应，浏览器在向服务器请求过程中传输的cookie 包含 sessionid ，服务器根据传输cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</p><h2 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h2><ul><li>cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高</li><li>单个cookie保存的数据不能超过4K，session无此限制</li><li>session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li>谢希仁. 计算机网络（第7版）. 电子工业出版社</li><li><a href="https://blog.csdn.net/ThinkWon/article/details/104903925">重学TCP&#x2F;IP协议和三次握手四次挥手</a></li><li><a href="https://blog.csdn.net/ls5718/article/details/52141571?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task">TCP&#x2F;UDP区别以及UDP如何实现可靠传输</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计算机网络概念&quot;&gt;&lt;a href=&quot;#计算机网络概念&quot; class=&quot;headerlink&quot; title=&quot;计算机网络概念&quot;&gt;&lt;/a&gt;计算机网络概念&lt;/h1&gt;&lt;h2 id=&quot;网络协议&quot;&gt;&lt;a href=&quot;#网络协议&quot; class=&quot;headerlink&quot; title=&quot;网络协议&quot;&gt;&lt;/a&gt;网络协议&lt;/h2&gt;&lt;p&gt;在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。&lt;/p&gt;
&lt;h2 id=&quot;计算机网络体系结构&quot;&gt;&lt;a href=&quot;#计算机网络体系结构&quot; class=&quot;headerlink&quot; title=&quot;计算机网络体系结构&quot;&gt;&lt;/a&gt;计算机网络体系结构&lt;/h2&gt;&lt;p&gt;计算机网络体系结构是指计算机网络层次结构模型，它是各层的协议以及层次之间的端口的集合。在计算机网络中实现通信必须依靠网络通信协议，目前广泛采用的是国际标准化组织（ISO）1997年提出的开放系统互联（Open System Interconnection，OSI）参考模型，习惯上称为ISO&amp;#x2F;OSI参考模型。&lt;/p&gt;</summary>
    
    
    
    <category term="CS" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/CS/"/>
    
    
    <category term="Network" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>C++ Review</title>
    <link href="https://github.com/suzhilong/suzhilong.github.io.git/2020/06/05/cppReview/"/>
    <id>https://github.com/suzhilong/suzhilong.github.io.git/2020/06/05/cppReview/</id>
    <published>2020-06-05T08:00:00.000Z</published>
    <updated>2020-10-21T11:48:06.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-源文件到可执行文件的过程"><a href="#C-源文件到可执行文件的过程" class="headerlink" title="C++源文件到可执行文件的过程"></a>C++源文件到可执行文件的过程</h1><p>对于C&#x2F;C++编写的程序，从源代码到可执行文件，一般经过下面四个步骤：</p><ol><li>预处理，产生.ii文件<ul><li>对所有的“#define”进行宏展开；</li><li>处理所有的条件编译指令，比如“#if”,“#ifdef”，“#elif”，“#else”,“#endif”</li><li>处理“#include”指令，这个过程是递归的，也就是说被包含的文件可能还包含其他文件</li><li>删除所有的注释“&#x2F;&#x2F;”和“&#x2F;**&#x2F;”</li><li>添加行号和文件标识</li><li>保留所有的“#pragma”编译器指令</li></ul></li><li>编译，产生汇编文件(.s文件)<br> 编译的过程就是将预处理完的文件进行一系列<strong>词法分析</strong>，<strong>语法分析</strong>，<strong>语义分析</strong>及优化后生成相应的汇编代码文件(.s文件)</li><li>汇编，产生目标文件(.o或.obj文件)<br>汇编器是将汇编代码转变成机器可以执行的代码（二进制文件），每一个汇编语句几乎都对应一条机器指令。最终产生目标文件(.o或.obj文件)。</li><li>链接,产生可执行文件(.out或.exe文件)<br>链接的过程主要包括了地址和空间分配(Address and Storage Allocation)、符号决议(Symbol Resolution)和重定位(Relocation)</li></ol><h1 id="Clang-x2F-LLVM-x2F-lldb-x2F-GCC-x2F-gdb"><a href="#Clang-x2F-LLVM-x2F-lldb-x2F-GCC-x2F-gdb" class="headerlink" title="Clang&#x2F;LLVM&#x2F;lldb&#x2F;GCC&#x2F;gdb"></a>Clang&#x2F;LLVM&#x2F;lldb&#x2F;GCC&#x2F;gdb</h1><ul><li>Clang 是 LLVM <strong>编译器工具集</strong>的前端（front-end），目的是输出代码对应的抽象语法树（Abstract Syntax Tree, AST），并将代码编译成LLVM Bitcode。接着在后端（back-end）使用LLVM编译成平台相关的机器语言 。Clang支持C、C++、Objective C。</li><li>LLVM 提供了完整编译系统的中间层，它会将中间语言（Intermediate form，IF）从编译器取出与最优化，最优化后的 IF 接着被转换及链接到目标平台的汇编语言。LLVM 后端也可以接受来自GCC工具链所编译的 IF。</li><li>lldb 是 LLVM 调试器(断点原理)。lldb是个开源的内置于XCode的具有REPL(read-eval-print-loop)特征的Debugger，其可以安装C++或者Python插件。</li><li>GCC（GNU Compiler Collection）在所有平台上都使用同一个前端处理程序（支持很多语言），产生一样的中介码，因此此中介码在各个其他平台上使用GCC编译，有很大的机会可得到正确无误的输出程序。</li><li>gdb 是 GCC 调试器。UNIX及UNIX-like下的调试工具。</li></ul><p>ref <a href="https://note.xianqiao.wang/post/clang-llvm-lldb-gcc-gdb-guan-xi">Clang&#x2F;LLVM&#x2F;lldb&#x2F;GCC&#x2F;gdb 关系</a></p><h1 id="头文件中的ifndef-x2F-define-x2F-endif有什么作用"><a href="#头文件中的ifndef-x2F-define-x2F-endif有什么作用" class="headerlink" title="头文件中的ifndef&#x2F;define&#x2F;endif有什么作用"></a>头文件中的ifndef&#x2F;define&#x2F;endif有什么作用</h1><p>这是C++预编译头文件保护符，保证即使文件被多次包含，头文件也只定义一次。</p><h1 id="typedef-和-define-有什么区别"><a href="#typedef-和-define-有什么区别" class="headerlink" title="typedef 和 define 有什么区别"></a>typedef 和 define 有什么区别</h1><ul><li>用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义常量，以及书写复杂使用频繁的宏。</li><li>执行时间不同：typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。</li><li>作用域不同：typedef 有作用域限定。define 不受作用域约束，只要是在 define 声明后的引用都是正确的。</li><li>对指针的操作不同：typedef 和 define 定义的指针时有很大的区别。</li></ul><p><em>注意：typedef 定义是语句，因为句尾要加上分号。而 define 不是语句，千万不能在句尾加分号。</em></p><h1 id="include-的顺序以及尖叫括号和双引号的区别"><a href="#include-的顺序以及尖叫括号和双引号的区别" class="headerlink" title="#include 的顺序以及尖叫括号和双引号的区别"></a>#include 的顺序以及尖叫括号和双引号的区别</h1><ul><li>#include的顺序的区别：<br>头文件的引用顺序对于程序的编译还是有一定影响的。如果要在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误，也就是常见的某行少个“；”符号。</li><li>#include尖括号和双引号的区别：  <ol><li>#include  &lt;&gt; ，认为该头文件是标准头文件。编译器将会在预定义的位置集查找该头文件，这些预定义的位置可以通过设置查找路径环境变量或者通过命令行选项来修改。使用的查找方式因编译器的不同而差别迥异。</li><li>#include “”，认为它是非系统头文件，非系统头文件的查找通常开始于源文件所在的路径。查找范围大于&lt;&gt;。</li></ol></li></ul><h1 id="main-函数执行以前，还会执行什么代码？"><a href="#main-函数执行以前，还会执行什么代码？" class="headerlink" title="main 函数执行以前，还会执行什么代码？"></a>main 函数执行以前，还会执行什么代码？</h1><p>全局对象的构造函数会在main 函数之前执行。</p><h1 id="内联函数和普通函数的区别"><a href="#内联函数和普通函数的区别" class="headerlink" title="内联函数和普通函数的区别"></a>内联函数和普通函数的区别</h1><ol><li>复杂程度不同：<br>内联函数比较简单，在内联函数中不允许使用循环语句和switch结果，带有异常接口声明的函数也不能声明为内联函数。</li><li>编译结果不同：<br>内联函数（有时称作在线函数或编译时期展开函数）是一种编程语言结构，用来建议编译器对一些特殊函数进行内联扩展（有时称作在线扩展）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文）。普通函数则会编译为单独的模块。</li><li>编译的时间不同：<br>对于基于C的编译系统，内联函数的使用可能大大增加编译时间，因为每个调用该函数的地方都需要替换成函数体，代码量的增加也同时带来了潜在的编译时间的增加。</li><li>运行的效率不同：<br>使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。</li></ol><h1 id="内联函数和宏定义的区别"><a href="#内联函数和宏定义的区别" class="headerlink" title="内联函数和宏定义的区别"></a>内联函数和宏定义的区别</h1><p>内联函数和宏的区别在于：</p><ul><li>宏是由预处理器对宏进行替代</li><li>内联函数是通过编译器控制来实现的</li></ul><p>而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。</p><p>内联函数与带参数的宏定义进行下比较，它们的代码效率是一样，但是内联函数要优于宏定义，因为内联函数遵循的类型和作用域规则，它与一般函数更相近，在一些编译器中，一旦关联上内联扩展，将与一般函数一样进行调用，比较方便。 </p><p>另外，宏定义在使用时只是简单的文本替换，并没有做严格的参数检查，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</p><p>C++的inline的提出就是为了完全取代宏定义，因为inline函数取消了宏定义的缺点，又很好地继承了宏定义的优点，《Effective C++》中就提到了尽量使用Inline替代宏定义的条款，足以说明inline的作用之大。</p><h1 id="定义MAX和MIN宏"><a href="#定义MAX和MIN宏" class="headerlink" title="定义MAX和MIN宏"></a>定义MAX和MIN宏</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define MAX(a,b) ((a) &gt; (b) ? (a) : (b))</span><br><span class="line">#define MIN(a,b) ((a) &lt; (b) ? (a) : (b))</span><br></pre></td></tr></table></figure><h1 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h1><p><strong>大端</strong>：高位存在低地址，低位存在高地址。</p><p><strong>小端</strong>：高位存在高地址，低位存在低地址。</p><p>大小端和CPU有关。</p><p>现代PC大多采用小段，所以<strong>小端字节序</strong>又被成为<strong>主机字节序</strong>。而<strong>大端字节序</strong>又被成为<strong>网络字节序</strong>。</p><p>判断大小端代码：</p><ul><li>方法一</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void byteOrder()&#123;</span><br><span class="line">union</span><br><span class="line">&#123;</span><br><span class="line">short val;</span><br><span class="line">char c_val[sizeof(short)];</span><br><span class="line">&#125; test;</span><br><span class="line">test.val = 0x0102;</span><br><span class="line">if((test.c_val[0]==1) &amp;&amp; (test.c_val[1]==2))</span><br><span class="line">cout &lt;&lt; &quot;Big endian&quot; &lt;&lt; endl;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; &quot;Little endian&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void byteOrder()&#123;</span><br><span class="line">int num = 0x0102;</span><br><span class="line">    char q = *(char *)&amp;num;</span><br><span class="line">    if (q == 0x02)</span><br><span class="line">cout &lt;&lt; &quot;Little endian&quot; &lt;&lt; endl;</span><br><span class="line">else</span><br><span class="line">        cout&lt;&lt;&quot;Big endian&quot; &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h1><ul><li>左值 (lvalue, locator value)：表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。</li><li>右值 (rvalue)：一个表达式不是 左值 就是 右值 。 那么，右值是一个 不 表示内存中某个可识别位置的对象的表达式。</li></ul><h2 id="左值引用-和-右值引用"><a href="#左值引用-和-右值引用" class="headerlink" title="左值引用 和 右值引用"></a>左值引用 和 右值引用</h2><p>C++11标准添加了右值引用(rvalue reference)，这种引用只能绑定右值，不能绑定左值，它使用两个&amp;&amp;来声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line"></span><br><span class="line">int&amp; b = a; //左值引用</span><br><span class="line">int&amp;&amp; c = 1; //右值引用</span><br><span class="line">int&amp;&amp; b = a; // 编译失败</span><br></pre></td></tr></table></figure><ul><li><a href="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/">理解 C&#x2F;C++ 中的左值和右值</a></li><li><a href="https://zhuanlan.zhihu.com/p/55229582">右值引用，移动语义，移动构造函数和移动赋值运算符</a></li></ul><h1 id="面向对象的三个基本特征"><a href="#面向对象的三个基本特征" class="headerlink" title="面向对象的三个基本特征"></a>面向对象的三个基本特征</h1><p>面向对象的三个基本特征是：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。<br><strong>封装</strong>可以隐藏实现细节，使得代码模块化；<strong>继承</strong>可以扩展已存在的代码模块（类）。它们的目的都是<strong>代码重用</strong>；而<strong>多态</strong>则是为了实现另一个目的——<strong>接口重用</strong>。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。</p><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><p>不同的类成员访问修饰符权限：</p><table><thead><tr><th>访问修饰符</th><th align="center">同一个类</th><th align="center">同包</th><th align="center">不同包，子类</th><th align="center">不同包，非子类</th></tr></thead><tbody><tr><td>private</td><td align="center">√</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td>public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td>默认</td><td align="center">√</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>使用继承时需要注意：<br>1、子类拥有父类非private的属性和方法。<br>2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。<br>3、子类可以用自己的方式实现父类的方法。</p><h3 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h3><p>在C++中 struct和class唯一的区别就在于<strong>默认的继承访问权限</strong>不同。</p><ul><li>struct 默认权限为公共</li><li>class 默认权限为私有</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class listNode&#123;//链表类</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    listNode *next;</span><br><span class="line">    listNode(int a) : val(a), next(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct biTree&#123;二叉树结构</span><br><span class="line">    int val;</span><br><span class="line">    biTree *lc;</span><br><span class="line">    biTree *rc;</span><br><span class="line">    biTree(int x) : val(x), lc(nullptr), rc(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //链表</span><br><span class="line">listNode *ln = new listNode(1);</span><br><span class="line">    listNode *cur = ln;</span><br><span class="line">    cur-&gt;next = new listNode(2);</span><br><span class="line">    cur = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = new listNode(3);</span><br><span class="line"></span><br><span class="line">//二叉树</span><br><span class="line">    biTree parent(1);</span><br><span class="line">biTree *root = new biTree(1);//也可以只有</span><br><span class="line">    biTree lc(2);</span><br><span class="line">    biTree rc(3);</span><br><span class="line">    parent.lc = &amp;lc;</span><br><span class="line">    parent.rc = &amp;rc;</span><br><span class="line"></span><br><span class="line">    biTree *root = &amp;parent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><p>构造函数和析构函数解决了<strong>对象的初始化和清理</strong>这两个非常重要的安全问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供构造函数和析构函数的空实现。</p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol><li>没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><ol><li>没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号 ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li><li>public、private、protected等权限控制对析构函数无效</li></ol><h4 id="构造函数与析构函数的特点"><a href="#构造函数与析构函数的特点" class="headerlink" title="构造函数与析构函数的特点"></a>构造函数与析构函数的特点</h4><ul><li>构造函数有如下特点：<ol><li>构造函数的名字必须与类名相同；</li><li>构造函数可以有任意类型的参数，但不能有返回类型；</li><li>定义对象时，编译系统会自动调用构造函数；</li><li>构造函数是特殊的成员函数，函数体可以在类体内也可以在类体外；</li><li>构造函数被声明为公有函数，但它不能像其他成员函数那样被显式调用，它是在定义对象的同时被调用的。</li></ol></li><li>析构函数有如下特点：<ol><li>析构函数的名字必须与类名相同，但它前面必须加一个波浪号；</li><li>析构函数没有参数，也没有返回值，而且不能被重载，因此在一个类中只能有一个析构函数；</li><li>当撤销对象时，编译系统会自动调用析构函数；</li><li>析构函数可以是virtual，而构造函数不能是虚函数。</li></ol></li></ul><h4 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h4><p>两种分类方式：</p><ul><li>按参数分为： 有参构造和无参构造</li><li>按类型分为： 普通构造和拷贝构造<br><em>ps. 有参构造有的可能会成为类型转换构造函数，比如在隐式转换调用的时候</em></li></ul><p>三种调用方式：</p><ul><li>括号法</li><li>显示法</li><li>隐式转换法</li></ul><p>构造函数分类示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span><br><span class="line">// 按照类型分类分为 普通构造和拷贝构造</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">//无参（默认）构造函数</span><br><span class="line">Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//有参构造函数</span><br><span class="line">Person(int a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//拷贝构造函数</span><br><span class="line">Person(const Person&amp; p) &#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//析构函数</span><br><span class="line">~Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>构造函数的调用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//调用无参构造函数</span><br><span class="line">void test01() &#123;</span><br><span class="line">Person p; //调用无参构造函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用有参的构造函数</span><br><span class="line">void test02() &#123;</span><br><span class="line"></span><br><span class="line">//2.1  括号法，常用</span><br><span class="line">Person p1(10);</span><br><span class="line">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span><br><span class="line">//Person p2();</span><br><span class="line"></span><br><span class="line">//2.2 显式法</span><br><span class="line">Person p2 = Person(10); </span><br><span class="line">Person p3 = Person(p2);</span><br><span class="line">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span><br><span class="line"></span><br><span class="line">//2.3 隐式转换法</span><br><span class="line">Person p4 = 10; // Person p4 = Person(10); </span><br><span class="line">Person p5 = p4; // Person p5 = Person(p4); </span><br><span class="line"></span><br><span class="line">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span><br><span class="line">//Person p5(p4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">//test02();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拷贝构造函数和赋值运算符的认识"><a href="#拷贝构造函数和赋值运算符的认识" class="headerlink" title="拷贝构造函数和赋值运算符的认识"></a>拷贝构造函数和赋值运算符的认识</h4><p>拷贝构造函数和赋值运算符重载有以下两个不同之处：</p><ul><li>拷贝构造函数生成新的类对象，而赋值运算符不能。</li><li>由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对象之前不用检验源对象是否和新建对象相同。而赋值运算符则需要这个操作，另外赋值运算中如果原来的对象中有内存分配要先把内存释放掉</li></ul><p><em>注意：当有类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符，不要使用默认的。</em></p><h4 id="构造函数和析构函数可以是虚函数吗？"><a href="#构造函数和析构函数可以是虚函数吗？" class="headerlink" title="构造函数和析构函数可以是虚函数吗？"></a>构造函数和析构函数可以是虚函数吗？</h4><ol><li><p>构造函数不能是虚函数</p><ul><li>存储空间角度<br>虚函数的调用需要 vptr 指针，而该指针存放在对象的内容空间中，需要调用构造函数才可以创建它的值，否则即使开辟了空间，该 vptr 指针为随机值；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有 vptr 地址用来调用虚函数之一的构造函数了。</li><li>使用，多态角度<br>虚函数主要是实现多态，在运行时才可以明确调用对象，根据传入的对象类型来调用函数，例如通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。那使用虚函数也没有实际意义。  </li><li>从实现角度<br>vtable在构造函数调用后才建立，所以构造函数不能是虚函数。在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，没有必要成为虚函数。</li></ul></li><li><p>析构函数常常是虚函数<br>创建一个对象时我们总是要明白指定对象的类型。虽然我们可能通过基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候假设析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。<br>如果基类的析构函数不是虚函数，派生类的析构函数用不上，会造成资源的泄漏。</p></li></ol><h4 id="构造函数和析构函数，可以调用其他的虚函数吗？"><a href="#构造函数和析构函数，可以调用其他的虚函数吗？" class="headerlink" title="构造函数和析构函数，可以调用其他的虚函数吗？"></a>构造函数和析构函数，可以调用其他的虚函数吗？</h4><p>《Effective C++》条款09：绝不在构造函数或析构函数中调用虚函数。</p><p>从语法上讲，调用完全没有问题。</p><p>但是从效果上看，往往不能达到需要的目的：派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。同样，进入基类析构函数时，对象也是基类类型。所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。</p><h4 id="子类和父类中，构造函数和析构函数的调用顺序是什么？"><a href="#子类和父类中，构造函数和析构函数的调用顺序是什么？" class="headerlink" title="子类和父类中，构造函数和析构函数的调用顺序是什么？"></a>子类和父类中，构造函数和析构函数的调用顺序是什么？</h4><ul><li>构造时，先调用父类构造函数，再调用子类构造函数</li><li>析构时，先调用子类析构函数，再调用父类析构函数</li></ul><p><strong>ps.</strong></p><ul><li>若一个类包含对象成员，在建立该类的对象时，先调用对象成员的构造函数，初始化相应的对象成员，然后才执行该类的构造函数。</li><li>如果一个类包含多个对象成员，对象成员的构造函数的调用顺序由它们在该类中的说明顺序决定，而它们在初始化表中的顺序无关。</li></ul><h4 id="虚析构函数有什么作用？"><a href="#虚析构函数有什么作用？" class="headerlink" title="虚析构函数有什么作用？"></a>虚析构函数有什么作用？</h4><ul><li>析构函数的工作方式是：最底层的派生类的析构函数最先被调用，然后调用每一个基类的析构函数；</li><li>在C++中，当一个派生类对象通过使用一个基类指针删除，而这个基类有一个非虚的析构函数，则可能导致运行时派生类不能被销毁。然而基类部分很有可能已经被销毁，这就导致“部分析构”现象，造成内存泄漏；</li><li>给基类一个虚析构函数，删除一个派生类对象的时候就将销毁整个对象，包括父类和全部的派生类部分。</li></ul><h4 id="拷贝构造函数在什么情况下会自动被调用"><a href="#拷贝构造函数在什么情况下会自动被调用" class="headerlink" title="拷贝构造函数在什么情况下会自动被调用"></a>拷贝构造函数在什么情况下会自动被调用</h4><ul><li>当类的一个对象去初始化该类的另一个对象时；</li><li>如果函数的形参是类的对象，调用函数进行形参和实参结合时；</li><li>如果函数的返回值是类对象，函数调用完成返回时。</li></ul><h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><ul><li><p>浅拷贝：简单的赋值拷贝操作。使用默认拷贝构造函数，拷贝过程中是按字节复制的，对于指针型成员变量只复制指针本身，而不复制指针所指向的目标，因此涉及堆区开辟内存时，会将两个成员属性指向相同的内存空间，从而在释放时导致内存空间被多次释放。</p></li><li><p>深拷贝：在堆区重新申请空间，进行拷贝操作。自定义拷贝构造函数，在堆内存中另外申请空间来储存数据，从而解决指针悬挂的问题。需要注意自定义析构函数中应该释放掉申请的内存。</p></li></ul><p>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的重复释放堆区问题。</p><p>拷贝构造函数的参数必须加const，因为防止修改，本来就是用现有的对象初始化新的对象。</p><p><em>ps. 在定义类或者结构体，这些结构的时候，最后都重写拷贝函数，避免浅拷贝这类不易发现但后果严重的错误产生</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//拷贝构造函数  </span><br><span class="line">Person(const Person&amp; p) &#123;</span><br><span class="line">  cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">  //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span><br><span class="line">  m_age = p.m_age;</span><br><span class="line">  m_height = new int(*p.m_height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//析构函数</span><br><span class="line">~Person() &#123;</span><br><span class="line">  cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">  if (m_height != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    delete m_height;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为<strong>对象成员</strong>。</p><p>当类中有对象成员时，构造的顺序是：<strong>先调用对象成员的构造，再调用本类构造。析构顺序与构造相反</strong>。<br>如：B类中有对象A作为成员，A为对象成员。那么当创建B对象时，先调用A的构造，再调用B的构造。结束时先析构B，再析构A。</p><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>成员变量和成员函数前加上关键字static，称为静态成员。<br>静态成员变量：</p><ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外初始化</li></ul><p>静态成员函数：</p><ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul><p>静态成员两种访问方式：</p><ol><li>通过对象。如：p1.m_A</li><li>通过类名。如：Person::m_B（私有权限访问不到）</li></ol><h4 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h4><ul><li>非静态成员变量占对象空间。int mA;</li><li>静态成员变量不占对象空间。static int mB; </li><li>函数也不占对象空间，所有函数共享一个函数实例。每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>静态成员函数也不占对象空间</li></ul><h3 id="对象模型和this指针"><a href="#对象模型和this指针" class="headerlink" title="对象模型和this指针"></a>对象模型和this指针</h3><h4 id="this指针概念"><a href="#this指针概念" class="headerlink" title="this指针概念"></a>this指针概念</h4><p>在类实例化对象时，只有非静态成员变量属于对象本身，剩余的静态成员变量，静态函数，非静态函数都不属于对象本身，因此非静态成员函数只会实例一份，多个同类型对象会共用一块代码。c++通过提供特殊的对象指针——this指针——区分调用自己的对象。this指针指向被调用的成员函数所属的对象。  </p><p>this指针的本质是一个指针常量，指针的指向不可修改。this的目的总是指向这个对象，  </p><p>this 是一个指向类的实例的一个指针，指向该实例的首地址，但是 this 不是 该对象实例的一部分，即在sizeof（某对象）中不包含this指针的大小。</p><h4 id="this指针的作用"><a href="#this指针的作用" class="headerlink" title="this指针的作用"></a>this指针的作用</h4><p>this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来做到这一点，因为this所指的正是这个对象。任何对类成员的直接访问都被看成this的隐式使用。</p><ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用<code>return *this</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">Person(int age)</span><br><span class="line">&#123;</span><br><span class="line">//1、当形参和成员变量同名时，可用this指针来区分</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person&amp; PersonAddPerson(Person p)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;age += p.age;</span><br><span class="line">//返回对象本身</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="this-指针需要注意的地方。"><a href="#this-指针需要注意的地方。" class="headerlink" title="this 指针需要注意的地方。"></a>this 指针需要注意的地方。</h4><ul><li>this 指针只能用于成员函数，成员变量，对于静态函数和静态变量，是不允许使用this（因为静态函数或变量，都是属于对象本身，即所有实例都可以访问他们，但是this只是指向自身实例的地址，是一个个例。）</li><li>友元函数也没有this指针。(友元函数至少需要一个参数)</li><li>this引用成员变量用法有二： <code>this-&gt;val</code> 或者 <code>(*this).val.</code> 这就像指针引用类似。</li></ul><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>友元的目的就是让一个函数或者类访问另一个类中私有成员（包括属性和方法），会破坏C++的封装性，尽量不使用。</p><p>友元的关键字为 <code>friend</code></p><p>友元的三种实现：</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。</p><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承方式一共有三种：</p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><h3 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h3><p>继承中，先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p><h3 id="继承同名成员处理方式"><a href="#继承同名成员处理方式" class="headerlink" title="继承同名成员处理方式"></a>继承同名成员处理方式</h3><p>当子类与父类出现同名的成员，通过子类对象访问子类或父类中同名的数据的方法：</p><ul><li>访问<strong>子类</strong>同名成员：直接访问即可</li><li>访问<strong>父类</strong>同名成员：需要加作用域</li></ul><p><em>ps. 同名静态成员处理方式和非静态处理方式一样</em></p><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>C++允许一个类继承多个类<br>语法：<code>class子类：继承方式 父类1，继承方式 父类2...</code></p><p><em>ps. 多继承可能会引发父类中有同名成员出现，需要加作用域区分</em></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p><p>多态性允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。</p><p>简而言之就是用<strong>父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数</strong>。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。</p><h3 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h3><ul><li>当类中存在虚函数时，编译器会在类中自动生成一个虚函数表</li><li>虚函数表是一个存储类成员函数指针的数据结构</li><li>虚函数表由编译器自动生成和维护</li><li>virtual 修饰的成员函数会被编译器放入虚函数表中</li><li>存在虚函数时，编译器会为对象自动生成一个指向虚函数表的指针（通常称之为 vptr 指针）</li></ul><h3 id="多态实现的三个条件"><a href="#多态实现的三个条件" class="headerlink" title="多态实现的三个条件"></a>多态实现的三个条件</h3><ol><li>要有继承</li><li>要有虚函数重写</li><li>要有父类指针指（父类引用）向子类对象</li></ol><h3 id="多态分为两类（实现多态的两种方法）"><a href="#多态分为两类（实现多态的两种方法）" class="headerlink" title="多态分为两类（实现多态的两种方法）"></a>多态分为两类（实现多态的两种方法）</h3><ul><li>重载——静态多态：<strong>函数重载</strong> 和 <strong>运算符重载</strong> 属于静态多态，复用函数名</li><li>重写（覆盖）——动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li></ul><p>其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。<br>如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。</p><p>也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚邦定）。</p><p>结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关。</p><h3 id="动态多态代码示例"><a href="#动态多态代码示例" class="headerlink" title="动态多态代码示例"></a>动态多态代码示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void Print() = 0;</span><br><span class="line">virtual ~Base()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class child_1 : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void Print()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;child_1 Print function&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~child_1()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;child_1 destructor function&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class child_2: public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void Print()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;child_2 Print function&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~child_2()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;child_2 destructor function&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Base *p = new child_1; //父类指针指向子类对象</span><br><span class="line">p-&gt;Print();</span><br><span class="line">delete p;  //记住释放,否则内存泄露</span><br><span class="line">p = new child_2;</span><br><span class="line">p-&gt;Print();</span><br><span class="line">delete p;</span><br><span class="line">p = NULL;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态多态代码示例"><a href="#静态多态代码示例" class="headerlink" title="静态多态代码示例"></a>静态多态代码示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//宏多态：a,b可以不同类型</span><br><span class="line">#define  sum(a,b)  ((a) + (b))</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void Print() //不需要定义为虚函数</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;base Print() functions&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void Print(int val) //重载,根据参数列表不同实现函数多态</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;base Print(int) functions&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class child : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void Print() //不需要定义为虚函数</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;child Print() functions&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void Print(int val) //重载,根据参数列表不同实现函数多态</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;child Print(int) functions&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">p.Print();</span><br><span class="line">p.Print(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Base base ;</span><br><span class="line">child ch;</span><br><span class="line">int a = 23, b = 19;</span><br><span class="line">double fa = 13.32, fb = 29.36;</span><br><span class="line">func(base);</span><br><span class="line">func(ch);</span><br><span class="line"></span><br><span class="line">//宏多态：a,b可以不同类型</span><br><span class="line">cout &lt;&lt; sum(a,b) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; sum(fa,fb) &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><ul><li>虚函数的作用主要是实现了多态的机制。</li><li>定义一个函数为虚函数，不代表函数为不被实现的函数。定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。</li><li>定义一个函数为纯虚函数，才代表函数没有被实现。定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</li><li>虚函数的功能是使子类可以用同名的函数对父类函数进行覆盖，并且在通过父类指针调用时，如果有覆盖则自动调用子类覆盖函数，如果没有覆盖则调用父类中的函数，从而实现灵活扩展和多态性；</li><li>如果是纯虚函数，则纯粹是为了在子类覆盖时有个统一的命名而已，子类必须覆盖纯虚函数，则否子类也是抽象类；</li><li>含有纯虚函数的类称为抽象类，不能实例化对象，主要用作接口类。</li></ul><p>示例：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void foo()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;A::foo() is called&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B:public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void foo()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;B::foo() is called&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    A *a = new B();</span><br><span class="line">    a-&gt;foo();   // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为<strong>纯虚函数</strong>。<br>当类中有了纯虚函数，这个类也称为<strong>抽象类</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0;</code></p><p>注意：</p><ol><li>纯虚函数没有函数体</li><li>最后的<code>=0</code>并不是表示返回值为0，只是形式上的作用，告诉编译系统<code>这是虚函数</code></li><li>这是一个声明，最后有分号</li></ol><h4 id="抽象类特点："><a href="#抽象类特点：" class="headerlink" title="抽象类特点："></a>抽象类特点：</h4><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li><li>类中只要有一个纯虚函数就称为抽象类</li></ul><h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码。<br>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：<br><code>virtual ~类名()&#123;&#125;</code></p><p>纯虚析构语法：<br><code>virtual ~类名() = 0;</code><br><code>类名::~类名()&#123;&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">Animal()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void Speak() = 0;</span><br><span class="line"></span><br><span class="line">//析构函数加上virtual关键字，变成虚析构函数</span><br><span class="line">//virtual ~Animal()</span><br><span class="line">//&#123;</span><br><span class="line">//cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">virtual ~Animal() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~Animal()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚基类和虚继承"><a href="#虚基类和虚继承" class="headerlink" title="虚基类和虚继承"></a>虚基类和虚继承</h3><p>多继承（Multiple Inheritance）是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。</p><p>多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是<strong>菱形继承</strong>。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//间接基类A</span><br><span class="line">class A&#123;</span><br><span class="line">protected:</span><br><span class="line">    int m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//直接基类B</span><br><span class="line">class B: public A&#123;</span><br><span class="line">protected:</span><br><span class="line">    int m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//直接基类C</span><br><span class="line">class C: public A&#123;</span><br><span class="line">protected:</span><br><span class="line">    int m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//派生类D</span><br><span class="line">class D: public B, public C&#123;</span><br><span class="line">public:</span><br><span class="line">    void seta(int a)&#123; m_a = a; &#125;  //命名冲突</span><br><span class="line">    void setb(int b)&#123; m_b = b; &#125;  //正确</span><br><span class="line">    void setc(int c)&#123; m_c = c; &#125;  //正确</span><br><span class="line">    void setd(int d)&#123; m_d = d; &#125;  //正确</span><br><span class="line">private:</span><br><span class="line">    int m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    D d;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>虚继承</strong>目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为<strong>虚基类</strong>（Virtual Base Class），继承的时候用关键字<code>virtual</code>声明。</p><p><strong>虚继承</strong>主要用来解决继承中的二义性问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//间接基类A</span><br><span class="line">class A&#123;</span><br><span class="line">protected:</span><br><span class="line">    int m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//直接基类B</span><br><span class="line">class B: virtual public A&#123;  //虚继承</span><br><span class="line">protected:</span><br><span class="line">    int m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//直接基类C</span><br><span class="line">class C: virtual public A&#123;  //虚继承</span><br><span class="line">protected:</span><br><span class="line">    int m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//派生类D</span><br><span class="line">class D: public B, public C&#123;</span><br><span class="line">public:</span><br><span class="line">    void seta(int a)&#123; m_a = a; &#125;  //正确</span><br><span class="line">    void setb(int b)&#123; m_b = b; &#125;  //正确</span><br><span class="line">    void setc(int c)&#123; m_c = c; &#125;  //正确</span><br><span class="line">    void setd(int d)&#123; m_d = d; &#125;  //正确</span><br><span class="line">private:</span><br><span class="line">    int m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    D d;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ref. <a href="http://c.biancheng.net/cpp/biancheng/view/238.html">C++虚继承和虚基类</a></p><h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>虚函数表是指在每个包含虚函数的类中都存在着一个函数地址的数组。当我们用父类的指针来操作一个子类的时候，这张虚函数表指明了实际所应该调用的函数。</p><p>虚函数表指针vptr一般存储在对象实例的最开头，里面又虚函数表vtable的地址。虚函数表vtable在Linux&#x2F;Unix中存放在可执行文件的只读数据段 .<strong>rodata</strong> 中<br><img src="https://i.loli.net/2020/08/05/2eGU6kMy8Xp5v4Y.png" alt="虚函数表的存储"></p><h3 id="ref"><a href="#ref" class="headerlink" title="ref."></a>ref.</h3><ul><li><a href="https://blog.csdn.net/afei__/article/details/82142775">多态的实现原理分析</a></li><li><a href="https://zhuanlan.zhihu.com/p/104605966">C++ 一篇搞懂多态的实现原理</a></li><li><a href="https://songlee24.github.io/2014/09/02/cpp-virtual-table/">C++进阶之虚函数表</a></li><li><a href="https://www.cnblogs.com/yunlambert/p/9876564.html">C++虚函数表</a></li><li><a href="https://blog.csdn.net/jiary5201314/article/details/52627630">虚函数表存放在哪里</a></li></ul><h3 id="多态用法示例"><a href="#多态用法示例" class="headerlink" title="多态用法示例"></a>多态用法示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//抽象CPU类</span><br><span class="line">class CPU</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//抽象的计算函数</span><br><span class="line">virtual void calculate() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//抽象显卡类</span><br><span class="line">class VideoCard</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//抽象的显示函数</span><br><span class="line">virtual void display() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//抽象内存条类</span><br><span class="line">class Memory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//抽象的存储函数</span><br><span class="line">virtual void storage() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//电脑类</span><br><span class="line">class Computer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Computer(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">&#123;</span><br><span class="line">m_cpu = cpu;</span><br><span class="line">m_vc = vc;</span><br><span class="line">m_mem = mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//提供工作的函数</span><br><span class="line">void work()</span><br><span class="line">&#123;</span><br><span class="line">//让零件工作起来，调用接口</span><br><span class="line">m_cpu-&gt;calculate();</span><br><span class="line"></span><br><span class="line">m_vc-&gt;display();</span><br><span class="line"></span><br><span class="line">m_mem-&gt;storage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//提供析构函数 释放3个电脑零件</span><br><span class="line">~Computer()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">//释放CPU零件</span><br><span class="line">if (m_cpu != NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_cpu;</span><br><span class="line">m_cpu = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//释放显卡零件</span><br><span class="line">if (m_vc != NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_vc;</span><br><span class="line">m_vc = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//释放内存条零件</span><br><span class="line">if (m_mem != NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_mem;</span><br><span class="line">m_mem = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">CPU * m_cpu; //CPU的零件指针</span><br><span class="line">VideoCard * m_vc; //显卡零件指针</span><br><span class="line">Memory * m_mem; //内存条零件指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//具体厂商</span><br><span class="line">//Intel厂商</span><br><span class="line">class IntelCPU :public CPU</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void calculate()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IntelVideoCard :public VideoCard</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void display()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IntelMemory :public Memory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void storage()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//Lenovo厂商</span><br><span class="line">class LenovoCPU :public CPU</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void calculate()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LenovoVideoCard :public VideoCard</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void display()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LenovoMemory :public Memory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void storage()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">//第一台电脑零件</span><br><span class="line">CPU * intelCpu = new IntelCPU;</span><br><span class="line">VideoCard * intelCard = new IntelVideoCard;</span><br><span class="line">Memory * intelMem = new IntelMemory;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;</span><br><span class="line">//创建第一台电脑</span><br><span class="line">Computer * computer1 = new Computer(intelCpu, intelCard, intelMem);</span><br><span class="line">computer1-&gt;work();</span><br><span class="line">delete computer1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;</span><br><span class="line">//第二台电脑组装</span><br><span class="line">Computer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;</span><br><span class="line">computer2-&gt;work();</span><br><span class="line">delete computer2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;</span><br><span class="line">//第三台电脑组装</span><br><span class="line">Computer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;</span><br><span class="line">computer3-&gt;work();</span><br><span class="line">delete computer3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>主要用来解决命名冲突的问题</p><ul><li>必须在全局作用域下声明</li><li>命名空间下可以放函数，变量、结构体和类</li><li>命名空间可以嵌套命名空间</li><li>命名空间是开放的，可以随时加入新成员（添加时只需要再次声明namespace，然后添加新成员即可</li></ul><h3 id="（作用域运算符）"><a href="#（作用域运算符）" class="headerlink" title="::（作用域运算符）"></a><code>::</code>（作用域运算符）</h3><ul><li>全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li><li>类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的</li><li>命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的</li></ul><h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><ul><li>using声明<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using std::cout;</span><br></pre></td></tr></table></figure></li><li>using编译指令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br></pre></td></tr></table></figure></li></ul><p><em>ps. 尽量使用声明而不是编译指令，不同命名空间中可能会有相同的变量名，编译指令执行两个命名空间后，会产生二义性</em></p><h2 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h2><p><a href="https://github.com/AnkerLeng/Cpp-0-1-Resource/blob/master/%E7%AC%AC3%E9%98%B6%E6%AE%B5-C%2B%2B%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%20%E8%B5%84%E6%96%99/%E8%AE%B2%E4%B9%89/C%2B%2B%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B.md">C++核心编程</a><br><a href="https://blog.csdn.net/ma1kong/article/details/4457044">面向对象的三大特性</a></p><h1 id="函数重载（overload）、重写（override，也叫覆盖）和隐藏（也叫重定义）"><a href="#函数重载（overload）、重写（override，也叫覆盖）和隐藏（也叫重定义）" class="headerlink" title="函数重载（overload）、重写（override，也叫覆盖）和隐藏（也叫重定义）"></a>函数重载（overload）、重写（override，也叫覆盖）和隐藏（也叫重定义）</h1><h2 id="重载（overload）"><a href="#重载（overload）" class="headerlink" title="重载（overload）"></a>重载（overload）</h2><p>当函数具有相同的名称，但是参数列表不相同的情形（包括参数的个数不同或参数的类型不同），这样的同名而不同参数的函数之间，互相被称之为重载函数。<br>(函数名相同，参数列表不同，overload只是在类的内部存在)<br>特征：</p><ol><li>具有相同的作用域（即同一个类定义中）；</li><li>函数名字相同；</li><li>函数参数 <strong>类型不同</strong> 或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong>；</li><li>virtual 关键字可有可无；</li><li>返回类型也可以不同。<br><em>ps:函数的访问权限、返回类型、抛出的异常不可以作为函数重载的条件</em></li></ol><p>函数重载实例判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">以下的集中写法，分别表示了哪些是重载的，哪些不是重载的。</span><br><span class="line">(1) void func1( int arg1);</span><br><span class="line">(2) void func1( double arg1);</span><br><span class="line">(3) void func1( int arg1, int arg2);</span><br><span class="line">(4) bool func1(int arg1, double arg2)</span><br><span class="line">(5) int func1(int arg1);</span><br><span class="line"></span><br><span class="line">在上述的5个函数中，函数名称都是func1，完全相同；但是：</span><br><span class="line">(2)与(1)的参数个数相同，参数类型不同，构成重载；</span><br><span class="line">(3)与(1)和(2)的参数个数不同，构成重载；</span><br><span class="line">(4)与(1)和(2)的参数个数不同，与(3)的参数个数相同，但是第二个参数类型不同，构成重载；</span><br><span class="line">(5)与(1)的参数个数和参数类型均相同，仅返回值的类型不相同，不构成重载；但是(5)与(2),(3)和(4)除返回值不同外，均有参数类型或参数个数不同的情况，因此构成重载关系。</span><br></pre></td></tr></table></figure><h2 id="重写（覆盖，override）"><a href="#重写（覆盖，override）" class="headerlink" title="重写（覆盖，override）"></a>重写（覆盖，override）</h2><p>重写（覆盖）是指派生类重新实现（或者改写）基类的成员函数，在继承关系之间。C++利用虚函数实现多态。其特征是：</p><ol><li>不同的<strong>作用域</strong>（分别位于派生类和基类中）；</li><li>完全相同的<strong>函数名</strong>，<strong>参数列表</strong> 和 <strong>返回类型</strong>；</li><li>基类函数必须是虚函数。即<strong>必须有virtual</strong>关键字，不能是static；</li><li>重写函数的<strong>访问修饰符</strong>可以不同。尽管父类的virtual方法是private的，派生类中重写改写为public、protected也是可以的；</li></ol><p>重写（override）代码示例：B中fun1重写了A中的fun1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fun1(int, int)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B : class A&#123;</span><br><span class="line">public:</span><br><span class="line">    void fun1(int, int)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="隐藏（重定义）"><a href="#隐藏（重定义）" class="headerlink" title="隐藏（重定义）"></a>隐藏（重定义）</h2><p>子类重新定义父类有相同名称的非虚函数(参数列表可以不同)。</p><ol><li>不在同一个<strong>作用域</strong>（分别位于派生类与基类） ；</li><li>函数<strong>名字相同</strong>，<strong>返回值可以不同</strong>；</li><li>函数名相同但<strong>参数不同</strong>。如果派生类的函数和基类的函数同名，但是参数不同，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载以及覆盖混淆）；</li><li>函数名相同且<strong>参数相同</strong>，但是基类函数没有 virtual关键字。此时，基类的函数被隐藏（否则就是重写了）。</li></ol><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序:"></a>示例程序:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void A(int x)&#123; cout &lt;&lt; &quot;Base::A(int)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    void A(float x)&#123; cout &lt;&lt; &quot;Base::A(float)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B(void)&#123; cout &lt;&lt; &quot;Base::B(void)&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void C(float x)&#123; cout &lt;&lt; &quot;Base::C(float)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void D(float x)&#123; cout &lt;&lt; &quot;Base::D(float)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    void E(float x)&#123; cout &lt;&lt; &quot;Base::E(float) &quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void B(void)&#123; cout &lt;&lt; &quot;Derived::B(void)&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void C(float x)&#123; cout &lt;&lt; &quot;Derived::C(float)&quot; &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void D(int x)&#123; cout &lt;&lt; &quot;Derived::D(int)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    void E(float x)&#123; cout &lt;&lt; &quot;Derived::E(float)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>重载：函数Base::A(int)与Base::A(float)相互重载</li><li>重写：函数Derived::B(void)重写了Base::B(void)，函数Derived::C(float)重写了Base::C(float)</li><li>隐藏：函数Derived:: D(int)隐藏了Base:: D(float)，函数Derived::E(float)隐藏了Base::E(float)</li></ul><h2 id="ref-2"><a href="#ref-2" class="headerlink" title="ref"></a>ref</h2><ul><li><a href="https://blog.csdn.net/qq_26437925/article/details/54933326">C++ 类成员函数的重载(overload)，重写&#x2F;覆盖(override)，隐藏</a></li><li><a href="https://www.cnblogs.com/-Mr-y/p/8352074.html#_lab2_1_1">函数重载(overload)和函数重写(override)</a></li><li><a href="https://www.cnblogs.com/luxiaoxun/archive/2012/08/09/2630751.html">C++的重载（overload）与重写（override）</a></li></ul><h1 id="函数模板与函数重载的异同？"><a href="#函数模板与函数重载的异同？" class="headerlink" title="函数模板与函数重载的异同？"></a>函数模板与函数重载的异同？</h1><ul><li>函数的重载是指定义了几个名字相同，但参数的类型或参数的个数不同的函数；</li><li>模板函数是指的几个函数的具体算法相同，而参数类型不同的函数；</li><li>模板函数可以减少重载函数，但也可能引发错误。</li></ul><h1 id="C-中的空类，默认会产生哪些类成员函数"><a href="#C-中的空类，默认会产生哪些类成员函数" class="headerlink" title="C++中的空类，默认会产生哪些类成员函数"></a>C++中的空类，默认会产生哪些类成员函数</h1><ul><li>默认构造函数 </li><li>析构函数 </li><li>拷贝构造函数 </li><li>赋值运算符（operator&#x3D;） </li><li>取址运算符（operator&amp;）（一对，一个非const的，一个const的）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Empty</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    Empty(); // 缺省构造函数</span><br><span class="line">    Empty( const Empty&amp; ); // 拷贝构造函数</span><br><span class="line">    ~Empty(); // 析构函数</span><br><span class="line">    Empty&amp; operator=( const Empty&amp; ); // 赋值运算符</span><br><span class="line">    Empty* operator&amp;(); // 取址运算符</span><br><span class="line">    const Empty* operator&amp;() const; // 取址运算符 const</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="类在内存中的存储方式"><a href="#类在内存中的存储方式" class="headerlink" title="类在内存中的存储方式"></a>类在内存中的存储方式</h1><ul><li>类的静态成员变量编译时被分配到静态&#x2F;全局区，因此静态成员变量是属于类的，所有对象共用一份，不计入类的内存空间</li><li>静态成员函数和非静态成员函数都是存放在代码区的，是属于类的，类可以直接调用静态成员函数，不可以直接调用非静态成员函数，两者主要的区别是有无this指针</li><li>派生类对象的存储空间 &#x3D; 基类存储空间 + 派生类特有的非static数据成员的空间<br><a href="https://zhuanlan.zhihu.com/p/103384358">C++类在内存中的存储方式</a></li></ul><h1 id="类成员变量的初始化顺序"><a href="#类成员变量的初始化顺序" class="headerlink" title="类成员变量的初始化顺序"></a>类成员变量的初始化顺序</h1><p>成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。</p><p><a href="https://www.cnblogs.com/littleswan/p/12511022.html">C++类成员变量的初始化顺序</a></p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><img src="https://i.loli.net/2020/08/27/ZNPO91H7jUeS6Ti.png" alt="数据类型"></p><h1 id="sizeof-与-strlen-的区别"><a href="#sizeof-与-strlen-的区别" class="headerlink" title="sizeof 与 strlen 的区别"></a>sizeof 与 strlen 的区别</h1><ul><li>sizeof是一个操作符，而strlen是库函数。</li><li>sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为’\0’的字符串作参数。</li><li>编译器在编译时就计算出了sizeof的结果，而strlen必须在运行时才能计算出来。</li><li>sizeof计算数据类型占内存的大小，strlen计算字符串实际长度。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; strlen(&quot;123&quot;) &lt;&lt; endl; //3</span><br><span class="line">cout &lt;&lt; sizeof(&quot;123&quot;) &lt;&lt; endl; //4</span><br></pre></td></tr></table></figure></li></ul><h1 id="strcpy-和-memcpy-的区别"><a href="#strcpy-和-memcpy-的区别" class="headerlink" title="strcpy 和 memcpy 的区别"></a>strcpy 和 memcpy 的区别</h1><p>strcpy 和 memcpy 都是标准C库函数</p><h2 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h2><p>strcpy提供了字符串的复制。即strcpy只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符。</p><p><code>char* strcpy(char* dest, const char* src);</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char * strcpy(char * dest, const char * src) // 实现src到dest的复制</span><br><span class="line">&#123;</span><br><span class="line">　　if ((src == NULL) || (dest == NULL)) //判断参数src和dest的有效性</span><br><span class="line">　　　　　　return NULL;</span><br><span class="line">　　char *strdest = dest;        //保存目标字符串的首地址</span><br><span class="line">　　while ((*strDest++ = *strSrc++)!=&#x27;\0&#x27;); //把src字符串的内容复制到dest下</span><br><span class="line">　　return strdest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h2><p>memcpy提供了一般内存的复制。即memcpy对于需要复制的内容没有限制，因此用途更广。</p><p><code>void *memcpy( void *dest, const void *src, size_t count );</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *memTo, const void *memFrom, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">　　if((memTo == NULL) || (memFrom == NULL)) //memTo和memFrom必须有效</span><br><span class="line">         return NULL;</span><br><span class="line">　　char *tempFrom = (char *)memFrom;             //保存memFrom首地址</span><br><span class="line">　　char *tempTo = (char *)memTo;                  //保存memTo首地址      </span><br><span class="line">　　while(size -- &gt; 0)                //循环size次，复制memFrom的值到memTo中</span><br><span class="line">       　　*tempTo++ = *tempFrom++ ;  </span><br><span class="line">　　return memTo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li><li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</li><li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li></ol><h1 id="x-amp-x-1"><a href="#x-amp-x-1" class="headerlink" title="x &amp; (x-1)"></a>x &amp; (x-1)</h1><p>相当于消除了 x 从右向左数遇到的第一个1。</p><h1 id="short-i-x3D-0-i-x3D-i-1L；这两句有错吗"><a href="#short-i-x3D-0-i-x3D-i-1L；这两句有错吗" class="headerlink" title="short i &#x3D; 0; i &#x3D; i + 1L；这两句有错吗"></a>short i &#x3D; 0; i &#x3D; i + 1L；这两句有错吗</h1><p>代码一是错的，代码二是正确的。</p><p><strong>说明</strong>：在数据安全的情况下大类型的数据向小类型的数据转换一定要显示的强制类型转换。</p><h1 id="amp-amp-和-amp-、-和-有什么区别"><a href="#amp-amp-和-amp-、-和-有什么区别" class="headerlink" title="&amp;&amp;和&amp;、||和|有什么区别"></a>&amp;&amp;和&amp;、||和|有什么区别</h1><ul><li>&amp;和|对操作数进行求值运算，&amp;&amp;和||只是判断逻辑关系。</li><li>&amp;&amp;和||在在判断左侧操作数就能确定结果的情况下就不再对右侧操作数求值。</li></ul><p><em>注意：在编程的时候有些时候将&amp;&amp;或||替换成&amp;或|没有出错，但是其逻辑是错误的，可能会导致不可预想的后果（比如当两个操作数一个是 1 另一个是 2 时。</em></p><h1 id="struct定义的四种方法"><a href="#struct定义的四种方法" class="headerlink" title="struct定义的四种方法"></a>struct定义的四种方法</h1><p>第一种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体名称&#123; </span><br><span class="line">   数据类型 member1； </span><br><span class="line">   数据类型 member2; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>第二种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct 结构体名称&#123; </span><br><span class="line">   数据类型 member1； </span><br><span class="line">   数据类型 member2; </span><br><span class="line">&#125;结构体名称别名; </span><br></pre></td></tr></table></figure><p>第三种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体名称&#123; </span><br><span class="line">   数据类型 member1； </span><br><span class="line">   数据类型 member2; </span><br><span class="line">&#125;结构体变量;</span><br></pre></td></tr></table></figure><p>第四种：此方式是匿名结构体，在定义时同时声明结构体变量，但不能在其它地方声明，因为我们无法得知该结构体的标识符，所以就无法通过标识符来声明变量。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &#123; </span><br><span class="line">   数据类型 member1； </span><br><span class="line">   数据类型 member2; </span><br><span class="line">&#125;结构体变量名;</span><br></pre></td></tr></table></figure><h1 id="联合（union）、结构（struct）、类（class）"><a href="#联合（union）、结构（struct）、类（class）" class="headerlink" title="联合（union）、结构（struct）、类（class）"></a>联合（union）、结构（struct）、类（class）</h1><ul><li><p>联合<br>在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的。<strong>union变量所占用的内存长度等于最长的成员的内存长度</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">union A</span><br><span class="line">&#123;//sizeof(union A)的值为8</span><br><span class="line">    char mark;</span><br><span class="line">    long num;</span><br><span class="line">    float score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>结构<br>将不同类型的数据组合成一个整体，是自定义类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct B</span><br><span class="line">&#123;//sizeof(struct B)的值为24</span><br><span class="line">    char mark;</span><br><span class="line">    long num;</span><br><span class="line">    float score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>结构体：将不同类型的数据组合成一个整体，是自定义类型</p></li></ul><p>区别：</p><ol><li><strong>结构体</strong>中的每个成员都有自己独立的地址，它们是同时存在的；<strong>共同体</strong>中的所有成员占用同一段内存，它们不能同时存在；</li><li>sizeof(struct)是内存对齐后所有成员长度的总和，sizeof(union)是内存对齐后最长数据成员的长度</li></ol><h2 id="结构体为什么要内存对齐呢？"><a href="#结构体为什么要内存对齐呢？" class="headerlink" title="结构体为什么要内存对齐呢？"></a>结构体为什么要内存对齐呢？</h2><p>看下面</p><h1 id="内存对齐（字节对齐）"><a href="#内存对齐（字节对齐）" class="headerlink" title="内存对齐（字节对齐）"></a>内存对齐（字节对齐）</h1><p><code>#pragma pack(n)</code> 表示的是设置n字节对齐，windows默认是8，linux是4。</p><h2 id="内存对齐规则"><a href="#内存对齐规则" class="headerlink" title="内存对齐规则"></a>内存对齐规则</h2><p>对于结构的各个成员，第一个成员位于偏移为0的位置，以后的每个数据成员的偏移量必须是 min(#pragma pack()指定的数,这个数据成员的自身长度)的倍数。</p><p>在所有的数据成员完成各自对齐之后，结构或联合体本身也要进行对齐，对齐将按照 #pragam pack指定的数值和结构或者联合体最大数据成员长度中比较小的那个，也就是 min(#pragram pack() , 长度最长的数据成员)。</p><h2 id="需要对齐的原因"><a href="#需要对齐的原因" class="headerlink" title="需要对齐的原因"></a>需要对齐的原因</h2><ul><li>平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</li><li>硬件原因：经过内存对齐之后，CPU的内存访问速度大大提升。访问未对齐的内存，处理器要访问两次（数据先读高位，再读低位），访问对齐的内存，处理器只要访问一次，为了提高处理器读取数据的效率，我们使用内存对齐</li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">    char a;</span><br><span class="line">    int b;</span><br><span class="line">    short c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>char占一个字节，起始偏移为零，int占四个字节，min(8,4)&#x3D;4；所以应该偏移量为4，所以应该在char后面加上三个字节，不存放任何东西，short占两个字节，min(8,2)&#x3D;2;所以偏移量是2的倍数，而short偏移量是8，是2的倍数，所以无需添加任何字节，所以第一个规则对齐之后内存状态为0xxx|0000|00</li><li>此时一共占了10个字节，但是还有结构体本身的对齐，min(8,4)&#x3D;4；所以总体应该是4的倍数，所以还需要添加两个字节在最后面，所以内存存储状态变为了 0xxx|0000|00xx，一共占据了12个字节</li></ul><p>ref. <a href="https://songlee24.github.io/2014/09/20/memory-alignment/">C&#x2F;C++内存对齐</a></p><h1 id="c-资源管理机制"><a href="#c-资源管理机制" class="headerlink" title="c++资源管理机制"></a>c++资源管理机制</h1><h2 id="内存的分类"><a href="#内存的分类" class="headerlink" title="内存的分类"></a>内存的分类</h2><ol><li><p><strong>堆（heap）</strong>：指的是动态分配内存的区域。这里的内存，<strong>需要程序员手动分配和释放（new,delete）</strong>，否则，就会造成内存泄漏。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。<br>与之相关的一个概念是<strong>自由存储区(free store)<strong>，特指使用 new 和 delete 来分配和释放内存的区域。一般来说，这是</strong>堆的一个子集</strong>。<br>new 和 delete 操作的区域是 free store<br>malloc 和 free 操作的区域是 heap<br><em>ps: new 和 delete 通常底层使用 malloc 和 free 来实现，所以 free store 也属于 heap</em></p></li><li><p><strong>栈（stack）</strong>：函数调用过程中产生的本地变量和调用数据的区域。由编译器自动分配和释放。<br>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p></li></ol><p><em>凡生命周期超出当前函数的，一般需要用堆（或者使用对象移动传递）。反之，生命周期在当前函数内的，就该用栈。</em></p><ol start="3"><li><p><strong>全局&#x2F;静态存储区（static）</strong>：全局变量和静态变量被分配到同一块内存中。<strong>程序结束后由系统释放。</strong><br>它们是在程序编译、链接时完全确定下来的，具有固定的存储位置（暂不考虑某些系统的地址扰乱机制）。堆和栈上的变量则都是动态的，地址无法确定。</p></li><li><p><strong>常量存储区</strong>：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。<strong>程序结束后由系统释放</strong>。</p></li><li><p><strong>程序代码区</strong>：存放程序的二进制代码。</p></li></ol><h2 id="栈展开（stack-unwinding）"><a href="#栈展开（stack-unwinding）" class="headerlink" title="栈展开（stack unwinding）"></a>栈展开（stack unwinding）</h2><p>指的是：如果在一个函数内部抛出异常，而此异常并未在该函数内部被捕捉，就将导致该函数的运行在抛出异常处结束，所有已经分配在栈上的局部变量都要被释放。<br><a href="https://www.dazhuanlan.com/2019/09/29/5d8fb29e775ec/">示例</a></p><p>最常见的栈展开就是正常的函数调用，任何一个函数返回都存在栈展开。C++引入异常机制后，当程序抛出异常，在异常向上传递的过程中，其函数调用栈也会展开。</p><p><a href="https://time.geekbang.org/column/article/169225">栈展开演示：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">class Obj &#123;</span><br><span class="line">public:</span><br><span class="line">  Obj() &#123; puts(&quot;Obj()&quot;); &#125;</span><br><span class="line">  ~Obj() &#123; puts(&quot;~Obj()&quot;); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(int n)</span><br><span class="line">&#123;</span><br><span class="line">  Obj obj;</span><br><span class="line">  if (n == 42)</span><br><span class="line">    throw &quot;life, the universe and everything&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    foo(41);</span><br><span class="line">    foo(42);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (const char* s) &#123;</span><br><span class="line">    puts(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行结果：不管是否发生了异常，obj 的析构函数都会得到执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Obj()</span><br><span class="line">~Obj()</span><br><span class="line">Obj()</span><br><span class="line">~Obj()</span><br><span class="line">life, the universe and everything</span><br></pre></td></tr></table></figure><h2 id="RAII-Resource-Acquisition-Is-Initialization"><a href="#RAII-Resource-Acquisition-Is-Initialization" class="headerlink" title="RAII(Resource Acquisition Is Initialization)"></a>RAII(Resource Acquisition Is Initialization)</h2><p>是 C++ 所特有的资源管理方式。RAII 依托栈和析构函数，来对所有的资源（包括堆内存在内）进行管理。</p><p>其原理是在对象析构函数中释放该对象获取的资源，利用栈展开过程栈上对象的析构函数将被自动调用的保证，从而正确地释放先前获取的资源。</p><p>RAII只有在栈展开正常执行的前提下才能正常工作。函数调用和正常的C++异常处理流程(异常处于try-catch块)都存在栈展开。</p><h2 id="申请后系统的响应"><a href="#申请后系统的响应" class="headerlink" title="申请后系统的响应"></a>申请后系统的响应</h2><p>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。<br>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p><h2 id="malloc-x2F-free-和-new-x2F-delete-区别："><a href="#malloc-x2F-free-和-new-x2F-delete-区别：" class="headerlink" title="malloc&#x2F;free 和 new&#x2F;delete 区别："></a>malloc&#x2F;free 和 new&#x2F;delete 区别：</h2><ol><li><p>属性不同：malloc&#x2F;free是标准库函数，new&#x2F;delete是操作符（运算符）。</p></li><li><p>申请的内存所在位置：new操作符从<strong>自由存储区（free store）</strong>上为对象动态分配内存空间，而malloc函数从<strong>堆</strong>上动态分配内存。 </p></li><li><p>内存分配失败时的返回值：new内存分配失败时，会抛出<strong>bad_alloc异常</strong>，它不会返回NULL；malloc分配内存失败时返回<strong>NULL</strong>。</p></li><li><p>是否需要指定内存大小：new&#x2F;delete分配可以自动计算需要的字节数，malloc&#x2F;free需要人为指定。</p></li><li><p>是否调用构造函数&#x2F;析构函数：</p><ul><li>new会先调用operator_new函数，申请足够的内存（通常底层使用malloc实现），然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator_delete函数释放内存（通常底层使用free实现）。  </li><li>malloc&#x2F;free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</li></ul></li><li><p>能否重载：new&#x2F;delete允许重载,malloc&#x2F;free不允许重载</p></li><li><p>已分配内存的扩充：malloc&#x2F;free可以通过realloc函数扩充，new&#x2F;free无法直观地处理</p></li><li><p>能否相互调用：operator_new&#x2F;operator _delete的实现可以基于malloc&#x2F;free，而malloc的实现不可以去调用new。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//main.cpp</span><br><span class="line">int a = 0; //全局初始化区</span><br><span class="line">char *p1; //全局未初始化区</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">int b; //栈</span><br><span class="line">char s[] = &quot;abc&quot;; //栈</span><br><span class="line">char *p2; //栈</span><br><span class="line">char *p3 = &quot;123456&quot;; //123456\0在常量区，p3在栈上。</span><br><span class="line">static int c =0； //全局（静态）初始化区</span><br><span class="line">p1 = (char *)malloc(10);</span><br><span class="line">p2 = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区。</span><br><span class="line">strcpy(p1, &quot;123456&quot;); //123456\0放在常量区，编译器可能会将它与p3所指的&quot;123456&quot;优化成一个地方</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="malloc实现原理"><a href="#malloc实现原理" class="headerlink" title="malloc实现原理"></a>malloc实现原理</h2><ol><li>malloc 函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。</li><li>调用 malloc（）函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。 然后，将该内存块一分为二（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节）。 接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块（如果有的话）返回到连接表上。</li><li>调用 free 函数时，它将用户释放的内存块连接到空闲链表上。</li><li>到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段， 那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc（）函数请求延时，并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。</li></ol><p>malloc会出现的问题：初始化的问题。没有初始化的内存中内容是随机的，所以如果直接使用的话，就可能造成程序运行结果不正确。</p><p><em>ps. malloc 函数可以向程序的虚拟空间申请一块虚拟地址空间，与物理内存没有直接的关系，所以是有可能用malloc函数申请超过该机器物理内存大小的内存块的</em></p><p>ref. <a href="https://blog.csdn.net/mmshixing/article/details/51679571">linux-malloc底层实现原理</a></p><h2 id="delete-与-delete-区别"><a href="#delete-与-delete-区别" class="headerlink" title="delete 与 delete[] 区别"></a>delete 与 delete[] 区别</h2><p>delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。delete与new配套，delete []与new []配套。</p><p>在More Effective C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator delete来释放内存。”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MemTest *mTest1 = new MemTest[10];</span><br><span class="line">MemTest *mTest2 = new MemTest;</span><br><span class="line"></span><br><span class="line">Int *pInt1 = new int [10];</span><br><span class="line">Int *pInt2 = new int;</span><br><span class="line"></span><br><span class="line">delete[] pInt1;   //-1-</span><br><span class="line">delete[] pInt2;   //-2-</span><br><span class="line">delete[] mTest1;  //-3-</span><br><span class="line">delete[] mTest2;  //-4-  在-4-处报错。</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。  </p><p>delete[]删除一个数组，delete删除一个指针。</p><p>简单来说，用new分配的内存用delete删除；用new[]分配的内存用delete[]删除。delete[]会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。内存泄漏会最终会导致内存溢出。</p><p>内存泄漏的原因：</p><ol><li>异常或分支导致delete未得到执行</li><li>分配和释放不在一个函数里导致的遗漏delete</li></ol><h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，于是就发生了内存溢出。</p><h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p>野指针指向一个已删除的对象 或 申请访问受限内存区域的指针。</p><p>原因：</p><ol><li>指针变量未初始化。<strong>解决办法</strong>：指针声明时初始化，可以是具体的地址值，也可让它指向 NULL。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *p;   //此时p为野指针</span><br></pre></td></tr></table></figure></li><li>指针释放未置空：指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。<strong>解决办法</strong>：指针指向的内存空间被释放后指针应该指向。NULL。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *p=new char[10];  //指向堆中分配的内存首地址</span><br><span class="line">cin&gt;&gt; p;</span><br><span class="line">delete []p; //p重新变为野指针</span><br></pre></td></tr></table></figure></li><li>指针操作超出作用域。返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。<strong>解决办法</strong>：在变量的作用域结束前释放掉变量的地址空间并且让指针指向 NULL。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *p=new char[10];  //指向堆中分配的内存首地址</span><br><span class="line">cin&gt;&gt; p;</span><br><span class="line">cout&lt;&lt;*(p+10);  //可能输出未知数据</span><br></pre></td></tr></table></figure><em>ps. “野指针”的解决方法也是编程规范的基本原则，平时使用指针时一定要避免产生“野指针”，在使用指针前一定要检验指针的合法性。</em></li></ol><h2 id="栈内存与文字常量区"><a href="#栈内存与文字常量区" class="headerlink" title="栈内存与文字常量区"></a>栈内存与文字常量区</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">char str1[] = &quot;abc&quot;;</span><br><span class="line">char str2[] = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">const char str3[] = &quot;abc&quot;;</span><br><span class="line">const char str4[] = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">const char *str5 = &quot;abc&quot;;</span><br><span class="line">const char *str6 = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">char *str7 = &quot;abc&quot;;</span><br><span class="line">char *str8 = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl;//0 分别指向各自的栈内存</span><br><span class="line">cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl;//0 分别指向各自的栈内存</span><br><span class="line">cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl;//1 指向文字常量区地址相同</span><br><span class="line">cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl;//1 指向文字常量区地址相同</span><br></pre></td></tr></table></figure><p>str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。</p><h2 id="ref-3"><a href="#ref-3" class="headerlink" title="ref"></a>ref</h2><ul><li><a href="https://time.geekbang.org/column/article/169225">极客时间《现代C++实战30讲》：01 | 堆、栈、RAII：C++里该如何管理资源？</a></li><li><a href="https://zh.wikipedia.org/zh-cn/RAII">RAII(wiki)</a></li><li><a href="https://www.cnblogs.com/qg-whz/p/5060894.html">C++ 自由存储区是否等价于堆？</a></li><li><a href="https://www.zhihu.com/question/281940376">为什么c++中要分为heap（堆）和stack（栈）</a>  </li><li><a href="https://zhuanlan.zhihu.com/p/82298443">C&#x2F;C++内存分配</a></li><li><a href="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/">C&#x2F;C++内存管理详解</a></li></ul><h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><p>声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。</p><ol><li><strong>引用</strong>只是变量的一个别名，<strong>指针</strong>是变量的地址，有分配内存。</li><li><strong>指针</strong>可以指向空值，但是在任何情况下都不能使用指向空值的<strong>引用</strong>。引用在声明时必须初始化。</li><li>指针与引用的另一个重要的不同是：<strong>指针</strong>可以被重新赋值以指向另一个不同的对象，但是<strong>引用</strong>则总是指向在初始化时被指定的对象，以后不能改变。  </li><li><strong>sizeof的意义</strong>不同：使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小。</li><li>指针和引用的<strong>自增运算符意义</strong>不同：指针是对内存地址的自增，引用是对值的自增</li><li>没有引用常量，有指针常量</li><li>参数传递：作为参数传递时，指针需要被<strong>解引用</strong>才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象</li><li>多级指针，一级引用. 指针可以有多级指针（**p），而引用只有一级</li><li>作为参数时，引用更安全，因为指针传递时会涉及到形参和实参，会多开辟内存。</li></ol><p>在以下情况下你应该使用指针：</p><ul><li>你考虑到存在不指向任何对象的可能(在 这种情况下，你能够设置指针为空)</li><li>你需要能够在不同的时刻指向不同的对象(在这种情况下，你能改变指针的指向)。</li></ul><p>如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。</p><p><em>ps: 函数传参时，可以使用引用。<br>&amp;emsp;&amp;emsp;引用也可以作为函数的返回值。但是要注意<code>不要返回局部变量引用</code>。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//返回局部变量引用</span><br><span class="line">int&amp; test01() &#123;</span><br><span class="line">int a = 10; //局部变量</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回静态变量引用</span><br><span class="line">int&amp; test02() &#123;</span><br><span class="line">static int a = 20;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ref-4"><a href="#ref-4" class="headerlink" title="ref"></a>ref</h2><ul><li>《more effective C++》 Item M1:指针与引用的区别  </li><li><a href="https://blog.csdn.net/weikangc/article/details/49762929">C++中指针和引用的区别</a></li><li><a href="https://github.com/twomonkeyclub/BackEnd/tree/master/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">C&#x2F;C++基础知识</a></li></ul><h1 id="函数参数传递中值传递、地址传递、引用传递有什么区别？"><a href="#函数参数传递中值传递、地址传递、引用传递有什么区别？" class="headerlink" title="函数参数传递中值传递、地址传递、引用传递有什么区别？"></a>函数参数传递中值传递、地址传递、引用传递有什么区别？</h1><ul><li>值传递，会为形参重新分配内存空间，将实参的值拷贝给形参，形参的值不会影响实参的值，函数调用结束后形参被释放；</li><li>引用传递，不会为形参重新分配内存空间，形参只是实参的别名，形参的改变会影响实参的值，函数调用结束后形参不会被释放；</li><li>地址传递，形参为指针变量，将实参的地址传递给函数，可以在函数中改变实参的值，调用时为形参指针变量分配内存，结束时释放指针变量。</li></ul><h1 id="常量指针，指针常量，常量引用，没有引用常量"><a href="#常量指针，指针常量，常量引用，没有引用常量" class="headerlink" title="常量指针，指针常量，常量引用，没有引用常量"></a>常量指针，指针常量，常量引用，没有引用常量</h1><ul><li>常量指针（常指针）：是一个指针，指向一个常量。</li><li>指针常量：是一个常量，这个常量的类型是指针</li><li>常量引用：是一个引用，是常量的引用</li><li>没有引用常量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//常量指针</span><br><span class="line">const int* p = &amp;a;  // *p 为常量，不能通过*p改变它指向的内容 </span><br><span class="line">int const* p = &amp;a;  // *p 为常量，同上</span><br><span class="line"></span><br><span class="line">//指针常量</span><br><span class="line">int* const p = &amp;a;  // p 为常量，初始化后不能再指向其它内容</span><br><span class="line"></span><br><span class="line">//指向常量的 常指针</span><br><span class="line">const int * const p;</span><br><span class="line">int const * const p;</span><br><span class="line"></span><br><span class="line">//常量引用</span><br><span class="line">int a = 10;</span><br><span class="line">const int &amp;r = a;</span><br><span class="line">const int &amp;r = 10;</span><br></pre></td></tr></table></figure><h1 id="常引用有什么作用"><a href="#常引用有什么作用" class="headerlink" title="常引用有什么作用"></a>常引用有什么作用</h1><p>常引用的引入主要是为了避免使用变量的引用时，在不知情的情况下改变变量的值。</p><p>常引用主要用于定义一个普通变量的只读属性的别名、作为函数的传入形参，避免实参在调用函数中被意外的改变。</p><p><strong>说明</strong>：很多情况下，需要用常引用做形参，被引用对象等效于常对象，不能在函数中改变实参的值，这样的好处是有较高的易读性和较小的出错率。</p><h1 id="指针常量与常量指针区别"><a href="#指针常量与常量指针区别" class="headerlink" title="指针常量与常量指针区别"></a>指针常量与常量指针区别</h1><ul><li><strong>指针常量</strong>是指这个指针的值只能在定义时初始化，其他地方不能改变。（重点在常量）</li><li><strong>常量指针</strong>是指这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。（重点在指针）</li></ul><p>指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。</p><p><em>注意：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。</em></p><h1 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h1><h2 id="指针和数组的区别"><a href="#指针和数组的区别" class="headerlink" title="指针和数组的区别"></a>指针和数组的区别</h2><ul><li><strong>概念不同</strong>。指针相当于一个变量，它存放的是数据在内存中的地址；数组是用于储存多个相同类型数据的集合</li><li><strong>赋值不同</strong>。同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝</li><li><strong>访问数据不同</strong>。指针是间接访问数据，获取指针，先解引用，再访问指针指向的地址中的内容；数组是直接访问</li><li><strong>sizeof意义不同</strong>。数组所占存储空间的内存：sizeof（数组名） 数组的大小：sizeof（数组名）&#x2F;sizeof（数据类型） 在32位平台下，sizeof（指针名）是4，在64位平台下，sizeof（指针名）是8</li><li><strong>指针和数组名异同</strong>。指针和数组名都可以表示地址，但指针是变量，可以修改；数组名是常量，不可修改赋值</li><li><strong>传参</strong>。数组传参时会退化成指针</li></ul><h2 id="指针数组和数组指针"><a href="#指针数组和数组指针" class="headerlink" title="指针数组和数组指针"></a>指针数组和数组指针</h2><ul><li><p>指针数组：它本质上是一个数组，数组的每个元素存放的是一个指针类型的元素。 int* arr[8];</p><ol><li>优先级问题：[]的优先级比*高</li><li>说明arr是一个数组，而int*是数组里面的内容</li><li>这句话的意思就是：arr是一个含有8和int*的数组</li></ol></li><li><p>数组指针：它本质上是一个指针，该指针指向一个数组。 int (*arr)[8];</p><ol><li>由于[]的优先级比<em>高，因此在写数组指针的时候必须将</em>arr用括号括起来</li><li>arr先和*结合，说明p是一个指针变量</li><li>这句话的意思就是：指针arr指向一个大小为8个整型的数组。</li></ol></li></ul><p><em>ps. 谁优先级高，本质是谁</em></p><h2 id="数组名和指针的区别"><a href="#数组名和指针的区别" class="headerlink" title="数组名和指针的区别"></a>数组名和指针的区别</h2><p>数组名并不是真正意义上的指针，它的内涵要比指针丰富的多。但是当数组名当做参数传递给函数后，其失去原来的含义，变作普通的指针。另外要注意 sizeof 不是函数，只是操作符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">char str[13]=&quot;Hello world!&quot;;</span><br><span class="line">char *pStr=&quot;Hello world!&quot;;</span><br><span class="line">cout&lt;&lt;sizeof(str)&lt;&lt;endl; //13</span><br><span class="line">cout&lt;&lt;sizeof(pStr)&lt;&lt;endl; //4</span><br><span class="line">cout&lt;&lt;strlen(str)&lt;&lt;endl; //12</span><br><span class="line">cout&lt;&lt;strlen(pStr)&lt;&lt;endl; //12</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>int a[10]和int* a &#x3D; new int[10]的区别：  </p><ul><li>int a[10]是静态分配</li><li>int* a&#x3D;new int[10]]是动态分配</li></ul><h2 id="数组的存放"><a href="#数组的存放" class="headerlink" title="数组的存放"></a>数组的存放</h2><ul><li>固定数组<ul><li>在函数体内分配的（不带static）是在栈中</li><li>全局变量&#x2F;带static的局部变量 是在全局数据存储区</li><li>类中分配的在堆中</li></ul></li><li>动态数组，都在堆中</li></ul><p>说明：</p><ol><li><code>int a[10]</code>使用简单，系统会自动实现内存的分配和回收。<code>int* a = new int[10]</code>需要判断内存是否分配成功，以及在不用时需要使用<code>delete[] a</code>进行内存释放，否则会造成内存泄漏； </li><li>如果不是<code>a[10]</code>，而是<code>a[1000000000]</code>或者更大的话，那一般情况下，就只能使用<code>int* a = new</code>这种方式了。这个涉及到内存存放位置的问题，<code>int a[]</code>这种方式，内存是存放在栈上；<code>int* a ＝ new</code>这种方式，内存是存放在堆上，栈的实际内存是连续内存，因此可分配空间较小，堆可以是非连续内存，因此可以分配较大内存。因此，如果需要分配较大内存，需要分配在堆上；（注意，同一个new出来的是连续内存，new一个一维数组确实是连续内存，但多个new出来的就不是连续内存了。）</li><li>使用<code>int a[10]</code>这种方式，内存大小需要用常量指定，比如这里的10。不能用<code>int m＝10; int a[m]</code>这种方式。但是<code>int* a= new</code>这种方式可以，因此在动态分配内存上，后者有非常大的优势。</li></ol><h2 id="ref-5"><a href="#ref-5" class="headerlink" title="ref"></a>ref</h2><ul><li><a href="https://github.com/twomonkeyclub/BackEnd/tree/master/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">C&#x2F;C++基础知识</a></li><li><a href="https://blog.csdn.net/anycodes/article/details/41087785">C&#x2F;C++ 数组的初始化</a></li></ul><h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><p>C++另一种编程思想称为<strong>泛型编程</strong>，主要利用的技术就是模板。</p><p>C++提供两种模板机制：<strong>函数模板</strong> 和 <strong>类模板</strong></p><h2 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h2><p>函数模板作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure><ul><li>template：声明创建模板  </li><li>typename：表面其后面的符号是一种数据类型，可以用class代替  </li><li>T：通用的数据类型，名称可以替换，通常为大写字母</li></ul><p>使用函数模板有两种方式：</p><ol><li>自动类型推导</li><li>显示指定类型</li></ol><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void mySwap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//利用模板实现交换</span><br><span class="line">//1、自动类型推导</span><br><span class="line">int a = 1, b = 2;</span><br><span class="line">mySwap(a, b);</span><br><span class="line"></span><br><span class="line">//2、显示指定类型</span><br><span class="line">mySwap&lt;int&gt;(a, b);</span><br></pre></td></tr></table></figure><h3 id="普通函数与函数模板的区别"><a href="#普通函数与函数模板的区别" class="headerlink" title="普通函数与函数模板的区别"></a>普通函数与函数模板的区别</h3><ul><li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li><li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显示指定类型的方式，可以发生隐式类型转换</li></ul><h3 id="普通函数与函数模板的调用规则"><a href="#普通函数与函数模板的调用规则" class="headerlink" title="普通函数与函数模板的调用规则"></a>普通函数与函数模板的调用规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//普通函数与函数模板调用规则</span><br><span class="line">void myPrint(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void myPrint(T a, T b) </span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void myPrint(T a, T b, T c) </span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; &quot;调用重载的模板&quot; &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span><br><span class="line">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">myPrint(a, b); //调用普通函数</span><br><span class="line"></span><br><span class="line">//2、可以通过空模板参数列表来强制调用函数模板</span><br><span class="line">myPrint&lt;&gt;(a, b); //调用函数模板</span><br><span class="line"></span><br><span class="line">//3、函数模板也可以发生重载</span><br><span class="line">int c = 30;</span><br><span class="line">myPrint(a, b, c); //调用重载的函数模板</span><br><span class="line"></span><br><span class="line">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span><br><span class="line">char c1 = &#x27;a&#x27;;</span><br><span class="line">char c2 = &#x27;b&#x27;;</span><br><span class="line">myPrint(c1, c2); //调用函数模板</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数模版实例"><a href="#函数模版实例" class="headerlink" title="函数模版实例"></a>函数模版实例</h3><p><em>转自下方参考1</em></p><p>利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序<br>排序规则从大到小，排序算法为选择排序<br>分别利用char数组和int数组进行测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">//交换的函数模板</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void mySwap(T &amp;a, T&amp;b)</span><br><span class="line">&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;class T&gt; // 也可以替换成typename</span><br><span class="line">//利用选择排序，进行对数组从大到小的排序</span><br><span class="line">void mySort(T arr[], int len)</span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">int max = i; //最大数的下标</span><br><span class="line">for (int j = i + 1; j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[max] &lt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">max = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (max != i) //如果最大数的下标不是i，交换两者</span><br><span class="line">&#123;</span><br><span class="line">mySwap(arr[max], arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void printArray(T arr[], int len) &#123;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">//测试char数组</span><br><span class="line">char charArr[] = &quot;bdcfeagh&quot;;</span><br><span class="line">int num = sizeof(charArr) / sizeof(char);</span><br><span class="line">mySort(charArr, num);</span><br><span class="line">printArray(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">//测试int数组</span><br><span class="line">int intArr[] = &#123; 7, 5, 8, 1, 3, 9, 2, 4, 6 &#125;;</span><br><span class="line">int num = sizeof(intArr) / sizeof(int);</span><br><span class="line">mySort(intArr, num);</span><br><span class="line">printArray(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类模版"><a href="#类模版" class="headerlink" title="类模版"></a>类模版</h2><p>类模板作用：建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure><ul><li>template：声明创建模板</li><li>typename：表面其后面的符号是一种数据类型，可以用class代替</li><li>T：通用的数据类型，名称可以替换，通常为大写字母</li></ul><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class NameType, class AgeType&gt; </span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;mName = name;</span><br><span class="line">this-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line">void showPerson()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">NameType mName;</span><br><span class="line">AgeType mAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类模板与函数模板区别"><a href="#类模板与函数模板区别" class="headerlink" title="类模板与函数模板区别"></a>类模板与函数模板区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">//类模板</span><br><span class="line">template&lt;class NameType, class AgeType = int&gt; </span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;mName = name;</span><br><span class="line">this-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line">void showPerson()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">NameType mName;</span><br><span class="line">AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//1、类模板没有自动类型推导的使用方式</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span><br><span class="line">Person &lt;string ,int&gt;p(&quot;孙悟空&quot;, 1000); //必须使用显示指定类型的方式，使用类模板</span><br><span class="line">p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2、类模板在模板参数列表中可以有默认参数</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">Person &lt;string&gt; p(&quot;猪八戒&quot;, 999); //类模板中的模板参数列表 可以指定默认参数</span><br><span class="line">p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ref-6"><a href="#ref-6" class="headerlink" title="ref"></a>ref</h2><p><a href="https://github.com/AnkerLeng/Cpp-0-1-Resource/blob/master/%E7%AC%AC5%E9%98%B6%E6%AE%B5-C%2B%2B%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E8%B5%84%E6%96%99/%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E8%B5%84%E6%96%99/%E8%AE%B2%E4%B9%89/C%2B%2B%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B.md">C++提高编程</a></p><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>不可修改</p><ul><li>修饰变量，说明该变量不可以被改变；</li><li>修饰指针，分为指向常量的指针和指针常量；int *const p和const int *p</li><li>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li><li>修饰成员函数，说明该成员函数内不能修改成员变量，本质是const this指针。</li></ul><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>对外不可见</p><ul><li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，在整个程序运行期间一直存在，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它，<strong>自动初始化为0</strong>。  <ul><li>全局变量作用域：全局静态变量在声明他的文件之外是不可见的，即便是 extern 外部声明也不可以。准确地说是从定义之处开始，到文件结尾。</li><li>局部变量作用域：仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</li></ul></li><li>修饰普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用</li><li>修饰类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过&lt;类名&gt;::&lt;静态成员&gt;来使用。在 static 函数内不能访问非静态成员</li></ul><p><a href="https://www.runoob.com/w3cnote/cpp-static-usage.html">static的用法</a></p><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>修饰变量或函数，表示该函数可以跨文件访问，或者表明该变量在其他文件定义，在此处引用。</p><p><strong>extern</strong>关键字的作用是共享代码。</p><ol><li>在其他文件中定义过的全局变量，在另一个文件中要调用时，只需在声明语句前加关键字extern。</li><li>对于常量，要调用其他文件的常量时，做法如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//文件1,定义常量</span><br><span class="line">extern const int i = 1;</span><br><span class="line"></span><br><span class="line">//文件2，声明常量</span><br><span class="line">extern const int i;</span><br></pre></td></tr></table></figure></li></ol><p>注意：  </p><ul><li>定义也是声明，因为当定义变量时我们也向程序表明了它的类型和名字</li><li>但声明不是定义，可以通过使用extern关键字声明变量而不定义它。不定义变量的声明包括对象名、对象类型和对象类型前的关键字extern</li><li>extern声明不是定义，不分配存储空间</li></ul><p>ref.</p><ul><li><a href="https://blog.csdn.net/CSDNwei/article/details/51836182">extern使用方法总结</a></li></ul><h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifdef _cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">#include &quot;XXX.h&quot;</span><br><span class="line">#ifdef _cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>extern “C”的作用是，告诉C++编译器，下面的代码按照C的方式进行编译，不要对这些函数进行名字重整（function name mangling）。通常在C++程序中使用C函数或者模块时，需要用到这个功能。</p><p>ref.</p><ul><li><a href="https://blog.csdn.net/qq_38880380/article/details/80035710">C–变量的存储方式、作用域和生命周期</a></li><li><a href="https://blog.csdn.net/scottly1/article/details/44221157">extern “C”用法总结</a></li></ul><h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>explicit关键字的作用就是防止对象间实现使用 “&#x3D;” 赋值，防止类构造函数的隐式自动转换,类构造函数默认情况下即声明为implicit(隐式)，另外explicit只用于单参数的构造函数，或者除了第一个参数以外的其他参数都有默认值.</p><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li><li>explicit 修饰转换函数时，可以防止隐式转换</li></ul><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>用于程序中定义内联函数。</p><p>内联函数是C++中的一种特殊函数，它可以像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是通过将函数体直接插入调用处来实现的，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。一般来说inline用于定义类的成员函数。</p><p>在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。类内声明可以不用加上inline关键字，但是类外定义函数体时必须要加上，这样才能保证编译器能够识别其为内联函数。</p><p><em>ps. 内联函数不能包括复杂的控制语句，如循环语句和switch语句</em></p><p>示例：使用内联函数来返回两个数中的最大值  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline int Max(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">   return (x &gt; y)? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h2><p>restrict只能修饰指针，restrict修饰的指针是能够访问所指区域的唯一入口，限制多个指针指向同一地址。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile是给编译器的指示来说明对它所修饰的对象不应该执行优化。volatile的作用就是用来进行多线程编程。在单线程中那就是只能起到限制编译器优化的作用。</p><p>如果一个基本变量被volatile修饰，编译器将不会把它保存到寄存器中，而是每一次都去访问内存中实际保存该变量的位置上。这一点就避免了没有volatile修饰的变量在多线程的读写中所产生的由于编译器优化所导致的灾难性问题。所以多线程中必须要共享的基本变量一定要加上volatile修饰符。</p><h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><p>C++中4种类型转换为：</p><ol><li>static_cast<br>完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换，不能用于普通指针的转换（void空指针除外）</li><li>dynamic_cast<br>动态类型转换，用于实现RTTI（运行时类型检查）。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常bad_cast</li><li>const_cast<br>用于删除 const、volatile特性</li><li>reinterpret_cast<br>几乎什么都可以转,不能丢掉 const、volatile特性</li></ol><h1 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h1><p>多重继承（多继承，Multiple Inheritance，MI）指的是一个类可以同时继承多个类，比如A类继承自B类和C类，这就是多重继承。</p><h2 id="ref-7"><a href="#ref-7" class="headerlink" title="ref"></a>ref</h2><ul><li>Effective C++ 40：明智地使用多继承</li></ul><h1 id="变量的声明和定义有什么区别"><a href="#变量的声明和定义有什么区别" class="headerlink" title="变量的声明和定义有什么区别"></a>变量的声明和定义有什么区别</h1><p>为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但是只在一个地方定义。加入 <code>extern</code> 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。</p><h1 id="局部变量，静态局部变量，全局变量，静态全局变量的区别"><a href="#局部变量，静态局部变量，全局变量，静态全局变量的区别" class="headerlink" title="局部变量，静态局部变量，全局变量，静态全局变量的区别"></a>局部变量，静态局部变量，全局变量，静态全局变量的区别</h1><h2 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h2><ul><li>该变量在全局数据区分配内存；</li><li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li><li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0；</li><li>它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。</li></ul><h2 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h2><ul><li>静态变量都在全局数据区分配内存;</li><li>未经初始化的静态全局变量会被程序自动初始化为0（在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为 0）；</li><li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。</li></ul><h2 id="全局变量-和-静态全局变量-的区别"><a href="#全局变量-和-静态全局变量-的区别" class="headerlink" title="全局变量 和 静态全局变量 的区别"></a>全局变量 和 静态全局变量 的区别</h2><ul><li>全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。</li><li>静态全局变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。</li></ul><h2 id="存放区别"><a href="#存放区别" class="headerlink" title="存放区别"></a>存放区别</h2><p>全局（静态）存储区：分为 DATA 段和 BSS 段。DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。</p><p>全局初始化的变量：.data:<br>全局未初始化变量：.bss<br>全局只读：.rdata</p><h2 id="ref-8"><a href="#ref-8" class="headerlink" title="ref"></a>ref</h2><ul><li><a href="https://www.runoob.com/w3cnote/cpp-static-usage.html">C&#x2F;C++ 中 static 的用法全局变量与局部变量</a></li><li><a href="https://www.cnblogs.com/bakari/archive/2012/08/05/2623637.html">局部变量，静态局部变量，全局变量，静态全局变量在内存中的存放区别</a></li><li><a href="https://blog.csdn.net/youyou519/article/details/82701083">全局初始化变量&#x2F;全局未初始化变量&#x2F;全局静态变量&#x2F;局部变量的存储位置，作用域，与生命周期</a></li></ul><h1 id="C-中哪些运算符不可以重载？"><a href="#C-中哪些运算符不可以重载？" class="headerlink" title="C++中哪些运算符不可以重载？"></a>C++中哪些运算符不可以重载？</h1><ol><li>.</li><li>?:</li><li>sizeof</li><li>::</li><li>*</li></ol><h1 id="简述C-异常处理方式"><a href="#简述C-异常处理方式" class="headerlink" title="简述C++异常处理方式"></a>简述C++异常处理方式</h1><p>一个典型的C++异常处理包含以下几个步骤：</p><ol><li>程序执行时发生错误；</li><li>以一个异常对象(最简单是一个整数)记录错误的原因及相关信息；</li><li>程序监测到这个错误(读取异常对象)；</li><li>程序决定如何处理错误；</li><li>进行错误处理，并在此后恢复&#x2F;终止程序的执行。</li></ol><h1 id="STL-Standard-Template-Library-标准模板库"><a href="#STL-Standard-Template-Library-标准模板库" class="headerlink" title="STL(Standard Template Library,标准模板库)"></a>STL(Standard Template Library,标准模板库)</h1><p>STL从广义上分为: <strong>容器(container)<strong>、</strong>算法(algorithm)<strong>、</strong>迭代器(iterator)</strong>  </p><p>容器和算法之间通过<strong>迭代器</strong>进行无缝连接。STL几乎所有的代码都采用了模板类或者模板函数。</p><p>STL大体分为六大组件，分别是：</p><ul><li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li><li>算法：各种常用的算法，如sort、find、copy、for_each等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ul><h2 id="常用STL容器、算法、迭代器"><a href="#常用STL容器、算法、迭代器" class="headerlink" title="常用STL容器、算法、迭代器"></a>常用STL容器、算法、迭代器</h2><p>请看<a href="https://suzhilong.github.io/2020/07/12/STL/">「STL常用方法」</a></p><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>重载函数调用操作符的类，其对象常称为<strong>函数对象</strong></p><h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><p>函数对象使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong>。函数对象(仿函数)是一个类，不是一个函数。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class Multiply&#123;</span><br><span class="line">public:</span><br><span class="line">    double operator()(double x, double y) const &#123;return x*y;&#125;</span><br><span class="line">    double operator()(double x, int y) const &#123;return x*y;&#125;</span><br><span class="line">    double operator()(int x, double y) const &#123;return x*y;&#125;</span><br><span class="line">    int operator()(int x, int y) const &#123;return x*y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Multiply multiply;</span><br><span class="line">    cout &lt;&lt; &quot; 3.6 * 7 = &quot; &lt;&lt; multiply(3.6,7) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot; 3 * 7 = &quot; &lt;&lt; multiply(3,7) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数对象的特点"><a href="#函数对象的特点" class="headerlink" title="函数对象的特点"></a>函数对象的特点</h3><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>返回bool类型的仿函数称为<strong>谓词</strong>。如果operator()接受一个参数，那么叫做<strong>一元谓词</strong>；如果operator()接受两个参数，那么叫做<strong>二元谓词</strong>。</p><ol><li>一元谓词<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct GreaterFive&#123;</span><br><span class="line">bool operator()(int val) &#123;</span><br><span class="line">return val &gt; 5;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());</span><br></pre></td></tr></table></figure></li><li>二元谓词<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyCompare</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(int num1, int num2)</span><br><span class="line">&#123;</span><br><span class="line">return num1 &gt; num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sort(v.begin(), v.end());//默认从小到大</span><br><span class="line">sort(v.begin(), v.end(), MyCompare());//使用函数对象改变算法策略，排序从大到小</span><br></pre></td></tr></table></figure></li></ol><h2 id="STL容器的底层数据结构"><a href="#STL容器的底层数据结构" class="headerlink" title="STL容器的底层数据结构"></a>STL容器的底层数据结构</h2><ol><li><p>vector  </p><ul><li>底层使用数组保存。  </li><li>push_back时若已经满了，则会2*n扩展空间，若实际元素数量低于分配空间的1&#x2F;4，则会将空间回收为原来的一半。  </li><li>扩容时，先申请新的空间，然后将旧空间的内容拷贝过去，然后再释放旧的空间。  </li><li>只适用于快速查找及只在末尾增删，而不适用于动态增删（可能涉及到元素的移动）。对元素进行增删时，可能导致旧的迭代器失效。防止迭代器失效的删除方法： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (vector&lt;int&gt;::iterator it = vec.begin();ite!=vec.end();)</span><br><span class="line">   &#123;</span><br><span class="line">       if(*it % 2 != 0) //删除vec中的奇数</span><br><span class="line">           it = vec.erase(it);</span><br><span class="line">       else</span><br><span class="line">           it++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>clear()可以清空所有元素，但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。可以用swap()来帮助你释放内存，也可以使用erase循环删除第一个。</li><li>vector和数组的区别<br> <img src="https://i.loli.net/2020/10/14/HijrufaCD6Rwebq.png" alt="vector和数组的区别"></li></ul></li><li><p>list  </p><ul><li>底层是双向链表，支持头尾增删，并且是一个环。  </li><li>不适用于查找频繁的情况，但适用于动态增删。</li></ul></li><li><p>stack  </p><ul><li>适配器。默认底层使用deque，适配之后只能从头插入和删除。</li></ul></li><li><p>queue  </p><ul><li>适配器。默认底层使用deque，适配之后只能从尾插入，从头删除。</li></ul></li><li><p>priority_queue</p><ul><li>适配器。一般以vector为底层容器，堆heap为处理规则来管理。</li></ul></li><li><p>map、multimap、set、multiset  </p><ul><li>底层使用红黑树实现，multimap是key值可重复的map。</li><li>防止迭代器失效的删除方法 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (auto it = m.begin(); it != m.end();)&#123;</span><br><span class="line">if(it-&gt;second == 10)//删除val==10的元素</span><br><span class="line">m.erase(it++);</span><br><span class="line">else</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>hash_map、hash_multimap、hash_set、hash_multiset  </p><ul><li>底层使用hashtable实现，其中hashtable是采用开链法来防止哈希冲突的。</li></ul></li><li><p>deque：  </p><ul><li>底层是一个分段的线性表。笼统的说就是使用了一个二维指针，第一维是每段的信息，而第二维就是一个数组了，实际保存的元素就是在这里。  </li><li>头尾都支持插入，但是维护麻烦很多。</li></ul></li><li><p>slist  </p><ul><li>使用单向链表实现的列表。</li></ul></li></ol><p><em>ps. queue，priority_queue，stack不是容器，是适配器，是对容器的再封装，没有迭代器</em></p><h2 id="vector和list的异同"><a href="#vector和list的异同" class="headerlink" title="vector和list的异同"></a>vector和list的异同</h2><ol><li>数据结构上的不同<ul><li>vector是用连续数组存储，内存空间连续，随机访问O(1)。内存不足是扩容一倍，申请更大的内存。</li><li>list底层是双向链表，不需要连续内存。插入删除O(1)，查找O(n)。</li></ul></li><li>迭代器<ul><li>vector中iterator支持”+”,”+&#x3D;”,”&lt;”等操作，list中不支持。</li></ul></li></ol><h2 id="push-back-和-emplace-back"><a href="#push-back-和-emplace-back" class="headerlink" title="push_back 和 emplace_back"></a>push_back 和 emplace_back</h2><p>C++11中，针对顺序容器(如vector、deque、list)，新标准引入了三个新成员：emplace_front、emplace和emplace_back，这些操作构造而不是拷贝元素。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定位置之前或容器尾部。</p><p>当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。</p><p>push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p><h2 id="map和unordered-map的区别"><a href="#map和unordered-map的区别" class="headerlink" title="map和unordered_map的区别"></a>map和unordered_map的区别</h2><ul><li>排序：map在缺省下，map按照递增的顺序进行排序；unordered_map不排序</li><li>内部原理：map内部采用了红黑树（自平衡的二叉搜索树），实现了数据排序；unordered_map内部采用了哈希表</li><li>搜索操作时间：map的搜索时间复杂度为O(log(n))；unordered_map平均搜索时间O(1)，最坏情况为O(n)</li><li>插入操作时间：map复杂度为log(n)+再平衡时间；unordered_map平均插入时间O(1)，最坏情况为O(n)</li><li>删除操作时间：与插入操作时间复杂度一样</li></ul><h2 id="ref-9"><a href="#ref-9" class="headerlink" title="ref"></a>ref</h2><ul><li><a href="https://github.com/AnkerLeng/Cpp-0-1-Resource/blob/master/%E7%AC%AC5%E9%98%B6%E6%AE%B5-C%2B%2B%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E8%B5%84%E6%96%99/%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E8%B5%84%E6%96%99/%E8%AE%B2%E4%B9%89/C%2B%2B%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B.md">C++提高编程</a>：后半部分有STL库的常用方法</li><li><a href="https://blog.csdn.net/BostonRayAlen/article/details/93041395?utm_medium=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">C&#x2F;C++ 最常见50道面试题</a></li><li><a href="https://blog.csdn.net/hsq1596753614/article/details/80249605?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">C&#x2F;C++ 经典面试题（一）之常考概念</a></li><li><a href="https://blog.csdn.net/ljh0302/article/details/81098764?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">常见C++笔试面试题整理</a></li></ul><h1 id="C-11-新特性"><a href="#C-11-新特性" class="headerlink" title="C++ 11 新特性"></a>C++ 11 新特性</h1><ol><li>关键字及新语法：auto、nullptr、for</li><li>STL容器：std::array、std::forward_list、std::unordered_map、std::unordered_set</li><li>多线程：std::thread、std::atomic、std::condition_variable</li><li>智能指针内存管理：std::shared_ptr、std::weak_ptr、std::unique_ptr</li><li>其他：std::function、std::bind和lamda表达式</li><li>C++11中对类(class)新增的特性：<ul><li>default&#x2F;delete 控制默认函数</li><li>override &#x2F;final 强制重写&#x2F;禁止重写虚函数</li><li>委托构造函数 Delegating constructors</li><li>继承的构造函数 Inheriting constructors</li><li>类内部成员的初始化 Non-static data member initializers</li><li>移动构造和移动赋值</li></ul></li></ol><h2 id="nullptr常量"><a href="#nullptr常量" class="headerlink" title="nullptr常量"></a>nullptr常量</h2><p>C++中NULL仅仅是define NULL 0的一个宏定义，因此，有时候会产生歧义。<br>    - 比如f（char*）和f（int），参数传NULL的话到底该调用哪个？事实上，在VS下测试这样的函数重载会优先调用f（int），但是f（char *）也是正确的，因此C++引入nullptr来避免这个问题<br>    - nullptr是一个空指针，可以被转换成其他任意指针的类型</p><h2 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h2><p>让编译器替我们去分析表达式所属的类型，直接推导。尤其是STL中map的迭代器这种很长的类型，适合用auto。</p><h2 id="decltype操作符"><a href="#decltype操作符" class="headerlink" title="decltype操作符"></a>decltype操作符</h2><p>从表达式的类型推断出要定义的变量的类型，跟表达式的类型也就是参数类型紧密相关<br>    - delctype (f()) sum &#x3D; x; 并不实际调用函数f()，只是使用f()的返回值当做sum的类型<br>    - delctype (i) sum &#x3D; x;和delctype ((i)) sum &#x3D; x; 其中i为int类型，前面的为int类型，后面的为int&amp;引用</p><h2 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h2><p>多与auto配合使用。如 <code>for(auto n:nums)</code></p><h2 id="多线程互斥锁"><a href="#多线程互斥锁" class="headerlink" title="多线程互斥锁"></a>多线程互斥锁</h2><h3 id="pthread-mutex-t"><a href="#pthread-mutex-t" class="headerlink" title="pthread_mutex_t"></a>pthread_mutex_t</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//互斥量的创建</span><br><span class="line">pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); ///attr不写或传入NULL即可</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line">//加锁</span><br><span class="line">pthread_mutex_lock(pthread_mutex_t *mutex); //如果其他线程已经加锁了, 则阻塞让出CPU直到其他线程Unlock</span><br><span class="line">//pthread_mutex_trylock(pthread_mutex_t *mutex); //如果不能加锁立即返回</span><br><span class="line">·</span><br><span class="line">·</span><br><span class="line">·</span><br><span class="line">//解锁</span><br><span class="line">pthread_mutex_unlock(pthread_mutex_t *mutex);</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line">//互斥量的删除</span><br><span class="line">pthread_mutex_destroy(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure><h3 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h3><p><code>.lock()</code>、<code>.unlock()</code>、<code>lock_guard</code>、<code>unique_lock</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;mutex&gt;</span><br><span class="line"></span><br><span class="line">std::mutex m_mutex;</span><br><span class="line"></span><br><span class="line">//方法1</span><br><span class="line">m_mutex.lock();</span><br><span class="line">···</span><br><span class="line">m_mutex.unlock();</span><br><span class="line"></span><br><span class="line">//方法2：初始化的时候就是锁的lock操作的时候，超出它的作用域之后析构时unlock</span><br><span class="line">lock_guard&lt;mutex&gt; lock(m_mutex);</span><br><span class="line">···</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="双层vector"><a href="#双层vector" class="headerlink" title="双层vector"></a>双层vector</h2><p>vector&lt;vector<int> &gt;(n, vector<int>(n, 0))</p><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>用于实现匿名函数，匿名函数只有函数体，没有函数名。  </p><p>用法：<code>[capture](parameters)-&gt;return-type &#123;body&#125;</code></p><p><code>[]</code>叫做捕获说明符，表示一个lambda表达式的开始。接下来<code>()</code>是参数列表，即这个匿名的lambda函数的参数，<code>-&gt;return-type</code>表示返回类型，如果没有返回类型，则可以省略这部分。最后<code>&#123;&#125;</code>就是函数体部分了。</p><p>lambda函数能够捕获lambda函数外的具有自动存储时期的变量。函数体与这些变量的集合合起来叫闭包。</p><ul><li>[] 不截取任何变量</li><li>[&amp;} 截取外部作用域中所有变量，并作为引用在函数体中使用</li><li>[&#x3D;] 截取外部作用域中所有变量，并拷贝一份在函数体中使用</li><li>[&#x3D;, &amp;foo] 截取外部作用域中所有变量，并拷贝一份在函数体中使用，但是对foo变量使用引用</li><li>[bar] 截取bar变量并且拷贝一份在函数体重使用，同时不截取其他变量</li><li>[x, &amp;y] x按值传递，y按引用传递</li><li>[this] 截取当前类中的this指针。如果已经使用了&amp;或者&#x3D;就默认添加此选项。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">auto func = [] () &#123; cout &lt;&lt; &quot;hello,world&quot;; &#125;;</span><br><span class="line">func(); //call the function</span><br><span class="line"></span><br><span class="line">auto func2 = [] () &#123; &#125;</span><br><span class="line"></span><br><span class="line">//sort函数的后面可以用lambda函数</span><br><span class="line">sort(vec.begin(), vec.end(), [](int a, int b)-&gt;bool&#123;return a &lt; b&#125;)</span><br></pre></td></tr></table></figure><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>放弃了C++98提供了第一个智能指针：<code>auto_ptr</code>。增加了3个新的智能指针：</p><ul><li>shared_ptr</li><li>weak_ptr</li><li>unique_ptr</li></ul><p>智能指针本质上是一个<strong>类</strong>，它将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。智能指针的出现实际上就是为了可以方便的控制对象的生命期，是 RAII 资源管理功能的自然展现。</p><p>STL一共给我们提供了四种智能指针：</p><ul><li>auto_ptr<br>C++98提供的解决方案，C+11已将将其摒弃。原因是避免潜在的内存崩溃问题：<strong>将一个auto_ptr赋值给另一个auto_ptr时，程序将试图删除同一个对象两次</strong>。</li><li>unique_ptr<br>当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做。</li><li>shared_ptr<br>采用<strong>引用计数</strong>的策略</li><li>weak_ptr<br>对于引用计数法实现的计数，总是避免不了循环引用（或环形引用）的问题，shared_ptr也不例外。为了解决类似这样的问题，C++11引入了weak_ptr，来打破这种循环引用。<br>weak_ptr是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是将一个shared_ptr赋值给weak_ptr不会改变shared_ptr的引用计数。不论是否有weak_ptr指向，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。</li></ul><p><em>ps：将一个智能指针赋值给另一个智能指针时有多种方法：<br>1）定义陚值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本，缺点是浪费空间，所以智能指针都未采用此方案。<br>2）建立所有权（ownership）概念。对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的构造函数会删除该对象。然后让赋值操作转让所有权。这就是用于auto_ptr和uniqiie_ptr 的策略，但unique_ptr的策略更严格。<br>3）创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1,。当减为0时才调用delete。这是shared_ptr采用的策略。</em></p><h2 id="ref-10"><a href="#ref-10" class="headerlink" title="ref"></a>ref</h2><ul><li><a href="https://www.cnblogs.com/feng-sc/p/5710724.html">C++11常用特性的使用经验总结</a></li><li><a href="https://www.cnblogs.com/me115/p/4777997.html">C++11中对类(class)新增的特性</a></li><li><a href="https://time.geekbang.org/column/article/169263">极客时间《现代C++实战30讲》：02 | 自己动手，实现C++的智能指针</a></li><li><a href="https://www.cnblogs.com/lanxuezaipiao/p/4132096.html">C++智能指针简单剖析</a></li></ul><h1 id="C-中常用的设计模式"><a href="#C-中常用的设计模式" class="headerlink" title="C++中常用的设计模式"></a>C++中常用的设计模式</h1><p>共有23种设计模式，但真正在开发中常用的模式有：</p><ol><li><p>Factory Method(工厂模式)；</p></li><li><p>Strategy(策略模式)；</p></li><li><p>Singleton(单例模式)；</p><ul><li><a href="https://www.cnblogs.com/sunchaothu/p/10389842.html">C++ 单例模式总结与剖析</a></li><li>懒汉模式：不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//普通懒汉</span><br><span class="line">class Singleton</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">Singleton()&#123;</span><br><span class="line">cout &lt;&lt; &quot;constructor called&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Singleton(Singleton&amp;) = delete;</span><br><span class="line">Singleton &amp;operator=(const Singleton&amp;) = delete;</span><br><span class="line">static Singleton *instance_ptr;</span><br><span class="line">public:</span><br><span class="line">~Singleton()&#123;</span><br><span class="line">std::cout&lt;&lt;&quot;destructor called&quot;&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">static Singleton* get_instance()&#123;</span><br><span class="line">if(instance_ptr==nullptr)&#123;</span><br><span class="line">instance_ptr = new Singleton;</span><br><span class="line">&#125;</span><br><span class="line">return instance_ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance_ptr = nullptr;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">Singleton* instance = Singleton::get_instance();</span><br><span class="line">Singleton* instance2 = Singleton::get_instance();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//线程安全、内存安全的懒汉式单例（智能指针，锁）</span><br><span class="line">class Singleton&#123;</span><br><span class="line">public:</span><br><span class="line">typedef shared_ptr&lt;Singleton&gt; Ptr;</span><br><span class="line">~Singleton()&#123;</span><br><span class="line">cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">static Ptr get_instance()&#123;</span><br><span class="line">if(instance_ptr==nullptr)&#123;// &quot;double checked lock&quot;</span><br><span class="line">std::lock_guard&lt;mutex&gt; lk(m_mutex);</span><br><span class="line">if (instance_ptr == nullptr)</span><br><span class="line">instance_ptr = Ptr(new Singleton);</span><br><span class="line">&#125;</span><br><span class="line">return instance_ptr;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">Singleton()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Singleton(Singleton &amp;) = delete;</span><br><span class="line">Singleton &amp;operator=(const Singleton &amp;) = delete;</span><br><span class="line">static Ptr instance_ptr;</span><br><span class="line">static mutex m_mutex;//锁</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// initialization static variables out of class</span><br><span class="line">Singleton::Ptr Singleton::instance_ptr = nullptr;</span><br><span class="line">mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">Singleton::Ptr instance = Singleton::get_instance();</span><br><span class="line">Singleton::Ptr instance1 = Singleton::get_instance();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//局部静态变量懒汉，最推荐</span><br><span class="line">class Singleton&#123;</span><br><span class="line">public:</span><br><span class="line">~Singleton()&#123;</span><br><span class="line">cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">static Singleton&amp; get_instance()&#123;//返回指针而不是返回引用无法避免用户使用 delete instance 导致对象被提前销毁。</span><br><span class="line">static Singleton instance;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">Singleton()&#123;</span><br><span class="line">cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Singleton(Singleton &amp;) = delete;</span><br><span class="line">Singleton &amp;operator=(const Singleton &amp;) = delete;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">Singleton&amp; instance = Singleton::get_instance();</span><br><span class="line">Singleton&amp; instance1 = Singleton::get_instance();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>饿汉：在单例类定义的时候就进行实例化 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">public:</span><br><span class="line">~Singleton()&#123;</span><br><span class="line">cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">static Singleton* get_instance()&#123;</span><br><span class="line">return instance_ptr;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">static Singleton* instance_ptr;</span><br><span class="line">Singleton()&#123;</span><br><span class="line">cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Singleton(Singleton &amp;) = delete;</span><br><span class="line">Singleton &amp;operator=(const Singleton &amp;) = delete;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton *Singleton::instance_ptr = new Singleton();</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">Singleton* instance = Singleton::get_instance();</span><br><span class="line">Singleton* instance1 = Singleton::get_instance();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Iterator(迭代器模式)；</p></li><li><p>Abstract Factory(抽象工厂模式)；</p></li><li><p>Builder(建造者模式)；</p></li><li><p>Adapter(适配器模式)；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Target &#123;  // Target，客户期望的接口，可以使具体或抽象的类，也可以是接口</span><br><span class="line">public:</span><br><span class="line">    virtual void Request() = 0;</span><br><span class="line">    virtual ~Target()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Adaptee &#123; //需适配的类</span><br><span class="line">public:</span><br><span class="line">    void SpecificRequest() &#123; cout &lt;&lt; &quot;Adaptee&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Adapter1 : public Target &#123; //通过内部包装一个Adaptee对象，把源接口转换为目标接口：</span><br><span class="line">private:</span><br><span class="line">    Adaptee* adaptee;</span><br><span class="line">public:</span><br><span class="line">    Adapter1() &#123; adaptee = new Adaptee(); &#125;</span><br><span class="line">    void Request() &#123; adaptee-&gt;SpecificRequest(); &#125;  // 调用Request()方法会转换成调用adaptee.SpecificRequest()</span><br><span class="line">    ~Adapter1() &#123; delete adaptee; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Adapter2 : public Target&#123;</span><br><span class="line">private:</span><br><span class="line">    Adaptee *adaptee;</span><br><span class="line">public:</span><br><span class="line">    Adapter2() &#123; adaptee = new Adaptee(); &#125;</span><br><span class="line">    void Request() &#123; adaptee-&gt;SpecificRequest(); &#125;</span><br><span class="line">    ~Adapter2() &#123; delete adaptee; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Target *target = new Adapter1();</span><br><span class="line">    target-&gt;Request();</span><br><span class="line">    delete target;</span><br><span class="line"></span><br><span class="line">    Target *target2 = new Adapter2();</span><br><span class="line">    target-&gt;Request();</span><br><span class="line">    delete target2;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Bridge(桥接模式)；</p></li><li><p>Composite(组合模式)；</p></li><li><p>Interpreter(解释器模式)；</p></li><li><p>Command(命令模式)；</p></li><li><p>Mediator(中介者模式)；</p></li><li><p>Observer(观察者模式)；</p></li><li><p>State(状态模式)；</p></li><li><p>Proxy(代理模式)。</p></li></ol><h1 id="设计模式6大原则"><a href="#设计模式6大原则" class="headerlink" title="设计模式6大原则"></a>设计模式6大原则</h1><ol><li>单一职责原则(Single Responsibility Principle)</li><li>开放封闭原则（Open Close Principle）</li><li>里氏替换原则（Liskov Substitution Principle）</li><li>依赖倒置原则（Dependence Inversion Principle）</li><li>接口隔离原则（InterfaceSegregation Principles）</li><li>迪米特原则（Law of Demeter）也称最少知识原则</li></ol><h1 id="对编程规范的理解或认识"><a href="#对编程规范的理解或认识" class="headerlink" title="对编程规范的理解或认识"></a>对编程规范的理解或认识</h1><p>编程规范可总结为：</p><ul><li>可行性</li><li>可读性</li><li>可移植性</li><li>可测试性</li></ul><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/153444857?utm_source=wechat_session&utm_medium=social&utm_oi=717486596282130432">C++ 继承、多态、重载、友元</a></li></ul>]]></content>
    
    
    <summary type="html">C++基础知识复习总结</summary>
    
    
    
    <category term="CS" scheme="https://github.com/suzhilong/suzhilong.github.io.git/categories/CS/"/>
    
    
    <category term="cpp" scheme="https://github.com/suzhilong/suzhilong.github.io.git/tags/cpp/"/>
    
  </entry>
  
</feed>
