{"meta":{"title":"SOUSIC","subtitle":"哈库呐玛塔塔","description":"I will always be with you","author":"Su Zhilong","url":"https://github.com/suzhilong/suzhilong.github.io.git","root":"/"},"pages":[{"title":"about","date":"2019-08-03T09:50:58.000Z","updated":"2019-08-03T09:52:32.418Z","comments":true,"path":"about/index.html","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/about/index.html","excerpt":"","text":"This is me!"},{"title":"categories","date":"2019-08-03T09:47:21.000Z","updated":"2019-08-03T09:48:36.960Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-03T09:41:32.000Z","updated":"2019-08-03T09:45:16.663Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"sshfs + Barrier 实现一套键跨平台多机控制","slug":"barrier_sshfs","date":"2023-02-17T14:45:00.000Z","updated":"2023-02-17T15:11:25.453Z","comments":true,"path":"2023/02/17/barrier_sshfs/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2023/02/17/barrier_sshfs/","excerpt":"1. sshfssshfs(Secure SHell FileSystem) 是一个客户端，可以让我们通过 SSH 文件传输协议(SFTP) 挂载远程的文件系统并且在本地机器上和远程的目录和文件进行交互。","text":"1. sshfssshfs(Secure SHell FileSystem) 是一个客户端，可以让我们通过 SSH 文件传输协议(SFTP) 挂载远程的文件系统并且在本地机器上和远程的目录和文件进行交互。 1.1 安装以 ubuntu 为例 1sudo apt-get install sshfs 1.2 修改本地映射文件夹权限12mkdir /xxx/xxx # 创建一个文件夹用来挂载，如 ~/Documents/local_pathchmod 777 /xxx/xxx # 将该文件夹权限修改为 777 1.3 挂载1sshfs -o allow_other user@xxx.xxx.x.xx:/remote/path /local/path 1.4 取消挂载1fusermount -u /local/path # 挂载文件夹的绝对路径 2. Barrier跨平台不同设备间共享键鼠的一个工具。 2.1 安装两边都需要安装 Barrier，下面以 Ubuntu 安装为例： 1sudo apt-get install barrier 2.2 设置 两边都关闭 SSL：打开 Barrier - 左上角 Barrier - 更改设置 - 取消勾选 SSL 配置服务端和客户端 Local（控制方）作为服务端 打开 Barrier 勾选【服务端】 【交互配置】 -【设置服务端】- 拖动屏幕设置屏幕名和布局 记住 服务端 IP 地址 点击启用 Remote（被控制方）作为客户端 打开 Barrier 勾选【客户端】 填写服务端 IP 地址 点击启用 启用成功后会显示【Barrier正在运行】","categories":[{"name":"Tool","slug":"Tool","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/Tool/"}],"tags":[{"name":"Barrier","slug":"Barrier","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Barrier/"}]},{"title":"SIMD 指令集","slug":"SIMD_Intro","date":"2023-02-01T15:02:00.000Z","updated":"2023-02-17T14:48:39.159Z","comments":true,"path":"2023/02/01/SIMD_Intro/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2023/02/01/SIMD_Intro/","excerpt":"SIMD(Single Instruction, Multiple Data)：单指令多数据流，实质是通过数据并行来提高执行效率。","text":"SIMD(Single Instruction, Multiple Data)：单指令多数据流，实质是通过数据并行来提高执行效率。 1. ARM 架构1.1 ARMv1 - ARMv9 基于 ARMv7 版本的 ARM Cortex 系列产品由 A、R、M 三个系列组成，具体分类延续了一直以来 ARM 面向具体应用设计 CPU 的思路。 1.2 AArch64&#x2F;AArch32 ARMv8 的两种执行状态： AArch64&#x2F;AArch32 AArch64：Armv8-A 架构中引入的 64 位执行状态，执行 A64 指令，使用64bit的通用寄存器 AArch32：兼容 Armv7-A 和先前的 32 位 Arm 架构的 32 位执行状态，执行A32&#x2F;T32指令，使用32bit的通用寄存器 ARMv8 支持浮点类型的除法向量操作，这是 ARMv7 没有的。另外 AArch64 还支持 double 类型的操作。 Arm Compiler –target=aarch64-arm-none-eabi 生成 AArch64 的可执行程序。默认使用 ARMv8-A target（处理器），也可使用 -mcpu 指定特定的 ARMv8 处理器。 –target=arm-arm-none-eabi 生成 AArch32的可执行程序。对 AArch32 而言，没有默认target（处理器），所以需要使用 -march 或者 -mcpu 来指定处理器，如：–target=arm-arm-none-eabi -mcpu=cortex-a53 2. SIMDSIMD(Single Instruction, Multiple Data)：单指令多数据流，实质是通过数据并行来提高执行效率。 2.1 x86 指令集 2.2 arm 指令集 - NEON2.2.1 寄存器 向量寄存器用来存放向量数据，每个向量元素的类型必须相同。 向量寄存器根据处理元素的大小可以划分为 2&#x2F;4&#x2F;8&#x2F;16 个通道。 AArch64 有 32 个 128bit 的向量寄存器，这些寄存器又可以划分为： 32 个 128bit 的 V 寄存器，V0~V31。 32 个 64bit 的 D 寄存器，D0~D31。 32 个 32bit 的 S 寄存器，S0~S31。 AArch32&#x2F;ARMv7 有 16 个 128bit 的向量寄存器，这些寄存器又可以划分为： 16 个128bit 的 Q 寄存器，Q0~Q15。 32 个 64bit 的 D 寄存器，D0~D31。 32 个 32bit 的 S 寄存器，S0~S31。 2.2.2 汇编指令格式&#123;&lt;prefix&gt;&#125;&lt;op&gt;&#123;&lt;suffix&gt;&#125; Vd.&lt;T&gt;, Vn.&lt;T&gt;, Vm.&lt;T&gt; 如： ：前缀名字，包括以下几类： S&#x2F;U&#x2F;F&#x2F;P：数据类型，分别为 有符号整型&#x2F;无符号整型&#x2F;浮点型&#x2F;布尔型。 Q：饱和（Saturating）计算。 R：舍入（Rounding）计算, Rounding 操作等价于加上 0.5 之后再截断。 H：折半（Halving）计算。 D：翻倍（Doubling）算。 ：具体的操作，例如 ADD，SUB 等等 ：后缀名字，包括以下几类： V：Reduction 计算。 P：Pairwise 计算。 H：结果只取每个通道的高半部分（High）。 L&#x2F;N&#x2F;W&#x2F;L2&#x2F;N2&#x2F;W2：数据长度的变化 L&#x2F;L2 ：输出向量是输入向量长度的 2 倍，其中 L 表示输入寄存器的低 64bit 数据有效，L2 表示输入寄存器的高 64bit 数据有效。 N&#x2F;N2：输出向量是输入向量的 1&#x2F;2 倍，N 表示输出向量只有低 64bit 有效，N2 则表示输出向量只有高 64bit 有效。 W&#x2F;W2：输出向量和第一个输入向量长度相等，且这两个向量是第二个向量长度的 2 倍，其中 W 表示第二个输入向量的低 64bit 有效，W2 表示第二输入向量的高 64bit 有效。 ：单个通道的数据类型，8B&#x2F;16B&#x2F;4H&#x2F;8H&#x2F;2S&#x2F;4S&#x2F;2D，B 表示 8bit，H 表示 16bit，S 表示 32bit，D 表示 64bit 2.2.3 intrinsics 指令格式2.2.3.1 向量类型格式非数组向量：&lt;type&gt;&lt;size&gt;x&lt;number_of_lanes&gt;_t 数组向量：&lt;type&gt;&lt;size&gt;x&lt;number_of_lanes&gt;x&lt;length_of_array&gt;_t &lt;type&gt; 数据类型，如 int &#x2F; uint &#x2F; float。 &lt;size&gt; 元素大小，如8&#x2F;16&#x2F;32&#x2F;64。 通道数。 数组中元素个数。 2.2.3.2 NEON 内联函数格式 v&lt;mod&gt;&lt;opname&gt;&lt;shape&gt;&lt;flags&gt;_&lt;type&gt; 举例12345678910111213141516// a 加 b 的结果做饱和计算int8x8_t vqadd_s8(int8x8_t a, int8x8_t b); // a 减 b 的结果右移一位int8x8_t vhsub_s8(int8x8_t a, int8x8_t b); // a 乘 b 的结果扩大一倍, 最后做饱和操作int32x4_t vqdmull_s16(int16x4_t a, int16x4_t b); // 将 a 与 b 的和减半,同时做 rounding 操作, 每个通道可以表达为: (ai + bi + 1) &gt;&gt; 1int8x8_t vrhadd_s8(int8x8_t a, int8x8_t b); // 将 a、b 向量的相邻数据进行两两和操作int8x8_t vpadd_s8(int8x8_t a, int8x8_t b);// l：long，输出向量的元素长度是输入长度的 2 倍uint16x8_t vaddl_u8(uint8x8_t a, uint8x8_t b)// n：narrow，输出向量的元素长度是输入长度的 1/2uint32x2_t vmovn_u64(uint64x2_t a)// wide，第一个输入向量和输出向量类型一样，且是第二个输入向量元素长度的 2 倍uint16x8_t vsubw_u8(uint16x8_t a, uint8x8_t b) Ref. CPU 优化技术-NEON 指令介绍 ARM Neon Intrinsics 学习指北：从入门、进阶到学个通透 ARM NEON技术之NEON基础介绍 Arm NEON programming quick reference guide","categories":[{"name":"CS","slug":"CS","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/CS/"}],"tags":[{"name":"Architecture","slug":"Architecture","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Architecture/"}]},{"title":"光流鲁棒性评估","slug":"optical_flow_evaluation","date":"2022-11-27T13:39:00.000Z","updated":"2022-11-28T13:40:14.761Z","comments":true,"path":"2022/11/27/optical_flow_evaluation/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2022/11/27/optical_flow_evaluation/","excerpt":"本篇文档对鲁棒性的定义：$$goodPoints&#x2F;allPoints$$ 其中 goodPoints：跟踪成功的特征点。即，向前-向后追踪回到开始帧，EPE 小于设定的阈值(单位: pixel)。 allPoints：所有特征点 使用全部特征点测试鲁棒性，$$Harris \\gtrsim Tomasi &gt; Fast$$ 使用我们的均匀化策略后的特征点测试鲁棒性，$$Fast &gt; Tomasi \\approx Harris$$","text":"本篇文档对鲁棒性的定义：$$goodPoints&#x2F;allPoints$$ 其中 goodPoints：跟踪成功的特征点。即，向前-向后追踪回到开始帧，EPE 小于设定的阈值(单位: pixel)。 allPoints：所有特征点 使用全部特征点测试鲁棒性，$$Harris \\gtrsim Tomasi &gt; Fast$$ 使用我们的均匀化策略后的特征点测试鲁棒性，$$Fast &gt; Tomasi \\approx Harris$$ 光流评估指标误差指标 EPE(Endpoint Error)：估计光流和 ground-truth 光流的欧氏距离$$EPE &#x3D; \\sqrt{(u_{est} - u_{gt})^2 + (v_{est} - v_{gt})^2}$$ 1234567891011121314151617std::vector&lt;float&gt; EndPointError(const std::vector&lt;cv::Point2f&gt;&amp; prevPoints, const std::vector&lt;cv::Point2f&gt;&amp; nextPoints, std::vector&lt;uchar&gt; status)&#123; std::vector&lt;float&gt; endPointError; for (int i = 0; i &lt; prevPoints.size(); i++) &#123; const cv::Point2f prevP = prevPoints[i]; const cv::Point2f nextP = nextPoints[i]; float distance = 100.0; if ((bool)status[i]) &#123; const cv::Point2f diff = nextP - prevP; distance = sqrt((float)diff.ddot(diff)); &#125; endPointError.push_back(distance); &#125; return endPointError;&#125; AE(Angular Error)：光流向量之间的角度误差。计算角度误差时增加一维，使用的是三维向量 (u, v, 1)$$\\mathrm{AE}&#x3D;\\arccos \\left(\\frac{\\left(\\mathrm{u}{\\mathrm{est}}, \\mathrm{v}{\\text {est }}, 1\\right)^{\\mathrm{T}} *\\left(\\mathrm{u}{\\mathrm{gt}}, \\mathrm{v}{\\mathrm{gt}}, 1\\right)}{\\left.\\sqrt{1.0+\\mathrm{u}{\\mathrm{est}} * \\mathrm{u}{\\mathrm{est}}+\\mathrm{v}{\\mathrm{est}} * \\mathrm{v}{\\mathrm{est}}} \\sqrt{1.0+\\mathrm{u}{\\mathrm{gt}} * \\mathrm{u}{\\mathrm{gt}}+\\mathrm{v}{\\mathrm{gt}} * \\mathrm{v}{\\mathrm{gt}}}\\right)}\\right)$$ 12345678910111213141516171819202122std::vector&lt;float&gt; AngularError(const std::vector&lt;cv::Point2f&gt;&amp; prevPoints, const std::vector&lt;cv::Point2f&gt;&amp; nextPoints, std::vector&lt;uchar&gt; status)&#123; std::vector&lt;float&gt; angularErrs; for (int i = 0; i &lt; prevPoints.size(); i++) &#123; const cv::Point2f prevPoint2d = prevPoints[i]; const cv::Point2f nextPoint2d = nextPoints[i]; const cv::Point3f prevPoint3d(prevPoint2d.x, prevPoint2d.y, 1); const cv::Point3f nextPoint3d(nextPoint2d.x, nextPoint2d.y, 1); double angularErr = 100.0; if ((bool)status[i]) &#123; double vecDocVec = prevPoint3d.ddot(nextPoint3d); double vecNormProvecNorm = norm(prevPoint3d) * norm(nextPoint3d); double mid = vecDocVec / vecNormProvecNorm; double AE = acos(mid); angularErr = acos((double)(prevPoint3d.ddot(nextPoint3d) / norm(prevPoint3d) * norm(nextPoint3d))); &#125; angularErrs.push_back(angularErr); &#125; return angularErrs;&#125; 统计指标 AEE：平均点误差 AAE：平均角误差 DatasetsMPI Sintel从人工生成的动画 sintel 中得到光流 ground truth，每一个版本都包含 1041 个可用来训练的图片对，提供的 ground truth 十分密集，大幅度、小幅度的运动都包含。 sintel 数据集包括两种版本： sintel final：包括运动模糊和一些环境氛围特效，如雾等 sintel clean：没有 final 的特效 Crowd-Flow 序列包含 371 到 1451 个独立运动的个体 数据集由 10 个长度范围的序列组成，在 300 至 450 帧之间，所有序列均以 25hz 的帧速率和高清分辨率呈现 与此前光流数据集相比，该数据集除了提高了分辨率和帧的数量之外，还以连续序列而不是单帧对进行组织，允许评估时间一致性，例如以轨迹的形式 KITTI只有一种特殊的动作类型（类似行车记录仪），并且位移很大，视频使用一个摄像头，ground-truth 由 3D 激光雷达得出，远距离的物体，如天空没法被捕捉，导致该数据集光流 ground-truth 比较稀疏。 KITTI 2012：194 组图片 KITTI 2015：200 组图片 Flying Chairs软件渲染生成的虚拟数据，包含了 22872 对图像。 SceneFlow利用软件渲染生成的虚拟立体数据集，包含 35454 个训练图像（有 ground truth），所有的图片分辨率都是 960x540。主要包含三个子集： FlyingThings3D Driving Monkaa Middlebury 评估使用 1.1 中的 4 个指标 gray 和 color 都有 位移很小，通常小于10个像素 12 个场景的图片流，每个场景图片只有 10 张 针对的是全图片的光流，ground-truth 只有 1 帧的。需要把跑出来的光流结果保存成指定的数据格式(.flo)，上传到指定地址 数据集生成工具 AirSim：能够生成无人机视角和公路驾驶视角的两类数据 Carla：高仿真的自动驾驶场景 不依赖数据集评估方案forward-backward使用基于奇偶数的 forward-backward：如有 5 幅图像。前向时为 0-2-4，后向时为 4-3-1-0，连起来为 0-2-4-3-1-0。最后使用欧氏距离计算出 0 帧与最后的 0 帧图像之间，特征点位置的漂移 e，即 final drift。设定一个阈值 threshold，计算小于 thresh 的特征点的百分比，为鲁棒性；e 的直方图用于表示稳定性。 12345678910111213float OpticalFlowRubost(std::vector&lt;float&gt; endpointErr, float thresh)&#123; int goodPoint = 0; int totalPoint = endpointErr.size(); for (size_t i = 0; i &lt; totalPoint; i++) &#123; if (endpointErr[i] &lt; thresh) &#123; goodPoint++; &#125; &#125; return (float)goodPoint / (float)totalPoint;&#125; Ref. optical flow光流估计的评价指标_wrotcat的博客-CSDN博客 Emgu CV &#x2F; OpenCV Contrib Git clone &#x2F; [4ec320] &#x2F;modules&#x2F;optflow&#x2F;samples&#x2F;optical_flow_evaluation.cpp 图像序列光流计算评估理论及方法研究 最全自动驾驶数据集分享系列四｜光流数据集 Datasets-OpenDataLab OPTICAL FLOW TOOLKIT optical flow数据集KITTI 2012 2015 sintel crowd flow_城俊BLOG的博客-CSDN博客 论文：Evaluation of Endoscopic Image Enhancement for Feature Tracking: A New Validation Framework 特征点检测和追踪评价:A New Validation Framework","categories":[{"name":"robot","slug":"robot","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/robot/"},{"name":"SLAM","slug":"robot/SLAM","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/robot/SLAM/"}],"tags":[{"name":"Computer vision","slug":"Computer-vision","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Computer-vision/"}]},{"title":"RCAR2021 wiki","slug":"rcar_wiki","date":"2021-03-30T02:40:00.000Z","updated":"2021-03-30T03:26:23.967Z","comments":true,"path":"2021/03/30/rcar_wiki/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2021/03/30/rcar_wiki/","excerpt":"How to register and make paymentContents: How to register How to payment Confirm whether the payment is successful","text":"How to register and make paymentContents: How to register How to payment Confirm whether the payment is successful Register Visit IEEE-RCAR2021 Register Finish the registration procedure Authors can start to register by login to softconf site Fill in your profile in below text-boxes(* is mandatory). Then click Continue to next Payment step Payment Choose item you need to pay for, then click Checkout button. Note: if your paper has more than 6 pages, you also need to pay for the extra pages Checkout your bill: Here a Payment information will be shown, and a transaction ID will be generated. Click Pay, you will receive a notification mail about this transaction. Using your PayPal account to pay. Confirm Login with your passcode Click Processed payment archive Check table list We are looking forward to see you at IEEE RCAR 2021! Regards, The IEEE RCAR 2021 committee.","categories":[{"name":"robot","slug":"robot","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/robot/"}],"tags":[{"name":"wiki","slug":"wiki","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/wiki/"}]},{"title":"基于ROS的无人机跟踪：tracking package","slug":"rotorsTracking","date":"2021-01-21T02:17:00.000Z","updated":"2021-02-23T06:55:57.287Z","comments":true,"path":"2021/01/21/rotorsTracking/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2021/01/21/rotorsTracking/","excerpt":"无人机仿真：rotors_simulator uav_tracking项目代码 下载编译克隆 package12cd ~/rotors_ws/src/git clone https://github.com/suzhilong/uav_tracking.git 复制.world文件：1cp ~/rotors_ws/src/uav_tracking/worlds/tracking_scen.world ~/rotors_ws/src/rotors_simulator/rotors_gazebo/worlds/ 编译12cd ~/rotors_wscatkin_make 然后重启终端","text":"无人机仿真：rotors_simulator uav_tracking项目代码 下载编译克隆 package12cd ~/rotors_ws/src/git clone https://github.com/suzhilong/uav_tracking.git 复制.world文件：1cp ~/rotors_ws/src/uav_tracking/worlds/tracking_scen.world ~/rotors_ws/src/rotors_simulator/rotors_gazebo/worlds/ 编译12cd ~/rotors_wscatkin_make 然后重启终端 tracking 包的使用12cd ~/rotors_wssource ./devel/setup.bash 录制 ros bag录制需要的话题，就可以避免每次仿真都打开gazebo： 运行 launch 文件1roslaunch uav_tracking video_record.launch 录制话题1rosbag record -o [BAGNAME] /topic1/xxx /topic2/xxx 话题可以使用rostopic list查看。例如我要录制相机采集的视频： 1rosbag record -o video /firefly/vi_sensor/left/image_raw 按 ctrl + c 结束录制 rosbag 回放1rosbag play -l [bagNAME] rosbag 转 MP41. bag2img.launch在uav_tracking/launch目录下新建bag2img.launch，写入下面内容： 123456&lt;launch&gt; &lt;node pkg=&quot;rosbag&quot; type=&quot;play&quot; name=&quot;rosbag&quot; args=&quot;-d 2 [BAGPATH]/xx.bag&quot;/&gt; &lt;node name=&quot;extract&quot; pkg=&quot;image_view&quot; type=&quot;extract_images&quot; respawn=&quot;false&quot; output=&quot;screen&quot; cwd=&quot;ROS_HOME&quot;&gt;&lt;remap from=&quot;image&quot; to=&quot;/[your_topic]&quot;/&gt; &lt;/node&gt;&lt;/launch&gt; 注意： [BAGPATH]&#x2F;xx.bag需要替换成自己的bag路径 remap中的/[your_topic]需要替换为自己图片的话题 2. 运行launch文件source 后运行这个launch文件 12source ~/rotors_ws/devel/setup.bashroslaunch bag2img.launch 成功后会在~/.ros文件夹中生成命名格式为framexxxx.jpg（如frame0000.jpg）的图片 3. 移动图片12mkdir ~/rotors_ws/imgsmv ~/.ros/frame*.jpg ~/rotors_ws/imgs/ 4. 图片序列转MP41ffmpeg -r 10 -s 752*480 -i frame%04d.jpg uav_record.mp4 ps: -r 后是帧率，-s后是分辨率，-i后是图片名，最后是输出视频名 trackingOpenCV_contrib 安装 安装OpenCV （已经安装好的使用命令pkg-config opencv --modversion查看安装的OpenCV版本） 下载对应的 OpenCV_contrib（点击tag找到所需版本） 将解压后的OpenCV_contrib文件夹移到opencv根目录下 安装依赖 123sudo apt-get install build-essentialsudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-devsudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev 进入 opencv/build （如果没有build，就新建一个build文件夹） 1cmake -D CMAKE_INSTALL_PREFIX=/usr/local -D CMAKE_BUILD_TYPE=Release -D OPENCV_EXTRA_MODULES_PATH=../opencv_contrib-3.4.0/modules .. 注意：参数 OPENCV_EXTRA_MODULES_PATH 中的opencv_contrib-3.4.0 就是 opencv_contrib 解压后移动到 opencv 目录下名字 编译安装 12make -j8sudo make install img_tracking.cpp使用 先roslaunch uav 的仿真 或 rosbag play录制好的bag文件 可以进入~/rotors_ws/devel/lib/usv_tracking/后使用./img_tracking运行视频目标跟踪程序 也可以source ~/rotors_ws/devel/setup.bash后直接使用rosrun uav_tracking img_tracking执行视频目标跟踪程序 跟踪目标边框初始化在img_tracking.cpp中，有两种方法初始化目标在第一帧的位置和大小： 初始化检测框的坐标和大小 1234boundingBox.x = 350;boundingBox.y = 200;boundingBox.width = 100;boundingBox.height = 80; 手动框选：1. 中的代码注释掉，使用下面代码： 1boundingBox = selectROI(curFrame, false); test_tracking.cpp这个文件是用来测试仿真uav录制视频的跟踪的。 修改跟踪目标文件1VideoCapture video(&quot;[video_path]/[video_name].mp4&quot;); 使用1roscore 新开一个终端，并且source一下，然后 1rosrun uav_tracking test_tracking 接着就会出现视频的第一帧，用鼠标框选出跟踪的目标，按回车就可以看到开始跟踪了。 uav_tracking.cpp打开 gazebo随便打开一个有 rotors 的 gazebo 世界，如： 1roslaunch uav_tracking video_record.launch 加载 turtlebot 到 gazebo1roslaunch uav_tracking add_turtlebot.launch 使用跟踪1rosrun uav_tracking uav_tracking 然后选中turtlebot 键盘控制turtlebot移动1roslaunch turtlebot_teleop keyboard_teleop.launch 就可以看到无人机跟随turtlebot运动了。 ref 为了实现高效的人体跟踪，我测试了这些开源CV算法 (Python)从零开始,简单快速学机器仿人视觉Opencv—运用五：物体运动跟踪 ROS实现无人机目标跟踪&#x2F;物体跟随&#x2F;循迹 基于ROS搭建简易软件框架实现ROV水下目标跟踪（十四完结）–目标跟踪模块 赛道环境ROS包 YOLO_ROS包 使用OpenCV实现单目标跟踪 linux下安装Opencv 和opencv-contrib Object Tracking using OpenCV ROS基础知识学习笔记（1）—数据类型 std_msgs::UInt8MultiArray发布数组 ROS 图像相关的命令与应用 ROS的相机节点 rosbag转mp4文件","categories":[{"name":"robot","slug":"robot","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/robot/"}],"tags":[{"name":"Drone","slug":"Drone","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Drone/"}]},{"title":"基于rotors_simulator和ROS的无人机仿真","slug":"rotorsSimulator","date":"2021-01-20T11:35:00.000Z","updated":"2021-02-23T04:39:01.518Z","comments":true,"path":"2021/01/20/rotorsSimulator/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2021/01/20/rotorsSimulator/","excerpt":"uav_tracking项目代码 安装 rotors_simulator1. 新建工作空间并初始化（有工作空间的跳过此步骤）123mkdir -p ~/rotors_ws/srccd ~/rotors_ws/srccatkin_init_workspace 2. 克隆源代码12cd ~/rotors_ws/srcgit clone https://github.com/ethz-asl/rotors_simulator.git","text":"uav_tracking项目代码 安装 rotors_simulator1. 新建工作空间并初始化（有工作空间的跳过此步骤）123mkdir -p ~/rotors_ws/srccd ~/rotors_ws/srccatkin_init_workspace 2. 克隆源代码12cd ~/rotors_ws/srcgit clone https://github.com/ethz-asl/rotors_simulator.git 3. 初始化wstool，并更新所需库1234wstool initwget https://raw.githubusercontent.com/ethz-asl/rotors_simulator/master/rotors_hil.rosinstallwstool merge rotors_hil.rosinstallwstool update 4. 编译12cd ~/rotors_ws/catkin_make 5. 环境变量1source ./devel/setup.bash 也可以用下面的方式： 12echo &quot;source ~/rotors_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 6. 测试1roslaunch rotors_gazebo mav_hovering_example.launch mav_name:=firefly world_name:=basic 如果安装成功，就能启动gazebo，看到飞机 切换环境和飞机模型可以在启动时指定参数切换飞机和场景，也可以修改launch文件。 下面以修改mav_hovering_example_with_vi_sensor.launch为例，mav_hovering_example_with_vi_sensor.launch文件位于~/rotors_ws/src/rotors_simulator/rotors_gazebo/launch/路径下： mav_hovering_example_with_vi_sensor.launch文件： 修改launch文件中的mav_name切换飞机 打开launch文件 1sudo gedit ~/rotors_ws/src/rotors_simulator/rotors_gazebo/launch/mav_hovering_example_with_vi_sensor.launch 第三行参数firefly可以改为~/rotors_ws/src/rotors_simulator/rotors_description/urdf路径中的任意一个飞机名，如iris，ardrone等。 修改launch文件中的world_name切换场景 打开launch文件 1sudo gedit ~/rotors_ws/src/rotors_simulator/rotors_gazebo/launch/mav_hovering_example_with_vi_sensor.launch 第四行参数outdoor可以改为~/rotors_ws/src/rotors_simulator/rotors_gazebo/worlds/路径中的任意一个文件名，如outdoor，plane等。 ~/rotors_ws/src/rotors_simulator/rotors_gazebo/worlds/路径下的文件如下图 测试修改完之后运行 1roslaunch rotors_gazebo mav_hovering_example_with_vi_sensor.launch 即可查看修改效果 ps. 如果修改的是其他launch文件，则运行对应的文件查看。 创建直接的 ROS package 来控制飞机1. 新建 ROS package12cd ~/rotors_ws/srccatkin_create_pkg [PACKAGE_NAME] std_msgs rospy roscpp 如：新建跟踪 package: catkin_create_pkg uav_tracking std_msgs rospy roscpp 2. 修改 uav_tracking/CMakeLists.txt 添加依赖修改前 12345find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs) 修改后 12345678910find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs sensor_msgs geometry_msgs mav_msgs gazebo_msgs) sensor_msgs,添加对ROS官方sensor_msgs消息的依赖,在包的程序中可以使用sensor_msgs&#x2F;xxx类型的消息; geometry_msgs,添加对ROS官方geometry_msgs消息的依赖,在包的程序中可以使用geometry_msgs&#x2F;xxx类型的消息; mav_msgs,添加对mav_msgs消息的依赖,在包的程序中可以使用mav_msgs&#x2F;xxx类型的消息,该消息的定义在UAV\\src\\mav_comm包中定义; gazebo_msgs添加对ROS官方gazebo_msgs消息的依赖,在包的程序中可以使用gazebo_msgs&#x2F;xxx类型的消息,主要用于从Gazebo中获取消息. 3. 修改 uav_tracking/package.xml在 &lt;exec_depend&gt;std_msg&lt;/exec_depend&gt; 后添加： 12345678&lt;depend&gt;gazebo_msgs&lt;/depend&gt;&lt;depend&gt;gazebo_plugins&lt;/depend&gt;&lt;depend&gt;geometry_msgs&lt;/depend&gt;&lt;depend&gt;joy&lt;/depend&gt;&lt;depend&gt;mav_msgs&lt;/depend&gt;&lt;depend&gt;rotors_gazebo_plugins&lt;/depend&gt;&lt;depend&gt;sensor_msgs&lt;/depend&gt;&lt;depend&gt;xacro&lt;/depend&gt; 添加后： 4. 新建测试 cpp 文件在uav_tracking/src/中新建control_test.cpp文件并写入下面代码，用于控制飞机： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;ros/ros.h&gt;#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;thread&gt;#include &lt;geometry_msgs/PointStamped.h&gt;#include &lt;std_srvs/Empty.h&gt;#include &lt;Eigen/Core&gt;#include &lt;mav_msgs/conversions.h&gt;#include &lt;mav_msgs/default_topics.h&gt;#include &lt;trajectory_msgs/MultiDOFJointTrajectory.h&gt;ros::Publisher trajectory_pub;geometry_msgs::PointStamped current_position;float linear_smoothing_navigation_step = 2;bool flag_gps_initialized_OK = false;bool flag_take_off_OK = false;int flag_tasks_OK = 0;Eigen::Vector3d home;/*Description: updateUavPosition(const geometry_msgs::PointStamped&amp; msg) gps数据更新的回调函数.Parameters: msg 位置信息Return: 无*/void updateUavPosition(const geometry_msgs::PointStamped&amp; msg)&#123; if (!flag_gps_initialized_OK) &#123; flag_gps_initialized_OK= true; home[0] = msg.point.x; home[1] = msg.point.y; home[2] = msg.point.z; &#125; current_position = msg; // std::cout&lt;&lt;&quot;UAV current position is: &quot;&lt;&lt;msg.point.x&lt;&lt; msg.point.y&lt;&lt; msg.point.z&lt;&lt;std::endl;&#125;/*Description: getDistanceToTarget(const Eigen::Vector3d&amp; target) 获取当前位置到指定位置位置的距离.Parameters: target 需要飞达的位置点Return: double 当前位置到达目标点的位置*/double getDistanceToTarget(const Eigen::Vector3d&amp; target)&#123; double temp = 0; temp += pow((target[0] - current_position.point.x), 2); temp += pow((target[1] - current_position.point.y), 2); temp += pow((target[2] - current_position.point.z), 2); temp = sqrt(temp); return temp;&#125;/*Description: reachTargetPosition(const Eigen::Vector3d&amp; target, float max_error) 判定是否到达指定的目标点.Parameters: target 需要飞达的位置点 max_error 允许的位置误差阈值,当前位置和目标位置小于该阈值时,判定无人机到达目标点Return: bool 到达目标点时返回 true 未到达目标点时返回 false*/bool reachTargetPosition(const Eigen::Vector3d&amp; target, float max_error)&#123; double temp = getDistanceToTarget(target); if (temp &lt; max_error) return true; return false;&#125;/*Description: linearSmoothingNavigationTask(const Eigen::Vector3d&amp; target) 控制无人机从当前位置飞向指定位置.Parameters: target 需要飞达的位置点Return: bool 起飞结束后返回 true 起飞过程中返回 false*/bool linearSmoothingNavigationTask(const Eigen::Vector3d&amp; target)&#123; trajectory_msgs::MultiDOFJointTrajectory trajectory_msg; trajectory_msg.header.stamp = ros::Time::now(); if (reachTargetPosition(target,0.2)) return true; double dist = getDistanceToTarget(target); Eigen::Vector3d next_step; if(dist&lt;linear_smoothing_navigation_step) &#123; next_step = target; &#125; else &#123; next_step[0] = current_position.point.x+(target[0]-current_position.point.x)/dist*linear_smoothing_navigation_step; next_step[1] = current_position.point.y+(target[1]-current_position.point.y)/dist*linear_smoothing_navigation_step; next_step[2] = current_position.point.z+(target[2]-current_position.point.z)/dist*linear_smoothing_navigation_step; &#125; double desired_yaw = 0.0; mav_msgs::msgMultiDofJointTrajectoryFromPositionYaw(next_step, desired_yaw, &amp;trajectory_msg); trajectory_pub.publish(trajectory_msg); return false;&#125;/*Description: takeOffTask(float height) 起飞函数,调用后无人机从起始位置起飞指定高度.Parameters: height 指定的起飞高度Return: bool 起飞结束后返回 true 起飞过程中返回 false*/bool takeOffTask(float height)&#123; trajectory_msgs::MultiDOFJointTrajectory trajectory_msg; trajectory_msg.header.stamp = ros::Time::now(); static Eigen::Vector3d desired_position(current_position.point.x, current_position.point.y, height); double desired_yaw = 0.0; if (reachTargetPosition(desired_position,0.2)) return true; mav_msgs::msgMultiDofJointTrajectoryFromPositionYaw(desired_position, desired_yaw, &amp;trajectory_msg); trajectory_pub.publish(trajectory_msg); return false;&#125;/*Description: gohome() 反航函数,调用后无人机先沿着当前高度飞到反航点正上方,然后降落.Parameters: 无Return: 无*/void gohome()&#123; static Eigen::Vector3d temp(home[0], home[1], current_position.point.z); static bool flag_temp = false; if (!flag_temp) &#123; flag_temp = linearSmoothingNavigationTask(temp); &#125; else &#123; linearSmoothingNavigationTask(home); &#125;&#125;int main(int argc, char** argv) &#123; ros::init(argc, argv, &quot;UAV_Controler&quot;); ros::NodeHandle nh; // Create a private node handle for accessing node parameters. ros::NodeHandle nh_private(&quot;~&quot;); std::string uav_name = &quot;&quot;; ros::param::get(&quot;~mav_name&quot;,uav_name); // 订阅话题 // /odometry_sensor1/position 无人机位置信息(包含噪声) ros::Subscriber position_sub = nh.subscribe(std::string(&quot;/&quot;+uav_name+&quot;/odometry_sensor1/position&quot;).c_str(), 10, &amp;updateUavPosition); trajectory_pub = nh.advertise&lt;trajectory_msgs::MultiDOFJointTrajectory&gt;(mav_msgs::default_topics::COMMAND_TRAJECTORY, 10); // 等待5s,让Gazebo可以成功启动. ros::Duration(5.0).sleep(); // 创建控制Gazebo自动运行的服务,这里自动运行是指让Gazebo自动Play std_srvs::Empty srv; bool unpaused = ros::service::call(&quot;/gazebo/unpause_physics&quot;, srv); // 尝试让Gazebo自动运行 int i=0; while (i &lt;= 10 &amp;&amp; !unpaused) &#123; ROS_INFO(&quot;Wait for 1 second before trying to unpause Gazebo again.&quot;); std::this_thread::sleep_for(std::chrono::seconds(1)); unpaused = ros::service::call(&quot;/gazebo/unpause_physics&quot;, srv); ++i; &#125; // 判断Gazebo有没有自动运行,没有成功Play则退出 if (!unpaused) &#123; ROS_FATAL(&quot;Could not wake up Gazebo.&quot;); return -1; &#125; else &#123; ROS_INFO(&quot;Unpaused the Gazebo simulation.&quot;); &#125; std::vector&lt;Eigen::Vector3d&gt; path; path.push_back(Eigen::Vector3d(5.f,5.f,5.f)); path.push_back(Eigen::Vector3d(-5.f,5.f,5.f)); path.push_back(Eigen::Vector3d(-5.f,-5.f,5.f)); path.push_back(Eigen::Vector3d(5.f,-5.f,5.f)); path.push_back(Eigen::Vector3d(5.f,5.f,5.f)); std::cout &lt;&lt; path.size() &lt;&lt; std::endl; ros::Rate loop_rate(10); while (ros::ok()) &#123; if(flag_gps_initialized_OK &amp;&amp; !flag_take_off_OK) &#123; // ROS_INFO(&quot;UAV take off task is running...&quot;); flag_take_off_OK = takeOffTask(3); &#125; else if(flag_take_off_OK &amp;&amp; flag_tasks_OK&lt;path.size()) &#123; if(flag_tasks_OK&lt;path.size()) &#123; bool temp = linearSmoothingNavigationTask(path[flag_tasks_OK]); if (temp) flag_tasks_OK ++; &#125; &#125; else if(flag_tasks_OK &gt;= path.size()) &#123; gohome(); &#125; ros::spinOnce(); loop_rate.sleep(); &#125;&#125; 5. 创建launch文件夹并新建control_test.launch文件1234cd ~/rotors_ws/src/uav_tracking/mkdir launch &amp;&amp; cd launchtouch control_test.launchgedit control_test.launch 在control_test.launch中写入： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;launch&gt; &lt;arg name=&quot;mav_name&quot; default=&quot;firefly&quot;/&gt; &lt;arg name=&quot;world_name&quot; default=&quot;basic&quot;/&gt; &lt;arg name=&quot;enable_logging&quot; default=&quot;false&quot; /&gt; &lt;arg name=&quot;enable_ground_truth&quot; default=&quot;true&quot; /&gt; &lt;arg name=&quot;log_file&quot; default=&quot;$(arg mav_name)&quot; /&gt; &lt;arg name=&quot;debug&quot; default=&quot;false&quot;/&gt; &lt;arg name=&quot;gui&quot; default=&quot;true&quot;/&gt; &lt;arg name=&quot;paused&quot; default=&quot;false&quot;/&gt; &lt;!-- The following line causes gzmsg and gzerr messages to be printed to the console (even when Gazebo is started through roslaunch) --&gt; &lt;arg name=&quot;verbose&quot; default=&quot;false&quot;/&gt; &lt;!--Run Gazebo--&gt; &lt;env name=&quot;GAZEBO_MODEL_PATH&quot; value=&quot;$&#123;GAZEBO_MODEL_PATH&#125;:$(find rotors_gazebo)/models&quot;/&gt; &lt;env name=&quot;GAZEBO_RESOURCE_PATH&quot; value=&quot;$&#123;GAZEBO_RESOURCE_PATH&#125;:$(find rotors_gazebo)/models&quot;/&gt; &lt;include file=&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;&gt; &lt;arg name=&quot;world_name&quot; value=&quot;$(find rotors_gazebo)/worlds/$(arg world_name).world&quot; /&gt; &lt;arg name=&quot;debug&quot; value=&quot;$(arg debug)&quot; /&gt; &lt;arg name=&quot;paused&quot; value=&quot;$(arg paused)&quot; /&gt; &lt;arg name=&quot;gui&quot; value=&quot;$(arg gui)&quot; /&gt; &lt;arg name=&quot;verbose&quot; value=&quot;$(arg verbose)&quot;/&gt; &lt;/include&gt; &lt;!--Run UAV model and control node--&gt; &lt;group ns=&quot;$(arg mav_name)&quot;&gt; &lt;include file=&quot;$(find rotors_gazebo)/launch/spawn_mav.launch&quot;&gt; &lt;arg name=&quot;mav_name&quot; value=&quot;$(arg mav_name)&quot; /&gt; &lt;arg name=&quot;model&quot; value=&quot;$(find rotors_description)/urdf/mav_generic_odometry_sensor.gazebo&quot; /&gt; &lt;arg name=&quot;enable_logging&quot; value=&quot;$(arg enable_logging)&quot; /&gt; &lt;arg name=&quot;enable_ground_truth&quot; value=&quot;$(arg enable_ground_truth)&quot; /&gt; &lt;arg name=&quot;log_file&quot; value=&quot;$(arg log_file)&quot;/&gt; &lt;/include&gt; &lt;node name=&quot;lee_position_controller_node&quot; pkg=&quot;rotors_control&quot; type=&quot;lee_position_controller_node&quot; output=&quot;screen&quot;&gt; &lt;rosparam command=&quot;load&quot; file=&quot;$(find rotors_gazebo)/resource/lee_controller_$(arg mav_name).yaml&quot; /&gt; &lt;rosparam command=&quot;load&quot; file=&quot;$(find rotors_gazebo)/resource/$(arg mav_name).yaml&quot; /&gt; &lt;remap from=&quot;odometry&quot; to=&quot;odometry_sensor1/odometry&quot; /&gt; &lt;/node&gt; &lt;node name=&quot;robot_state_publisher&quot; pkg=&quot;robot_state_publisher&quot; type=&quot;robot_state_publisher&quot; /&gt; &lt;node name=&quot;joint_state_publisher&quot; pkg=&quot;joint_state_publisher&quot; type=&quot;joint_state_publisher&quot; /&gt; &lt;!--name属性用来定义节点运行的名称。pkg定义节点所在的功能包名称，type定义节点的可执行文件名称，这两个属性等同于在终端中使用rosrun命令执行节点时的输入参数--&gt; &lt;node name=&quot;control_test&quot; pkg=&quot;uav_tracking&quot; type=&quot;control_test&quot; output=&quot;screen&quot;&gt; &lt;param name=&quot;mav_name&quot; type=&quot;string&quot; value=&quot;$(arg mav_name)&quot;/&gt; &lt;/node&gt; &lt;/group&gt;&lt;/launch&gt; 6. 在 uav_tracking/CMakeLists.txt 添加编译在uav_tracking/CMakeLists.txt文件最下方添加： 12add_executable(control_test src/control_test.cpp)target_link_libraries(control_test $&#123;catkin_LIBRARIES&#125;) 7. 编译12cd ~/rotors_wscatkin_make 8. 运行重启终端： 12source ~/rotors_ws/devel/setup.bashroslaunch uav_tracking control_test.launch 如果启动成功，就可以看到程序自动启动仿真，无人机根据control_test.cpp的代码开始自己运动 tracking 包的使用基于ROS的无人机跟踪：tracking package ref rotors_simulator项目 uav_tracking包 rotors_simulator ROS wiki rotors无人机仿真 无人机ROS仿真包 rotors_simulator 编译教程 无人机ROS仿真包 rotors_simulator 使用教程","categories":[{"name":"robot","slug":"robot","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/robot/"}],"tags":[{"name":"Drone","slug":"Drone","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Drone/"}]},{"title":"无人机仿真","slug":"droneSimulator","date":"2021-01-19T11:19:00.000Z","updated":"2021-01-20T11:47:47.259Z","comments":true,"path":"2021/01/19/droneSimulator/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2021/01/19/droneSimulator/","excerpt":"无人机仿真的几种方法在ros环境下无人机的仿真方式有以下几种 hector_quadrotor rotors_simulator XTDrone：基于PX4的无人机仿真","text":"无人机仿真的几种方法在ros环境下无人机的仿真方式有以下几种 hector_quadrotor rotors_simulator XTDrone：基于PX4的无人机仿真 本教程环境 系统：ubuntu16.04 ROS版本：kinetic hector_quadrotorhector_quadrotor wiki 安装1. 新建工作空间并初始化123mkdir -p hector_quadrotor_catkin/srccd hector_quadrotor_catkin/srccatkin_init_workspace 2. 克隆源代码1git clone https://github.com/tu-darmstadt-ros-pkg/hector_quadrotor.git 3. 初始化wstool，并更新所需库123wstool initwstool merge tutorials.rosinstallwstool update 4. 编译12cd ~/hector_quadrotor_catkin/catkin build 5. 环境变量1source ./devel/setup.bash 也可以用下面的方式： 12echo &quot;source ~/hector_quadrotor_catkin/devel/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 运行编译成功后可以运行demo试一下，hector_quadrotor一共有两个demo，indoor和outdoor. indoor1roslaunch hector_quadrotor_demo indoor_slam_gazebo.launch outdoor1roslaunch hector_quadrotor_demo outdoor_flight_gazebo.launch 键盘操控使用teleop_twist_keyboard package： 12sudo apt-get install ros-kinetic-teleop-twist-keyboardrosrun teleop_twist_keyboard teleop_twist_keyboard.py ps:需要先按t让飞机先飞起来才能控制 rotors_simulator安装1. 新建工作空间并初始化123mkdir -p rotors_ws/srccd rotors_ws/srccatkin_init_workspace 2. 克隆源代码1git clone https://github.com/ethz-asl/rotors_simulator.git 3. 初始化wstool，并更新所需库1234wstool initwget https://raw.githubusercontent.com/ethz-asl/rotors_simulator/master/rotors_hil.rosinstallwstool merge rotors_hil.rosinstallwstool update 4. 编译12cd ~/rotors_ws/catkin_make 5. 环境变量1source ./devel/setup.bash 也可以用下面的方式： 12echo &quot;source ~/rotors_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 运行1roslaunch rotors_gazebo mav_hovering_example.launch mav_name:=firefly world_name:=basic 功能开发更多功能的开发请看无人机仿真：rotors_simulator的使用 XTDrone其实这是基于PX4和ROS的无人机仿真平台，不过有很多已经开发好的项目 一、PX4的安装安装使用PX4可以直接看官方文档 也可以照着XTDrone的步骤（推荐） 1. 安装依赖1234567sudo apt install -y ninja-build exiftool python-argparse python-empy python-toml python-numpy python-yaml python-dev python-pip ninja-build protobuf-compiler libeigen3-dev genromfs xmlstarlet libgstreamer1.0-dev libgstreamer-plugins-base1.0-devpip2 install pandas jinja2 pyserial cerberus pyulog numpy toml pyquaternionpip3 install packaging numpy empy toml pyyaml jinja2//gazebosudo apt install ros-kinetic-gazebo9-* 2. 安装 mavros 以及相关的 geographiclib datasetmavros 是一个飞机固件与ros通信的包 12345sudo apt install ros-kinetic-mavros ros-kinetic-mavros-extras//如果出现443拒绝连接的情况，可能是因为域名污染，在/etc/hosts中加入raw.githubusercontent.com指定ip就行wget https://raw.githubusercontent.com/mavlink/mavros/master/mavros/scripts/install_geographiclib_datasets.shsudo chmod a+x ./install_geographiclib_datasets.shsudo ./install_geographiclib_datasets.sh 3. 下载编译px4 Firmware创建工作空间（已经有工作空间的跳过）12345mkdir -p ~/px4_ws/srccd ~/px4_ws/src/catkin_init_workspacecd ..catkin_make 下载编译px4123456789//一般将固件放在主目录下而不是ros的工作空间中git clone https://github.com/PX4/PX4-Autopilot.gitmv PX4-Autopilot PX4_Firmwarecd PX4_Firmware//可以根据需求改变版本号v1.x.xgit checkout v1.11.2git submodule update --init --recursive//开始编译make px4_sitl_default gazebo 编译报错编译报错时，可能缺少了必要的依赖，可以在编译前： 1234cd ~/PX4_Firmwarebash//只是进行ros下开发仿真的话，可以把ubuntu.sh里的INSTALL_NUTTX改为’false’，或是加上参数--no-nuttxbash ./Tools/setup/ubuntu.sh --no-nuttx 注意：ubuntu.sh可能安装失败，请务必重新运行ubuntu.sh脚本，直至成功 4. 添加环境变量12345678910111213//添加工作空间sourceecho &quot;source ~/px4_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc//添加px4路径echo &quot;source ~/PX4_Firmware/Tools/setup_gazebo.bash\\ ~/PX4_Firmware/\\ ~/PX4_Firmware/build/px4_sitl_default&quot;\\ &gt;&gt; ~/.bashrcecho &quot;export ROS_PACKAGE_PATH=\\$ROS_PACKAGE_PATH:~/PX4_Firmware&quot; &gt;&gt; ~/.bashrcecho &quot;export ROS_PACKAGE_PATH=\\$ROS_PACKAGE_PATH:~/PX4_Firmware/Tools/sitl_gazebo&quot; &gt;&gt; ~/.bashrc//source一下source ~/.bashrc 5. 运行123cd ~/PX4_Firmware//此命令同时启动了mavrosroslaunch px4 mavros_posix_sitl.launch 二、安装无人机的地面站控制软件QGCQGroundControl 是一个基于PX4自动驾驶仪配置和飞行的应用程序 官方安装指导教程 1. 准备工作123sudo usermod -a -G dialout $USERsudo apt-get remove modemmanager -ysudo apt install gstreamer1.0-plugins-bad gstreamer1.0-libav gstreamer1.0-gl -y 2. 安装QGC1) 下载前往QCG发布网站下载合适的版本的QGroundControl.AppImage 注意： ubuntu16.04只能使用4.0以前的版本，4.0（含）以后的版本至少需要18.04，官方安装指导教程中已经说明 2) 安装12chmod +x ./QGroundControl.AppImage./QGroundControl.AppImage //或者双击就可以打开QGC 3) 使用roslaunch px4 mavros_posix_sitl.launch之后打开QGC会显示飞机已连接，在里面中添加飞行任务，然后上传，再滑动就可以启动飞行任务。 ———————-PX4与ROS基础配置完成———————– 各部分间的关系如下图所示： 三、XTDrone部分见XTDrone使用文档 ref 玩转四旋翼无人机（仿真） hector_quadrotor 的编译运行 hector_quadrotor 的论文：Comprehensive Simulation of Quadrotor UAVsusing ROS and Gazebo rotors无人机仿真 无人机ROS仿真包 rotors_simulator 编译教程 无人机ROS仿真包 rotors_simulator 使用教程 PX4无人机ROS下仿真开发 ROS下基于YOLO的px4无人机目标检测 基于px4的无人机自主导航 px4文档 开源无人机项目：XTDrone","categories":[{"name":"robot","slug":"robot","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/robot/"}],"tags":[{"name":"Drone","slug":"Drone","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Drone/"}]},{"title":"ubuntu找不到ttyUSB*","slug":"UbuntuNoUSB","date":"2021-01-17T07:44:00.000Z","updated":"2021-01-17T07:57:42.301Z","comments":true,"path":"2021/01/17/UbuntuNoUSB/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2021/01/17/UbuntuNoUSB/","excerpt":"问题描述在使用dji妙算（arm架构ubuntu14.04）连接激光雷达（ ubuntu RPLIDAR A2的使用）时，出现不能调用端口的错误，经过搜索后发现，是因为没有ttyUSB*驱动。","text":"问题描述在使用dji妙算（arm架构ubuntu14.04）连接激光雷达（ ubuntu RPLIDAR A2的使用）时，出现不能调用端口的错误，经过搜索后发现，是因为没有ttyUSB*驱动。 解决方法（待补充） ref Ubuntu下找不到ttyUSB*问题解决 为您的内核版本构建cp210x ubuntu arm妙算加载cp210x驱动 cp210x&#x2F;ch340等驱动地址","categories":[{"name":"OS","slug":"OS","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/OS/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/ubuntu/"}]},{"title":"Docker使用记录","slug":"Docker","date":"2021-01-13T12:47:00.000Z","updated":"2021-01-18T02:42:24.493Z","comments":true,"path":"2021/01/13/Docker/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2021/01/13/Docker/","excerpt":"Docker的安装","text":"Docker的安装 ref Docker——从入门到实践 MacOS通过Docker使用ROS 可以通过GUI打开gazebo, rviz, rqt等工具的镜像","categories":[{"name":"OS","slug":"OS","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/OS/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Docker/"}]},{"title":"ubuntu开机失败——ACPI Error","slug":"acpiError","date":"2021-01-13T12:47:00.000Z","updated":"2021-01-17T07:44:02.375Z","comments":true,"path":"2021/01/13/acpiError/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2021/01/13/acpiError/","excerpt":"开机循环进入GNU GRUB 或者 黑屏","text":"开机循环进入GNU GRUB 或者 黑屏 有提示ACPI Error错误如图： 解决办法1）先用下面方法进入系统 在GUN GRUB界面，选择ubuntu，按e开启编辑； 在开头为linux的一行最后，加上apci=off 按f10重启 2）更改grub 修改grub文件：sudo vim /etc/default/grub 把GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;改为GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash acpi=off&quot;(vim的使用方法请自行搜索) sudo update-grub ref 这是由于acpi和ubuntu版本不兼容：Booting Ubuntu with “acpi&#x3D;off” grub parameter","categories":[{"name":"OS","slug":"OS","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/OS/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/ubuntu/"}]},{"title":"使用NodeJs和VueJs搭建网站","slug":"vue","date":"2020-12-15T11:47:00.000Z","updated":"2021-01-31T16:48:42.953Z","comments":true,"path":"2020/12/15/vue/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2020/12/15/vue/","excerpt":"一、工具Vue.jsVue是一套用于构建用户界面的渐进式框架。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。 Vue官方网站 ElementUI一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。 ElementUI官网 可以直接去官网的组件中，选择想要的组件，复制代码直接使用。 NodeJsNode.js 是能够在服务器端运行JavaScript 的开放源代码、跨平台 JavaScript 运行环境。 安装：sudo apt-get install nodejs npmnpm 是 Node.js 官方提供的包管理工具，他已经成了 Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。","text":"一、工具Vue.jsVue是一套用于构建用户界面的渐进式框架。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。 Vue官方网站 ElementUI一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。 ElementUI官网 可以直接去官网的组件中，选择想要的组件，复制代码直接使用。 NodeJsNode.js 是能够在服务器端运行JavaScript 的开放源代码、跨平台 JavaScript 运行环境。 安装：sudo apt-get install nodejs npmnpm 是 Node.js 官方提供的包管理工具，他已经成了 Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。 安装sudo apt-get install nodejs ps. 安装完后需要使用npm config set registry https://registry.npm.taobao.org切换成淘宝镜像，不然速度很慢。 更新npm i -g n n latest 安装vuenpm i -g @vue/cli 服务端后台常驻进程npm i -g nodemon MongoDB一个数据库 官网安装步骤 或 sudo apt-get install mongodb-server NginxNginx是异步框架的网页服务器，也可以用作反向代理、负载平衡器和HTTP缓存。简单来说，就是通过服务器通过Nginx替你找到html文件。 安装sudo apt-get install nginx 配置 在线配置nginx：Go Nginx config 根据要求依次选择相应的 网站配置选项：Preset，域名等等 全局配置选项：刚开始基本不用管 下载&#x2F;复制config文件 把config文件复制到服务器的/etc/nginx/sites-available/文件夹中，再在/etc/nginx/sites-enabled/中创建一个软连接指向/etc/nginx/sites-available/中的config文件 例如域名为test.com： cp sites-available/test.com.conf /etc/nginx/sites-available/ cd /etc/nginx/sites-avaible sudo ln -s ../sites-available/test* /etc/nginx/sites-enabled/ Change &#109;&#101;&#64;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d; to your email sudo certbot --non-interactive --redirect --agree-tos --nginx -d test.com -m me@example.com 二、搭建项目示例项目 项目初始化及其框架以示例项目为例： admin是管理员界面项目，可以用vue create admin来创建，里面包含public和src文件夹，src文件夹就是源代码所在文件夹 desktop是pc桌面界面项目，可以用vue create desktop来创建 web是移动端界面项目，可以用vue create web来创建 server是nodejs组成的服务端项目，包括给后台和前端提供的接口。 使用mkdir server创建文件夹后cd server，使用npm init -y初始化一个node项目（会生成一个package.json文件） 再在文件夹里新建一个index.js作为服务端入口文件 在package.json的scripts中，插入一行&quot;serve&quot;: &quot;nodemon index.js&quot;,。这样就可以在server中使用npm run serve来运行服务器项目 初始化完以后就可以cd进各个文件夹使用npm run serve本地运行，查看每个项目的效果。 ps: 如果提示错误，可以先使用npm i安装依赖 安装elementUI和路由在admin和desktop中，使用vue add element安装ElementUI，vue add router安装路由。 vue项目文件说明以admin为例： public可以先不管 src是项目源代码 components是组件文件夹 views存放的主要是总体页面的代码，views中新建.vue文件后，需要再../router.js中增加路由 项目部署服务器系统设置Install Packages Install Nodejs sudo apt-get install nodejs Install npm sudo apt-get install npm Config Taobao registry npm config set registry https://registry.npm.taobao.org Update Nodejs npm i -g n n latest Reload cmd shell Install pm2 npm i -g pm2 Install Mongodb sudo apt-get install mongodb-server Install Nginx sudo apt-get install nginx Install certbot sudo apt install -y nginx certbot python-certbot-nginx Setup123cd desktopnpm inpm run build npm run build可以编译成静态html文件，直接打开 把npm run build改为npm run server可以在本地测试网站效果 注意：build之前需要把对应文件夹里的vue.config.js（如：desktop/vue.config.js）中的publicPath的/改为./。outputDir:可以改为你想要编译到的目的路径 以示例项目为例，build 后在desktop中生产的dist文件夹就是静态html文件目录，点击dist/index.html就可以打开网站，把生成的dist文件夹里的文件放到服务器的对应文件夹就可以访问了。 Ref 学习视频","categories":[{"name":"web前端","slug":"web前端","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/vue/"}]},{"title":"网络编程笔记","slug":"后端","date":"2020-10-15T08:00:00.000Z","updated":"2020-10-21T09:14:50.161Z","comments":true,"path":"2020/10/15/后端/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2020/10/15/%E5%90%8E%E7%AB%AF/","excerpt":"网络编程大小端大端：高位存在低地址，低位存在高地址。 小端：高位存在高地址，低位存在低地址。 大小端和CPU有关。 现代PC大多采用小段，所以小端字节序又被成为主机字节序。而大端字节序又被成为网络字节序。","text":"网络编程大小端大端：高位存在低地址，低位存在高地址。 小端：高位存在高地址，低位存在低地址。 大小端和CPU有关。 现代PC大多采用小段，所以小端字节序又被成为主机字节序。而大端字节序又被成为网络字节序。 基础APITCP: recv, send UDP: recvfrom, sendto(也可以面向连接) 通用: recvmsg, sendmsg 网络I&#x2F;O 管道：ini pipi(int fd[2]); 双向管道：ini socketpair(int domain, int type, int protocol, int fd[2]); 分散读：readv、集中写：writev 两个文件描述符之间传递数据：sendfile 进程间通信共享内存：申请mmap, 释放munmap 两个文件描述符之间移动数据：splice 两个管道文件描述符间复制数据：tee 文件描述符的各种控制：fcntl 日志 syslog rsyslogd 用户信息 getuid, geteuid, getgid, getegid, getpgid, getsid setuid, seteuid, setgid, setegid, setpgid, setsid 服务器框架TCP客户端与服务器工作流程 I&#x2F;O模型 同步 阻塞I&#x2F;O I&#x2F;O复用 信号驱动I&#x2F;O 异步 I&#x2F;O复用 select，监听文件描述符。O(n)的无差别轮询，最大连接数1024。 poll，轮询文件描述符。也是O(n)的无差别轮询，但是它没有最大连接数的限制，原因是它是基于链表来存储的。 epoll。可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I&#x2F;O事件通知我们。复杂度降低到了O(1)。 LT模式，ET模式 epoll_create epoll_ctl epoll_wait ref. select、poll、epoll之间的区别 select、poll、epoll之间的区别总结 事件处理模式 Reactor Proactor 并发模式 半同步&#x2F;半异步 (变体)&#x3D;&gt; 半同步&#x2F;半反应堆 领导者&#x2F;追随者 池 内存池 进程池 线程池 连接池 信号 kill SIG_IGN SIG_DFL SIGHUP, SIGPIPE, SIGGURG 定时器Linux定时方法 socket方法 SO_RCVTIMEO SO_SNDTIMEO SIGALRM I&#x2F;O复用系统调用的超时参数 高性能定时器 时间轮 时间堆 I&#x2F;O框架库 LibeventLinux服务器必须处理的3件事 I&#x2F;O 时间 信号 定时器 基于Reactor的框架库 句柄 事件多路分发器 事件处理器和具体事件处理器 Reactor handle_event register_handler remove_handler 多进程 fork exec 系列 僵尸进程 wait waitpid 进程间通信 管道 (pipe) 信号量 (Semaphore): P, V. semget semop semctl IPC_PRIVATE 共享内存 shmget shmat shmdt shmctl 消息队列 msgget msgsnd msgrcv msgctl 多线程 LinuxThreads NPTL 创建 pthread_creatr pthread_exit pthread_join pthread_cancel 线程间同步 POSIX信号量: sem_xxx 互斥量: pthread_mutex_xxx 条件变量: pthread_cond_xxx 线程同步机制类: locker.h 进程和线程: pthread_atfork 线程和信号: pthread_sigmask 进程池和线程池 随机算法、Round Robin、工作队列 半同步&#x2F;半异步进程池实现 Reference 游双. Linux高性能服务器编程. 机械工业出版社 徐晓鑫. 后台开发：核心技术与应用实践. 机械工业出版社","categories":[{"name":"back-end","slug":"back-end","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/back-end/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"操作系统","slug":"os","date":"2020-08-18T05:00:00.000Z","updated":"2020-09-03T06:10:08.003Z","comments":true,"path":"2020/08/18/os/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2020/08/18/os/","excerpt":"","text":"系统ubuntu开机的时候系统做了什么 加载BIOSBIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做”硬件自检”。硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。 读取MBR计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。 Bootloader在这种情况下，计算机读取”主引导记录”前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统。Boot Loader 就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核做好一切准备。Boot Loader有若干种，其中Grub、Lilo和spfdisk是常见的Loader。Linux环境中，目前最流行的启动管理器是Grub。 加载内核内核的加载，内核加载后，接开始操作系统初始化，根据进程的优先级启动进程。 ref. ubuntu启动过程 内核态（管态）和用户态（目态）用户态（User Mode）：处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的。 内核态（Kernel Mode）：处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。 三种会导致用户态到内核态切换的情况： 系统调用：应用程序主动向操作系统发出的服务请求 异常：非法指令或者其他原因导致当前指令执行失败。(如：内存出错)后的处理请求 外围设备的中断：来自硬件设备的处理请求 用户态和内核态的区别 什么的系统调用用户态调用操作系统提供的内核态级别的子功能。 系统调用按功能大致可分为如下几类： 设备管理。完成设备的请求或释放，以及设备启动等功能。 文件管理。完成文件的读、写、创建及删除等功能。 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。 进程通信。完成进程之间的消息传递或信号传递等功能。 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。 存储管理 连续内存分配动态分区分配 最先匹配(First-fit) 最佳匹配(Best-fit) 最差匹配(Worst-fit) 伙伴算法(Buddy system)Buddy（伙伴的定义）：这里给出伙伴的概念，满足以下三个条件的称为伙伴： 两个块大小相同； 两个块地址连续； 两个块必须是同一个大块中分离出来的； 伙伴算法分配内存:若申请的内存大小为n则将n向上取整为2的幂设次数为s,则需要分配s大小的内存块,定位大相应数组： 如果该数组有剩余内存块,则分配出去； 若没有剩余内存块就沿数组向上查找,然后再将该内存块分割出来s并将剩余的内存块放入相应大小的数组中。 例如分配5大小的内存块：定位到大小为8的链表中。若该链表中之中没有空余元素,则定位到16的链表中,16中有剩余元素,则取出该元素,并分割出大小为8的内存块供用户使用,然后将剩余的8连接到大小为8的数组中。 伙伴算法的内存合并:当用户用完内存后会归还,然后根据该内存块实际大小(向上取整为2的幂)归入链表中,在归入之前, 我们还要检测他的伙伴内存块是否空闲, 如果空闲就合并在一起,合并后转到1,继续执行. 若果不是空闲的就直接归入链表中. 一般来说,伙伴算法实现中会用位图记录内存块是否被使用,用于伙伴内存的合并。 伙伴算法的特点: 伙伴算法会浪费大量的内存，(如果需要大小为9的内存块必须分配大小为16的内存块) 优点也是明显的，分配和合并算法都很简单易行。 ps. 对于小块内存的分配和回收,伙伴算法效果不好，一般采用slab算法,或者叫做slab机制 什么是内存碎片，怎么解决空闲的内存不但是能被利用 外部碎片：分配单元之间的未被使用内存 内部碎片： 分配单元内部的未被使用内存 取决于分配单元大小是否要取整 解决：使用非连续内存分配：段、页、段页式 非连续内存分配段式存储管理系统进程的段地址空间由多个段组成 主代码段 子模块代码段 公用库代码段 堆栈段(stack) 堆数据(heap) 初始化数据段 符号表等 页式存储管理系统分页就是说，将磁盘或者硬盘分为大小固定的数据块，叫做页，然后内存也分为同样大小的块，叫做页框。当进程执行的时候，会将磁盘的页载入内存的某些页框中，并且正在执行的进程如果发生缺页中断也会发生这个过程。页和页框都是由两个部分组成的，一个是页号或者页框号，一个是偏移量。分页一般是有硬件来完成的，每个页都对应一个页框，它们的对应关系存放在一个叫做页表的数据结构中，页号作为这个页表的索引，页框号作为页表的值。操作系统负责维护这个页表。 帧（物理页面）把物理地址空间划分为大小相同的基本分配单位，大小为2的n次方，如512, 4096, 8192。 内存物理地址的表示：二元组 (f, o) f：帧号 (F 位, 共有2^F个帧) o：帧内偏移 (S 位, 每帧有2^S字节) 物理地址 &#x3D; f * 2^S + o 页（逻辑页面）把逻辑地址空间也划分为相同大小的基本分配单位，帧和页的大小必须是相同的。 页内偏移 &#x3D; 帧内偏移 通常：页号大小 ≠ 帧号大小 进程逻辑地址的表示：二元组 (p, o) p：页号 (P 位, 2P 个页) o：页内偏移 (S 位, 每页有2S 字节) 虚拟地址 &#x3D; p * 2S + o 页表 页表项的组成： 帧号 f 页表项标志 存在位 引用位 修改位 快表（TLB）缓存近期访问的页表项。TLB 使用关联存储(associative memory)实现，具备快速访问性能。 如果TLB命中，物理页号可以很快被获取 如果TLB未命中，对应的表项被更新到TLB中 多级页表 分页和分段有什区别？ 分页对程序员是透明的，但是分段需要程序员显式划分每个段。 分页的地址空间是一维地址空间，分段是二维的。 页的大小不可变，段的大小可以动态改变。 分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。 段页式存储管理系统在段式存储管理基础上，给每个段加一级页表 段页式存储管理中的内存共享： 虚拟存储虚拟存储就是说，让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。虚拟内存使用部分加载的技术，让一个进程或者资源的某些页面加载进内存，从而能够加载更多的进程，甚至能加载比内存大的进程，这样看起来好像内存变大了，这部分内存其实包含了磁盘或者硬盘，并且就叫做虚拟内存。 虚拟页式存储管理在页式存储管理的基础上，增加请求调页和页面置换。 当用户程序要装载到内存运行时，只装入部分页面，就启动程序运行 进程在运行中发现有需要的代码或数据不在内存时，则向系统发出缺页异常请求 操作系统在处理缺页异常时，将外存中相应的页面调入内存，使得进程能继续运行 虚拟段式存储管理在段式存储管理的基础上，以分段为单位进行换入换出。 缺页异常 页面置换算法当出现缺页异常，需调入新页面而内存已满时，置换算法选择被置换的物理页面 局部置换置换页面的选择范围仅限于当前进程占用的物理页面内 最优置换算法选择的被换出的页面是未来最长时间内不再被访问的页面，通常可以保证获得最低的缺页率。这是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。 先进先出选择换出的页面是最先进入的页面。该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。 最近最久未使用(Least Recently Used, LRU)虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。 时钟算法(Clock)页面装入内存时，访问位初始化为0。访问页面（读&#x2F;写)时，置访问位置为1。缺页时，从指针当前位置顺序检查环形链表： 访问位为0，则置换该页 访问位为1，则访问位置0，并指针移动到下一个页面，直到找到可置换的页面 最不常用算法(Least Frequently Used, LFU)缺页时，置换访问次数最少的页面。每个页面设置一个访问计数，访问页面时，访问计数加1，缺页时，置换计数最小的页面。 全局置换置换页面的选择范围是所有可换出的物理页面。 工作集置换算法：换出不在工作集中的页面。当前时刻前τ个内存访问的页引用是工作集，τ被称为窗口大小。 缺页率算法：通过调节常驻集大小，使每个进程的缺页率保持在一个合理的范围内。 Belady现象采用FIFO等算法时，可能出现分配的物理页面数增加，缺页次数反而升高的异常现象 FIFO算法的置换特征与进程访问内存的动态特征矛盾 被它置换出去的页面并不一定是进程近期不会访问的 LRU算法没有Belady现象 抖动(thrashing)进程物理页面太少，不能包含工作集，造成大量缺页，频繁置换，进程运行速度变慢。 原因：随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升。 进程和线程进程Linux 下创建新进程的系统调用是fork 123456#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork(void);//处理僵尸进程pid_t waitpid(pid_t pid, int* stat_loc, int options); 进程有哪几种状态?他们的转换方式 创建状态(new)：进程正在被创建，尚未到就绪状态。 就绪状态(ready)：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。 运行状态(running)：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。 阻塞状态(waiting)：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。 结束状态(terminated)：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。 进程间的通信方式 管道&#x2F;匿名管道(Pipes)：速度慢，容量有限，只用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。 命名管道(Names Pipes&#x2F;FIFO)：任何进程间都能通讯，但速度慢，严格遵循先进先出(first in first out)。 消息队列(Message Queuing)：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。 信号量(Semaphores)：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。不能传递复杂消息，只能用来同步。 共享内存(Shared memory)：能够很容易控制容量，速度快，但需要依靠某种同步操作，如互斥锁和信号量等。比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。 套接字(Sockets)：此方法主要用于在客户端和服务器之间通过网络进行通信，也可以用于同一主机上的socket通信。 信号(Signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 进程间的五种通信方式介绍 进程控制块（process control block，PCB）PCB 是进程存在的唯一标识，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。 进程描述信息： 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符； 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务； 进程控制和管理信息： 进程当前状态，如 new、ready、running、waiting 或 blocked 等； 进程优先级：进程抢占 CPU 时的优先级； 资源分配清单： 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I&#x2F;O 设备信息。 CPU 相关信息： CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。 每个 PCB 是如何组织的呢？通常是通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。比如： 将所有处于就绪状态的进程链在一起，称为就绪队列； 把所有因等待某事件而处于等待状态的进程链在一起就组成各种阻塞队列； 另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。 进程的调度算法 先到先服务(FCFS)调度算法：从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。 短作业优先(SJF)的调度算法：从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。 时间片轮转调度算法：时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。 多级反馈队列调度算法：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。 优先级调度：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。 孤儿进程，僵尸进程，守护进程孤儿进程：父进程退出后子进程还在运行。这些子进程就叫做孤儿进程。孤儿进程被init进程收养。 僵尸进程：子进程结束后，内核不会立即释放该进程的进程表表项，以满足父进程后续对该子进程的信息查询。子进程退出之后，父进程读取其退出状态（调用waitpid获取子进程状态信息）之前，就是僵尸进程。 守护进程：在后台运行不受终端控制的进程。如输入，输出，网络服务等。 创建守护进程 创建子进程，父进程退出 在子进程中创建新的会话（脱离控制终端）：使用系统函数setsid()来创建。 改变当前目录为根目录 重设文件权限掩码，关闭文件描述符 处理孤儿进程，僵尸进程孤儿进程没有什么危害，所以并不需要怎么处理。 如果父进程一直不调用wait&#x2F;waitpid处理以及退出的子进程，子进程就会一直在系统里占用资源。 僵尸进程的处理方式为：当一个进程结束时，它会给父进程发送一个SIGCHLD信号，我们在父进程中捕获SIGCHLD信号，并在信号处理函数中调用waitpid函数来处理退出的子进程。 线程Linux 系统中，线程的基础API都定义在 pthread.h 中。 12345#include &lt;pthead.h&gt;int pthread_create(pthread_t* thread, const pthread_attr_r* attr, void* (*start_routine)(void*), void* arg);void pthread_exit(void* retval); 线程间的同步的方式 锁机制 互斥锁：互斥锁提供了以排他方式防止数据结构被并发修改的方法 读写锁：读写锁允许多个线程同时读共享数据，而对写操作是互斥的 条件变量：条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用 自旋锁 信号量(Semphares)：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量 信号机制(Signal)：类似进程间的信号处理 互斥锁与信号量的区别： 互斥锁用户线程互斥，信号量用于线程同步。 互斥锁仅用于线程，信号量还可以用于进程。 线程安全怎么实现线程安全定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。 线程安全的实现方式： 互斥同步：指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用。常见的互斥实现方式有：临界区(critical selection)，互斥量(mutex)和信号量(semaphore)。互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种实现方式也叫阻塞同步。从处理问题的方式上来说，互斥同步属于一种悲观的并发策略。 非阻塞同步：随着硬件指令集的发展，我们有了另外的一个选择：基于冲突检测的乐观并发策略。也就是先进行操作，如果没有其它线程使用共享数据，那就操作成功；如果有，那就再采取补偿措施。这种方式不需要把线程挂起，因此称为：非阻塞同步(Non-Blocking Synchronization)。 无同步方案： 可重入代码 线程本地存储：如果一段代码中所需要的数据都完全包含在同一个线程中，如果能保证这一点，那就不会因为跟其它线程争抢修改资源而导致数据不一致，也就没有线程风险，是线程安全的。 ref. 线程安全的实现方式 进程和线程的差别线程是指进程内的一个执行单元，也是进程内的可调度实体。线程与进程的区别： 调度：线程作为CPU调度的基本单位，进程作为拥有资源的基本单位； 拥有资源：进程是拥有资源的一个独立单元，进程拥有一个完整的资源平台；线程只独享必不可少的资源，如寄存器和栈，不拥有系统资源但可以访问隶属于进程的资源 并发性：不仅进程之间可以并发执行，同一个进程的多个线程也可以并发执行； 线程的状态：线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系； 系统开销：在创建或撤销进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤销线程时的开销； 进程上下文切换，线程上下文切换，中断上下文切换进程上下文切换进程上下文包括计算机系统中与执行该进程有关的各种寄存器（例如通用寄存器，程序计数器PC，程序状态字寄存器PS等）的值，程序段在经过编译过后形成的机器指令代码集，数据集及各种堆栈值PCB结构。 当切换进程时，需要保存当前进程的所有状态，即当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。 发生进程上下文切换有哪些场景？在进程状态发生改变时，且进程基本都属于进程上下文切换的场景： 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行； 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行； 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度； 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行； 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序； 线程上下文切换线程上下文：当进程只有一个线程时，可以认为进程就等于线程；当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的；另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。 线程的上下文切换： 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样； 当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据； 中断上下文切换中断上下文：中断时需要保存的参数和进程环境。 线程有自己的堆，栈吗与线程“绑定”的是栈，用于存储自动变量。每一个线程建立的时候，都会新建一个默认栈与之配合。堆则是通常与进程相关，用于存储全局性的变量，进程建立的时候，会建立默认堆。于是，每一个线程都有自己的栈，然后访问共同的堆。当然，你可以通过OsApi建立其他堆栈。 堆：是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。 栈：是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是 thread safe的。操作系统在切换线程的时候会自动的切换栈，就是切换 ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放。 并发，同步，异步，互斥，阻塞，非阻塞并发：多个程序同时运行即并发。并发可分为同步和互斥。 同步，互斥互斥：同一时间只能有一个访问者访问资源，无序的 同步：必须按照某种顺序运行。在互斥的基础上通过其他机制实现资源的有序访问。 同步时一种更复杂的互斥，互斥是一种特殊的同步。 同步，异步同步：顺序执行，需要等待、协调运作。 异步：彼此独立，在等待某事件的过程中继续做自己的事，不需要等待。 线程是实现异步的一个方式 异步 不等于 多线程。异步是最终目的，多线程只是实现异步的一种手段 阻塞，非阻塞经常访问数据时，根据IO操作的就绪状态不同采取的不同处理方式。比如读取文件内容，阻塞方式下主程序会等到函数读取完再继续，非阻塞方式下主程序不等待文件读取完就继续往下执行。 一般可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞 同步阻塞，同步非阻塞，异步阻塞，异步非阻塞以发送方发出请求要接收方读取文件内容为例。 同步阻塞：发送方发出请求后一直等待（同步）。接受方开始读取，如果不能马上读到就一直等待，直到读取后响应发送方，等待期间不能做其他操作（阻塞）。 同步非阻塞：发送方发出请求后一直等待（同步）。接受方开始读取，如果不能马上读到就立即返回继续做其他事情（非阻塞），并未响应发送方。直到IO完成才响应。 异步阻塞：发送方发出请求后不等待响应，继续其他工作（异步）。接受方开始读取，如果不能马上读到就一直等待，直到读取后响应发送方，等待期间不能做其他操作（阻塞）。 异步非阻塞：发送方发出请求后不等待响应，继续其他工作（异步）。接受方开始读取，如果不能马上读到就立即返回继续做其他事情（非阻塞），并未响应发送方。直到IO完成才响应。（效率最高） ps. 发送方等待就是同步，不等待就是异步；接收方等待就是阻塞，不等待就是非阻塞。 总结： 同步异步是两个线程之间的关系，两个线程之间要么是同步的，要么是异步的。 阻塞与非阻塞是对同一个线程来说。某个时刻，线程处于阻塞或非阻塞 多进程、多线程的优缺点 多进程更鲁棒，一个进程死了不影响其他进程，子进程死了不影响主进程。多线程比较脆弱，一个线程崩溃可能会影响整个程序。 进程性能大于线程，但是创建进程花销大于线程。 进程通讯需要跨越进程边界，不适合大量数据传送，更适合小数据活着密集数据。线程可以共享内存和变量，适合大量数据的传送。 多进程逻辑空控制比多线程复杂 多线程虽然逻辑控制比较简单，但是需要复杂的同步和加锁控制等机制 可以通过增加CPU数量来增加进程的数量，但是不能通过增加CPU来增加线程的数量，线程的数量由进程的空间资源和线程本身栈大小确定。 为什么要使用线程？与进程相比有哪些好处 资源和进程相比，它是一种非常”节俭”的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。 切换效率运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。（但是进程性能大于线程） 通信线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。 使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。(CPU设计保证） 改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。（代码易维护） 什么时候用进程，什么时候用线程进程用来“做大事”，线程用来“各自做小事”： 创建和销毁较频繁，用线程 需要大量数据传送，用线程 并行操作，用线程 总结：安全稳定用进程，快速频繁用线程 Linux查看&#x2F;杀死&#x2F;重启进程 查看：ps -aux 或 ps -ef 杀死：kill -PID 或强制杀死kill -KILL PID 重启：kill -HUP PID ref进程、线程基础知识全家桶 有哪些锁？ 互斥锁：同一时间只能有一个线程获得互斥锁，其他线程阻塞进入休眠态 读写锁：同一时间可以有多个线程获得读锁，适用于读操作频繁的场景 自旋锁：同一时间只能有一个线程获得自旋锁，其他线程会一直等待锁并且不会进入休眠态，如果不加限制，某个线程申请已经锁定的自旋锁，就会导致其他线程卡死，所以自旋锁适用于锁拥有者保持锁时间很短的场景 C++有哪些锁 什么是可重入和不可重入函数？ 可重入函数可以由多个任务并发使用，而不必担心数据错误。可重入函数可以在任意时刻被中断，稍后继续运行，不会丢失数据，可重入函数要么使用本地变量，要么使用全局变量时保护自己的数据。 不可重入函数不能由多个任务共享，除非能确保函数的互斥。 特点： 可重入函数 不可连续的调用持有静态数据； 不返回指向静态数据的指针，所有数据都是由函数的调用者提供； 使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据； 如果必须访问全局变量，记住利用互斥信号量来保护全局变量； 绝不调用任何不可重入函数。 不可重入函数 函数中使用了静态变量，无论是全局静态变量还是局部静态变量； 函数返回静态变量； 函数中调用了不可重入函数； 函数体内使用了静态的数据结构； 函数体内调用了malloc()或者free()函数； 函数体内调用了其他标准I&#x2F;O函数； 总之，如果一个函数在重入条件下使用了未受保护的共享资源，那么就是不可重入的。 死锁死锁是指两个或多个进程在执行的过程中，因为竞争资源而造成互相等待的现象，若无外力作用，它们都无法推进下去。 死锁的处理方法 预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。 避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。 检测死锁：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。 解除死锁：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来。 产生死锁的原因 因为系统资源不足。 进程运行推进的顺序不合适。 资源分配不当等。 死锁的4个必要条件 互斥：一个资源每次只能被一个进程使用。 请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺：进程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待：若干进程之间形成一种头尾相接的循环等待资源关系。 死锁的预防我们可以通过破坏产生死锁的四个必要条件来预防死锁，但是资源互斥是固有特性无法改变的。 破坏“请求与保持”条件 静态分配，每个进程在开始执行时就申请他所需要的全部资源。 动态分配，每个进程在申请所需要的资源时他本身不占用系统资源。 破坏“不可剥夺”条件一个进程不可获得其所需要的全部资源便处于等待状态，等待期间他占用的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。 破坏“循环等待”条件采用资源有序分配的基本思想。将系统中的资源顺序进行编号，将紧缺的、稀少的资源采用较大的编号，申请资源时必须按照编号的顺序执行，一个进程只有较小编号的进程才能申请较大编号的进程。 死锁的避免 有序资源分配法：源按某种规则系统中的所有资源统一编号，申请时必须以上升的次序。 银行家算法 ref. 死锁 进程占用率过高怎么排查 jstack：适用于java进程，可以取到所以线程的堆栈dump； pstack：适用于所有linux进程，是对gdb的功能封装。此命令可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID。 文件系统文件描述符文件描述符是打开文件的标识，操作系统在打开文件表中维护的打开文件状态和信息。 文件指针 文件打开计数 文件的磁盘位置 访问权限 Linux文件系统Linux文件系统里面有文件和目录，组成一个树状的结构，树的每一个叶子节点表示文件或者空目录。每个文件基本上都由两部分组成： inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号； block：记录文件的内容，文件太大时，会占用多个 block。 除此之外还包括： superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等； block bitmap：记录 block 是否被使用的位图。 当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。 从内核文件系统看文件读写过程 什么是 inode理解inode，要从文件储存说起。 文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。 操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。 文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。 每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。 Linux 文件系统通过 i 节点把文件的逻辑结构和物理结构转换的工作过程Linux 通过 inode 节点表将文件的逻辑结构和物理结构进行转换。 inode 节点是一个 64 字节长的表，表中包含了文件的相关信息，其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息。在 inode 节点表中最重要的内容是磁盘地址表。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。Linux 文件系统通过把 inode 节点和文件名进行连接，当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的 inode 节点号，通过该 inode 节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构。 硬链接和软链接有什么区别 硬链接：由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1。不足： 不可以在不同文件系统的文件间建立链接； 只有超级用户才可以为目录创建硬链接。 软链接：软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。不足： 因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。 实际场景下，基本是使用软链接。总结区别如下： 硬链接不可以跨分区，软件链可以跨分区。 硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点。 删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。 文件的分配 连续分配 链式分配 索引分配 操作系统读写文件的过程从Linux文件系统看文件读写过程从内核文件系统看文件读写过程 I&#x2F;O三种I&#x2F;O操作 阻塞I&#x2F;O：读写数据时，进程将进入等待状态 非阻塞I&#x2F;O：立即从read或write系统调用返回，返回值为成功传输字节数 异步I&#x2F;O：使用指针标记好用户缓冲区，立即返回；稍后内核再处理并通知用户 I&#x2F;O请求生存周期 CPU与设备控制器的数据传输程序控制I&#x2F;O(PIO, Programmed I&#x2F;O)通过CPU的in&#x2F;out或者load&#x2F;store传输所有数据。 直接内存访问(DMA)设备控制器可直接访问系统总线，控制器直接与内存互相传输数据。 I&#x2F;O设备如何通知操作系统 CPU主动轮询：I&#x2F;O 设备在特定的状态寄存器中放置状态和错误信息，操作系统定期检测状态寄存器。 设备中断：CPU在I&#x2F;O之前设置任务参数；CPU发出I&#x2F;O请求后，继续执行其他任务；I&#x2F;O设备处理I&#x2F;O请求；I&#x2F;O设备处理完成时，触发CPU中断请求；CPU接收中断，分发到相应中断处理例程。 磁盘调度算法 先来先服务(FIFO) 按照磁盘请求的顺序进行调度。 优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。 最短寻道时间优先(SSTF) 优先调度与当前磁头所在磁道距离最近的磁道。 虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。一般来说，两端的磁道请求更容易出现饥饿现象。 电梯算法(SCAN扫描算法) 电梯算法就是说读写磁头总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。 因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了最短寻道时间优先的饥饿问题。 循环扫描算法(C-SCAN) 限制了仅在一个方向上扫描 当最后一个磁道也被访问过了后，磁臂返回到磁盘的另外一端再次进行 C-LOOK算法 磁臂先到达该方向上最后一个请求处，然后立即反转，而不是先到最后点路径上的所有请求 N步扫描(N-step-SCAN)算法 磁头粘着(Arm Stickiness)现象：SSTF、SCAN及CSCAN等算法中，可能出现磁头停留在某处不动的情况 N步扫描算法将磁盘请求队列分成长度为N的子队列，按FIFO算法依次处理所有子队列，扫描算法处理每个队列 双队列扫描(FSCAN)算法 FSCAN算法是N步扫描算法的简化，FSCAN只将磁盘请求队列分成两个子队列 把磁盘I&#x2F;O请求分成两个队列，交替使用扫描算法处理一个队列，新生成的磁盘I&#x2F;O请求放入另一队列中，所有的新请求都将被推迟到下一次扫描时处理。 磁盘缓存 单缓存 双缓存 ref 清华大学操作系统课程","categories":[{"name":"CS","slug":"CS","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/CS/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/OS/"}]},{"title":"Leetcode每日一题 - 2020年八月","slug":"LeetcodeDaily_Aug","date":"2020-08-01T12:00:00.000Z","updated":"2020-08-27T02:16:53.524Z","comments":true,"path":"2020/08/01/LeetcodeDaily_Aug/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2020/08/01/LeetcodeDaily_Aug/","excerpt":"","text":"8月3日 415. 字符串相加（简单）给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： 1234num1 和num2 的长度都小于 5100.num1 和num2 都只包含数字 0-9.num1 和num2 都不包含任何前导零。你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。 题解：两个数字位数不同时，在指针当前下标处于负数的时候返回 0，等价于对位数较短的数字进行了补零操作，这样就可以除去两个数字位数不同情况的处理。 12345678910111213141516string addStrings(string num1, string num2)&#123; int i = num1.length() - 1, j = num2.length() - 1, add = 0; string res = &quot;&quot;; while (i &gt;= 0 || j &gt;= 0 || carry != 0) &#123; int x = i &gt;= 0 ? num1[i] - &#x27;0&#x27; : 0; int y = j &gt;= 0 ? num2[j] - &#x27;0&#x27; : 0; int result = x + y + carry; res.push_back(&#x27;0&#x27; + result % 10); carry = result / 10; i -= 1; j -= 1; &#125; // 计算完以后的答案需要翻转过来 reverse(res.begin(), res.end()); return res;&#125; 时间复杂度：O(max{n1,n2})空间复杂度：O(1) 8月4日 207. 课程表（中等）你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1] 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？ 示例 1: 123输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例 2: 123输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 提示： 123输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。你可以假定输入的先决条件中没有重复的边。1 &lt;= numCourses &lt;= 10^5 题解： 有向图的dfs遍历。visited[i]表示第i和节点的状态，0表示没有被访问过，1表示正在被访问，2表示访问结束的节点。circle表示有向图有环。使用dfs遍历有向图： 当正在访问的节点（visited[i]&#x3D;1）又被访问时，说明有向图存在环，返回false。 全部节点访问完毕，返回true1234567891011121314151617181920212223242526272829303132void dfs(int u, vector&lt;vector&lt;int&gt; &gt; &amp;graph, vector&lt;int&gt; &amp;visited)&#123; visited[u] = 1;//正在访问该节点 for(int v:graph[u])&#123; if(visited[v]==0)&#123; dfs(v, graph, visited); if(circle) return; &#125;else if(visited[v]==1)&#123; circle = true; return; &#125; &#125; visited[u] = 2;&#125;bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123; if(prerequisites.empty()) return true; vector&lt;vector&lt;int&gt; &gt; graph(numCourses); for (auto course : prerequisites) &#123;//build graph graph[course[1]].push_back(course[0]); &#125; vector&lt;int&gt; visited(numCourses); for (int i = 0; i &lt; numCourses &amp;&amp; !circle; i++) &#123; if(!visited[i]) dfs(i, graph, visited); &#125; return !circle;&#125; 时间复杂度：O(m+n)。m是有向图的边，n是有向图的节点。空间复杂度：O(m+n) bfs入度为0的点拓扑排序中，起点都是入度为0的点。把所有入度为0的节点放入队列，依次访问队列中的节点。访问的时候把所有从该节点出去的边都删掉，即该节点出发连接的边的入度都减1。再把入度减到0的点加入队列。1234567891011121314151617181920212223242526272829303132bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123; if(prerequisites.empty()) return true; vector&lt;vector&lt;int&gt; &gt; graph(numCourses); vector&lt;int&gt; inDegree(numCourses, 0); for (auto course : prerequisites) &#123;//build graph graph[course[1]].push_back(course[0]); inDegree[course[0]]++; &#125; queue&lt;int&gt; que; for (int i = 0; i &lt; numCourses;i++) &#123; if(inDegree[i]==0) que.push(i); &#125; int visited = 0; while (!que.empty()) &#123; visited++; int u = que.front(); que.pop(); for(int v:graph[u])&#123; inDegree[v]--; if(inDegree[v]==0) que.push(v); &#125; &#125; return visited == numCourses;&#125; 时间复杂度：O(m+n)。m是有向图的边，n是有向图的节点。空间复杂度：O(m+n) 真题模版匹配前面给一个词做模版，看后面的多个词是否能和前面的模版匹配。 示例1： 12输入：pattern = &quot;noon&quot;, str = &quot;big star star big&quot;输出：true 示例2: 12输入：pattern = &quot;noon&quot;, str = &quot;big star star not&quot;输出：false 题解： 1234567891011121314151617181920212223242526272829bool testMatch(string pattern, string str) &#123; map&lt;string,char&gt; wordMap; char used[128] = &#123;0&#125;; string word; int pos = 0; str.push_back(&#x27; &#x27;); for (int i = 0; i &lt; str.size();i++)&#123; if(str[i]==&#x27; &#x27;)&#123; if(pos==pattern.size()) return false; if(wordMap.find(word)==wordMap.end())&#123; if(used[pattern[pos]]) return false; wordMap[word] = pattern[pos]; used[pattern[pos]] = 1; &#125;else&#123; if(wordMap[word]!=pattern[pos]) return false; &#125; word = &quot;&quot;; pos++; &#125;else&#123; word += str[i]; &#125; &#125; if(pos!=pattern.size()) return false; return true;&#125; 找到最小的排列组合数找到比原数字位数排列组合后，比原数字大的，最小的数。没有就输出-1 123456789101112131415161718//80% 比如 2231就不对了int findGreaterNum(int N) &#123; string s = to_string(N); for (int i = s.size() - 1; i &gt; 0; i--) &#123; if (s[i] &gt; s[i - 1]) &#123; swap(s[i], s[i - 1]); break; &#125; &#125; int res = atoi(s.c_str()); if (res == N) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; res; return 0;&#125; 1477. 找两个和为目标值且不重叠的子数组给你一个整数数组 arr 和一个整数值 target。 请你在 arr 中找两个互不重叠的子数组 且它们的和都等于 target。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。 请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。 题解：dp[i]表示i后面和等T的最小子数组长度 12345678910111213141516int minSumOfLengths(vector&lt;int&gt;&amp; arr, int target)&#123; int sum = 0, r = arr.size() - 1, res = 200000; vector&lt;int&gt; dp(arr.size() + 1, 200000);//后面子数组的最小长度 for (int l = r; l &gt;= 0; --l) &#123; //l,r是滑动区间的左右坐标 sum += arr[l]; while (sum &gt; target) sum -= arr[r--]; if (sum == target) &#123; int curLen = r - l + 1; //子数组长度 res = min(res, curLen + dp[r + 1]); //子数组长度 + r后面子数组的最小长度 dp[l] = min(dp[l + 1], curLen); //更新l后面子数组的最小长度 &#125;else dp[l] = dp[l + 1]; //更新子数组的最小长度 &#125; return res == 200000 ? -1 : res;&#125; 16进制和10进制的互转1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465string convert_10_to_16(int num)&#123; vector&lt;int&gt; ivec; int Num = num; while (num != 0) &#123; ivec.push_back(num % 16); num = num / 16; &#125; vector&lt;int&gt;::size_type sz = ivec.size(); vector&lt;string&gt; ivec2; int m = 0; string s; for (vector&lt;int&gt;::size_type index = 0; index != sz; ++index) &#123; if (ivec[sz - 1 - index] &gt; 9) &#123; m = ivec[sz - 1 - index] + 55; s = m+&#x27;0&#x27;-&#x27;0&#x27;; ivec2.push_back(s); &#125; else &#123; s = ivec[sz - 1 - index] + &#x27;0&#x27;; ivec2.push_back(s); &#125; &#125; string res = &quot;&quot;; for (auto item : ivec2) res += item; return res;&#125;double convert_16_to_10(string str)&#123; double sum = 0, times; double m; string::size_type sz = str.size(); for (string::size_type index = 0; index != sz; ++index) &#123; str[index] = tolower(str[index]); if (str[index] &gt;= &#x27;a&#x27; &amp;&amp; str[index] &lt;= &#x27;f&#x27;) &#123; m = str[index] - &#x27;a&#x27; + 10; times = pow(16, (sz - 1 - index)); sum += m * times; &#125; else if (isdigit(str[index])) &#123; m= str[index] - 48; times = pow(16, (sz - 1 - index)); sum += m * times; &#125; else &#123; break; &#125; &#125; return sum;&#125; 8月10日 696. 计数二进制子串给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。 重复出现的子串要计算它们出现的次数。 示例 1 : 1234567输入: &quot;00110011&quot;输出: 6解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。请注意，一些重复出现的子串要计算它们出现的次数。另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。 示例 2 : 123输入: &quot;10101&quot;输出: 4解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。 注意： 12s.length 在1到50,000之间。s 只包含“0”或“1”字符。 题解： 把每个相同的字符分组，比如“00111011” 就可以分为subs&#x3D;{2,3,1,2}，表示2个0，3个1，1个0，2个1。每一对相邻的能有min{subs[i],subs[i+1]}个字串。 123456789101112131415161718int countBinarySubstrings(string s) &#123; vector&lt;int&gt; subs; int i = 0; while(i&lt;s.size())&#123; int mark = i; char cur = s[i]; while(i&lt;s.size() &amp;&amp; s[i]==cur) i++; subs.push_back(i-mark); &#125; int res = 0; for(int i = 0;i&lt;subs.size()-1;i++)&#123; res += min(subs[i],subs[i+1]); &#125; return res;&#125; 时间复杂度：O(n)空间复杂度：O(n) 优化。空间复杂度优化到O(1)。也只用到subs的上一个状态量，所以可以不用保存整个subs数组。 1（代码略） 8月11日 130. 被围绕的区域（中等）给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。 找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。 示例: 12345678910X X X XX O O XX X O XX O X X运行你的函数后，矩阵变为：X X X XX X X XX X X XX O X X 解释:被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。题解：dfs。也可以用bfs，但是需要自己用队列实现，还是递归方便一点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;void dfs(vector&lt;vector&lt;char&gt; &gt;&amp; board,vector&lt;int&gt; &amp; s,vector&lt;vector&lt;bool&gt; &gt; &amp;marked)&#123; int x=s[0],y=s[1]; if(board[x][y]==&#x27;X&#x27; || marked[x][y]) return; marked[x][y] = true; for(auto d:dirs)&#123; int next_i = x+d[0], next_j = y+d[1]; vector&lt;int&gt; tmp = &#123;next_i,next_j&#125;; if((next_i &gt; 0 &amp;&amp; next_i &lt; board.size()) &amp;&amp; (next_j &gt; 0 &amp;&amp; next_j &lt; board[0].size())) dfs(board,tmp,marked); &#125; return;&#125;void solve(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123; if(board.empty()) return; int m = board.size(),n = board[0].size(); vector&lt;vector&lt;bool&gt; &gt; marked(m,vector&lt;bool&gt;(n, false)); vector&lt;vector&lt;int&gt; &gt; side; for(int i=0;i&lt;n;i++)&#123; if(board[0][i]==&#x27;O&#x27;)&#123; side.push_back(&#123;0,i&#125;); //marked[0][i] = true; &#125; if(board[m-1][i]==&#x27;O&#x27;)&#123; side.push_back(&#123;m-1,i&#125;); //marked[m-1][i] = true; &#125; &#125; for(int i=1;i&lt;m-1;i++)&#123; if(board[i][0]==&#x27;O&#x27;)&#123; side.push_back(&#123;i,0&#125;); //marked[i][0] = true; &#125; if(board[i][n-1]==&#x27;O&#x27;)&#123; side.push_back(&#123;i,n-1&#125;); //marked[i][n-1] = true; &#125; &#125; for(auto s:side)&#123; dfs(board,s,marked); &#125; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(!marked[i][j] &amp;&amp; board[i][j]==&#x27;O&#x27;) board[i][j] = &#x27;X&#x27;; &#125; &#125; return;&#125; 时间复杂度：O(mn)空间复杂度：O(mn) 8月12日 133. 克隆图（中等）给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。 图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。 1234class Node &#123; public int val; public List&lt;Node&gt; neighbors;&#125; 题解： bfs 123456789101112131415161718192021222324252627282930313233Node* cloneGraph(Node* node) &#123; if (node == nullptr) &#123; return node; &#125; unordered_map&lt;Node*, Node*&gt; visited; // 将题目给定的节点添加到队列 queue&lt;Node*&gt; que; que.push(node); // 克隆第一个节点并存储到哈希表中 visited[node] = new Node(node-&gt;val); // 广度优先搜索 while (!que.empty()) &#123; // 取出队列的头节点 auto curNode = que.front(); que.pop(); // 遍历该节点的邻居 for (auto&amp; neighbor: curNode-&gt;neighbors) &#123; if (visited.find(neighbor) == visited.end()) &#123; // 如果没有被访问过，就克隆并存储在哈希表中 visited[neighbor] = new Node(neighbor-&gt;val); // 将邻居节点加入队列中 que.push(neighbor); &#125; // 更新当前节点的邻居列表 visited[curNode]-&gt;neighbors.emplace_back(visited[neighbor]); &#125; &#125; return visited[node];&#125; 时间复杂度：O(n)空间复杂度：O(n) dfs 12345678910111213141516171819unordered_map&lt;Node*, Node*&gt; visited;Node* cloneGraph(Node* node) &#123; if (node == nullptr) &#123; return node; &#125; if(visited.find(node) != visited.end()) return visited[node]; Node *cloneNode = new Node(node-&gt;val); visited[node] = cloneNode; for(auto &amp;neighbor:node-&gt;neighbors)&#123; cloneNode-&gt;neighbors.push_back(cloneGraph(neighbor)); &#125; return visited[node];&#125; 时间复杂度：O(n)空间复杂度：O(n) 8月13日 43. 字符串相乘（中等）给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1: 12输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;输出: &quot;6&quot; 示例 2: 12输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;输出: &quot;56088&quot; 说明： 1234num1 和 num2 的长度小于110。num1 和 num2 只包含数字 0-9。num1 和 num2 均不以零开头，除非是数字 0 本身。不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 题解：大数相乘问题。 1234567891011121314151617181920212223242526272829303132string multiply(string num1, string num2)&#123; int m = num1.size(), n = num2.size(); vector&lt;long long&gt; num(m + n - 1, 0); for (int i = 0; i &lt; m;i++)&#123;//前面是高位，后面是低位 int a = num1[i] - &#x27;0&#x27;; for (int j = 0; j &lt; n; j++) &#123; int b = num2[j] - &#x27;0&#x27;; num[i + j] += a * b; &#125; &#125; int carry = 0; for (int i = num.size() - 1; i &gt;= 0;i--)&#123;//前面是高位，后面是低位 int cur = num[i] + carry; num[i] = cur % 10; carry = cur / 10; &#125; while(carry!=0)&#123; int cur = carry % 10; carry /= 10; num.insert(num.begin(), cur); &#125; string res = &quot;&quot;; for (auto a : num) &#123; res += to_string(a); &#125; return res;&#125; 时间复杂度：O(m*n)空间复杂度：O(m+n) 8月19日 647. 回文子串（中等）给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例 1： 123输入：&quot;abc&quot;输出：3解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; 示例 2： 123输入：&quot;aaa&quot;输出：6解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot; 题解：枚举每一个字串，再判断是不是回文。 123456789101112131415161718192021222324bool isPalindrome(string str)&#123; int L = 0, R = str.size() - 1; while(L&lt;R)&#123; if(str[L]!=str[R]) break; L++; R--; &#125; return L&gt;=R;&#125;int countSubstrings(string s) &#123; int n = s.size(); if(n==0) return 0; int res = n; for(int m=2;m&lt;=n;m++)&#123; for(int i=0;i&lt;=n-m;i++)&#123; string cur_str = s.substr(i,m); if(isPalindrome(cur_str)) res++; &#125; &#125; return res;&#125; 时间复杂度：O(n^2)空间复杂度：O(1) 8月20日 529. 扫雷游戏（中等）让我们一起来玩扫雷游戏！ 给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，’E’ 代表一个未挖出的空方块，’B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’X’ 则表示一个已挖出的地雷。 现在给出在所有未挖出的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板： 如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’。如果一个没有相邻地雷的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的未挖出方块都应该被递归地揭露。如果一个至少与一个地雷相邻的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。如果在此次点击中，若无更多方块可被揭露，则返回面板。 示例 1： 12345678910111213输入: [[&#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;], [&#x27;E&#x27;, &#x27;E&#x27;, &#x27;M&#x27;, &#x27;E&#x27;, &#x27;E&#x27;], [&#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;], [&#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;]]Click : [3,0]输出: [[&#x27;B&#x27;, &#x27;1&#x27;, &#x27;E&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;M&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]] 示例 2： 12345678910111213输入: [[&#x27;B&#x27;, &#x27;1&#x27;, &#x27;E&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;M&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]]Click : [1,2]输出: [[&#x27;B&#x27;, &#x27;1&#x27;, &#x27;E&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;X&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]] 题解： dfs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;,&#123;-1,1&#125;&#125;;void dfs(vector&lt;vector&lt;char&gt; &gt; &amp;res, int row, int col, vector&lt;vector&lt;bool&gt; &gt; &amp;hasVisited)&#123; if(hasVisited[row][col]) return; //处理当前格子 int boom = 0; for(auto d:dirs)&#123; int next_i=row+d[0]; int next_j=col+d[1]; if(next_i &lt; 0 || next_i &gt;= res.size() || next_j &lt; 0 || next_j &gt;= res[0].size()) continue; if(res[next_i][next_j]==&#x27;M&#x27;) boom++; &#125; hasVisited[row][col] = true; if(boom==0) res[row][col] = &#x27;B&#x27;; else&#123; res[row][col] = to_string(boom)[0]; // res[cur_i][cur_j] = boom + &#x27;0&#x27;; return; &#125; //处理下一个格子 for(auto d:dirs)&#123; int next_i=row+d[0]; int next_j=col+d[1]; if(next_i &lt; 0 || next_i &gt;= res.size() || next_j &lt; 0 || next_j &gt;= res[0].size()) continue; dfs(res,next_i,next_j,hasVisited); &#125;&#125;vector&lt;vector&lt;char&gt;&gt; updateBoard(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;int&gt;&amp; click) &#123; if(board.empty()) return board; int row = click[0],col=click[1]; vector&lt;vector&lt;char&gt; &gt; res = board; if(board[row][col]==&#x27;M&#x27;)&#123; res[row][col] = &#x27;X&#x27;; return res; &#125; vector&lt;vector&lt;bool&gt; &gt; hasVisited(board.size(), vector&lt;bool&gt;(board[0].size(),false)); dfs(res,row,col,hasVisited); return res;&#125; 时间复杂度：O(mn)空间复杂度：O(mn) bfs。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;,&#123;-1,1&#125;&#125;;void bfs(vector&lt;vector&lt;char&gt; &gt; &amp;res, int row, int col, vector&lt;vector&lt;bool&gt; &gt; &amp;hasVisited)&#123; queue&lt;vector&lt;int&gt; &gt; que; que.push(&#123;row,col&#125;); hasVisited[row][col] = true; while(!que.empty())&#123; int sizeq = que.size(); while(sizeq--&gt;0)&#123; int cur_i = que.front()[0]; int cur_j = que.front()[1]; que.pop(); int boom = 0; for(auto d:dirs)&#123; int next_i=cur_i+d[0]; int next_j=cur_j+d[1]; if(next_i &lt; 0 || next_i &gt;= res.size() || next_j &lt; 0 || next_j &gt;= res[0].size()) continue; if(res[next_i][next_j]==&#x27;M&#x27;) boom++; &#125; if(boom==0)&#123; //处理当前格子 res[cur_i][cur_j] = &#x27;B&#x27;; //下一个格子 for(auto d:dirs)&#123; int next_i=cur_i+d[0]; int next_j=cur_j+d[1]; if(next_i &lt; 0 || next_i &gt;= res.size() || next_j &lt; 0 || next_j &gt;= res[0].size() || hasVisited[next_i][next_j]) continue; if(res[next_i][next_j]==&#x27;E&#x27;)&#123; que.push(&#123;next_i,next_j&#125;); hasVisited[next_i][next_j] = true; &#125; &#125; &#125; else res[cur_i][cur_j] = to_string(boom)[0]; &#125; &#125;&#125;vector&lt;vector&lt;char&gt; &gt; updateBoard(vector&lt;vector&lt;char&gt; &gt;&amp; board, vector&lt;int&gt;&amp; click) &#123; if(board.empty()) return board; int row = click[0],col=click[1]; vector&lt;vector&lt;char&gt; &gt; res = board; if(board[row][col]==&#x27;M&#x27;)&#123; res[row][col] = &#x27;X&#x27;; return res; &#125; vector&lt;vector&lt;bool&gt; &gt; hasVisited(board.size(), vector&lt;bool&gt;(board[0].size(),false)); bfs(res,row,col,hasVisited); return res;&#125; 时间复杂度：O(mn)空间复杂度：O(mn) 元素平衡A，B，C，D四个数，每次可以任意减少2个单位然后增加1各单位，问当四个数相等时，最大和为多少。 题解：笔试真题。 123456789101112131415161718192021222324252627282930int main()&#123; vector&lt;long&gt; nums(4); cin &gt;&gt; nums[0] &gt;&gt; nums[1] &gt;&gt; nums[2] &gt;&gt; nums[3]; sort(nums.begin(), nums.end()); long long sumn = nums[0] + nums[1] + nums[2] + nums[3]; long maxn = sumn / 4; while(maxn&gt;0)&#123; int sumL = 0, sumR = 0, idx = 0; while(idx&lt;4 &amp;&amp; nums[idx]&lt;maxn)&#123; sumL += (maxn - nums[idx]); idx++; &#125; while(idx&lt;4 &amp;&amp; nums[idx]==maxn) idx++; while(idx&lt;4 &amp;&amp; nums[idx]&gt;maxn)&#123; sumR += (nums[idx] - maxn); idx++; &#125; if(sumL*2 &lt;= sumR)&#123; cout &lt;&lt; maxn * 4 &lt;&lt; endl; return 0; &#125; maxn--; &#125; cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/Algorithm/"}],"tags":[{"name":"Leetcode daily","slug":"Leetcode-daily","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Leetcode-daily/"}]},{"title":"STL常用方法","slug":"STL","date":"2020-07-12T06:30:00.000Z","updated":"2020-08-21T08:45:34.860Z","comments":true,"path":"2020/07/12/STL/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2020/07/12/STL/","excerpt":"常用STL库的使用方法记录了常用的STL使用方法","text":"常用STL库的使用方法记录了常用的STL使用方法 vector：数组12345678910111213141516171819202122232425262728293031323334#include &lt;vector&gt; vector&lt;int&gt; a(10);//初始化10个默认为0的数 vector&lt;int&gt; a(10,1);//初始化10个默认为1的数 vector&lt;int&gt; a; //初始化二维数组 vector&lt;vector&lt;int&gt; &gt; 2dVec(m ,vector&lt;int&gt;(n)); //m*n的二维vector，注意两个 &quot;&gt; &quot;之间要有空格2dVec.push_back(&#123;1, 2, 3&#125;);//可以这样加vector vector&lt;vector&lt;int&gt; &gt; 2dVec(m ,vector&lt;int&gt;(n,0)); //m*n的二维vector，所有元素初始化为0 a.push_back() a[0] a.front() //首元素 a.back() //尾元素 a.size() a.pop_back()//删除不输出 it = a.begin()+1 a.erase(it) it2 = a.begin()+3 a.erase(it,it2)//删除[it1,it2) a.clear() a.empty() a.insert(it,-1) vector&lt;int&gt;::iterator itDele;it = find(a.begin(), a.end(), 3);//查找3if(it!=a.end())//如果找到了//pair make_pairvector&lt;pair&lt;int ,int&gt; &gt; vp;vp.push_back(&#123;1, 0&#125;);vp.push_back(make_pair(0, 1));vector&lt;pair&lt;int, int&gt; &gt; vp2 = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;vp2.push_back(make_pair&lt;int, int&gt;(5, 6)); list：数组Lists将元素按顺序储存在链表中. 与向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢。 12345678910111213141516171819202122232425262728#include &lt;list&gt;pop_back() 删除最后一个元素 pop_front() 删除第一个元素 push_back() 在list的末尾添加一个元素 push_front() 在list的头部添加一个元素 back() 返回最后一个元素 front() 返回第一个元素 begin() 返回指向第一个元素的迭代器 end() 返回末尾的迭代器 size() 返回list中的元素个数 clear() 删除所有元素 empty() 如果list是空的则返回truea.sort() 给list排序erase() 删除一个元素 assign() 给list赋值 get_allocator() 返回list的配置器 insert() 插入一个元素到list中 max_size() 返回list能容纳的最大元素数量 merge() 合并两个list rbegin() 返回指向第一个元素的逆向迭代器 remove() 从list删除元素 remove_if() 按指定条件删除元素 rend() 指向list末尾的逆向迭代器 resize() 改变list的大小 reverse() 把list的元素倒转 splice() 合并两个list swap() 交换两个list unique() 删除list中重复的元素 stack：栈12345678#include &lt;stack&gt;stack&lt;int&gt; a;a.push()a.top()a.pop()a.empty()a.size() queue：队列123456789#include &lt;queue&gt;queue&lt;int&gt; a;a.push()a.front()a.back()a.pop()a.empty()a.size() priority_queue：堆12345678910111213141516171819202122232425262728293031323334353637#include &lt;queue&gt;//priority_queue&lt;type,container,function&gt;//小根堆，a&gt;bpriority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; //大根堆，a&lt;bpriority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; q;//默认是大根堆priority_queue &lt;int&gt; q ;//自定义堆的比较方式//方法1，用类class cmp&#123;public: bool operator()(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b)&#123; return a.second &gt; b.second; //a&gt;b = greater&lt;int&gt; &#125;&#125;;//方法2，用structstruct cmp&#123; bool operator()(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b)&#123; return a.second &gt; b.second; &#125;&#125;;priority_queue&lt;pair&lt;int, int&gt;,vector&lt;pair&lt;int,int&gt; &gt;, cmp&gt; pq;//注意！没有front和backq.push()q.pop()q.top()q.empty()q.size() map&#x2F;unordered_map哈希表的实现：STL中，map/set 对应的数据结构是红黑树。红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 O(logN)。而 unordered_map/unordered_set 对应 哈希表，哈希表的特点就是查找效率高，时间复杂度为常数级别 O(1)， 而额外空间复杂度则要高出许多而且无序。所以对于需要高效率查询的情况，使用 unordered_map 容器。而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用 map 容器。 123456789101112131415161718#include &lt;map&gt;std:map&lt;int,int&gt; mapA;//插入mapA.insert(std::pair&lt;int,int&gt;(0,1));mapA.insert(map&lt;int,int&gt;::value_type (0,1));mapA[0] = 1;mapA.at(0)mapA.size()map&lt;int, int&gt;::iterator iter;//迭代器mapA.erase(key/iter)mapA.clear()mapA.empty()mapA.count() //由于map不包含重复的key，因此m.count(key)取值为0，或者1，表示是否包含。mapA.find(key)//返回迭代器，判断是否存在。mapA.find(key) != mapA.end() //为真说明存在#include &lt;unordered_map&gt; //和map差不多 map的注意事项： 在map中，由key查找value时，首先要判断map中是否包含key。 如果不检查，直接返回map[key]，可能会出现意想不到的行为。如果map包含key，没有问题，如果map不包含key，使用下标有一个危险的副作用，会在map中插入一个key的元素，value取默认值，返回value。也就是说，map[key]不可能返回null。 比如： 1234unordered_map&lt;string, int&gt; mapA;cout &lt;&lt; mapA.size() &lt;&lt; endl; //这时为0int a = mapA[&quot;aa&quot;] //本来是空map，但是调用mapA[&quot;aa&quot;]之后，会自动插入mapA[&quot;aa&quot;]=0，返回0cout &lt;&lt; mapA.size() &lt;&lt; endl; //这使为1 set&#x2F;multiset&#x2F;unordered_setset和multiset的区别： set不可以有重复的元素 multiset可以有重复的元素 和map&#x2F;unordered_map一样，也是set&#x2F;multiset使用红黑树实现，unordered_set使用哈希表实现。unordered_set和unordered_map内部实现的公共接口大致相同。 set是按照一定的次序存储元素的容器，set遍历后有序，默认按照小于排序 set中只放value，但是底层存放的是&lt;value, value&gt;的键值对。每个value必须是惟一的 set允许插入和删除，不允许修改 set按照内部比较对象（类型比较）所指示的特定严格弱排序准则进行排序 set在底层用二叉搜索树（红黑树）实现 set中查找、插入、删除元素的复杂度为O(logn)，unordered_set为O(1) 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;set&gt;#include &lt;unordered_set&gt;unordered_set&lt;int&gt; us;us.insert(2);//插入unordered_set&lt;int&gt; us1(us);//us1=usunordered_set&lt;int&gt; us2(us1.begin(),us1.end());us.erase(6); //删除键值为6的元素set&lt;int&gt;::iterator it; it = us.find(6); //查找键值为6的元素int n = us.count(6);//也能判断一个数是否在集合中。n=0不在，n=在set&lt;int&gt; s = &#123;3,8,12,15&#125;s.lower_bound(8); //表示查找 &gt;= 8 的元素中最小的一个(8)，并返回指向该元素的迭代器s.upper_bound(8); //表示查找 &gt;8 的元素中最小的一个(12)，并返回指向该元素的迭代器s.lower_bound(9); //12s.upper_bound(9); //12begin() //返回指向第一个元素的迭代器clear() //清除所有元素count() //返回某个值元素的个数empty() //如果集合为空，返回trueend() //返回指向最后一个元素的迭代器equal_range() //返回集合中与给定值相等的上下限的两个迭代器erase() //删除集合中的元素find() //返回一个指向被查找到元素的迭代器get_allocator() //返回集合的分配器insert() //在集合中插入元素lower_bound() //返回指向大于（或等于）某值的第一个元素的迭代器key_comp() //返回一个用于元素间值比较的函数max_size() //返回集合能容纳的元素的最大限值rbegin() //返回指向集合中最后一个元素的反向迭代器rend() //返回指向集合中第一个元素的反向迭代器size() //集合中元素的数目swap() //交换两个集合变量upper_bound() //返回大于某个值元素的迭代器value_comp() //返回一个用于比较元素间的值的函数 string12345678910111213141516#include &lt;string&gt;string s;s.find()//在s当中查找第一个出现s.rfind()//在s当中查找最后一个出现int is = stoi(val) //把string val转换成int。stoi()会做范围检查，默认范围是在int的范围内的，如果超出范围的话则会runtime errorint is = atoi(val.c_str()) //atoi()不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界#include &lt;algorithm&gt;reverse(s.begin(),s.end()); //反转字符串#include &lt;cstring&gt;//s1 s2需要c风格字符串char//如果是string，需要s1.c_str()strcmp(s1,s2) //相等返回0；s1-s2大于0，则返回1，小于0则返回-1strncmp(s1,s2,n) //比较前n个strcpy(s1,s2) //s2复制到s1,注意s2不要比s1长 大小写转换 对应大小写字母之间相差32 transform函数：直接处理string123string s = &quot;aBc&quot;;transform(s.begin(), s.end(), s.begin(), ::tolower);//::toupper转大写 toupper, tolower：处理char12345#include &lt;cctype&gt;char s = &#x27;a&#x27;;char sl = tolower(s);char su = toupper(sl); algorithmsortsort并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。 1234567891011121314151617181920#include &lt;algorithm&gt;//nums必须是线性容器//降序排序sort(nums.begin(),nums.end(),greater&lt;int&gt;());//升序（默认是升序）sort(nums.begin(),nums.end(),less&lt;int&gt;());sort(nums.begin(),nums.end());//自定义排序函数vector&lt;vecotr&lt;int&gt; &gt; nums2d;bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123; //注意！这个函数要在类外面定义 return a[1] &gt; b[1];//按第二维降序&#125;sort(nums2d.begin(),nums2d.end(),cmp);//稳定排序stable_sort(nums.begin(),nums.end(),greater&lt;int&gt;());stable_sort(nums.begin(),nums.end(),less&lt;int&gt;()); sort算法有个限制，利用sort算法只能对序列容器进行排序，就是线性的，如vector，list，deque。map也是一个集合容器，但它里面存储的元素是pair，不是线性存储的（前面提过，像红黑树），所以利用sort不能直接和map结合进行排序。 如果想对map进行排序，可以把map放到vector中。 12345678// 将map中的内容转存到vector中vector&lt;pair&lt;string, int&gt; &gt; vec(map.begin(), map.end());bool cmp(const pair&lt;string, int&gt;&amp; a, const pair&lt;string, int&gt;&amp; b) &#123; return a.second &lt; b.second;&#125;//对线性的vector进行排序sort(vec.begin(), vec.end(), cmp); 注意： 支持随机存取迭代器（连续存储空间）的vector，deque （双向存取的vector）可以使用sort； 支持随机存取迭代器（链式非连续存储空间）的list（双向链表）和slist（单向链表forward_list），不能使用STL的sort，但是类中有自定义的sort()成员函数； 关系型容器中基于红黑树的set，multiset，map，multimap，本身就有自动排序的功能，不需要sort函数。如果有特殊排序需求的话，可以放入vector中； stack，queue没有迭代器，入口出口固定，不能进行排序； 基于哈希表的unordered_map等都是为排序的，也不需要排序。 count1234#include &lt;algorithm&gt;vector&lt;int&gt; nums = &#123;100,100,100,101&#125;;int num = count(nums.begin(),nums.end(),100);//统计100出现的次数 lower_bound、upper_bound、binary_search12345#include &lt;algorithm&gt;lower_bound(起始地址，结束地址，要查找的数值) //返回的是数值 第一个 出现的位置。upper_bound(起始地址，结束地址，要查找的数值) //返回的是数值 最后一个 出现的位置。binary_search(起始地址，结束地址，要查找的数值) //返回的是是否存在这么一个数，是一个bool值。 一些数学运算1#include &lt;cmath&gt; 迭代器1#include &lt;iterator&gt; cctype123456789101112131415#include &lt;cctype&gt;isalnum(c)//当c是字母或数字时为真isalpha(c)//当c是字母时为真isdigit(c)//当c是数字时为真islower(c)//当c是小写字母时为真isupper(c)//当c是大写字母时为真isspace(c)//当c是空白时为真（即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符）iscntrl(c)//当c是控制字符时为真isgraph(c)//当c不是空格但可打印时为真isprint(c)//当c是可打印字符时为真（即c是空格或c具有可视形式）ispunct(c)//当c是标点符号时为真isxdigit(c)//当c是十六进制数字时为真tolower(c)//如果c是大写字母，输出对应的小写字母，否则原样输出ctoupper(c)//如果c是小写字母，输出对应的大写字母，否则原样输出c","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/Algorithm/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/cpp/"}]},{"title":"笔试输入输出总结","slug":"cin_cout","date":"2020-07-11T13:10:00.000Z","updated":"2020-08-31T01:42:45.422Z","comments":true,"path":"2020/07/11/cin_cout/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2020/07/11/cin_cout/","excerpt":"常见输入常见机试输入","text":"常见输入常见机试输入 输入一个数字再加上空格间隔的数组，并且给了数组元素个数n12345int n;cin &gt;&gt; n;vector&lt;int&gt; input(n);for(int i = 0; i &lt; n; i++) cin &gt;&gt; input[i]; 输入一个数字再加上空格间隔的数组，但是没有给数组元素个数n1234567int a;vector&lt;int&gt; input;while(cin &gt;&gt; a)&#123; input.push_back(a); if(cin.get() == &#x27;\\n&#x27;) break;&#125; 给你输入的数据组数t，和很多组数据。这些数据有换行，但是数组元素个数都没有给比如： 12345673 //有3组数据1 2 3 4 5 //第一组数据A2 4 5 3 6 //第一组数据B3 4 6 //第二组数据A2 2 5 //第二组数据B1 //第三组数据A0 //第三组数据B 因为没有给每行数据的个数，所以一行数据输入完成时需要识别换行符。输入方法： 123456789101112131415int t, a;cin &gt;&gt; t;vector&lt;int&gt; A, B;for(int i = 0; i &lt; 2*t; i++)&#123; while(cin &gt;&gt; a)&#123; A.push_back(a); if (cin.get() == &#x27;\\n&#x27;) break; &#125; while(cin &gt;&gt; a)&#123; B.push_back(a); if (cin.get() == &#x27;\\n&#x27;) break; &#125;&#125; 不存在空格的字符数组12string s;cin &gt;&gt; s; 输入带有空格的字符数组12string s;getline(cin, s); 输入多个整数12int a,b,c,d;cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; 字符串的输入getline getline(istream&amp; is, string&amp; str); 把is传到str中 getline(istream&amp; is, string&amp; str, char delim); delim是截断字符，可以用来分割字符串12345678#include &lt;sstream&gt;string s = &quot;alice,20,800,sz&quot;;istringstream is(s);string str;std::getline(is, str); //str: alice,20,800,szstd::getline(is, str, &#x27;,&#x27;); //str: alice 输入：[1,1,1,1,2,1,1],[5,2,5,4,5,1,6]。要求提取出数字。 12345678910111213141516int main()&#123; string sw, sh; getline(cin, sw, &#x27;]&#x27;); getline(cin, sh, &#x27;]&#x27;); istringstream isw(sw.substr(1)), ish(sh.substr(2)); string tmp; vector&lt;int&gt; width, height; while (getline(isw, tmp, &#x27;,&#x27;)) width.push_back(stoi(tmp)); while (getline(ish, tmp, &#x27;,&#x27;)) height.push_back(stoi(tmp)); return 0;&#125; 输出精度控制如：输出保留2位小数 123456double d = 1.666666;//c++#include &lt;iomanip&gt;cout &lt;&lt; setprecision(3) &lt;&lt; d &lt;&lt; endl; //1.67//cprintf(&quot;%.2f\\n&quot;, d); //1.67 OJ练习牛客","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/Algorithm/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/cpp/"}]},{"title":"光流法","slug":"OpticalFlow","date":"2020-07-05T11:00:00.000Z","updated":"2020-08-17T07:30:34.020Z","comments":true,"path":"2020/07/05/OpticalFlow/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2020/07/05/OpticalFlow/","excerpt":"光流法光流法是利用图像序列中的像素强度数据的时域变化和相关性来确定各自像素位置的“运动”。简单说来说，光流法的目的是找到灰度图中各像素在连续图像中的移动方向和速度。 光流法的实现要求满足几个基本假设： 相邻帧之间的亮度恒定； 相邻视频帧的取帧时间连续，或者，相邻帧之间物体的运动比较“微小”； 保持空间一致性；即，同一子图像的像素点具有相同的运动。","text":"光流法光流法是利用图像序列中的像素强度数据的时域变化和相关性来确定各自像素位置的“运动”。简单说来说，光流法的目的是找到灰度图中各像素在连续图像中的移动方向和速度。 光流法的实现要求满足几个基本假设： 相邻帧之间的亮度恒定； 相邻视频帧的取帧时间连续，或者，相邻帧之间物体的运动比较“微小”； 保持空间一致性；即，同一子图像的像素点具有相同的运动。 光流法的分类基于梯度（微分法）Horn-Schunck光流法Horn-Schunck光流法基于全局平滑假设，即运动物体内部的光流场是相同的，因此物体内部光流场的梯度应该为零，也就是说物体内部的光流场应当是平滑的，故得到一个二阶梯度为0的约束方程。 特点：稠密光流，二阶导，计算量大 论文：Horn B K P, Schunck B G. Determining optical flow[J]. Artificial intelligence, 1981, 17(1-3): 185-203 Lucas-Kanade光流法Lucas-Kanade算法认为：一个像素周围的相邻像素的光流场应该和中心的像素光流场一致。因此可以得到一系列等式，可以用最小二乘法求解。 特点：稀疏光流 论文：Baker S, Matthews I. Lucas-kanade 20 years on: A unifying framework[J]. International journal of computer vision, 2004, 56(3): 221-255. 基于图像金字塔的Lucas-Kanade光流法普通的光流算法有一个问题——孔径问题。 同时，LK算法的约束条件——小速度，亮度不变以及区域一致性——都是较强的假设，并不很容易得到满足。如当物体运动速度较快时，假设不成立，那么后续的假设就会有较大的偏差，使得最终求出的光流值有较大的误差。 图像金字塔可以解决这个问题。 特点：稀疏光流 论文：Pyramidal Implementation of the Lucas Kanade Feature TrackerDescription of the algorithm 基于块匹配先找出原图中的特征点，再在待匹配的图中的同一个位置附近区域使用块匹配的方法寻找最匹配的块。 块匹配的主要方法： SAD（绝对误差和） MAD（平均绝对差) SSD（误差平方和） MSD（平均误差平方和） OpenCV中的光流法函数具体API可以查看OpenCV官方文档 CalcOpticalFlowHSHS光流法的实现 calcOpticalFlowPyrLK基于图像金字塔的Lucas-Kanade光流法的实现 CalcOpticalFlowBM通过块匹配的方法来计算光流 calcOpticalFlowFarneback用Gunnar Farneback 的算法计算稠密光流（即图像上所有像素点的光流都计算出来）。 论文：Two-Frame Motion Estimation Based on PolynomialExpansion calcOpticalFlowSF论文：SimpleFlow: A Non-iterative, Sublinear Optical FlowAlgorithm px4flow源码笔记flow.c文件地址 px4flow cpp项目地址 只用图像信息c代码：去掉角速度，用随机生成的二维矩阵测试 compute_flow函数参数参数：*image1,*image2,x_rate,y_rate,z_rate,*pixel_flow_x, *pixel_flow_y 意义：图像1，图像2，绕x轴旋旋转速度，绕y轴旋转速度，绕z轴旋转速度，x轴像素移动，y轴像素移动 加了备注 c代码 cpp代码 函数伪码： 点击查看伪码 1234567891011121314151617181920212223242526272829303132333435def compute_flow(): for block_mid_pix in img1://步长为block的大小 diff = compute_diff() if(diff&lt;THRESHOLD): continue for pix_in_win in img2: temp_dist = ABSDIFF() if(temp_dist&lt;dist): sumx = x偏移量 sumy = y偏移量 dist = temp_dist if(dist&lt;MIN_SAD): meanflowx += sumx meanflowy += sumy compute_subpixel();//计算半像素 得到具有最小SAD的半像素方向mindir dirsx[meancount] = sumx dirsy[meancount] = sumy subdirs[meancount] = mindir meancount++ 统计4个方向（类似坐标系的4个象限）的直方图 if(meancount&gt;10)://特征点超过10个点 meanflowx /= meancount meanflowy /= meancount 从直方图中找到4个方向中出现最多的方向 if(滤波)： 滤波法 else： 平均法 //NUM_BLOCKS是一个维度被分成了几块 计算qual=meancount * 255 / (NUM_BLOCKS*NUM_BLOCKS) 分析计算特征点使用了compute_diff函数，计算光流用的是SAD块匹配。 compute_diff(*image, offX, offY, row_size)参数：图像，图像左上角像素的x坐标，图像左上角像素的y坐标 compute_subpixelcompute_subpixel(*image1,*image2,off1X,off1Y,off2X, off2Y,*acc,row_size)参数：图像1，图像2，图像1左上角像素的x坐标，图像1左上角像素的y坐标，图像2左上角像素的x坐标，图像2左上角像素的y坐标， 计算流程 重要参数含义 筛选特征点 在附近搜索“距离”最近的块 半像素增加精度 直方图统计 进一步计算：直方图法用统计数量峰值的前后两个像素数据（共5个）来取平均；平均法全部加起来取平均。 角速度补偿 ref 光流法的过去，现在和发展趋势 计算机视觉–光流法(optical flow)简介 基于灰度的模板匹配算法（一）：MAD、SAD、SSD、MSD、NCC、SSDA、SATD算法 Opencv学习笔记（九）光流法 光流Optical Flow介绍与OpenCV实现 ABSDIFF和USADA8的汇编代码 Px4 flow分析 PX4FLOW flow.c函数流程详细解析 px4flow源码分析","categories":[{"name":"robot","slug":"robot","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/robot/"}],"tags":[{"name":"Computer vision","slug":"Computer-vision","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Computer-vision/"}]},{"title":"Leetcode每日一题 - 2020年七月","slug":"LeetcodeDaily_July","date":"2020-07-01T12:00:00.000Z","updated":"2020-08-17T07:39:45.704Z","comments":true,"path":"2020/07/01/LeetcodeDaily_July/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2020/07/01/LeetcodeDaily_July/","excerpt":"","text":"7月1日 718. 最长重复子数组（中等）给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。 示例： 123456输入：A: [1,2,3,2,1]B: [3,2,1,4,7]输出：3解释：长度最长的公共子数组是 [3, 2, 1] 。 题解： 滑动窗口。主串从第一个开始，滑动匹配串直到与主串的当前元素相等，再看后面一共有几个元素相等。分别以 A 为主串和 B 为主串匹配一次取最大。比如A &#x3D; {0,0,0,0,0,0,1,0,0,0}, B &#x3D; {0,0,0,0,0,0,0,1,0,0}，以 A 为主串会得到6。 12345678910111213141516171819202122232425262728293031int findCore(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B)&#123; int maxLen = 0; for (int i = 0; i &lt; A.size(); i++) &#123; int j = 0; while (j &lt; B.size()) &#123; while(j&lt;B.size() &amp;&amp; B[j]!=A[i])//判断边界的一定要在前面 j++; if(j==B.size()) break; int cur = i; while(cur&lt;A.size() &amp;&amp; j&lt;B.size() &amp;&amp; A[cur]==B[j])&#123; cur++; j++; &#125; maxLen = max(maxLen, cur - i); &#125; &#125; return maxLen;&#125;int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123; if(A.empty() || B.empty()) return 0; int a = findCore(A, B); int b = findCore(B, A); return max(a, b);&#125; 时间复杂度：O((m+n) * min{n,m})。m、n为数组的长度。空间复杂度：O(1) 二维dp。dp[i][j]表示A[0:i) 和 B[0:i)最长公共字串长度。 1234567891011121314151617int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123; if(A.empty() || B.empty()) return 0; int a = A.size(), b = B.size(); vector&lt;vector&lt;int&gt; &gt; dp(a + 1, vector&lt;int&gt;(b + 1, 0)); int maxLen = 0; for (int i = 1; i &lt;= a; i++) &#123; for (int j = 1; j &lt;= b;j++)&#123; if(A[i - 1] == B[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; maxLen = max(maxLen, dp[i][j]); &#125; &#125; return maxLen;&#125; 时间复杂度：O(mn)空间复杂度：O(mn) 一维dp。因为只用到了上一行的dp，所以可以只用一维dp来做，但是j的更新就需要从后往前，因为更新当前的值需要上一行的前面的值。 12345678910111213141516171819int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123; if(A.empty() || B.empty()) return 0; int a = A.size(), b = B.size(); vector&lt;int&gt; dp(b + 1, 0); int maxLen = 0; for (int i = 1; i &lt;= a; i++) &#123; for (int j = b; j &gt; 0;j--)&#123; if(A[i - 1] == B[j - 1]) dp[j] = dp[j - 1] + 1; else dp[j] = 0; maxLen = max(maxLen, dp[j]); &#125; &#125; return maxLen;&#125; 时间复杂度：O(mn)空间复杂度：O(m) 7月2日 378. 有序矩阵中第K小的元素（中等）给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。 示例： 12345678matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,返回 13。 题解： 把二维拉成一维，然后排序。 12345678910int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; vector&lt;int&gt; vec; for(int i=0;i&lt;matrix.size();i++)&#123; for(int j=0;j&lt;matrix[0].size();j++)&#123; vec.push_back(matrix[i][j]); &#125; &#125; sort(vec.begin(),vec.end()); return vec[k-1];&#125; 时间复杂度：O(n^2 * log(n^2))空间复杂度：O(n^2) 类似与归并排序。到第k个就结束。本代码每次都遍历每一行的首位元素，找到最小值弹出。（其实可以用一个小根堆来求最小值，可以减少时间复杂度为O(k * logn)） 123456789101112131415161718int kthSmallest(vector&lt;vector&lt;int&gt; &gt;&amp; matrix, int k) &#123; int n = matrix.size(); for (int i = 0; i &lt; k;i++)&#123; int min = 0; for (int j = 0; j &lt; n; j++) &#123; while (matrix[min].empty()) min++; if (matrix[j].empty()) continue; min = matrix[min][0] &lt;= matrix[j][0] ? min : j; &#125; if(i==k-1) return matrix[min][0]; matrix[min].erase(matrix[min].begin(), matrix[min].begin() + 1); &#125; return 0;&#125; 时间复杂度：O(k * n)空间复杂度：O(1) 7月3日 108. 将有序数组转换为二叉搜索树（简单）将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 123456789给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 题解：递归。中序遍历，总是选择中间位置左边的数字作为根节点。 123456789101112131415161718TreeNode *buildTree(vector&lt;int&gt;&amp; nums, int left, int right)&#123; if (left &gt; right) &#123; return nullptr; &#125; // 总是选择中间位置左边的数字作为根节点 int mid = (left + right) / 2; TreeNode* root = new TreeNode(nums[mid]); root-&gt;left = buildTree(nums, left, mid - 1); root-&gt;right = buildTree(nums, mid + 1, right); return root;&#125;TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; int L = 0, R = nums.size()-1; TreeNode *res = buildTree(nums, L, R); return res;&#125; 时间复杂度：O(n)空间复杂度：O(logn) 7月4日 32. 最长有效括号（困难）给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 123输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot; 示例 2: 123输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot; 示例3: 123输入: &quot;()(())&quot;输出: 6解释，都是有效的。 题解： 栈。 123456789101112131415161718int longestValidParentheses(string s) &#123; stack&lt;int&gt; st1; st1.push(-1); int longest = 0; for (int i = 0; i &lt; s.size(); i++) &#123; if(s[i]==&#x27;(&#x27;) st1.push(i); else&#123; st1.pop(); if(st1.empty()) st1.push(i); else longest = max(longest, i - st1.top()); &#125; &#125; return longest;&#125; 时间复杂度：O(n)空间复杂度：O(n) dp。 s[i]&#x3D;‘)’ 且 s[i−1]&#x3D;‘(’，也就是字符串形如 “……()”“……()”，我们可以推出：dp[i]=dp[i-2]+2 s[i]&#x3D;‘)’ 且 s[i−1]&#x3D;‘)’，也就是字符串形如 “……))”“……))”，我们可以推出：如果s[i−dp[i−1]−1]&#x3D;‘(’，那么：dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2 1（代码略） 7月5日 44. 通配符匹配（困难）给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。 ‘?’ 可以匹配任何单个字符。 ‘*’ 可以匹配任意字符串（包括空字符串）。 两个字符串完全匹配才算匹配成功。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。 示例 1: 12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例 2: 12345输入:s = &quot;aa&quot;p = &quot;*&quot;输出: true解释: &#x27;*&#x27; 可以匹配任意字符串。 示例 3: 12345输入:s = &quot;cb&quot;p = &quot;?a&quot;输出: false解释: &#x27;?&#x27; 可以匹配 &#x27;c&#x27;, 但第二个 &#x27;a&#x27; 无法匹配 &#x27;b&#x27;。 示例 4: 12345输入:s = &quot;adceb&quot;p = &quot;*a*b&quot;输出: true解释: 第一个 &#x27;*&#x27; 可以匹配空字符串, 第二个 &#x27;*&#x27; 可以匹配字符串 &quot;dce&quot;. 示例 5: 1234输入:s = &quot;acdcb&quot;p = &quot;a*c?b&quot;输出: false 题解： 递归。 1234567891011121314151617181920212223242526bool matchCore(string s, string p, int idxS, int idxP)&#123; if(idxS == s.size() &amp;&amp; idxP == p.size()) return true; if(idxS &gt;= s.size())&#123; if(p[idxP] != &#x27;*&#x27;) return false; else return matchCore(s, p, idxS, idxP + 1); &#125; if(p[idxP]==&#x27;*&#x27;)&#123; if(idxP==p.size()-1) return true; while(p[idxP]==&#x27;*&#x27;)//匹配连续的&#x27;*&#x27; idxP++; return matchCore(s, p, idxS + 1, idxP - 1) || matchCore(s, p, idxS, idxP); &#125; if(p[idxP]==&#x27;?&#x27; || s[idxS]==p[idxP]) return matchCore(s, p, idxS + 1, idxP + 1); else return false;&#125;bool isMatch(string s, string p) &#123; return matchCore(s, p, 0, 0);&#125; 时间复杂度：O(2^k)。k是‘*’串的个数。超时，941 &#x2F; 1809 个通过测试用例。空间复杂度：O(2^k)，递归调用需要用到栈 dp。dp[i][j]表示字符串s的前i个字符p的前j个字符是否能匹配。 注意：s和p下标是从 0 开始的。 当s[i-1]==p[j-1]或p[j-1]==&#39;?&#39;时：dp[i][j] = dp[i - 1][j - 1]。 当p[j-1]==&#39;*&#39;时：如果使用’*‘，则dp[i][j] = dp[i-1][j]；如果不使用’*‘，则dp[i][j] = dp[i][j-1]。 初始状态：dp[0][0] = true；dp[i][0] = false；如果直到p[i]前面都是”*“，dp[0][0～i] = true。1234567891011121314151617181920212223bool isMatch(string s, string p) &#123; int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt; &gt; dp(m + 1, vector&lt;bool&gt;(n + 1, false)); dp[0][0] = true; for (int i = 1; i &lt;= n; i++) &#123; if (p[i - 1] == &#x27;*&#x27;) dp[0][i] = true; else break; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n;j++)&#123; if(p[j-1]==&#x27;?&#x27; || p[j-1]==s[i-1]) dp[i][j] = dp[i - 1][j - 1]; else if(p[j-1]==&#x27;*&#x27;) dp[i][j] = dp[i][j - 1] || dp[i - 1][j]; &#125; &#125; return dp[m][n];&#125; 时间复杂度：O(mn)空间复杂度：O(mn) ps. 以后碰到这种题，直接用dp，递归基本都是时间复杂度比较高的。 7月6日 63. 不同路径 II（中等）一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例 1: 123456789101112输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 题解： 二维dp。dp[i][j] = dp[i-1][j] + dp[i][j-1] 注意初始化： 当obstacleGrid[i][j]&#x3D;&#x3D;1时dp[i][j] &#x3D; 0； 第一行和第一列，obstacleGrid[0][j]&#x3D;&#x3D;1和obstacleGrid[i][0]&#x3D;&#x3D;1之前初始化为1。1234567891011121314151617181920212223242526272829int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt; &gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); if(m==0 || obstacleGrid[0][0]==1) return 0; vector&lt;vector&lt;int&gt; &gt; dp(m,vector&lt;int&gt;(n,0)); dp[0][0] = 1; for (int i = 1; i &lt; m; i++)&#123; if(obstacleGrid[i][0]==1) break; dp[i][0] = 1; &#125; for (int j = 1; j &lt; n;j++)&#123; if(obstacleGrid[0][j]==1) break; dp[0][j] = 1; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n;j++)&#123; if(obstacleGrid[i][j]==1) continue; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1];&#125; 一维dp。因为只会用到上一行j之后（含j）的数据，所以可以优化为只用一维dp。1234567891011121314151617181920212223242526272829int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt; &gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); if(m==0 || obstacleGrid[0][0]==1) return 0; vector&lt;int&gt; dp(n+1,0); dp[0] = 1; for (int i = 1; i &lt; n; i++)&#123; if(obstacleGrid[0][i]==1) break; dp[i] = 1; &#125; for (int i = 1; i &lt; m; i++) &#123; if(dp[0]==1 &amp;&amp; obstacleGrid[i][0]==0) dp[0] = 1; else dp[0] = 0; for (int j = 1; j &lt; n; j++) &#123; if(obstacleGrid[i][j]==1) dp[j] = 0; else dp[j] = dp[j] + dp[j - 1]; &#125; &#125; return dp[n-1];&#125; 7月7日 112. 路径总和（简单）给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum &#x3D; 22， 12345678 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 题解： dfs（递归）。 12345678910bool hasPathSum(TreeNode* root, int sum) &#123; if(root==nullptr) return false; if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)&#123; return root-&gt;val==sum; &#125; int curVal = root-&gt;val; return hasPathSum(root-&gt;left,sum-curVal) || hasPathSum(root-&gt;right,sum-curVal);&#125; 时间复杂度：O(n)空间复杂度：O(h)。h为树的高度，最坏情况下h &#x3D; n。 bfs。队列实现。时空复杂度都是O(n) 1（代码略） 7月8日 程序员面试金典 面试题 16.11. 跳水板（简单）你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。返回的长度需要从小到大排列。 示例： 12345输入：shorter = 1longer = 2k = 3输出： &#123;3,4,5,6&#125; 题解：shorter的使用次数分别为0-k。注意返回需要从小到大。 123456789101112vector&lt;int&gt; divingBoard(int shorter, int longer, int k) &#123; if(k==0) return &#123;&#125;; if (shorter == longer) &#123; return &#123;shorter * k&#125;; &#125; vector&lt;int&gt; res; for(int i=0;i&lt;=k;i++)&#123; res.push_back(shorter*(k-i)+longer*i); &#125; return res;&#125; 时间复杂度：O(k)空间复杂度：O(k) 7月9日 程序员面试金典 面试题 17.13. 恢复空格（中等）哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子”I reset the computer. It still didn’t boot!”已经变成了”iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。 注意：本题相对原题稍作改动，只需返回未识别的字符数 示例： 12345输入：dictionary = [&quot;looked&quot;,&quot;just&quot;,&quot;like&quot;,&quot;her&quot;,&quot;brother&quot;]sentence = &quot;jesslookedjustliketimherbrother&quot;输出： 7解释： 断句后为&quot;jess looked just like tim her brother&quot;，共7个未识别字符。 题解：dp。dp[i] 表示第 i 个之前字母（含i）之前未识别的最少字符数。 当s[i-d:d)与字典中某一字符串匹配时： dp[i] &#x3D; min(dp[i - d],dp[i])。需要枚举每一个字典中的字符串。 当与所有不重合时： dp[i] &#x3D; dp[i -1] + 1， 把 s[i-1] 当作一个未识别字符。12345678910111213int respace(vector&lt;string&gt;&amp; dictionary, string sentence) &#123; vector&lt;int&gt; dp(sentence.size() + 1,sentence.size()); dp[0] = 0; for (int i = 1; i &lt;= sentence.size(); i++) &#123; for (string dict : dictionary) &#123; int d = dict.size(); if (i &gt;= d &amp;&amp; sentence.substr(i - d, d) == dict) dp[i] = min(dp[i - d], dp[i]); else dp[i] = min(dp[i - 1] + 1,dp[i]); &#125; &#125; return dp[sentence.size()];&#125; 时间复杂度：O(n*k)。n 为字符串 s 的长度，k为字典的长度。空间复杂度：O(n) 7月10日 309. 最佳买卖股票时机含冷冻期（中等）给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例: 123输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 题解：dp。dp[i] 表示第 i 天结束之后的累计最大收益。一共有三个状态：A观望，B持股，C冷却 12345状态转移图：A-(观望)-&gt;A, A-(买入｜-price)-&gt;B, B-(观望)-&gt;B, B-(卖出|+price)-&gt;C, C-(冷却)-&gt;A 持有：用dp[i][0]表示 冷却：用dp[i][1]表示 观望：用dp[i][2]表示 根据状态转移图可以写出dp[i][j]的状态转移方程： dp[i][0] &#x3D; max(dp[i - 1][2] - prices[i], dp[i - 1][0]); dp[i][1] &#x3D; dp[i - 1][0] + prices[i]; dp[i][2] &#x3D; max(dp[i - 1][1], dp[i - 1][2]);123456789101112int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; vector&lt;vector&lt;int&gt; &gt; dp(prices.size(), vector&lt;int&gt;(3)); dp[0][0] = -prices[0]; for (int i = 1; i &lt; prices.size();i++)&#123; dp[i][0] = max(dp[i - 1][2] - prices[i], dp[i - 1][0]); dp[i][1] = dp[i - 1][0] + prices[i]; dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]); &#125; return max(dp[prices.size() - 1][1], dp[prices.size() - 1][2]);&#125; 时间复杂度：O(n)空间复杂度：O(n) 7月11日 315. 计算右侧小于当前元素的个数（困难）给定一个整数数组 nums，按要求返回一个新数组 *counts。数组 *counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。 示例: 1234567输入: [5,2,6,1]输出: [2,1,1,0] 解释:5 的右侧有 2 个更小的元素 (2 和 1).2 的右侧仅有 1 个更小的元素 (1).6 的右侧有 1 个更小的元素 (1).1 的右侧有 0 个更小的元素. 题解： 暴力。O(n^2)123456789101112vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res(nums.size()); for(int i = 0;i&lt;nums.size();i++)&#123; int greater = 0; for(int j=i+1;j&lt;nums.size();j++)&#123; if(nums[j]&lt;nums[i]) greater++; &#125; res[i] = greater; &#125; return res;&#125; 从后往前，维护一个升序数组。插入的序号就是比它小数字的个数。1234567891011121314151617181920212223242526272829303132333435363738int insertNums(vector&lt;int&gt; &amp;sorted, int num)&#123; if(sorted.size()==1)&#123; if(num&gt;sorted[0])&#123; sorted.push_back(num); return 1; &#125; else&#123; sorted.insert(sorted.begin(),num); return 0; &#125; &#125; int l = 0, r = sorted.size()-1; int mid = (l + r) / 2; while (l &lt;= r) &#123; if(sorted[mid]&lt;num) l = mid + 1; else r = mid - 1; mid = (l+r)/2; &#125; sorted.insert(sorted.begin()+l, num); return l;&#125;vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return &#123;&#125;; vector&lt;int&gt; sorted; vector&lt;int&gt; res(nums.size()); sorted.push_back(nums[nums.size()-1]); for(int i=nums.size()-2;i&gt;=0;i--)&#123; int idx = insertNums(sorted, nums[i]); res[i] = idx; &#125; return res;&#125; 时间复杂度：O(nlogn)。每次插入二分查找需要O(logn)的复杂度。空间复杂度：O(n) 真题给定两个长度为n，值不重复的数列 A &amp; B ，将 A 这个数列进行入栈出栈操作，请问能否得到 B。 示例1： 12345输入：A = [0,1,2,3,4]B = [2,1,0,4,3]输出： Y 示例2: 12345输入：A = [0]B = [1]输出： N 题解： 1234567891011121314151617181920212223242526272829303132bool canGetB(vector&lt;int&gt; A, vector&lt;int&gt; B)&#123; stack&lt;int&gt; st; int idxA = 0, idxB = 0; for (; idxB &lt; B.size(); idxB++) &#123; if(idxA&lt;A.size() &amp;&amp; !st.empty() &amp;&amp; st.top()==B[idxB])&#123; st.pop(); continue; &#125; while (idxA&lt;A.size() &amp;&amp; A[idxA]!=B[idxB]) &#123; st.push(A[idxA]); idxA++; &#125; if(idxA&lt;A.size())&#123; idxA++; &#125; else break; &#125; while(!st.empty() &amp;&amp; idxB&lt;B.size())&#123; if(B[idxB]==st.top())&#123; idxB++; st.pop(); &#125;else&#123; break; &#125; &#125; if(idxA &lt; A.size() || idxB &lt; B.size()) return false; return true;&#125; 时间复杂度：O(n)空间复杂度：O(n) 7月12日 174. 地下城游戏（困难）一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。 骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。 有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。 为了尽快到达公主，骑士决定每次只向右或向下移动一步。 编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。 例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。 123-2(K) -3 3-5 -10 110 30 -5(P) 说明: 骑士的健康点数没有上限。 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。 题解：反向dp。因为正向dp需要维护两个重要变量：当 前HP 和 最大伤害。没办法做到无后效性。dp[i][j] 表示从坐标 (i,j) 到终点所需的最小初始值。 1234567891011121314int calculateMinimumHP(vector&lt;vector&lt;int&gt; &gt;&amp; dungeon) &#123; if(dungeon.empty()) return 0; int M = dungeon.size(), N = dungeon[0].size(); vector&lt;vector&lt;int&gt; &gt; dp(M+1, vector&lt;int&gt;(N+1, INT_MAX)); dp[M][N - 1] = dp[M - 1][N] = 1; for (int i = M - 1; i &gt;= 0;i--)&#123; for (int j = N - 1; j &gt;= 0;j--)&#123; int minn = min(dp[i + 1][j], dp[i][j + 1]); dp[i][j] = max(minn - dungeon[i][j], 1); &#125; &#125; return dp[0][0];&#125; 时间复杂度：O(MN)空间复杂度：O(MN) 7月13日 350. 两个数组的交集 II（简单）给定两个数组，编写一个函数来计算它们的交集。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2] 示例 2: 12输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9] 题解： 双指针。但是需要先排序。 1234567891011121314151617181920vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; sort(nums1.begin(),nums1.end()); sort(nums2.begin(),nums2.end()); vector&lt;int&gt; res; int idx1=0,idx2=0; while(idx1&lt;nums1.size() &amp;&amp; idx2&lt;nums2.size())&#123; if(nums1[idx1]==nums2[idx2])&#123; res.push_back(nums1[idx1]); idx1++; idx2++; &#125;else&#123; if(nums1[idx1]&lt;nums2[idx2]) idx1++; else idx2++; &#125; &#125; return res;&#125; 时间复杂度：O(mlogmnlogn)。 排序需要 O(nlognmlogm)。空间复杂度：O(min{m,n})。 哈希表。遍历其中一个数组，存入哈希表。 12345678910111213141516171819vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; if(nums2.size()&lt;nums1.size()) return intersect(nums2, nums1); unordered_map&lt;int,int&gt; numMap; for (int n : nums1) numMap[n]++; vector&lt;int&gt; res; for (int n : nums2) &#123; if(numMap.count(n))&#123; res.push_back(n); numMap[n]--; if(numMap[n]==0) numMap.erase(n); &#125; &#125; return res;&#125; 时间复杂度：O(m+n)。空间复杂度：O(min{m,n})。 7月14日 120. 三角形最小路径和（中等）给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。 例如，给定三角形： 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。 说明：如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 题解： 普通dp。12345678910111213141516int minimumTotal(vector&lt;vector&lt;int&gt; &gt;&amp; triangle) &#123; if(triangle.empty()) return 0; int n = triangle.size(); vector&lt;vector&lt;int&gt; &gt; dp(n,vector&lt;int&gt;(n)); dp[0][0] = triangle[0][0]; for (int i = 1; i &lt; n; i++) &#123; dp[i][0] = dp[i - 1][0] + triangle[i][0]; for (int j = 1; j &lt; i;j++)&#123; dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j]; &#125; dp[i][i] = dp[i - 1][i - 1] + triangle[i][i]; &#125; return *min_element(dp[n - 1].begin(), dp[n - 1].end());&#125; 时间复杂度：O(n^2)。空间复杂度：O(n^2)。 7月15日 96. 不同的二叉搜索树（中等）给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 1234567891011输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 题解： dp。设需要求 n 个节点。以一个节点为根节点，左子树的数量加右子树的数量就是以这个节点为根节点的数量。遍历不同的根节点（0~n）累加。123456789101112int numTrees(int n) &#123; vector&lt;int&gt; dp(n + 1, 0); dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; dp[i] += dp[j - 1] * dp[i - j]; &#125; &#125; return dp[n];&#125; 数学。数学上被称为卡塔兰数。1234567nt numTrees(int n) &#123; long long C = 1; for (int i = 0; i &lt; n; ++i) &#123; C = C * 2 * (2 * i + 1) / (i + 2); &#125; return (int)C;&#125; 7月16日 785. 判断二分图（中等）给定一个无向图graph，当这个图为二分图时返回true。 如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。 graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。 示例 1: 123456789输入: [[1,3], [0,2], [1,3], [0,2]]输出: true解释: 无向图如下:0----1| || |3----2我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。 示例 2: 123456789输入: [[1,2,3], [0,2], [0,1,3], [0,2]]输出: false解释: 无向图如下:0----1| \\ || \\ |3----2我们不能将节点分割成两个独立的子集。 题解：bfs或者dfs，把经过的点分别标上交替的记号。 1（代码待补全） 7月17日 35. 搜索插入位置（简单）给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 12输入: [1,3,5,6], 5输出: 2 示例 2: 12输入: [1,3,5,6], 2输出: 1 示例 3: 12输入: [1,3,5,6], 7输出: 4 示例 4: 12输入: [1,3,5,6], 0输出: 0 题解：二分查找。可以用O(n)的复杂度顺序遍历。但是一看到排好序，就想到了二分查找。 12345678910111213141516int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.empty()) return 0; int L=0,R=nums.size()-1; int mid; while(L&lt;=R)&#123; mid = (L+R)/2; if(nums[mid]&gt;target) R = mid - 1; else if(nums[mid]&lt;target) L = mid + 1; else return mid; &#125; return L;&#125; 时间复杂度：O(logn)。空间复杂度：O(1)。 7月18日 97. 交错字符串（困难）给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。 示例 1: 12输入: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;输出: true 示例 2: 12输入: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;输出: false 题解： 双指针递归。（超时）99 &#x2F; 101 个通过测试用例1234567891011121314151617181920212223bool isInterleaveCore(string s1,string s2,string s3,int idx1,int idx2,int idx3)&#123; if(idx1==s1.size()) return s2.substr(idx2,s2.size()-idx2+1)==s3.substr(idx3,s3.size()-idx3+1); if(idx2==s2.size()) return s1.substr(idx1,s1.size()-idx1+1)==s3.substr(idx3,s3.size()-idx3+1); if(s1[idx1]==s3[idx3])&#123; if(s2[idx2]==s3[idx3]) return isInterleaveCore(s1,s2,s3,idx1+1,idx2,idx3+1) || isInterleaveCore(s1,s2,s3,idx1,idx2+1,idx3+1); else return isInterleaveCore(s1,s2,s3,idx1+1,idx2,idx3+1); &#125;else&#123; if(s2[idx2]==s3[idx3]) return isInterleaveCore(s1,s2,s3,idx1,idx2+1,idx3+1); else return false; &#125;&#125;bool isInterleave(string s1, string s2, string s3) &#123; if(s3.size() != s1.size()+s2.size()) return false; return isInterleaveCore(s1,s2,s3,0,0,0);&#125; 二维dp。dp[i][j] 表示字符串 s3[0:i+j] 能否由 s1[0:i] 和 s2[0:j] 组成。1234567891011121314151617181920212223242526bool isInterleave(string s1, string s2, string s3) &#123; if(s3.size() != s1.size()+s2.size()) return false; vector&lt;vector&lt;bool&gt; &gt; dp(s1.size()+1,vector&lt;bool&gt;(s2.size()+1,false)); dp[0][0] = true; for(int i=1;i&lt;=s1.size();i++)&#123; if(s1[i-1]==s3[i-1]) dp[i][0] = true; else break; &#125; for(int i=1;i&lt;=s2.size();i++)&#123; if(s2[i-1]==s3[i-1]) dp[0][i] = true; else break; &#125; for(int i=1;i&lt;=s1.size();i++)&#123; for(int j=1;j&lt;=s2.size();j++)&#123; dp[i][j] = (s1[i-1]==s3[i+j-1] &amp;&amp; dp[i-1][j]) || (s2[j-1]==s3[i+j-1] &amp;&amp; dp[i][j-1]); &#125; &#125; return dp[s1.size()][s2.size()];&#125; 时间复杂度：O(mn)。m 为s1的长度，n 为s2的长度。空间复杂度：O(mn)。 ref. leetcode题解 一维dp。因为dp在计算时只用到了上一行，所以可以优化为只用一维数组。1代码略 7月19日 312. 戳气球（困难）有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。如果你戳破气球 i ，就可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。 求所能获得硬币的最大数量。 说明: 你可以假设 nums[-1] &#x3D; nums[n] &#x3D; 1，但注意它们不是真实存在的所以并不能被戳破。 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 示例: 1234输入: [3,1,5,8]输出: 167 解释: nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 题解：dp。dp[i][j]表示(i:j)开区间内所能得到的最大值。外层循环要倒序，因为子问题dp[k][j]要在父问题dp[i][j]（i&lt;&#x3D;k&lt;&#x3D;j）之前。 12345678910111213141516int maxCoins(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;vector&lt;int&gt; &gt; dp(n + 2, vector&lt;int&gt;(n + 2, 0)); nums.insert(nums.begin(), 1); nums.push_back(1); for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i + 2; j &lt;= n + 1; j++) &#123; for (int k = i + 1; k &lt; j; k++) &#123; dp[i][j] = max( dp[i][j], (dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])); &#125; &#125; &#125; return dp[0][n + 1];&#125; 时间复杂度：O(n^3)。空间复杂度：O(n^2)。 7月20日 167. 两数之和 II - 输入有序数组（简单）给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 123输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 题解： 哈希表。哈希表保存每个元素，再遍历一次即可。 123456789101112vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; unordered_map&lt;int, int&gt; numMap; for (int i = 0; i &lt; numbers.size();i++) numMap[numbers[i]] = i; for (int i = 0; i &lt; numbers.size();i++)&#123; auto it = numMap.find(target - numbers[i]); if (it != numMap.end()) return &#123;i + 1, it-&gt;second+1&#125;; &#125; return &#123;&#125;;&#125; 时间复杂度：O(n)。空间复杂度：O(n)。 二分查找。时间复杂度：O(nlogn)。空间复杂度：O(1)。 1代码略 双指针。初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。 1234567891011121314vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int L = 0, R = numbers.size() - 1; while (L &lt; R) &#123; int sum = numbers[L] + numbers[R]; if (sum == target) &#123; return &#123;L + 1, R + 1&#125;; &#125; else if (sum &lt; target) &#123; ++L; &#125; else &#123; --R; &#125; &#125; return &#123;-1, -1&#125;;&#125; 时间复杂度：O(n)。空间复杂度：O(1)。 7月21日 95. 不同的二叉搜索树 II（中等）给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。 示例： 1234567891011121314151617输入：3输出：[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释：以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 提示：0 &lt;&#x3D; n &lt;&#x3D; 8 题解：递归。 12345678910111213141516171819202122232425vector&lt;TreeNode*&gt; generateSubTree(int L, int R)&#123; if(L&gt;R) return &#123;nullptr&#125;; vector&lt;TreeNode*&gt; Trees; for(int i=L;i&lt;=R;i++)&#123; vector&lt;TreeNode*&gt; leftTree = generateSubTree(L,i-1); vector&lt;TreeNode*&gt; rightTree = generateSubTree(i+1,R); for(auto lTree:leftTree)&#123; for(auto rTree:rightTree)&#123; TreeNode* root = new TreeNode(i); root-&gt;left = lTree; root-&gt;right = rTree; Trees.push_back(root); &#125; &#125; &#125; return Trees;&#125;vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if(n==0) return &#123;&#125;; return generateSubTree(1,n);&#125; 7月22日 剑指 Offer 11. 旋转数组的最小数字（简单）把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1： 12输入：[3,4,5,1,2]输出：1 示例 2： 12输入：[2,2,2,0,1]输出：0 题解： 暴力。 123456789int minArray(vector&lt;int&gt;&amp; numbers) &#123; if(numbers.empty()) return 0; for(int i=1;i&lt;numbers.size();i++)&#123; if(numbers[i]&lt;numbers[i-1]) return numbers[i]; &#125; return numbers[0];&#125; 时间复杂度：O(n)空间复杂度：O(1) 二分。注意：当numbers[mid]==numbers[R]时，由于重复元素的存在，我们并不能确定numbers[mid]究竟在最小值的左侧还是右侧，因此我们不能忽略某一部分的元素。但是由于它们的值相同，所以可以忽略二分查找区间的右端点numbers[R]。 12345678910111213141516int minArray(vector&lt;int&gt;&amp; numbers) &#123; if(numbers.empty()) return 0; int L=0,R=numbers.size()-1; while(L&lt;R)&#123; int mid = (L+R)/2; if(numbers[mid]&lt;numbers[R]) R=mid; else if(numbers[mid]&gt;numbers[R]) L=mid+1; else&#123; R--; &#125; &#125; return numbers[R];&#125; 时间复杂度：O(logn)空间复杂度：O(1) 7月23日 64. 最小路径和（中等）给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 题解： 二维dp。dp[i][j]表示走到第i行第j列格子时的最小值。 123456789101112131415int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; if(grid.empty()) return 0; int m = grid.size(),n=grid[0].size(); vector&lt;vector&lt;int&gt; &gt; dp(m+1,vector&lt;int&gt;(n+1,INT_MAX)); dp[1][1] = grid[0][0]; for(int i = 1;i&lt;=m;i++)&#123; for(int j = 1;j&lt;=n;j++)&#123; if(i==1&amp;&amp;j==1) continue; dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1]; &#125; &#125; return dp[m][n];&#125; 时间复杂度：O(mn)空间复杂度：O(mn) 一维dp。因为只用到了上一行的dp，所以二维dp可以优化为一维。 1234567891011121314151617181920int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; if(grid.empty()) return 0; int m = grid.size(),n=grid[0].size(); vector&lt;int&gt; dp(n,0); dp[0] = grid[0][0]; for(int i = 1;i&lt;n;i++) dp[i] = grid[0][i]+dp[i-1]; for(int i = 1;i&lt;m;i++)&#123; for(int j = 0;j&lt;n;j++)&#123; if(j==0) dp[j] = dp[j]+grid[i][0]; else dp[j] = min(dp[j-1],dp[j])+grid[i][j]; &#125; &#125; return dp[n-1];&#125; 时间复杂度：O(mn)空间复杂度：O(n) 7月24日 1025. 除数博弈（简单）爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 &lt; x &lt; N 且 N % x &#x3D;&#x3D; 0 。用 N - x 替换黑板上的数字 N 。如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 示例 1： 123输入：2输出：true解释：爱丽丝选择 1，鲍勃无法进行操作。 示例 2： 123输入：3输出：false解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。 题解： dp。 123456789101112131415bool divisorGame(int N) &#123; vector&lt;bool&gt; dp(N+1,false); dp[1] = false; dp[2]= true; int n=N; for(int i=3;i&lt;=N;i++)&#123; for(int j=1;j&lt;i;j++)&#123; if(i % j == 0 &amp;&amp; !dp[i - j])&#123; dp[i] = true; break; &#125; &#125; &#125; return dp[N];&#125; 时间复杂度：O(N^2)空间复杂度：O(N) 归纳法。N 为奇数的时候 Alice（先手）必败，N 为偶数的时候 Alice 必胜。 123bool divisorGame(int N) &#123; return N % 2 == 0;&#125; 时间复杂度：O(1)空间复杂度：O(1) 7月25日 410. 分割数组的最大值（困难）给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。 注意:数组长度 n 满足以下条件: 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n) 示例: 1234567891011输入:nums = [7,2,5,10,8]m = 2输出:18解释:一共有四种方法将nums分割为2个子数组。其中最好的方式是将其分为[7,2,5] 和 [10,8]，因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。 题解： dp。dp[i][j]表示前i个数被分成j段的答案。dp[i][j]的状态转移方程为： dp[i][j] = min(max(dp[k][j-1],subSum(k+1,i))) 其中min里需要枚举k&#x3D;[0,i)，subSum(k+1,i)表示nums[k+1]到nums[i]的和。 12345678910111213141516171819int splitArray(vector&lt;int&gt;&amp; nums, int m) &#123; vector&lt;vector&lt;long long&gt; &gt; dp(nums.size() + 1, vector&lt;long long&gt;(m + 1, LLONG_MAX)); vector&lt;long long&gt; preSum(nums.size() + 1, 0); for (int i = 1; i &lt;= nums.size();i++) preSum[i] = preSum[i - 1] + nums[i-1]; dp[0][0] = 0; for (int i = 1; i &lt;= nums.size(); i++) &#123; for (int j = 1; j &lt;= min(m, i); j++) &#123; for (int k = 0; k &lt; i; k++) dp[i][j] = min(dp[i][j], max(dp[k][j - 1], preSum[i] - preSum[k])); &#125; &#125; return (int)dp[nums.size()][m];&#125; 时间复杂度：O(m * n^2)空间复杂度：O(mn) 7月26日 329. 矩阵中的最长递增路径（困难）给定一个整数矩阵，找出最长递增路径的长度。 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。 示例 1: 12345678输入: nums = [ [9,9,4], [6,6,8], [2,1,1]] 输出: 4 解释: 最长递增路径为 [1, 2, 6, 9]。 示例 2: 12345678输入: nums = [ [3,4,5], [3,2,6], [2,2,1]] 输出: 4 解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。 题解：有记忆的dfs。普通dfs会超时，所以加了二位矩阵来记录已经得到的最长序列。 12345678910111213141516171819202122232425262728vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;int dfs(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int i, int j, vector&lt;vector&lt;int&gt; &gt; &amp;memo)&#123; if(memo[i][j]!=0) return memo[i][j]; memo[i][j] = 1; for(auto d:dirs)&#123; if (i + d[0] &gt;= 0 &amp;&amp; i + d[0] &lt; matrix.size() &amp;&amp; j + d[1] &gt;= 0 &amp;&amp; j + d[1] &lt; matrix[0].size() &amp;&amp; matrix[i + d[0]][j + d[1]] &gt; matrix[i][j]) memo[i][j] = max(memo[i][j], dfs(matrix, i + d[0], j + d[1], memo) + 1); &#125; return memo[i][j];&#125;int longestIncreasingPath(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123; if(matrix.empty()) return 0; int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt; &gt; memo(m, vector&lt;int&gt;(n, 0)); int res = 0; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; res = max(res, dfs(matrix, i, j, memo)); &#125; &#125; return res;&#125; 时间复杂度：O(mn)空间复杂度：O(mn) 7月27日 392. 判断子序列（简单）给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~&#x3D; 500,000），而 s 是个短字符串（长度 &lt;&#x3D;100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例 1: 12s = &quot;abc&quot;, t = &quot;ahbgdc&quot;返回 true. 示例 2: 12s = &quot;axc&quot;, t = &quot;ahbgdc&quot;返回 false. 后续挑战：如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 题解：双指针。 12345678910111213141516bool isSubsequence(string s, string t) &#123; if(t.empty())&#123; if(s.empty()) return true; else return false; &#125; int idxS=0,idxT=0; while(idxS&lt;s.size() &amp;&amp; idxT&lt;t.size())&#123; if(s[idxS]==t[idxT]) idxS++; idxT++; &#125; return idxS==s.size();&#125; 时间复杂度：O(m+n)空间复杂度：O(1) 7月28日 104. 二叉树的最大深度（简单）给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。 题解： 层序遍历（BFS）。 123456789101112131415161718192021int maxDepth(TreeNode* root)&#123; if(root==nullptr) return 0; queue&lt;TreeNode*&gt; que; que.push(root); int hight = 0; while(!que.empty())&#123; hight++; int n = que.size(); for (int i = 0; i &lt; n; i++) &#123; TreeNode *curNode = que.front(); que.pop(); if(curNode-&gt;left!=nullptr) que.push(curNode-&gt;left); if(curNode-&gt;right!=nullptr) que.push(curNode-&gt;right); &#125; &#125; return hight;&#125; 时间复杂度：O(n)空间复杂度：O(n) 递归。 12345int maxDepth(TreeNode* root)&#123; if(root==nullptr) return 0; return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;&#125; 时间复杂度：O(n)空间复杂度：O(hight) 7月29日 LCP 13. 寻宝（困难）我们得到了一副藏宝图，藏宝图显示，在一个迷宫中存在着未被世人发现的宝藏。 迷宫是一个二维矩阵，用一个字符串数组表示。它标识了唯一的入口（用 ‘S’ 表示），和唯一的宝藏地点（用 ‘T’ 表示）。但是，宝藏被一些隐蔽的机关保护了起来。在地图上有若干个机关点（用 ‘M’ 表示），只有所有机关均被触发，才可以拿到宝藏。 要保持机关的触发，需要把一个重石放在上面。迷宫中有若干个石堆（用 ‘O’ 表示），每个石堆都有无限个足够触发机关的重石。但是由于石头太重，我们一次只能搬一个石头到指定地点。 迷宫中同样有一些墙壁（用 ‘#’ 表示），我们不能走入墙壁。剩余的都是可随意通行的点（用 ‘.’ 表示）。石堆、机关、起点和终点（无论是否能拿到宝藏）也是可以通行的。 我们每步可以选择向上&#x2F;向下&#x2F;向左&#x2F;向右移动一格，并且不能移出迷宫。搬起石头和放下石头不算步数。那么，从起点开始，我们最少需要多少步才能最后拿到宝藏呢？如果无法拿到宝藏，返回 -1 。 示例 1： 12345输入： [&quot;S#O&quot;, &quot;M..&quot;, &quot;M.T&quot;]输出：16解释：最优路线为： S-&gt;O, cost = 4, 去搬石头 O-&gt;第二行的M, cost = 3, M机关触发 第二行的M-&gt;O, cost = 3, 我们需要继续回去 O 搬石头。 O-&gt;第三行的M, cost = 4, 此时所有机关均触发 第三行的M-&gt;T, cost = 2，去T点拿宝藏。 总步数为16。 示例 2： 12345输入： [&quot;S#O&quot;, &quot;M.#&quot;, &quot;M.T&quot;]输出：-1解释：我们无法搬到石头触发机关 示例 3： 12345输入： [&quot;S#O&quot;, &quot;M.T&quot;, &quot;M..&quot;]输出：17解释：注意终点也是可以通行的。 限制： 1234561 &lt;= maze.length &lt;= 1001 &lt;= maze[i].length &lt;= 100maze[i].length == maze[j].lengthS 和 T 有且只有一个0 &lt;= M的数量 &lt;= 160 &lt;= O的数量 &lt;= 40，题目保证当迷宫中存在 M 时，一定存在至少一个 O 。 题解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134int dx[4] = &#123;1, -1, 0, 0&#125;;int dy[4] = &#123;0, 0, 1, -1&#125;;int n, m;bool inBound(int x, int y) &#123; return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;&#125;vector&lt;vector&lt;int&gt;&gt; bfs(int x, int y, vector&lt;string&gt;&amp; maze) &#123; vector&lt;vector&lt;int&gt;&gt; ret(n, vector&lt;int&gt;(m, -1)); ret[x][y] = 0; queue&lt;pair&lt;int, int&gt;&gt; Q; Q.push(&#123;x, y&#125;); while (!Q.empty()) &#123; auto p = Q.front(); Q.pop(); int x = p.first, y = p.second; for (int k = 0; k &lt; 4; k++) &#123; int nx = x + dx[k], ny = y + dy[k]; if (inBound(nx, ny) &amp;&amp; maze[nx][ny] != &#x27;#&#x27; &amp;&amp; ret[nx][ny] == -1) &#123; ret[nx][ny] = ret[x][y] + 1; Q.push(&#123;nx, ny&#125;); &#125; &#125; &#125; return ret;&#125;int minimalSteps(vector&lt;string&gt;&amp; maze) &#123; n = maze.size(), m = maze[0].size(); // 机关 &amp; 石头 vector&lt;pair&lt;int, int&gt;&gt; buttons, stones; // 起点 &amp; 终点 int sx, sy, tx, ty; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (maze[i][j] == &#x27;M&#x27;) &#123; buttons.push_back(&#123;i, j&#125;); &#125; if (maze[i][j] == &#x27;O&#x27;) &#123; stones.push_back(&#123;i, j&#125;); &#125; if (maze[i][j] == &#x27;S&#x27;) &#123; sx = i, sy = j; &#125; if (maze[i][j] == &#x27;T&#x27;) &#123; tx = i, ty = j; &#125; &#125; &#125; int nb = buttons.size(); int ns = stones.size(); vector&lt;vector&lt;int&gt;&gt; start_dist = bfs(sx, sy, maze); // 边界情况：没有机关 if (nb == 0) &#123; return start_dist[tx][ty]; &#125; // 从某个机关到其他机关 / 起点与终点的最短距离。 vector&lt;vector&lt;int&gt;&gt; dist(nb, vector&lt;int&gt;(nb + 2, -1)); // 中间结果 vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dd(nb); for (int i = 0; i &lt; nb; i++) &#123; vector&lt;vector&lt;int&gt;&gt; d = bfs(buttons[i].first, buttons[i].second, maze); dd[i] = d; // 从某个点到终点不需要拿石头 dist[i][nb + 1] = d[tx][ty]; &#125; for (int i = 0; i &lt; nb; i++) &#123; int tmp = -1; for (int k = 0; k &lt; ns; k++) &#123; int mid_x = stones[k].first, mid_y = stones[k].second; if (dd[i][mid_x][mid_y] != -1 &amp;&amp; start_dist[mid_x][mid_y] != -1) &#123; if (tmp == -1 || tmp &gt; dd[i][mid_x][mid_y] + start_dist[mid_x][mid_y]) &#123; tmp = dd[i][mid_x][mid_y] + start_dist[mid_x][mid_y]; &#125; &#125; &#125; dist[i][nb] = tmp; for (int j = i + 1; j &lt; nb; j++) &#123; int mn = -1; for (int k = 0; k &lt; ns; k++) &#123; int mid_x = stones[k].first, mid_y = stones[k].second; if (dd[i][mid_x][mid_y] != -1 &amp;&amp; dd[j][mid_x][mid_y] != -1) &#123; if (mn == -1 || mn &gt; dd[i][mid_x][mid_y] + dd[j][mid_x][mid_y]) &#123; mn = dd[i][mid_x][mid_y] + dd[j][mid_x][mid_y]; &#125; &#125; &#125; dist[i][j] = mn; dist[j][i] = mn; &#125; &#125; // 无法达成的情形 for (int i = 0; i &lt; nb; i++) &#123; if (dist[i][nb] == -1 || dist[i][nb + 1] == -1) return -1; &#125; // dp 数组， -1 代表没有遍历到 vector&lt;vector&lt;int&gt;&gt; dp(1 &lt;&lt; nb, vector&lt;int&gt;(nb, -1)); for (int i = 0; i &lt; nb; i++) &#123; dp[1 &lt;&lt; i][i] = dist[i][nb]; &#125; // 由于更新的状态都比未更新的大，所以直接从小到大遍历即可 for (int mask = 1; mask &lt; (1 &lt;&lt; nb); mask++) &#123; for (int i = 0; i &lt; nb; i++) &#123; // 当前 dp 是合法的 if (mask &amp; (1 &lt;&lt; i)) &#123; for (int j = 0; j &lt; nb; j++) &#123; // j 不在 mask 里 if (!(mask &amp; (1 &lt;&lt; j))) &#123; int next = mask | (1 &lt;&lt; j); if (dp[next][j] == -1 || dp[next][j] &gt; dp[mask][i] + dist[i][j]) &#123; dp[next][j] = dp[mask][i] + dist[i][j]; &#125; &#125; &#125; &#125; &#125; &#125; int ret = -1; int final_mask = (1 &lt;&lt; nb) - 1; for (int i = 0; i &lt; nb; i++) &#123; if (ret == -1 || ret &gt; dp[final_mask][i] + dist[i][nb + 1]) &#123; ret = dp[final_mask][i] + dist[i][nb + 1]; &#125; &#125; return ret;&#125; 7月30日 343. 整数拆分（中等）给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1: 123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2: 123输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 题解： dp。dp[i]表示数字i分解后能达到的最大积。可以分为两种情况： 1）i分解为j和i-j两个数； 2）i分解为j和i-j后，i-j还可以再分解，其最大积为dp[i-j]。 枚举1~i-1每一个点，看哪个点分解后的积最大1234567891011int integerBreak(int n) &#123; vector&lt;int&gt; dp(n+1,0); for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j])); &#125; &#125; return dp[n];&#125; 时间复杂度：O(n^2)空间复杂度：O(n) 7月31日 程序员面试金典 面试题 08.03. 魔术索引（简单）魔术索引。 在数组A[0…n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。 示例1: 123输入：nums = [0, 2, 3, 4, 5]输出：0说明: 0下标的元素为0 示例2: 12输入：nums = [1, 1, 1]输出：1 提示: nums长度在[1, 1000000]之间 题解： 1234567int findMagicIndex(vector&lt;int&gt;&amp; nums) &#123; for(int i=0;i&lt;nums.size();i++)&#123; if(nums[i]==i) return i; &#125; return -1;&#125; 时间复杂度：O(n)空间复杂度：O(1)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/Algorithm/"}],"tags":[{"name":"Leetcode daily","slug":"Leetcode-daily","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Leetcode-daily/"}]},{"title":"数据结构","slug":"dataStructure","date":"2020-06-19T16:30:00.000Z","updated":"2020-08-19T14:41:24.378Z","comments":true,"path":"2020/06/20/dataStructure/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2020/06/20/dataStructure/","excerpt":"","text":"链表和数组的区别在哪里？链表和数组都可以叫线性表，数组又叫顺序表，主要区别在于： 存储形式：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间，长度可变，每个结点要保存相邻结点指针。 数据查找：数组的线性查找速度快，查找操作直接使用偏移地址。链表需要按顺序检索结点，效率低。 数据插入或删除：链表可以快速插入和删除结点，而数组则可能需要大量数据移动。 越界问题：链表不存在越界问题，数组有越界问题。 说明：在选择数组或链表数据结构时，一定要根据实际需要进行选择。数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。 hash冲突怎么办 开放地址法 线性探测 二次探测：左右左右… 伪随机数 再哈希法 链地址法 建立公共溢出区 HashMap扩容机制HashMap的容量是有限的。当经过多次元素插入的时候，使得HashMap达到一定的饱和度，Key映射位置的几率不断变大。这个时候（扩容因子&#x3D;0.75），HashMap就需要扩容了，也就是Resize。一般是增加1倍。 扩容因子：数组中元素的个数&#x2F;数组容量 B树和B+树B树B树是一颗多路平衡查找树。 每个节点最多有m-1个关键字（可以存有的键值对）。 根节点最少可以只有1个关键字。 非根节点至少有m&#x2F;2个关键字。 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。 每个节点都存有索引和数据，也就是对应的key和value。 所以，根节点的关键字数量范围：1 &lt;&#x3D; k &lt;&#x3D; m-1，非根节点的关键字数量范围：m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m-1。 另外，我们需要注意一个概念，描述一颗B树时需要指定它的阶数，阶数表示了一个节点最多有多少个孩子节点，一般用字母m表示阶数。 B+树B+树其实和B树是非常相似的。 相同点： 根节点至少一个元素 非根节点元素范围：m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m-1 不同点： B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。 父节点存有右孩子的第一个元素的索引。 B+树相对于B树的优势可以归结为下面几点： 单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。 所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。 所有的叶子节点形成了一个有序链表，更加便于查找。 叶子结点连起来还可以范围查询。 红黑树平衡二叉树就是为了解决二叉查找树退化成一颗链表而诞生。 虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 O(logn)，不过却不是最佳的，因为平衡树要求每个节点的左子树和右子树的高度差至多等于1，这个要求实在是太严了，导致每次进行插入&#x2F;删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。 显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了红黑树，红黑树具有如下特点： 具有二叉查找树的特点； 根节点是黑色的； 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据； 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的(但是黑色节点可以相连)； 每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。 红黑树和AVL树的区别：AVL 和 RBT 都是二叉查找树的优化。其性能要远远好于二叉查找树。他们之间都有自己的优势，其应用上也有不同。 结构对比：AVL的结构高度平衡，RBT的结构基本平衡。平衡度AVL &gt; RBT. 查找对比：AVL 查找时间复杂度最好，最坏情况都是O(logN)。RBT 查找时间复杂度最好为O(logN)，最坏情况下比AVL略差。 插入删除对比： AVL的插入和删除结点很容易造成树结构的不平衡，而RBT的平衡度要求较低。因此在大量数据插入的情况下，RBT需要通过旋转变色操作来重新达到平衡的频度要小于AVL。 如果需要平衡处理时，RBT比AVL多一种变色操作，而且变色的时间复杂度在O(logN)数量级上。但是由于操作简单，所以在实践中这种变色仍然是非常快速的。 当插入一个结点都引起了树的不平衡，AVL和RBT都最多需要2次旋转操作。但删除一个结点引起不平衡后，AVL最多需要logN 次旋转操作，而RBT最多只需要3次。因此两者插入一个结点的代价差不多，但删除一个结点的代价RBT要低一些。 AVL和RBT的插入删除代价主要还是消耗在查找待操作的结点上。因此时间复杂度基本上都是与O(logN) 成正比的。 3老鼠确定8瓶子原理 二分法：每次取一半混合给小鼠喝。但是瓶子太多就不好混合了。 二进制：每只老鼠代表一位，n只老鼠可以检测2^n个瓶子。","categories":[{"name":"CS","slug":"CS","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/CS/"}],"tags":[{"name":"data structure","slug":"data-structure","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/data-structure/"}]},{"title":"数据库","slug":"database","date":"2020-06-19T16:30:00.000Z","updated":"2020-08-18T09:27:15.629Z","comments":true,"path":"2020/06/20/database/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2020/06/20/database/","excerpt":"","text":"数据库范式 1NF(第一范式)属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。1NF是所有关系型数据库的最基本要求 ，也就是说关系型数据库中创建的表一定满足第一范式。 2NF(第二范式)2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。 3NF(第三范式)3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖 。符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系R(学号 ,姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合3NF的要求。 总结 1NF：属性不可再分。 2NF：1NF的基础之上，消除了非主属性对于码的部分函数依赖。 3NF：3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖 。 ref. 详解第一范式、第二范式、第三范式、BCNF范式 范式通俗理解：1NF、2NF、3NF和BNCF 关系型数据库和非关系型数据库关系型数据库关系型数据库，是指采用了关系模型来组织数据的数据库。 主要代表：SQL Server, Oracle, Mysql, PostgreSQL 关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。关系模型中常用的概念： 关系：可以理解为一张二维表，每个关系都具有一个关系名，就是通常说的表名 元组：可以理解为二维表中的一行，在数据库中经常被称为记录 属性：可以理解为二维表中的一列，在数据库中经常被称为字段 域：属性的取值范围，也就是数据库中某一列的取值限制 关键字：一组可以唯一标识元组的属性，数据库中常称为主键，由一个或多个列组成 关系模式：指对关系的描述。其格式为：关系名(属性1，属性2， … … ，属性N)，在数据库中成为表结构 码：码就是能唯一标识实体的属性，对应表中的列。 候选码： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。 主码：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。 外码：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。 主属性：候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）.显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。 非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。 关系型数据库的优点： 容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解 使用方便：通用的SQL语言使得操作关系型数据库非常方便 易于维护：数据库的ACID属性，大大减低了数据冗余和数据不一致的概率 关系型数据库的瓶颈： 海量数据的读写效率：对于网站的并发量高，往往达到每秒上万次的请求，对于传统关系型数据库来说，硬盘I&#x2F;o是一个很大的挑战。 高扩展性和可用性：在基于web的结构中，数据库是最难以横向拓展的，当一个应用系统的用户量和访问量与日俱增的时候，数据库没有办法像web Server那样简单的通过添加更多的硬件和服务节点来拓展性能和负载能力。 主键和外键有什么区别 主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。 外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。 非关系型数据库 NoSQL主要指那些非关系型的、分布式的，且一般不保证ACID的数据存储系统。依据结构化方法以及应用场合的不同，主要分为以下几类： 面向高性能并发读写的key-value数据库：key-value数据库的主要特点即使具有极高的并发读写性能，Redis,Tokyo Cabinet,Flare就是这类的代表 面向海量数据访问的面向文档数据库：这类数据库的特点是，可以在海量的数据中快速的查询数据，典型代表为MongoDB以及CouchDB 面向可扩展性的分布式数据库：这类数据库想解决的问题就是传统数据库存在可扩展性上的缺陷，这类数据库可以适应数据量的增加以及数据结构的变化 缺点：但是由于Nosql约束少，所以也不能够像sql那样提供where字段属性的查询。因此适合存储较为简单的数据。有一些不能够持久化数据，所以需要和关系型数据库结合。 ref 关系型数据库和非关系型数据库区别、oracle与mysql的区别 关系型数据库 VS 非关系型数据库 主键索引和唯一索引区别唯一索引的值可以为null吗主键索引的值可以为null吗一个表有几个主键一个表可以有多个唯一索引吗 sql语句数据库事务的4个特征（ACID特性） 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。 持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。 事务隔离级别隔离级别越高，性能越低 Serializable（串行化）：可避免脏读、不可重复读、虚读情况的发生； Reapeatable read（可重复读）：可避免脏读、不可重复读的情况的发生； Read Committed（读已提交）：可避免脏读的情况 Read uncommitted（读未提交）：最低级别，任何情况均无法保证； ref 面试题之数据库","categories":[{"name":"CS","slug":"CS","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/CS/"}],"tags":[{"name":"database","slug":"database","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/database/"}]},{"title":"计算机网络","slug":"network","date":"2020-06-10T09:00:00.000Z","updated":"2020-10-14T07:29:18.607Z","comments":true,"path":"2020/06/10/network/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2020/06/10/network/","excerpt":"计算机网络概念网络协议在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。 计算机网络体系结构计算机网络体系结构是指计算机网络层次结构模型，它是各层的协议以及层次之间的端口的集合。在计算机网络中实现通信必须依靠网络通信协议，目前广泛采用的是国际标准化组织（ISO）1997年提出的开放系统互联（Open System Interconnection，OSI）参考模型，习惯上称为ISO&#x2F;OSI参考模型。","text":"计算机网络概念网络协议在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。 计算机网络体系结构计算机网络体系结构是指计算机网络层次结构模型，它是各层的协议以及层次之间的端口的集合。在计算机网络中实现通信必须依靠网络通信协议，目前广泛采用的是国际标准化组织（ISO）1997年提出的开放系统互联（Open System Interconnection，OSI）参考模型，习惯上称为ISO&#x2F;OSI参考模型。 不同的网络体系结构OSI七层协议体系结构OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。 OSI七层协议模型主要包括是： 应用层（Application） 表示层（Presentation） 会话层（Session） 运输层（Transport） 网络层（Network） 数据链路层（Data Link） 物理层（Physical） TCP&#x2F;IP四层体系结构TCP&#x2F;IP 是一个四层体系结构，主要包括： 应用层 运输层 网际层（用网际层这个名字是强调这一层是为了解决不同网络的互连问题） 网络接口层 不过从实质上讲，TCP&#x2F;IP 只有最上面的三层，因为最下面的网络接口层并没有什么具体内容，因此在学习计算机网络的原理时往往采用折中的办法，即综合 OSI 和 TCP&#x2F;IP 的优点，采用一种只有五层协议的体系结构。 五层协议的体系结构五层协议的体系结构主要包括： 应用层 运输层 网络层 数据链路层 物理层 ps. 五层协议的体系结构只是为了介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构。 TCP&#x2F;IP 具有五层协议的体系结构应用层应用层（application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。 运输层运输层（transport layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。 运输层主要使用一下两种协议 TCP-传输控制协议：提供面向连接的，可靠的数据传输服务 UDP-用户数据协议：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性） 每一个应用层（TCP&#x2F;IP参考模型的最高层）协议一般都会使用到两个传输层协议之一ps. 以下协议是应用层协议： 运行在TCP协议上的协议： HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。端口号：80 HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。端口号：443 FTP（File Transfer Protocol，文件传输协议），用于文件传输。端口号：21 POP3（Post Office Protocol, version 3，邮局协议），收邮件用。 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。 TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。端口号：23 SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。 运行在UDP协议上的协议： BOOTP（Boot Protocol，启动协议），应用于无盘设备。 NTP（Network Time Protocol，网络时间协议），用于网络同步。 DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。 运行在TCP和UDP协议上： DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。 网络层（网际层）网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。 互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。 数据链路层数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 物理层在物理层上所传送的数据单位是比特。 数据传输过程 TCP的三次握手四次挥手三次握手 四次挥手 MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。 CLOSED：表示初始状态。 LISTEN：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。 SYN_SENT：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。 SYN_RCVD: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。 ESTABLISHED：表示连接已经建立。 FIN_WAIT_1: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。 FIN_WAIT_2：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。 TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。 CLOSING: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。 CLOSE_WAIT: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。 LAST_ACK: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。 半关闭状态 为什么TCP连接的时候是3次，不是2次因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。 如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。 为什么连接的时候是三次握手，关闭的时候却是四次握手？因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文（所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次）。 为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。 如果已经建立了连接，但是客户端突然出现故障了怎么办？TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 TCP和UDP对比 UPD TCP 是否连接 无连接 面向连接（3次握手） 是否可靠 尽最大努力交付，不保证可靠。不使用流量控制和拥塞控制 使用流量控制和拥塞控制。可靠服务：无差错、不丢失、不重复、按序到达 传输方式 面向报文 面向字节流 连接对象个数 一对一，多对多，多对一，一对多 一对一 首部开销 8字节 首部最小20字节，最大60字节 TCP怎么保证可靠 应用数据被分割成 TCP 认为最适合发送的数据块。 TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 TCP 的接收端会丢弃重复的数据。 流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 拥塞控制：当网络拥塞时，减少数据的发送。 ARQ协议：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 拥塞控制和流量控制都是保证TCP可靠的方法。 拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况 流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的 拥塞控制 慢开始：从小到大逐渐增大发送窗口，每个传输轮次后将 cwnd 大小加倍。 拥塞避免：用慢开始门限（ssthresh）的阈值来控制 cwnd 的增长 cwnd &lt; ssthresh , 使用慢开始算法 cwnd &#x3D; ssthresh , 使用慢开始算法或拥塞避免算法（线性增长，一般是加1）都可以 cwnd &gt; ssthresh , 使用拥塞避免算法。只要发现网络中出现拥塞就乘法减小ssthresh并从cwnd&#x3D;1开始重新执行慢开始算法。 快重传：允许发送方再连续收到 3 个重复的确认后就可以开始执行乘法减小过程而不必再等待所设置的重传计时器到时。 快恢复：是与快重传算法配合使用的一个算法。快恢复算法后与原来不同的一点是当发现网络出现拥塞并执行了乘法减小过程后，并不是设置cwnd&#x3D;1并重新开始执行慢开始算法，而是让 cwnd &#x3D;乘法减小后的ssthresh并开始执行拥塞避免算法。 ps. ssthresh的设置：TCP&#x2F;IP 中规定无论是在慢开始阶段还是在拥塞避免阶段，只要发现网络中出现拥塞（没有按时收到确认），就要把ssthresh设置为此时发送窗口的一半大小（不能小于2） TCP的拥塞控制（详解） 流量控制 RTT算法 滑动窗口 发送窗口 接受窗口 使UPD可靠的方法 超时重传（定时器） 有序接受 （添加包序号） 应答确认 （Seq&#x2F;Ack应答机制） 滑动窗口流量控制等机制 （滑动窗口协议） 已有协议： 可靠用户数据报协议（RUDP）：RUDP使用类似于TCP的重发机制和拥塞控制算法 实时协议（RTP）：有效负载识别，序列编号，时间戳和投递监听 基于UDP的数据传输协议（UDT）：序列号、滑动窗口 为什么会发生 TCP 粘包、拆包粘包问题是由TCP是“字节流”协议，没有消息边界所引起的。 应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。 应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。 进行 MSS （最大报文长度）大小的 TCP 分段，当 TCP报文长度 - TCP头部长度 &gt; MSS 的时候将发生拆包。 接收方法不及时读取套接字缓冲区数据，这将发生粘包。 如何处理粘包、拆包？解决粘包的方法就是由应用层进行分包处理，本质上就是由应用层来维护消息和消息的边界。 使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。 设置定长消息，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。 设置消息边界，服务端从网络流中按消息编辑分离出消息内容，一般使用‘\\n’。 更为复杂的协议。 简述Socket通信基本步骤具体分成两个部分： 服务端 socket(创建socket) bind(绑定socket和端口号) listen(监听该端口号) accept(等待并接受客户端连接请求) read,write(读取数据和返回数据) close(关闭socket) 客户端 socket(创建socket) connect(连接指定的端口) read,write(读取数据和返回数据) close(关闭socket) GET、POST的区别 作用GET 用于获取资源，而 POST 用于传输数据。 参数GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。 安全GET 方法是安全的，而 POST 却不是。安全就是说请求方法不会改变服务器状态，也就是说它只是可读的。因为 POST 的目的是传送数据，这个数据可能是用户上传的表单，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。所以，从这个方面来讲，POST是不安全的。 幂等GET方法都是幂等的，但 POST 方法不是。幂等就是说，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。所以，幂等方法不应该具有副作用。 HTTP与HTTPS的区别 https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 HTTPS是运行在SSL&#x2F;TLS之上的HTTP协议，SSL&#x2F;TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。 SSL四次握手 客户端请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA公钥加密，此时是明文传输。 服务端回复一种客户端支持的加密方法、一个随机数–Server random、授信的服务器证书和非对称加密的公钥。 客户端收到服务端的回复后利用服务端的公钥，加上新的随机数–Premaster secret 通过服务端下发的公钥及加密方法进行加密，发送给服务器。 服务端收到客户端的回复，利用已知的加解密方式进行解密，同时利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key – session key。 什么是对称加密与非对称加密 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等。这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方； 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。 ref 详细解析HTTP 与HTTPS 的区别 HTTPS工作原理 首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验； 客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）； 消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名； 发送给服务端，此时只有服务端（RSA私钥）能解密。 解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。 HTTP长连接，短连接是什么？HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。 在HTTP&#x2F;1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 而从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 HTTP版本对比HTTP1.0版本的特性： 1.0的HTTP版本，是一种无状态、无连接的应用层协议。 HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。 HTTP1.1版本新特性 默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求 管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应 断点续传原理 HTTP2.0版本的特性 二进制分帧（采用二进制格式的编码将其封装） 首部压缩（设置了专门的首部压缩设计的HPACK算法。） 流量控制（设置了接收某个数据流的多少字节一些流量控制） 多路复用（可以在共享TCP链接的基础上同时发送请求和响应） 请求优先级（可以通过优化这些帧的交错和传输顺序进一步优化性能） 服务器推送（就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资 源无需客户端明确的请求。（重大更新）） HTTP1.1 和 HTTP2.0 的区别 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。 header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。 ref. HTTP1.0、HTTP1.1 和 HTTP2.0 的区别 输入URL到显示网页的过程 DNS解析：简单地说就是找到URL对应的IP地址。 TCP连接：浏览器与目标服务器建立TCP连接 HTTP协议建立在TCP协议之上，HTTP请求前，需先进行TCP连接，形成客户端到服务器的稳定的通道。俗称TCP的三次握手。 TCP连接完成后，HTTP请求开始，请求有多种方式，常见的有GET，POST等。 发送HTTP请求 HTTP请求包含请求头，也可能包含请求体两部分，请求头中包含我们希望对请求文件的操作的信息，请求体中包含传递给后台的参数。 服务器处理请求并返回HTTP报文 服务器收到HTTP请求后，后台开始工作，如负载平衡，跨域等，这里就是后端的工作了。 文件处理完毕，生成响应数据包，响应也包含两部分，响应头和相应体，响应体就是我们所请求的文件。 经过网络传输，文件被下载到本地客户端，客户端开始加载。 浏览器解析渲染HTML页面 客户端浏览器加载了HTML文件后，由上到下解析HTML为DOM树（DOM Tree）。 遇到CSS文件，CSS中的url发起HTTP请求。 这是第二次HTTP请求，由于HTTP1.1协议增加了Connection: keep-alive声明，故TCP连接不会关闭，可以复用。 HTTP连接是无状态连接，客户端与服务器端需要重新发起请求–响应。在请求CSS的过程中，解析器继续解析HTML，然后到了script标签。 由于script可能会改变DOM结构，故解析器停止生成DOM树，解析器被js阻塞，等待js文件发起HTTP请求，然后加载。这是第三次HTTP请求。js执行完成后解析器继续解析。 由于CSS文件可能会影响js文件的执行结果，因此需等CSS文件加载完成后再执行。 浏览器收到CSS文件后，开始解析CSS文件为CSSOM树（CSS Rule Tree）。 CSSOM树生成后，DOM Tree与CSS Rule Tree结合生成渲染树（Render Tree）。 Render Tree会被CSS文件阻塞，渲染树生成后，先布局，绘制渲染树中节点的属性(位置，宽度，大小等)，然后渲染，页面就会呈现信息。 继续边解析边渲染，遇到了另一个js文件，js文件执行后改变了DOM树，渲染树从被改变的dom开始再次渲染。 继续向下渲染，碰到一个img标签，浏览器发起HTTP请求，不会等待img加载完成，继续向下渲染，之后再重新渲染此部分。 DOM树遇到HTML结束标签，停止解析，进而渲染结束。 连接结束 涉及到的协议：IP(网络)、OSPF(路由)、ARP(本地MAC解析) ARP，RARP 和 ICMP ARP协议：属于ipv4协议簇，工作在数据链路层。其功能是把网络层32位的IP转换成数据链路层48位的MAC地址，在这个过程中有一个很重要的表——ARP缓存表， ARP缓存表中缓存了IP地址和MAC地址的映射关系。如果没有缓存的情况，ARP会广播某一个IP的信息，收到这个广播的设备会回应一个包，表示我是不是这个IP地址。如果是，广播该IP地址的设备会记录对应设备的MAC地址。 RARP协议:(reverse arp，反向arp协议)，和ARP协议做相反的工作，它将48位的MAC地址转换为32位的IP地址。 ICMP协议:（Internet Control Message Protocol，网络控制消息协议），它的功能是报告无法传送的数据包的错误，并帮助对这些错误进行疑难解答。 DNS(Domain Name System, 域名系统) 域名解析过程域名格式：三级域名.二级域名.顶级域名(www.baidu.com) 域名服务器：保存域名到IP地址映射的服务器。 递归查询：主机向本地域名服务器的查询一般都是采用递归查询。指的是，当主机所询问的本地域名服务器不知道被查询的域名IP地址时，本地域名服务器就以DNS客户的身份，向其他根域名服务器继续查询，而不是让主机自己进行下一步查询， 迭代查询：本地域名服务器向根域名服务器查询通常采用迭代查询。指的是，当根域名服务器没有保存本地域名服务器所查询的域名IP地址时，就告诉本地域名服务器下一步应当找哪一个域名服务器查询，而不是根域名服务器以客户身份查询。 找域名服务器查询之前，会先找缓存中有没有： 浏览器缓存：当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在） 系统缓存：当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP 路由器缓存：当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查 当以上三个缓存中都没有，才会向DNS服务器查询。 NAT(Network Address Translation, 网络地址转换)协议用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。 cookie和session对于HTTP有什么用？HTTP协议本身是无法判断用户身份。所以需要cookie或者session 什么是cookiecookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信息。客户端向服务器发起请求，就提取浏览器中的用户信息由http发送给服务器 什么是sessionsession 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给session。 服务器默认为客户浏览器的cookie中设置 sessionid，这个sessionid就和cookie对应，浏览器在向服务器请求过程中传输的cookie 包含 sessionid ，服务器根据传输cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。 cookie与session区别 cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高 单个cookie保存的数据不能超过4K，session无此限制 session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。 Reference 谢希仁. 计算机网络（第7版）. 电子工业出版社 重学TCP&#x2F;IP协议和三次握手四次挥手 TCP&#x2F;UDP区别以及UDP如何实现可靠传输","categories":[{"name":"CS","slug":"CS","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/CS/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Network/"}]},{"title":"C++ Review","slug":"cppReview","date":"2020-06-05T08:00:00.000Z","updated":"2020-10-21T11:48:06.357Z","comments":true,"path":"2020/06/05/cppReview/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2020/06/05/cppReview/","excerpt":"","text":"C++源文件到可执行文件的过程对于C&#x2F;C++编写的程序，从源代码到可执行文件，一般经过下面四个步骤： 预处理，产生.ii文件 对所有的“#define”进行宏展开； 处理所有的条件编译指令，比如“#if”,“#ifdef”，“#elif”，“#else”,“#endif” 处理“#include”指令，这个过程是递归的，也就是说被包含的文件可能还包含其他文件 删除所有的注释“&#x2F;&#x2F;”和“&#x2F;**&#x2F;” 添加行号和文件标识 保留所有的“#pragma”编译器指令 编译，产生汇编文件(.s文件) 编译的过程就是将预处理完的文件进行一系列词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件(.s文件) 汇编，产生目标文件(.o或.obj文件)汇编器是将汇编代码转变成机器可以执行的代码（二进制文件），每一个汇编语句几乎都对应一条机器指令。最终产生目标文件(.o或.obj文件)。 链接,产生可执行文件(.out或.exe文件)链接的过程主要包括了地址和空间分配(Address and Storage Allocation)、符号决议(Symbol Resolution)和重定位(Relocation) Clang&#x2F;LLVM&#x2F;lldb&#x2F;GCC&#x2F;gdb Clang 是 LLVM 编译器工具集的前端（front-end），目的是输出代码对应的抽象语法树（Abstract Syntax Tree, AST），并将代码编译成LLVM Bitcode。接着在后端（back-end）使用LLVM编译成平台相关的机器语言 。Clang支持C、C++、Objective C。 LLVM 提供了完整编译系统的中间层，它会将中间语言（Intermediate form，IF）从编译器取出与最优化，最优化后的 IF 接着被转换及链接到目标平台的汇编语言。LLVM 后端也可以接受来自GCC工具链所编译的 IF。 lldb 是 LLVM 调试器(断点原理)。lldb是个开源的内置于XCode的具有REPL(read-eval-print-loop)特征的Debugger，其可以安装C++或者Python插件。 GCC（GNU Compiler Collection）在所有平台上都使用同一个前端处理程序（支持很多语言），产生一样的中介码，因此此中介码在各个其他平台上使用GCC编译，有很大的机会可得到正确无误的输出程序。 gdb 是 GCC 调试器。UNIX及UNIX-like下的调试工具。 ref Clang&#x2F;LLVM&#x2F;lldb&#x2F;GCC&#x2F;gdb 关系 头文件中的ifndef&#x2F;define&#x2F;endif有什么作用这是C++预编译头文件保护符，保证即使文件被多次包含，头文件也只定义一次。 typedef 和 define 有什么区别 用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义常量，以及书写复杂使用频繁的宏。 执行时间不同：typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。 作用域不同：typedef 有作用域限定。define 不受作用域约束，只要是在 define 声明后的引用都是正确的。 对指针的操作不同：typedef 和 define 定义的指针时有很大的区别。 注意：typedef 定义是语句，因为句尾要加上分号。而 define 不是语句，千万不能在句尾加分号。 #include 的顺序以及尖叫括号和双引号的区别 #include的顺序的区别：头文件的引用顺序对于程序的编译还是有一定影响的。如果要在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误，也就是常见的某行少个“；”符号。 #include尖括号和双引号的区别： #include &lt;&gt; ，认为该头文件是标准头文件。编译器将会在预定义的位置集查找该头文件，这些预定义的位置可以通过设置查找路径环境变量或者通过命令行选项来修改。使用的查找方式因编译器的不同而差别迥异。 #include “”，认为它是非系统头文件，非系统头文件的查找通常开始于源文件所在的路径。查找范围大于&lt;&gt;。 main 函数执行以前，还会执行什么代码？全局对象的构造函数会在main 函数之前执行。 内联函数和普通函数的区别 复杂程度不同：内联函数比较简单，在内联函数中不允许使用循环语句和switch结果，带有异常接口声明的函数也不能声明为内联函数。 编译结果不同：内联函数（有时称作在线函数或编译时期展开函数）是一种编程语言结构，用来建议编译器对一些特殊函数进行内联扩展（有时称作在线扩展）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文）。普通函数则会编译为单独的模块。 编译的时间不同：对于基于C的编译系统，内联函数的使用可能大大增加编译时间，因为每个调用该函数的地方都需要替换成函数体，代码量的增加也同时带来了潜在的编译时间的增加。 运行的效率不同：使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。 内联函数和宏定义的区别内联函数和宏的区别在于： 宏是由预处理器对宏进行替代 内联函数是通过编译器控制来实现的 而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。 内联函数与带参数的宏定义进行下比较，它们的代码效率是一样，但是内联函数要优于宏定义，因为内联函数遵循的类型和作用域规则，它与一般函数更相近，在一些编译器中，一旦关联上内联扩展，将与一般函数一样进行调用，比较方便。 另外，宏定义在使用时只是简单的文本替换，并没有做严格的参数检查，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。 C++的inline的提出就是为了完全取代宏定义，因为inline函数取消了宏定义的缺点，又很好地继承了宏定义的优点，《Effective C++》中就提到了尽量使用Inline替代宏定义的条款，足以说明inline的作用之大。 定义MAX和MIN宏12#define MAX(a,b) ((a) &gt; (b) ? (a) : (b))#define MIN(a,b) ((a) &lt; (b) ? (a) : (b)) 大小端大端：高位存在低地址，低位存在高地址。 小端：高位存在高地址，低位存在低地址。 大小端和CPU有关。 现代PC大多采用小段，所以小端字节序又被成为主机字节序。而大端字节序又被成为网络字节序。 判断大小端代码： 方法一 123456789101112void byteOrder()&#123; union &#123; short val; char c_val[sizeof(short)]; &#125; test; test.val = 0x0102; if((test.c_val[0]==1) &amp;&amp; (test.c_val[1]==2)) cout &lt;&lt; &quot;Big endian&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Little endian&quot; &lt;&lt; endl;&#125; 方法二 12345678void byteOrder()&#123; int num = 0x0102; char q = *(char *)&amp;num; if (q == 0x02) cout &lt;&lt; &quot;Little endian&quot; &lt;&lt; endl; else cout&lt;&lt;&quot;Big endian&quot; &lt;&lt;endl;&#125; 左值和右值 左值 (lvalue, locator value)：表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。 右值 (rvalue)：一个表达式不是 左值 就是 右值 。 那么，右值是一个 不 表示内存中某个可识别位置的对象的表达式。 左值引用 和 右值引用C++11标准添加了右值引用(rvalue reference)，这种引用只能绑定右值，不能绑定左值，它使用两个&amp;&amp;来声明： 12345int a = 1;int&amp; b = a; //左值引用int&amp;&amp; c = 1; //右值引用int&amp;&amp; b = a; // 编译失败 理解 C&#x2F;C++ 中的左值和右值 右值引用，移动语义，移动构造函数和移动赋值运算符 面向对象的三个基本特征面向对象的三个基本特征是：封装、继承、多态。封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）。它们的目的都是代码重用；而多态则是为了实现另一个目的——接口重用。 封装是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。 封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。 不同的类成员访问修饰符权限： 访问修饰符 同一个类 同包 不同包，子类 不同包，非子类 private √ protected √ √ √ public √ √ √ √ 默认 √ √ 使用继承时需要注意：1、子类拥有父类非private的属性和方法。2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。3、子类可以用自己的方式实现父类的方法。 struct和class的区别在C++中 struct和class唯一的区别就在于默认的继承访问权限不同。 struct 默认权限为公共 class 默认权限为私有 例子： 1234567891011121314151617181920212223242526272829303132333435class listNode&#123;//链表类public: int val; listNode *next; listNode(int a) : val(a), next(nullptr)&#123;&#125;&#125;;struct biTree&#123;二叉树结构 int val; biTree *lc; biTree *rc; biTree(int x) : val(x), lc(nullptr), rc(nullptr)&#123;&#125;&#125;;int main()&#123; //链表 listNode *ln = new listNode(1); listNode *cur = ln; cur-&gt;next = new listNode(2); cur = cur-&gt;next; cur-&gt;next = new listNode(3); //二叉树 biTree parent(1); biTree *root = new biTree(1);//也可以只有 biTree lc(2); biTree rc(3); parent.lc = &amp;lc; parent.rc = &amp;rc; biTree *root = &amp;parent; return 0;&#125; 构造函数和析构函数构造函数和析构函数解决了对象的初始化和清理这两个非常重要的安全问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。 对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供构造函数和析构函数的空实现。 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。 构造函数语法：类名()&#123;&#125; 没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次 析构函数语法： ~类名()&#123;&#125; 没有返回值也不写void 函数名称与类名相同,在名称前加上符号 ~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次 public、private、protected等权限控制对析构函数无效 构造函数与析构函数的特点 构造函数有如下特点： 构造函数的名字必须与类名相同； 构造函数可以有任意类型的参数，但不能有返回类型； 定义对象时，编译系统会自动调用构造函数； 构造函数是特殊的成员函数，函数体可以在类体内也可以在类体外； 构造函数被声明为公有函数，但它不能像其他成员函数那样被显式调用，它是在定义对象的同时被调用的。 析构函数有如下特点： 析构函数的名字必须与类名相同，但它前面必须加一个波浪号； 析构函数没有参数，也没有返回值，而且不能被重载，因此在一个类中只能有一个析构函数； 当撤销对象时，编译系统会自动调用析构函数； 析构函数可以是virtual，而构造函数不能是虚函数。 构造函数的分类及调用两种分类方式： 按参数分为： 有参构造和无参构造 按类型分为： 普通构造和拷贝构造ps. 有参构造有的可能会成为类型转换构造函数，比如在隐式转换调用的时候 三种调用方式： 括号法 显示法 隐式转换法 构造函数分类示例： 1234567891011121314151617181920212223242526// 按照参数分类分为 有参和无参构造 无参又称为默认构造函数// 按照类型分类分为 普通构造和拷贝构造class Person &#123;public: //无参（默认）构造函数 Person() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; &#125; //有参构造函数 Person(int a) &#123; age = a; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; age = p.age; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; &#125; //析构函数 ~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; &#125;public: int age;&#125;; 构造函数的调用示例： 1234567891011121314151617181920212223242526272829303132333435//调用无参构造函数void test01() &#123; Person p; //调用无参构造函数&#125;//调用有参的构造函数void test02() &#123; //2.1 括号法，常用 Person p1(10); //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明 //Person p2(); //2.2 显式法 Person p2 = Person(10); Person p3 = Person(p2); //Person(10)单独写就是匿名对象 当前行结束之后，马上析构 //2.3 隐式转换法 Person p4 = 10; // Person p4 = Person(10); Person p5 = p4; // Person p5 = Person(p4); //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明 //Person p5(p4);&#125;int main() &#123; test01(); //test02(); system(&quot;pause&quot;); return 0;&#125; 拷贝构造函数和赋值运算符的认识拷贝构造函数和赋值运算符重载有以下两个不同之处： 拷贝构造函数生成新的类对象，而赋值运算符不能。 由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对象之前不用检验源对象是否和新建对象相同。而赋值运算符则需要这个操作，另外赋值运算中如果原来的对象中有内存分配要先把内存释放掉 注意：当有类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符，不要使用默认的。 构造函数和析构函数可以是虚函数吗？ 构造函数不能是虚函数 存储空间角度虚函数的调用需要 vptr 指针，而该指针存放在对象的内容空间中，需要调用构造函数才可以创建它的值，否则即使开辟了空间，该 vptr 指针为随机值；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有 vptr 地址用来调用虚函数之一的构造函数了。 使用，多态角度虚函数主要是实现多态，在运行时才可以明确调用对象，根据传入的对象类型来调用函数，例如通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。那使用虚函数也没有实际意义。 从实现角度vtable在构造函数调用后才建立，所以构造函数不能是虚函数。在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，没有必要成为虚函数。 析构函数常常是虚函数创建一个对象时我们总是要明白指定对象的类型。虽然我们可能通过基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候假设析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。如果基类的析构函数不是虚函数，派生类的析构函数用不上，会造成资源的泄漏。 构造函数和析构函数，可以调用其他的虚函数吗？《Effective C++》条款09：绝不在构造函数或析构函数中调用虚函数。 从语法上讲，调用完全没有问题。 但是从效果上看，往往不能达到需要的目的：派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。同样，进入基类析构函数时，对象也是基类类型。所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。 子类和父类中，构造函数和析构函数的调用顺序是什么？ 构造时，先调用父类构造函数，再调用子类构造函数 析构时，先调用子类析构函数，再调用父类析构函数 ps. 若一个类包含对象成员，在建立该类的对象时，先调用对象成员的构造函数，初始化相应的对象成员，然后才执行该类的构造函数。 如果一个类包含多个对象成员，对象成员的构造函数的调用顺序由它们在该类中的说明顺序决定，而它们在初始化表中的顺序无关。 虚析构函数有什么作用？ 析构函数的工作方式是：最底层的派生类的析构函数最先被调用，然后调用每一个基类的析构函数； 在C++中，当一个派生类对象通过使用一个基类指针删除，而这个基类有一个非虚的析构函数，则可能导致运行时派生类不能被销毁。然而基类部分很有可能已经被销毁，这就导致“部分析构”现象，造成内存泄漏； 给基类一个虚析构函数，删除一个派生类对象的时候就将销毁整个对象，包括父类和全部的派生类部分。 拷贝构造函数在什么情况下会自动被调用 当类的一个对象去初始化该类的另一个对象时； 如果函数的形参是类的对象，调用函数进行形参和实参结合时； 如果函数的返回值是类对象，函数调用完成返回时。 深拷贝与浅拷贝 浅拷贝：简单的赋值拷贝操作。使用默认拷贝构造函数，拷贝过程中是按字节复制的，对于指针型成员变量只复制指针本身，而不复制指针所指向的目标，因此涉及堆区开辟内存时，会将两个成员属性指向相同的内存空间，从而在释放时导致内存空间被多次释放。 深拷贝：在堆区重新申请空间，进行拷贝操作。自定义拷贝构造函数，在堆内存中另外申请空间来储存数据，从而解决指针悬挂的问题。需要注意自定义析构函数中应该释放掉申请的内存。 如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的重复释放堆区问题。 拷贝构造函数的参数必须加const，因为防止修改，本来就是用现有的对象初始化新的对象。 ps. 在定义类或者结构体，这些结构的时候，最后都重写拷贝函数，避免浅拷贝这类不易发现但后果严重的错误产生 123456789101112131415//拷贝构造函数 Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题 m_age = p.m_age; m_height = new int(*p.m_height);&#125;//析构函数~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; if (m_height != NULL) &#123; delete m_height; &#125; 类对象作为类成员C++类中的成员可以是另一个类的对象，我们称该成员为对象成员。 当类中有对象成员时，构造的顺序是：先调用对象成员的构造，再调用本类构造。析构顺序与构造相反。如：B类中有对象A作为成员，A为对象成员。那么当创建B对象时，先调用A的构造，再调用B的构造。结束时先析构B，再析构A。 静态成员成员变量和成员函数前加上关键字static，称为静态成员。静态成员变量： 所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化 静态成员函数： 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 静态成员两种访问方式： 通过对象。如：p1.m_A 通过类名。如：Person::m_B（私有权限访问不到） 成员变量和成员函数分开存储 非静态成员变量占对象空间。int mA; 静态成员变量不占对象空间。static int mB; 函数也不占对象空间，所有函数共享一个函数实例。每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码123void func() &#123; cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl;&#125; 静态成员函数也不占对象空间 对象模型和this指针this指针概念在类实例化对象时，只有非静态成员变量属于对象本身，剩余的静态成员变量，静态函数，非静态函数都不属于对象本身，因此非静态成员函数只会实例一份，多个同类型对象会共用一块代码。c++通过提供特殊的对象指针——this指针——区分调用自己的对象。this指针指向被调用的成员函数所属的对象。 this指针的本质是一个指针常量，指针的指向不可修改。this的目的总是指向这个对象， this 是一个指向类的实例的一个指针，指向该实例的首地址，但是 this 不是 该对象实例的一部分，即在sizeof（某对象）中不包含this指针的大小。 this指针的作用this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来做到这一点，因为this所指的正是这个对象。任何对类成员的直接访问都被看成this的隐式使用。 当形参和成员变量同名时，可用this指针来区分 在类的非静态成员函数中返回对象本身，可使用return *this12345678910111213141516171819class Person&#123;public: Person(int age) &#123; //1、当形参和成员变量同名时，可用this指针来区分 this-&gt;age = age; &#125; Person&amp; PersonAddPerson(Person p) &#123; this-&gt;age += p.age; //返回对象本身 return *this; &#125; int age;&#125;; this 指针需要注意的地方。 this 指针只能用于成员函数，成员变量，对于静态函数和静态变量，是不允许使用this（因为静态函数或变量，都是属于对象本身，即所有实例都可以访问他们，但是this只是指向自身实例的地址，是一个个例。） 友元函数也没有this指针。(友元函数至少需要一个参数) this引用成员变量用法有二： this-&gt;val 或者 (*this).val. 这就像指针引用类似。 友元友元的目的就是让一个函数或者类访问另一个类中私有成员（包括属性和方法），会破坏C++的封装性，尽量不使用。 友元的关键字为 friend 友元的三种实现： 全局函数做友元 类做友元 成员函数做友元 继承继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。 继承方式继承方式一共有三种： 公共继承 保护继承 私有继承 继承中构造和析构顺序继承中，先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 继承同名成员处理方式当子类与父类出现同名的成员，通过子类对象访问子类或父类中同名的数据的方法： 访问子类同名成员：直接访问即可 访问父类同名成员：需要加作用域 ps. 同名静态成员处理方式和非静态处理方式一样 多继承C++允许一个类继承多个类语法：class子类：继承方式 父类1，继承方式 父类2... ps. 多继承可能会引发父类中有同名成员出现，需要加作用域区分 多态指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。 因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。 多态性允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。 简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。 多态的实现原理 当类中存在虚函数时，编译器会在类中自动生成一个虚函数表 虚函数表是一个存储类成员函数指针的数据结构 虚函数表由编译器自动生成和维护 virtual 修饰的成员函数会被编译器放入虚函数表中 存在虚函数时，编译器会为对象自动生成一个指向虚函数表的指针（通常称之为 vptr 指针） 多态实现的三个条件 要有继承 要有虚函数重写 要有父类指针指（父类引用）向子类对象 多态分为两类（实现多态的两种方法） 重载——静态多态：函数重载 和 运算符重载 属于静态多态，复用函数名 重写（覆盖）——动态多态: 派生类和虚函数实现运行时多态 静态多态和动态多态区别： 静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 - 运行阶段确定函数地址 其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。 也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚邦定）。 结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关。 动态多态代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;class Base&#123; public: virtual void Print() = 0; virtual ~Base()&#123;&#125;&#125;;class child_1 : public Base&#123; public: void Print() &#123; cout &lt;&lt; &quot;child_1 Print function&quot; &lt;&lt; endl; &#125; ~child_1() &#123; cout &lt;&lt; &quot;child_1 destructor function&quot; &lt;&lt; endl; &#125;&#125;;class child_2: public Base&#123; public: void Print() &#123; cout &lt;&lt; &quot;child_2 Print function&quot; &lt;&lt; endl; &#125; ~child_2() &#123; cout &lt;&lt; &quot;child_2 destructor function&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Base *p = new child_1; //父类指针指向子类对象 p-&gt;Print(); delete p; //记住释放,否则内存泄露 p = new child_2; p-&gt;Print(); delete p; p = NULL; return 0;&#125; 静态多态代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;//宏多态：a,b可以不同类型#define sum(a,b) ((a) + (b))class Base&#123; public: void Print() //不需要定义为虚函数 &#123; cout &lt;&lt; &quot;base Print() functions&quot; &lt;&lt; endl; &#125; void Print(int val) //重载,根据参数列表不同实现函数多态 &#123; cout &lt;&lt; &quot;base Print(int) functions&quot; &lt;&lt; endl; &#125;&#125;;class child : public Base&#123; public: void Print() //不需要定义为虚函数 &#123; cout &lt;&lt; &quot;child Print() functions&quot; &lt;&lt; endl; &#125; void Print(int val) //重载,根据参数列表不同实现函数多态 &#123; cout &lt;&lt; &quot;child Print(int) functions&quot; &lt;&lt; endl; &#125; &#125;;template&lt;typename T&gt;void func(T &amp;p)&#123; p.Print(); p.Print(1);&#125;int main()&#123; Base base ; child ch; int a = 23, b = 19; double fa = 13.32, fb = 29.36; func(base); func(ch); //宏多态：a,b可以不同类型 cout &lt;&lt; sum(a,b) &lt;&lt; endl; cout &lt;&lt; sum(fa,fb) &lt;&lt; endl; return 0;&#125; 虚函数 虚函数的作用主要是实现了多态的机制。 定义一个函数为虚函数，不代表函数为不被实现的函数。定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。 定义一个函数为纯虚函数，才代表函数没有被实现。定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。 虚函数的功能是使子类可以用同名的函数对父类函数进行覆盖，并且在通过父类指针调用时，如果有覆盖则自动调用子类覆盖函数，如果没有覆盖则调用父类中的函数，从而实现灵活扩展和多态性； 如果是纯虚函数，则纯粹是为了在子类覆盖时有个统一的命名而已，子类必须覆盖纯虚函数，则否子类也是抽象类； 含有纯虚函数的类称为抽象类，不能实例化对象，主要用作接口类。 示例： 12345678910111213141516171819202122class A&#123;public: virtual void foo() &#123; cout&lt;&lt;&quot;A::foo() is called&quot;&lt;&lt;endl; &#125;&#125;;class B:public A&#123;public: void foo() &#123; cout&lt;&lt;&quot;B::foo() is called&quot;&lt;&lt;endl; &#125;&#125;;int main(void)&#123; A *a = new B(); a-&gt;foo(); // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的! return 0;&#125; 纯虚函数和抽象类在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为纯虚函数。当类中有了纯虚函数，这个类也称为抽象类 纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0; 注意： 纯虚函数没有函数体 最后的=0并不是表示返回值为0，只是形式上的作用，告诉编译系统这是虚函数 这是一个声明，最后有分号 抽象类特点： 无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 类中只要有一个纯虚函数就称为抽象类 虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码。解决方式：将父类中的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构共性： 可以解决父类指针释放子类对象 都需要有具体的函数实现 虚析构和纯虚析构区别： 如果是纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法：virtual ~类名()&#123;&#125; 纯虚析构语法：virtual ~类名() = 0;类名::~类名()&#123;&#125; 1234567891011121314151617181920212223class Animal &#123;public: Animal() &#123; cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl; &#125; virtual void Speak() = 0; //析构函数加上virtual关键字，变成虚析构函数 //virtual ~Animal() //&#123; // cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl; //&#125; virtual ~Animal() = 0;&#125;;Animal::~Animal()&#123; cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;&#125; 虚基类和虚继承多继承（Multiple Inheritance）是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。 多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是菱形继承。如： 123456789101112131415161718192021222324252627282930313233//间接基类Aclass A&#123;protected: int m_a;&#125;;//直接基类Bclass B: public A&#123;protected: int m_b;&#125;;//直接基类Cclass C: public A&#123;protected: int m_c;&#125;;//派生类Dclass D: public B, public C&#123;public: void seta(int a)&#123; m_a = a; &#125; //命名冲突 void setb(int b)&#123; m_b = b; &#125; //正确 void setc(int c)&#123; m_c = c; &#125; //正确 void setd(int d)&#123; m_d = d; &#125; //正确private: int m_d;&#125;;int main()&#123; D d; return 0;&#125; 虚继承目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），继承的时候用关键字virtual声明。 虚继承主要用来解决继承中的二义性问题： 123456789101112131415161718192021222324252627282930313233//间接基类Aclass A&#123;protected: int m_a;&#125;;//直接基类Bclass B: virtual public A&#123; //虚继承protected: int m_b;&#125;;//直接基类Cclass C: virtual public A&#123; //虚继承protected: int m_c;&#125;;//派生类Dclass D: public B, public C&#123;public: void seta(int a)&#123; m_a = a; &#125; //正确 void setb(int b)&#123; m_b = b; &#125; //正确 void setc(int c)&#123; m_c = c; &#125; //正确 void setd(int d)&#123; m_d = d; &#125; //正确private: int m_d;&#125;;int main()&#123; D d; return 0;&#125; ref. C++虚继承和虚基类 虚函数表虚函数表是指在每个包含虚函数的类中都存在着一个函数地址的数组。当我们用父类的指针来操作一个子类的时候，这张虚函数表指明了实际所应该调用的函数。 虚函数表指针vptr一般存储在对象实例的最开头，里面又虚函数表vtable的地址。虚函数表vtable在Linux&#x2F;Unix中存放在可执行文件的只读数据段 .rodata 中 ref. 多态的实现原理分析 C++ 一篇搞懂多态的实现原理 C++进阶之虚函数表 C++虚函数表 虚函数表存放在哪里 多态用法示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include&lt;iostream&gt;using namespace std;//抽象CPU类class CPU&#123;public: //抽象的计算函数 virtual void calculate() = 0;&#125;;//抽象显卡类class VideoCard&#123;public: //抽象的显示函数 virtual void display() = 0;&#125;;//抽象内存条类class Memory&#123;public: //抽象的存储函数 virtual void storage() = 0;&#125;;//电脑类class Computer&#123;public: Computer(CPU * cpu, VideoCard * vc, Memory * mem) &#123; m_cpu = cpu; m_vc = vc; m_mem = mem; &#125; //提供工作的函数 void work() &#123; //让零件工作起来，调用接口 m_cpu-&gt;calculate(); m_vc-&gt;display(); m_mem-&gt;storage(); &#125; //提供析构函数 释放3个电脑零件 ~Computer() &#123; //释放CPU零件 if (m_cpu != NULL) &#123; delete m_cpu; m_cpu = NULL; &#125; //释放显卡零件 if (m_vc != NULL) &#123; delete m_vc; m_vc = NULL; &#125; //释放内存条零件 if (m_mem != NULL) &#123; delete m_mem; m_mem = NULL; &#125; &#125;private: CPU * m_cpu; //CPU的零件指针 VideoCard * m_vc; //显卡零件指针 Memory * m_mem; //内存条零件指针&#125;;//具体厂商//Intel厂商class IntelCPU :public CPU&#123;public: virtual void calculate() &#123; cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl; &#125;&#125;;class IntelVideoCard :public VideoCard&#123;public: virtual void display() &#123; cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl; &#125;&#125;;class IntelMemory :public Memory&#123;public: virtual void storage() &#123; cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl; &#125;&#125;;//Lenovo厂商class LenovoCPU :public CPU&#123;public: virtual void calculate() &#123; cout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl; &#125;&#125;;class LenovoVideoCard :public VideoCard&#123;public: virtual void display() &#123; cout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl; &#125;&#125;;class LenovoMemory :public Memory&#123;public: virtual void storage() &#123; cout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; //第一台电脑零件 CPU * intelCpu = new IntelCPU; VideoCard * intelCard = new IntelVideoCard; Memory * intelMem = new IntelMemory; cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl; //创建第一台电脑 Computer * computer1 = new Computer(intelCpu, intelCard, intelMem); computer1-&gt;work(); delete computer1; cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl; //第二台电脑组装 Computer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);; computer2-&gt;work(); delete computer2; cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl; //第三台电脑组装 Computer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);; computer3-&gt;work(); delete computer3;&#125; 符号namespace主要用来解决命名冲突的问题 必须在全局作用域下声明 命名空间下可以放函数，变量、结构体和类 命名空间可以嵌套命名空间 命名空间是开放的，可以随时加入新成员（添加时只需要再次声明namespace，然后添加新成员即可 ::（作用域运算符） 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的 using using声明1using std::cout; using编译指令1using namespace std; ps. 尽量使用声明而不是编译指令，不同命名空间中可能会有相同的变量名，编译指令执行两个命名空间后，会产生二义性 refC++核心编程面向对象的三大特性 函数重载（overload）、重写（override，也叫覆盖）和隐藏（也叫重定义）重载（overload）当函数具有相同的名称，但是参数列表不相同的情形（包括参数的个数不同或参数的类型不同），这样的同名而不同参数的函数之间，互相被称之为重载函数。(函数名相同，参数列表不同，overload只是在类的内部存在)特征： 具有相同的作用域（即同一个类定义中）； 函数名字相同； 函数参数 类型不同 或者 个数不同 或者 顺序不同； virtual 关键字可有可无； 返回类型也可以不同。ps:函数的访问权限、返回类型、抛出的异常不可以作为函数重载的条件 函数重载实例判断： 123456789101112以下的集中写法，分别表示了哪些是重载的，哪些不是重载的。(1) void func1( int arg1);(2) void func1( double arg1);(3) void func1( int arg1, int arg2);(4) bool func1(int arg1, double arg2)(5) int func1(int arg1);在上述的5个函数中，函数名称都是func1，完全相同；但是：(2)与(1)的参数个数相同，参数类型不同，构成重载；(3)与(1)和(2)的参数个数不同，构成重载；(4)与(1)和(2)的参数个数不同，与(3)的参数个数相同，但是第二个参数类型不同，构成重载；(5)与(1)的参数个数和参数类型均相同，仅返回值的类型不相同，不构成重载；但是(5)与(2),(3)和(4)除返回值不同外，均有参数类型或参数个数不同的情况，因此构成重载关系。 重写（覆盖，override）重写（覆盖）是指派生类重新实现（或者改写）基类的成员函数，在继承关系之间。C++利用虚函数实现多态。其特征是： 不同的作用域（分别位于派生类和基类中）； 完全相同的函数名，参数列表 和 返回类型； 基类函数必须是虚函数。即必须有virtual关键字，不能是static； 重写函数的访问修饰符可以不同。尽管父类的virtual方法是private的，派生类中重写改写为public、protected也是可以的； 重写（override）代码示例：B中fun1重写了A中的fun1 123456789class A&#123;public: virtual void fun1(int, int)&#123;&#125;&#125;;class B : class A&#123;public: void fun1(int, int)&#123;&#125;&#125;; 隐藏（重定义）子类重新定义父类有相同名称的非虚函数(参数列表可以不同)。 不在同一个作用域（分别位于派生类与基类） ； 函数名字相同，返回值可以不同； 函数名相同但参数不同。如果派生类的函数和基类的函数同名，但是参数不同，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载以及覆盖混淆）； 函数名相同且参数相同，但是基类函数没有 virtual关键字。此时，基类的函数被隐藏（否则就是重写了）。 示例程序:12345678910111213141516171819class Base&#123;public: void A(int x)&#123; cout &lt;&lt; &quot;Base::A(int)&quot; &lt;&lt; endl; &#125; void A(float x)&#123; cout &lt;&lt; &quot;Base::A(float)&quot; &lt;&lt; endl; &#125; virtual void B(void)&#123; cout &lt;&lt; &quot;Base::B(void)&quot; &lt;&lt; endl;&#125; virtual void C(float x)&#123; cout &lt;&lt; &quot;Base::C(float)&quot; &lt;&lt; endl; &#125; virtual void D(float x)&#123; cout &lt;&lt; &quot;Base::D(float)&quot; &lt;&lt; endl; &#125; void E(float x)&#123; cout &lt;&lt; &quot;Base::E(float) &quot; &lt;&lt; endl; &#125;&#125;;class Derived : public Base&#123;public: virtual void B(void)&#123; cout &lt;&lt; &quot;Derived::B(void)&quot; &lt;&lt; endl;&#125; virtual void C(float x)&#123; cout &lt;&lt; &quot;Derived::C(float)&quot; &lt;&lt; x &lt;&lt; endl; &#125; virtual void D(int x)&#123; cout &lt;&lt; &quot;Derived::D(int)&quot; &lt;&lt; endl; &#125; void E(float x)&#123; cout &lt;&lt; &quot;Derived::E(float)&quot; &lt;&lt; endl; &#125;&#125;; 重载：函数Base::A(int)与Base::A(float)相互重载 重写：函数Derived::B(void)重写了Base::B(void)，函数Derived::C(float)重写了Base::C(float) 隐藏：函数Derived:: D(int)隐藏了Base:: D(float)，函数Derived::E(float)隐藏了Base::E(float) ref C++ 类成员函数的重载(overload)，重写&#x2F;覆盖(override)，隐藏 函数重载(overload)和函数重写(override) C++的重载（overload）与重写（override） 函数模板与函数重载的异同？ 函数的重载是指定义了几个名字相同，但参数的类型或参数的个数不同的函数； 模板函数是指的几个函数的具体算法相同，而参数类型不同的函数； 模板函数可以减少重载函数，但也可能引发错误。 C++中的空类，默认会产生哪些类成员函数 默认构造函数 析构函数 拷贝构造函数 赋值运算符（operator&#x3D;） 取址运算符（operator&amp;）（一对，一个非const的，一个const的）12345678910class Empty&#123; public: Empty(); // 缺省构造函数 Empty( const Empty&amp; ); // 拷贝构造函数 ~Empty(); // 析构函数 Empty&amp; operator=( const Empty&amp; ); // 赋值运算符 Empty* operator&amp;(); // 取址运算符 const Empty* operator&amp;() const; // 取址运算符 const&#125;; 类在内存中的存储方式 类的静态成员变量编译时被分配到静态&#x2F;全局区，因此静态成员变量是属于类的，所有对象共用一份，不计入类的内存空间 静态成员函数和非静态成员函数都是存放在代码区的，是属于类的，类可以直接调用静态成员函数，不可以直接调用非静态成员函数，两者主要的区别是有无this指针 派生类对象的存储空间 &#x3D; 基类存储空间 + 派生类特有的非static数据成员的空间C++类在内存中的存储方式 类成员变量的初始化顺序成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。 C++类成员变量的初始化顺序 数据类型 sizeof 与 strlen 的区别 sizeof是一个操作符，而strlen是库函数。 sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为’\\0’的字符串作参数。 编译器在编译时就计算出了sizeof的结果，而strlen必须在运行时才能计算出来。 sizeof计算数据类型占内存的大小，strlen计算字符串实际长度。12cout &lt;&lt; strlen(&quot;123&quot;) &lt;&lt; endl; //3cout &lt;&lt; sizeof(&quot;123&quot;) &lt;&lt; endl; //4 strcpy 和 memcpy 的区别strcpy 和 memcpy 都是标准C库函数 strcpystrcpy提供了字符串的复制。即strcpy只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符。 char* strcpy(char* dest, const char* src); 12345678char * strcpy(char * dest, const char * src) // 实现src到dest的复制&#123; if ((src == NULL) || (dest == NULL)) //判断参数src和dest的有效性 return NULL; char *strdest = dest; //保存目标字符串的首地址 while ((*strDest++ = *strSrc++)!=&#x27;\\0&#x27;); //把src字符串的内容复制到dest下 return strdest;&#125; memcpymemcpy提供了一般内存的复制。即memcpy对于需要复制的内容没有限制，因此用途更广。 void *memcpy( void *dest, const void *src, size_t count ); 12345678910void *memcpy(void *memTo, const void *memFrom, size_t size)&#123; if((memTo == NULL) || (memFrom == NULL)) //memTo和memFrom必须有效 return NULL; char *tempFrom = (char *)memFrom; //保存memFrom首地址 char *tempTo = (char *)memTo; //保存memTo首地址 while(size -- &gt; 0) //循环size次，复制memFrom的值到memTo中 *tempTo++ = *tempFrom++ ; return memTo;&#125; 区别 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。 用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy x &amp; (x-1)相当于消除了 x 从右向左数遇到的第一个1。 short i &#x3D; 0; i &#x3D; i + 1L；这两句有错吗代码一是错的，代码二是正确的。 说明：在数据安全的情况下大类型的数据向小类型的数据转换一定要显示的强制类型转换。 &amp;&amp;和&amp;、||和|有什么区别 &amp;和|对操作数进行求值运算，&amp;&amp;和||只是判断逻辑关系。 &amp;&amp;和||在在判断左侧操作数就能确定结果的情况下就不再对右侧操作数求值。 注意：在编程的时候有些时候将&amp;&amp;或||替换成&amp;或|没有出错，但是其逻辑是错误的，可能会导致不可预想的后果（比如当两个操作数一个是 1 另一个是 2 时。 struct定义的四种方法第一种 1234struct 结构体名称&#123; 数据类型 member1； 数据类型 member2; &#125;; 第二种 1234typedef struct 结构体名称&#123; 数据类型 member1； 数据类型 member2; &#125;结构体名称别名; 第三种 1234struct 结构体名称&#123; 数据类型 member1； 数据类型 member2; &#125;结构体变量; 第四种：此方式是匿名结构体，在定义时同时声明结构体变量，但不能在其它地方声明，因为我们无法得知该结构体的标识符，所以就无法通过标识符来声明变量。 1234struct &#123; 数据类型 member1； 数据类型 member2; &#125;结构体变量名; 联合（union）、结构（struct）、类（class） 联合在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的。union变量所占用的内存长度等于最长的成员的内存长度。 123456union A&#123;//sizeof(union A)的值为8 char mark; long num; float score;&#125;; 结构将不同类型的数据组合成一个整体，是自定义类型。 123456struct B&#123;//sizeof(struct B)的值为24 char mark; long num; float score;&#125;; 结构体：将不同类型的数据组合成一个整体，是自定义类型 区别： 结构体中的每个成员都有自己独立的地址，它们是同时存在的；共同体中的所有成员占用同一段内存，它们不能同时存在； sizeof(struct)是内存对齐后所有成员长度的总和，sizeof(union)是内存对齐后最长数据成员的长度 结构体为什么要内存对齐呢？看下面 内存对齐（字节对齐）#pragma pack(n) 表示的是设置n字节对齐，windows默认是8，linux是4。 内存对齐规则对于结构的各个成员，第一个成员位于偏移为0的位置，以后的每个数据成员的偏移量必须是 min(#pragma pack()指定的数,这个数据成员的自身长度)的倍数。 在所有的数据成员完成各自对齐之后，结构或联合体本身也要进行对齐，对齐将按照 #pragam pack指定的数值和结构或者联合体最大数据成员长度中比较小的那个，也就是 min(#pragram pack() , 长度最长的数据成员)。 需要对齐的原因 平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常 硬件原因：经过内存对齐之后，CPU的内存访问速度大大提升。访问未对齐的内存，处理器要访问两次（数据先读高位，再读低位），访问对齐的内存，处理器只要访问一次，为了提高处理器读取数据的效率，我们使用内存对齐 举例12345struct A&#123; char a; int b; short c;&#125;; char占一个字节，起始偏移为零，int占四个字节，min(8,4)&#x3D;4；所以应该偏移量为4，所以应该在char后面加上三个字节，不存放任何东西，short占两个字节，min(8,2)&#x3D;2;所以偏移量是2的倍数，而short偏移量是8，是2的倍数，所以无需添加任何字节，所以第一个规则对齐之后内存状态为0xxx|0000|00 此时一共占了10个字节，但是还有结构体本身的对齐，min(8,4)&#x3D;4；所以总体应该是4的倍数，所以还需要添加两个字节在最后面，所以内存存储状态变为了 0xxx|0000|00xx，一共占据了12个字节 ref. C&#x2F;C++内存对齐 c++资源管理机制内存的分类 堆（heap）：指的是动态分配内存的区域。这里的内存，需要程序员手动分配和释放（new,delete），否则，就会造成内存泄漏。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。与之相关的一个概念是自由存储区(free store)，特指使用 new 和 delete 来分配和释放内存的区域。一般来说，这是堆的一个子集。new 和 delete 操作的区域是 free storemalloc 和 free 操作的区域是 heapps: new 和 delete 通常底层使用 malloc 和 free 来实现，所以 free store 也属于 heap 栈（stack）：函数调用过程中产生的本地变量和调用数据的区域。由编译器自动分配和释放。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 凡生命周期超出当前函数的，一般需要用堆（或者使用对象移动传递）。反之，生命周期在当前函数内的，就该用栈。 全局&#x2F;静态存储区（static）：全局变量和静态变量被分配到同一块内存中。程序结束后由系统释放。它们是在程序编译、链接时完全确定下来的，具有固定的存储位置（暂不考虑某些系统的地址扰乱机制）。堆和栈上的变量则都是动态的，地址无法确定。 常量存储区：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。程序结束后由系统释放。 程序代码区：存放程序的二进制代码。 栈展开（stack unwinding）指的是：如果在一个函数内部抛出异常，而此异常并未在该函数内部被捕捉，就将导致该函数的运行在抛出异常处结束，所有已经分配在栈上的局部变量都要被释放。示例 最常见的栈展开就是正常的函数调用，任何一个函数返回都存在栈展开。C++引入异常机制后，当程序抛出异常，在异常向上传递的过程中，其函数调用栈也会展开。 栈展开演示： 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;class Obj &#123;public: Obj() &#123; puts(&quot;Obj()&quot;); &#125; ~Obj() &#123; puts(&quot;~Obj()&quot;); &#125;&#125;;void foo(int n)&#123; Obj obj; if (n == 42) throw &quot;life, the universe and everything&quot;;&#125;int main()&#123; try &#123; foo(41); foo(42); &#125; catch (const char* s) &#123; puts(s); &#125;&#125; 代码执行结果：不管是否发生了异常，obj 的析构函数都会得到执行。 12345Obj()~Obj()Obj()~Obj()life, the universe and everything RAII(Resource Acquisition Is Initialization)是 C++ 所特有的资源管理方式。RAII 依托栈和析构函数，来对所有的资源（包括堆内存在内）进行管理。 其原理是在对象析构函数中释放该对象获取的资源，利用栈展开过程栈上对象的析构函数将被自动调用的保证，从而正确地释放先前获取的资源。 RAII只有在栈展开正常执行的前提下才能正常工作。函数调用和正常的C++异常处理流程(异常处于try-catch块)都存在栈展开。 申请后系统的响应栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 malloc&#x2F;free 和 new&#x2F;delete 区别： 属性不同：malloc&#x2F;free是标准库函数，new&#x2F;delete是操作符（运算符）。 申请的内存所在位置：new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。 内存分配失败时的返回值：new内存分配失败时，会抛出bad_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。 是否需要指定内存大小：new&#x2F;delete分配可以自动计算需要的字节数，malloc&#x2F;free需要人为指定。 是否调用构造函数&#x2F;析构函数： new会先调用operator_new函数，申请足够的内存（通常底层使用malloc实现），然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator_delete函数释放内存（通常底层使用free实现）。 malloc&#x2F;free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。 能否重载：new&#x2F;delete允许重载,malloc&#x2F;free不允许重载 已分配内存的扩充：malloc&#x2F;free可以通过realloc函数扩充，new&#x2F;free无法直观地处理 能否相互调用：operator_new&#x2F;operator _delete的实现可以基于malloc&#x2F;free，而malloc的实现不可以去调用new。 1234567891011121314//main.cppint a = 0; //全局初始化区char *p1; //全局未初始化区main()&#123;int b; //栈char s[] = &quot;abc&quot;; //栈char *p2; //栈char *p3 = &quot;123456&quot;; //123456\\0在常量区，p3在栈上。static int c =0； //全局（静态）初始化区p1 = (char *)malloc(10);p2 = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区。strcpy(p1, &quot;123456&quot;); //123456\\0放在常量区，编译器可能会将它与p3所指的&quot;123456&quot;优化成一个地方&#125; malloc实现原理 malloc 函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。 调用 malloc（）函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。 然后，将该内存块一分为二（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节）。 接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块（如果有的话）返回到连接表上。 调用 free 函数时，它将用户释放的内存块连接到空闲链表上。 到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段， 那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc（）函数请求延时，并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。 malloc会出现的问题：初始化的问题。没有初始化的内存中内容是随机的，所以如果直接使用的话，就可能造成程序运行结果不正确。 ps. malloc 函数可以向程序的虚拟空间申请一块虚拟地址空间，与物理内存没有直接的关系，所以是有可能用malloc函数申请超过该机器物理内存大小的内存块的 ref. linux-malloc底层实现原理 delete 与 delete[] 区别delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。delete与new配套，delete []与new []配套。 在More Effective C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator delete来释放内存。” 12345678910MemTest *mTest1 = new MemTest[10];MemTest *mTest2 = new MemTest;Int *pInt1 = new int [10];Int *pInt2 = new int;delete[] pInt1; //-1-delete[] pInt2; //-2-delete[] mTest1; //-3-delete[] mTest2; //-4- 在-4-处报错。 说明：对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。 delete[]删除一个数组，delete删除一个指针。 简单来说，用new分配的内存用delete删除；用new[]分配的内存用delete[]删除。delete[]会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。 内存泄漏当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。内存泄漏会最终会导致内存溢出。 内存泄漏的原因： 异常或分支导致delete未得到执行 分配和释放不在一个函数里导致的遗漏delete 内存溢出程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，于是就发生了内存溢出。 野指针野指针指向一个已删除的对象 或 申请访问受限内存区域的指针。 原因： 指针变量未初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向 NULL。1char *p; //此时p为野指针 指针释放未置空：指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。解决办法：指针指向的内存空间被释放后指针应该指向。NULL。123char *p=new char[10]; //指向堆中分配的内存首地址cin&gt;&gt; p;delete []p; //p重新变为野指针 指针操作超出作用域。返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向 NULL。123char *p=new char[10]; //指向堆中分配的内存首地址cin&gt;&gt; p;cout&lt;&lt;*(p+10); //可能输出未知数据 ps. “野指针”的解决方法也是编程规范的基本原则，平时使用指针时一定要避免产生“野指针”，在使用指针前一定要检验指针的合法性。 栈内存与文字常量区12345678910111213141516char str1[] = &quot;abc&quot;;char str2[] = &quot;abc&quot;;const char str3[] = &quot;abc&quot;;const char str4[] = &quot;abc&quot;;const char *str5 = &quot;abc&quot;;const char *str6 = &quot;abc&quot;;char *str7 = &quot;abc&quot;;char *str8 = &quot;abc&quot;;cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl;//0 分别指向各自的栈内存cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl;//0 分别指向各自的栈内存cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl;//1 指向文字常量区地址相同cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl;//1 指向文字常量区地址相同 str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。 ref 极客时间《现代C++实战30讲》：01 | 堆、栈、RAII：C++里该如何管理资源？ RAII(wiki) C++ 自由存储区是否等价于堆？ 为什么c++中要分为heap（堆）和stack（栈） C&#x2F;C++内存分配 C&#x2F;C++内存管理详解 指针和引用的区别声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。 引用只是变量的一个别名，指针是变量的地址，有分配内存。 指针可以指向空值，但是在任何情况下都不能使用指向空值的引用。引用在声明时必须初始化。 指针与引用的另一个重要的不同是：指针可以被重新赋值以指向另一个不同的对象，但是引用则总是指向在初始化时被指定的对象，以后不能改变。 sizeof的意义不同：使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小。 指针和引用的自增运算符意义不同：指针是对内存地址的自增，引用是对值的自增 没有引用常量，有指针常量 参数传递：作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象 多级指针，一级引用. 指针可以有多级指针（**p），而引用只有一级 作为参数时，引用更安全，因为指针传递时会涉及到形参和实参，会多开辟内存。 在以下情况下你应该使用指针： 你考虑到存在不指向任何对象的可能(在 这种情况下，你能够设置指针为空) 你需要能够在不同的时刻指向不同的对象(在这种情况下，你能改变指针的指向)。 如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。 ps: 函数传参时，可以使用引用。&amp;emsp;&amp;emsp;引用也可以作为函数的返回值。但是要注意不要返回局部变量引用。 1234567891011//返回局部变量引用int&amp; test01() &#123; int a = 10; //局部变量 return a;&#125;//返回静态变量引用int&amp; test02() &#123; static int a = 20; return a;&#125; ref 《more effective C++》 Item M1:指针与引用的区别 C++中指针和引用的区别 C&#x2F;C++基础知识 函数参数传递中值传递、地址传递、引用传递有什么区别？ 值传递，会为形参重新分配内存空间，将实参的值拷贝给形参，形参的值不会影响实参的值，函数调用结束后形参被释放； 引用传递，不会为形参重新分配内存空间，形参只是实参的别名，形参的改变会影响实参的值，函数调用结束后形参不会被释放； 地址传递，形参为指针变量，将实参的地址传递给函数，可以在函数中改变实参的值，调用时为形参指针变量分配内存，结束时释放指针变量。 常量指针，指针常量，常量引用，没有引用常量 常量指针（常指针）：是一个指针，指向一个常量。 指针常量：是一个常量，这个常量的类型是指针 常量引用：是一个引用，是常量的引用 没有引用常量 123456789101112131415//常量指针const int* p = &amp;a; // *p 为常量，不能通过*p改变它指向的内容 int const* p = &amp;a; // *p 为常量，同上//指针常量int* const p = &amp;a; // p 为常量，初始化后不能再指向其它内容//指向常量的 常指针const int * const p;int const * const p;//常量引用int a = 10;const int &amp;r = a;const int &amp;r = 10; 常引用有什么作用常引用的引入主要是为了避免使用变量的引用时，在不知情的情况下改变变量的值。 常引用主要用于定义一个普通变量的只读属性的别名、作为函数的传入形参，避免实参在调用函数中被意外的改变。 说明：很多情况下，需要用常引用做形参，被引用对象等效于常对象，不能在函数中改变实参的值，这样的好处是有较高的易读性和较小的出错率。 指针常量与常量指针区别 指针常量是指这个指针的值只能在定义时初始化，其他地方不能改变。（重点在常量） 常量指针是指这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。（重点在指针） 指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。 注意：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。 指针和数组指针和数组的区别 概念不同。指针相当于一个变量，它存放的是数据在内存中的地址；数组是用于储存多个相同类型数据的集合 赋值不同。同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝 访问数据不同。指针是间接访问数据，获取指针，先解引用，再访问指针指向的地址中的内容；数组是直接访问 sizeof意义不同。数组所占存储空间的内存：sizeof（数组名） 数组的大小：sizeof（数组名）&#x2F;sizeof（数据类型） 在32位平台下，sizeof（指针名）是4，在64位平台下，sizeof（指针名）是8 指针和数组名异同。指针和数组名都可以表示地址，但指针是变量，可以修改；数组名是常量，不可修改赋值 传参。数组传参时会退化成指针 指针数组和数组指针 指针数组：它本质上是一个数组，数组的每个元素存放的是一个指针类型的元素。 int* arr[8]; 优先级问题：[]的优先级比*高 说明arr是一个数组，而int*是数组里面的内容 这句话的意思就是：arr是一个含有8和int*的数组 数组指针：它本质上是一个指针，该指针指向一个数组。 int (*arr)[8]; 由于[]的优先级比高，因此在写数组指针的时候必须将arr用括号括起来 arr先和*结合，说明p是一个指针变量 这句话的意思就是：指针arr指向一个大小为8个整型的数组。 ps. 谁优先级高，本质是谁 数组名和指针的区别数组名并不是真正意义上的指针，它的内涵要比指针丰富的多。但是当数组名当做参数传递给函数后，其失去原来的含义，变作普通的指针。另外要注意 sizeof 不是函数，只是操作符。 123456789101112#include &lt;iostream.h&gt;#include &lt;string.h&gt;void main(void)&#123; char str[13]=&quot;Hello world!&quot;; char *pStr=&quot;Hello world!&quot;; cout&lt;&lt;sizeof(str)&lt;&lt;endl; //13 cout&lt;&lt;sizeof(pStr)&lt;&lt;endl; //4 cout&lt;&lt;strlen(str)&lt;&lt;endl; //12 cout&lt;&lt;strlen(pStr)&lt;&lt;endl; //12 return;&#125; 数组数组的初始化int a[10]和int* a &#x3D; new int[10]的区别： int a[10]是静态分配 int* a&#x3D;new int[10]]是动态分配 数组的存放 固定数组 在函数体内分配的（不带static）是在栈中 全局变量&#x2F;带static的局部变量 是在全局数据存储区 类中分配的在堆中 动态数组，都在堆中 说明： int a[10]使用简单，系统会自动实现内存的分配和回收。int* a = new int[10]需要判断内存是否分配成功，以及在不用时需要使用delete[] a进行内存释放，否则会造成内存泄漏； 如果不是a[10]，而是a[1000000000]或者更大的话，那一般情况下，就只能使用int* a = new这种方式了。这个涉及到内存存放位置的问题，int a[]这种方式，内存是存放在栈上；int* a ＝ new这种方式，内存是存放在堆上，栈的实际内存是连续内存，因此可分配空间较小，堆可以是非连续内存，因此可以分配较大内存。因此，如果需要分配较大内存，需要分配在堆上；（注意，同一个new出来的是连续内存，new一个一维数组确实是连续内存，但多个new出来的就不是连续内存了。） 使用int a[10]这种方式，内存大小需要用常量指定，比如这里的10。不能用int m＝10; int a[m]这种方式。但是int* a= new这种方式可以，因此在动态分配内存上，后者有非常大的优势。 ref C&#x2F;C++基础知识 C&#x2F;C++ 数组的初始化 模版C++另一种编程思想称为泛型编程，主要利用的技术就是模板。 C++提供两种模板机制：函数模板 和 类模板 函数模版函数模板作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。 语法： 12template&lt;typename T&gt;函数声明或定义 template：声明创建模板 typename：表面其后面的符号是一种数据类型，可以用class代替 T：通用的数据类型，名称可以替换，通常为大写字母 使用函数模板有两种方式： 自动类型推导 显示指定类型 示例 123456789101112131415template&lt;typename T&gt;void mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;//利用模板实现交换//1、自动类型推导int a = 1, b = 2;mySwap(a, b);//2、显示指定类型mySwap&lt;int&gt;(a, b); 普通函数与函数模板的区别 普通函数调用时可以发生自动类型转换（隐式类型转换） 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换 如果利用显示指定类型的方式，可以发生隐式类型转换 普通函数与函数模板的调用规则1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//普通函数与函数模板调用规则void myPrint(int a, int b)&#123; cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a, T b) &#123; cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a, T b, T c) &#123; cout &lt;&lt; &quot;调用重载的模板&quot; &lt;&lt; endl; &#125;void test01()&#123; //1、如果函数模板和普通函数都可以实现，优先调用普通函数 // 注意 如果告诉编译器 普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到 int a = 10; int b = 20; myPrint(a, b); //调用普通函数 //2、可以通过空模板参数列表来强制调用函数模板 myPrint&lt;&gt;(a, b); //调用函数模板 //3、函数模板也可以发生重载 int c = 30; myPrint(a, b, c); //调用重载的函数模板 //4、 如果函数模板可以产生更好的匹配,优先调用函数模板 char c1 = &#x27;a&#x27;; char c2 = &#x27;b&#x27;; myPrint(c1, c2); //调用函数模板&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 函数模版实例转自下方参考1 利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序排序规则从大到小，排序算法为选择排序分别利用char数组和int数组进行测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//交换的函数模板template&lt;typename T&gt;void mySwap(T &amp;a, T&amp;b)&#123; T temp = a; a = b; b = temp;&#125;template&lt;class T&gt; // 也可以替换成typename//利用选择排序，进行对数组从大到小的排序void mySort(T arr[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; int max = i; //最大数的下标 for (int j = i + 1; j &lt; len; j++) &#123; if (arr[max] &lt; arr[j]) &#123; max = j; &#125; &#125; if (max != i) //如果最大数的下标不是i，交换两者 &#123; mySwap(arr[max], arr[i]); &#125; &#125;&#125;template&lt;typename T&gt;void printArray(T arr[], int len) &#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; //测试char数组 char charArr[] = &quot;bdcfeagh&quot;; int num = sizeof(charArr) / sizeof(char); mySort(charArr, num); printArray(charArr, num);&#125;void test02()&#123; //测试int数组 int intArr[] = &#123; 7, 5, 8, 1, 3, 9, 2, 4, 6 &#125;; int num = sizeof(intArr) / sizeof(int); mySort(intArr, num); printArray(intArr, num);&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 类模版类模板作用：建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。 语法： 12template&lt;typename T&gt;类 template：声明创建模板 typename：表面其后面的符号是一种数据类型，可以用class代替 T：通用的数据类型，名称可以替换，通常为大写字母 示例 1234567891011121314151617template&lt;class NameType, class AgeType&gt; class Person&#123;public: Person(NameType name, AgeType age) &#123; this-&gt;mName = name; this-&gt;mAge = age; &#125; void showPerson() &#123; cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl; &#125;public: NameType mName; AgeType mAge;&#125;; 类模板与函数模板区别123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType = int&gt; class Person&#123;public: Person(NameType name, AgeType age) &#123; this-&gt;mName = name; this-&gt;mAge = age; &#125; void showPerson() &#123; cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl; &#125;public: NameType mName; AgeType mAge;&#125;;//1、类模板没有自动类型推导的使用方式void test01()&#123; // Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导 Person &lt;string ,int&gt;p(&quot;孙悟空&quot;, 1000); //必须使用显示指定类型的方式，使用类模板 p.showPerson();&#125;//2、类模板在模板参数列表中可以有默认参数void test02()&#123; Person &lt;string&gt; p(&quot;猪八戒&quot;, 999); //类模板中的模板参数列表 可以指定默认参数 p.showPerson();&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; refC++提高编程 关键字const不可修改 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针和指针常量；int *const p和const int *p 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量，本质是const this指针。 static对外不可见 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，在整个程序运行期间一直存在，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它，自动初始化为0。 全局变量作用域：全局静态变量在声明他的文件之外是不可见的，即便是 extern 外部声明也不可以。准确地说是从定义之处开始，到文件结尾。 局部变量作用域：仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变； 修饰普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用 修饰类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过&lt;类名&gt;::&lt;静态成员&gt;来使用。在 static 函数内不能访问非静态成员 static的用法 extern修饰变量或函数，表示该函数可以跨文件访问，或者表明该变量在其他文件定义，在此处引用。 extern关键字的作用是共享代码。 在其他文件中定义过的全局变量，在另一个文件中要调用时，只需在声明语句前加关键字extern。 对于常量，要调用其他文件的常量时，做法如下：12345//文件1,定义常量extern const int i = 1;//文件2，声明常量extern const int i; 注意： 定义也是声明，因为当定义变量时我们也向程序表明了它的类型和名字 但声明不是定义，可以通过使用extern关键字声明变量而不定义它。不定义变量的声明包括对象名、对象类型和对象类型前的关键字extern extern声明不是定义，不分配存储空间 ref. extern使用方法总结 extern “C”1234567#ifdef _cplusplusextern &quot;C&quot; &#123;#endif#include &quot;XXX.h&quot;#ifdef _cplusplus&#125;#endif extern “C”的作用是，告诉C++编译器，下面的代码按照C的方式进行编译，不要对这些函数进行名字重整（function name mangling）。通常在C++程序中使用C函数或者模块时，需要用到这个功能。 ref. C–变量的存储方式、作用域和生命周期 extern “C”用法总结 explicitexplicit关键字的作用就是防止对象间实现使用 “&#x3D;” 赋值，防止类构造函数的隐式自动转换,类构造函数默认情况下即声明为implicit(隐式)，另外explicit只用于单参数的构造函数，或者除了第一个参数以外的其他参数都有默认值. explicit 修饰构造函数时，可以防止隐式转换和复制初始化 explicit 修饰转换函数时，可以防止隐式转换 inline用于程序中定义内联函数。 内联函数是C++中的一种特殊函数，它可以像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是通过将函数体直接插入调用处来实现的，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。一般来说inline用于定义类的成员函数。 在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。类内声明可以不用加上inline关键字，但是类外定义函数体时必须要加上，这样才能保证编译器能够识别其为内联函数。 ps. 内联函数不能包括复杂的控制语句，如循环语句和switch语句 示例：使用内联函数来返回两个数中的最大值 1234inline int Max(int x, int y)&#123; return (x &gt; y)? x : y;&#125; restrictrestrict只能修饰指针，restrict修饰的指针是能够访问所指区域的唯一入口，限制多个指针指向同一地址。 volatilevolatile是给编译器的指示来说明对它所修饰的对象不应该执行优化。volatile的作用就是用来进行多线程编程。在单线程中那就是只能起到限制编译器优化的作用。 如果一个基本变量被volatile修饰，编译器将不会把它保存到寄存器中，而是每一次都去访问内存中实际保存该变量的位置上。这一点就避免了没有volatile修饰的变量在多线程的读写中所产生的由于编译器优化所导致的灾难性问题。所以多线程中必须要共享的基本变量一定要加上volatile修饰符。 强制类型转换C++中4种类型转换为： static_cast完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换，不能用于普通指针的转换（void空指针除外） dynamic_cast动态类型转换，用于实现RTTI（运行时类型检查）。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常bad_cast const_cast用于删除 const、volatile特性 reinterpret_cast几乎什么都可以转,不能丢掉 const、volatile特性 多重继承多重继承（多继承，Multiple Inheritance，MI）指的是一个类可以同时继承多个类，比如A类继承自B类和C类，这就是多重继承。 ref Effective C++ 40：明智地使用多继承 变量的声明和定义有什么区别为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但是只在一个地方定义。加入 extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。 局部变量，静态局部变量，全局变量，静态全局变量的区别静态局部变量 该变量在全局数据区分配内存； 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化； 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0； 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。 静态全局变量 静态变量都在全局数据区分配内存; 未经初始化的静态全局变量会被程序自动初始化为0（在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为 0）； 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。 全局变量 和 静态全局变量 的区别 全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。 静态全局变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。 存放区别全局（静态）存储区：分为 DATA 段和 BSS 段。DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。 全局初始化的变量：.data:全局未初始化变量：.bss全局只读：.rdata ref C&#x2F;C++ 中 static 的用法全局变量与局部变量 局部变量，静态局部变量，全局变量，静态全局变量在内存中的存放区别 全局初始化变量&#x2F;全局未初始化变量&#x2F;全局静态变量&#x2F;局部变量的存储位置，作用域，与生命周期 C++中哪些运算符不可以重载？ . ?: sizeof :: * 简述C++异常处理方式一个典型的C++异常处理包含以下几个步骤： 程序执行时发生错误； 以一个异常对象(最简单是一个整数)记录错误的原因及相关信息； 程序监测到这个错误(读取异常对象)； 程序决定如何处理错误； 进行错误处理，并在此后恢复&#x2F;终止程序的执行。 STL(Standard Template Library,标准模板库)STL从广义上分为: 容器(container)、算法(algorithm)、迭代器(iterator) 容器和算法之间通过迭代器进行无缝连接。STL几乎所有的代码都采用了模板类或者模板函数。 STL大体分为六大组件，分别是： 容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。 算法：各种常用的算法，如sort、find、copy、for_each等 迭代器：扮演了容器与算法之间的胶合剂。 仿函数：行为类似函数，可作为算法的某种策略。 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。 空间配置器：负责空间的配置与管理。 常用STL容器、算法、迭代器请看「STL常用方法」 函数对象重载函数调用操作符的类，其对象常称为函数对象 仿函数函数对象使用重载的()时，行为类似函数调用，也叫仿函数。函数对象(仿函数)是一个类，不是一个函数。 例如： 12345678910111213141516171819#include &lt;iostream&gt; using namespace std; class Multiply&#123;public: double operator()(double x, double y) const &#123;return x*y;&#125; double operator()(double x, int y) const &#123;return x*y;&#125; double operator()(int x, double y) const &#123;return x*y;&#125; int operator()(int x, int y) const &#123;return x*y;&#125;&#125;; int main()&#123; Multiply multiply; cout &lt;&lt; &quot; 3.6 * 7 = &quot; &lt;&lt; multiply(3.6,7) &lt;&lt; endl; cout &lt;&lt; &quot; 3 * 7 = &quot; &lt;&lt; multiply(3,7) &lt;&lt; endl; return 0;&#125; 函数对象的特点 函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值 函数对象超出普通函数的概念，函数对象可以有自己的状态 函数对象可以作为参数传递 谓词返回bool类型的仿函数称为谓词。如果operator()接受一个参数，那么叫做一元谓词；如果operator()接受两个参数，那么叫做二元谓词。 一元谓词1234567struct GreaterFive&#123; bool operator()(int val) &#123; return val &gt; 5; &#125;&#125;;vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); 二元谓词123456789101112class MyCompare&#123;public: bool operator()(int num1, int num2) &#123; return num1 &gt; num2; &#125;&#125;;sort(v.begin(), v.end());//默认从小到大sort(v.begin(), v.end(), MyCompare());//使用函数对象改变算法策略，排序从大到小 STL容器的底层数据结构 vector 底层使用数组保存。 push_back时若已经满了，则会2*n扩展空间，若实际元素数量低于分配空间的1&#x2F;4，则会将空间回收为原来的一半。 扩容时，先申请新的空间，然后将旧空间的内容拷贝过去，然后再释放旧的空间。 只适用于快速查找及只在末尾增删，而不适用于动态增删（可能涉及到元素的移动）。对元素进行增删时，可能导致旧的迭代器失效。防止迭代器失效的删除方法： 1234567for (vector&lt;int&gt;::iterator it = vec.begin();ite!=vec.end();) &#123; if(*it % 2 != 0) //删除vec中的奇数 it = vec.erase(it); else it++; &#125; clear()可以清空所有元素，但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。可以用swap()来帮助你释放内存，也可以使用erase循环删除第一个。 vector和数组的区别 list 底层是双向链表，支持头尾增删，并且是一个环。 不适用于查找频繁的情况，但适用于动态增删。 stack 适配器。默认底层使用deque，适配之后只能从头插入和删除。 queue 适配器。默认底层使用deque，适配之后只能从尾插入，从头删除。 priority_queue 适配器。一般以vector为底层容器，堆heap为处理规则来管理。 map、multimap、set、multiset 底层使用红黑树实现，multimap是key值可重复的map。 防止迭代器失效的删除方法 123456for (auto it = m.begin(); it != m.end();)&#123; if(it-&gt;second == 10)//删除val==10的元素 m.erase(it++); else it++;&#125; hash_map、hash_multimap、hash_set、hash_multiset 底层使用hashtable实现，其中hashtable是采用开链法来防止哈希冲突的。 deque： 底层是一个分段的线性表。笼统的说就是使用了一个二维指针，第一维是每段的信息，而第二维就是一个数组了，实际保存的元素就是在这里。 头尾都支持插入，但是维护麻烦很多。 slist 使用单向链表实现的列表。 ps. queue，priority_queue，stack不是容器，是适配器，是对容器的再封装，没有迭代器 vector和list的异同 数据结构上的不同 vector是用连续数组存储，内存空间连续，随机访问O(1)。内存不足是扩容一倍，申请更大的内存。 list底层是双向链表，不需要连续内存。插入删除O(1)，查找O(n)。 迭代器 vector中iterator支持”+”,”+&#x3D;”,”&lt;”等操作，list中不支持。 push_back 和 emplace_backC++11中，针对顺序容器(如vector、deque、list)，新标准引入了三个新成员：emplace_front、emplace和emplace_back，这些操作构造而不是拷贝元素。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定位置之前或容器尾部。 当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。 push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。 map和unordered_map的区别 排序：map在缺省下，map按照递增的顺序进行排序；unordered_map不排序 内部原理：map内部采用了红黑树（自平衡的二叉搜索树），实现了数据排序；unordered_map内部采用了哈希表 搜索操作时间：map的搜索时间复杂度为O(log(n))；unordered_map平均搜索时间O(1)，最坏情况为O(n) 插入操作时间：map复杂度为log(n)+再平衡时间；unordered_map平均插入时间O(1)，最坏情况为O(n) 删除操作时间：与插入操作时间复杂度一样 ref C++提高编程：后半部分有STL库的常用方法 C&#x2F;C++ 最常见50道面试题 C&#x2F;C++ 经典面试题（一）之常考概念 常见C++笔试面试题整理 C++ 11 新特性 关键字及新语法：auto、nullptr、for STL容器：std::array、std::forward_list、std::unordered_map、std::unordered_set 多线程：std::thread、std::atomic、std::condition_variable 智能指针内存管理：std::shared_ptr、std::weak_ptr、std::unique_ptr 其他：std::function、std::bind和lamda表达式 C++11中对类(class)新增的特性： default&#x2F;delete 控制默认函数 override &#x2F;final 强制重写&#x2F;禁止重写虚函数 委托构造函数 Delegating constructors 继承的构造函数 Inheriting constructors 类内部成员的初始化 Non-static data member initializers 移动构造和移动赋值 nullptr常量C++中NULL仅仅是define NULL 0的一个宏定义，因此，有时候会产生歧义。 - 比如f（char*）和f（int），参数传NULL的话到底该调用哪个？事实上，在VS下测试这样的函数重载会优先调用f（int），但是f（char *）也是正确的，因此C++引入nullptr来避免这个问题 - nullptr是一个空指针，可以被转换成其他任意指针的类型 auto关键字让编译器替我们去分析表达式所属的类型，直接推导。尤其是STL中map的迭代器这种很长的类型，适合用auto。 decltype操作符从表达式的类型推断出要定义的变量的类型，跟表达式的类型也就是参数类型紧密相关 - delctype (f()) sum &#x3D; x; 并不实际调用函数f()，只是使用f()的返回值当做sum的类型 - delctype (i) sum &#x3D; x;和delctype ((i)) sum &#x3D; x; 其中i为int类型，前面的为int类型，后面的为int&amp;引用 范围for语句多与auto配合使用。如 for(auto n:nums) 多线程互斥锁pthread_mutex_t1234567891011121314151617//互斥量的创建pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); ///attr不写或传入NULL即可······//加锁pthread_mutex_lock(pthread_mutex_t *mutex); //如果其他线程已经加锁了, 则阻塞让出CPU直到其他线程Unlock//pthread_mutex_trylock(pthread_mutex_t *mutex); //如果不能加锁立即返回···//解锁pthread_mutex_unlock(pthread_mutex_t *mutex);······//互斥量的删除pthread_mutex_destroy(pthread_mutex_t *mutex); std::mutex.lock()、.unlock()、lock_guard、unique_lock 12345678910111213#include&lt;mutex&gt;std::mutex m_mutex;//方法1m_mutex.lock();···m_mutex.unlock();//方法2：初始化的时候就是锁的lock操作的时候，超出它的作用域之后析构时unlocklock_guard&lt;mutex&gt; lock(m_mutex);··· 双层vectorvector&lt;vector &gt;(n, vector(n, 0)) lambda表达式用于实现匿名函数，匿名函数只有函数体，没有函数名。 用法：[capture](parameters)-&gt;return-type &#123;body&#125; []叫做捕获说明符，表示一个lambda表达式的开始。接下来()是参数列表，即这个匿名的lambda函数的参数，-&gt;return-type表示返回类型，如果没有返回类型，则可以省略这部分。最后&#123;&#125;就是函数体部分了。 lambda函数能够捕获lambda函数外的具有自动存储时期的变量。函数体与这些变量的集合合起来叫闭包。 [] 不截取任何变量 [&amp;} 截取外部作用域中所有变量，并作为引用在函数体中使用 [&#x3D;] 截取外部作用域中所有变量，并拷贝一份在函数体中使用 [&#x3D;, &amp;foo] 截取外部作用域中所有变量，并拷贝一份在函数体中使用，但是对foo变量使用引用 [bar] 截取bar变量并且拷贝一份在函数体重使用，同时不截取其他变量 [x, &amp;y] x按值传递，y按引用传递 [this] 截取当前类中的this指针。如果已经使用了&amp;或者&#x3D;就默认添加此选项。 示例： 1234567auto func = [] () &#123; cout &lt;&lt; &quot;hello,world&quot;; &#125;;func(); //call the functionauto func2 = [] () &#123; &#125;//sort函数的后面可以用lambda函数sort(vec.begin(), vec.end(), [](int a, int b)-&gt;bool&#123;return a &lt; b&#125;) 智能指针放弃了C++98提供了第一个智能指针：auto_ptr。增加了3个新的智能指针： shared_ptr weak_ptr unique_ptr 智能指针本质上是一个类，它将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。智能指针的出现实际上就是为了可以方便的控制对象的生命期，是 RAII 资源管理功能的自然展现。 STL一共给我们提供了四种智能指针： auto_ptrC++98提供的解决方案，C+11已将将其摒弃。原因是避免潜在的内存崩溃问题：将一个auto_ptr赋值给另一个auto_ptr时，程序将试图删除同一个对象两次。 unique_ptr当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做。 shared_ptr采用引用计数的策略 weak_ptr对于引用计数法实现的计数，总是避免不了循环引用（或环形引用）的问题，shared_ptr也不例外。为了解决类似这样的问题，C++11引入了weak_ptr，来打破这种循环引用。weak_ptr是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是将一个shared_ptr赋值给weak_ptr不会改变shared_ptr的引用计数。不论是否有weak_ptr指向，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。 ps：将一个智能指针赋值给另一个智能指针时有多种方法：1）定义陚值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本，缺点是浪费空间，所以智能指针都未采用此方案。2）建立所有权（ownership）概念。对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的构造函数会删除该对象。然后让赋值操作转让所有权。这就是用于auto_ptr和uniqiie_ptr 的策略，但unique_ptr的策略更严格。3）创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1,。当减为0时才调用delete。这是shared_ptr采用的策略。 ref C++11常用特性的使用经验总结 C++11中对类(class)新增的特性 极客时间《现代C++实战30讲》：02 | 自己动手，实现C++的智能指针 C++智能指针简单剖析 C++中常用的设计模式共有23种设计模式，但真正在开发中常用的模式有： Factory Method(工厂模式)； Strategy(策略模式)； Singleton(单例模式)； C++ 单例模式总结与剖析 懒汉模式：不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化： 1234567891011121314151617181920212223242526272829//普通懒汉class Singleton&#123;private: Singleton()&#123; cout &lt;&lt; &quot;constructor called&quot; &lt;&lt; endl; &#125; Singleton(Singleton&amp;) = delete; Singleton &amp;operator=(const Singleton&amp;) = delete; static Singleton *instance_ptr;public: ~Singleton()&#123; std::cout&lt;&lt;&quot;destructor called&quot;&lt;&lt;std::endl; &#125; static Singleton* get_instance()&#123; if(instance_ptr==nullptr)&#123; instance_ptr = new Singleton; &#125; return instance_ptr; &#125;&#125;;Singleton* Singleton::instance_ptr = nullptr;int main()&#123; Singleton* instance = Singleton::get_instance(); Singleton* instance2 = Singleton::get_instance(); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435//线程安全、内存安全的懒汉式单例（智能指针，锁）class Singleton&#123;public: typedef shared_ptr&lt;Singleton&gt; Ptr; ~Singleton()&#123; cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl; &#125; static Ptr get_instance()&#123; if(instance_ptr==nullptr)&#123;// &quot;double checked lock&quot; std::lock_guard&lt;mutex&gt; lk(m_mutex); if (instance_ptr == nullptr) instance_ptr = Ptr(new Singleton); &#125; return instance_ptr; &#125;private: Singleton() &#123; cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl; &#125; Singleton(Singleton &amp;) = delete; Singleton &amp;operator=(const Singleton &amp;) = delete; static Ptr instance_ptr; static mutex m_mutex;//锁&#125;;// initialization static variables out of classSingleton::Ptr Singleton::instance_ptr = nullptr;mutex Singleton::m_mutex;int main()&#123; Singleton::Ptr instance = Singleton::get_instance(); Singleton::Ptr instance1 = Singleton::get_instance(); return 0;&#125; 123456789101112131415161718192021222324//局部静态变量懒汉，最推荐class Singleton&#123;public: ~Singleton()&#123; cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl; &#125; static Singleton&amp; get_instance()&#123;//返回指针而不是返回引用无法避免用户使用 delete instance 导致对象被提前销毁。 static Singleton instance; return instance; &#125;private: Singleton()&#123; cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl; &#125; Singleton(Singleton &amp;) = delete; Singleton &amp;operator=(const Singleton &amp;) = delete;&#125;;int main()&#123; Singleton&amp; instance = Singleton::get_instance(); Singleton&amp; instance1 = Singleton::get_instance(); return 0;&#125; 饿汉：在单例类定义的时候就进行实例化 123456789101112131415161718192021222324class Singleton&#123;public: ~Singleton()&#123; cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl; &#125; static Singleton* get_instance()&#123; return instance_ptr; &#125;private: static Singleton* instance_ptr; Singleton()&#123; cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl; &#125; Singleton(Singleton &amp;) = delete; Singleton &amp;operator=(const Singleton &amp;) = delete;&#125;;Singleton *Singleton::instance_ptr = new Singleton();int main()&#123; Singleton* instance = Singleton::get_instance(); Singleton* instance1 = Singleton::get_instance(); return 0;&#125; Iterator(迭代器模式)； Abstract Factory(抽象工厂模式)； Builder(建造者模式)； Adapter(适配器模式)； 1234567891011121314151617181920212223242526272829303132333435363738394041class Target &#123; // Target，客户期望的接口，可以使具体或抽象的类，也可以是接口public: virtual void Request() = 0; virtual ~Target()&#123;&#125;;&#125;;class Adaptee &#123; //需适配的类public: void SpecificRequest() &#123; cout &lt;&lt; &quot;Adaptee&quot; &lt;&lt; endl; &#125;&#125;;class Adapter1 : public Target &#123; //通过内部包装一个Adaptee对象，把源接口转换为目标接口：private: Adaptee* adaptee;public: Adapter1() &#123; adaptee = new Adaptee(); &#125; void Request() &#123; adaptee-&gt;SpecificRequest(); &#125; // 调用Request()方法会转换成调用adaptee.SpecificRequest() ~Adapter1() &#123; delete adaptee; &#125;&#125;;class Adapter2 : public Target&#123;private: Adaptee *adaptee;public: Adapter2() &#123; adaptee = new Adaptee(); &#125; void Request() &#123; adaptee-&gt;SpecificRequest(); &#125; ~Adapter2() &#123; delete adaptee; &#125;&#125;;int main()&#123; Target *target = new Adapter1(); target-&gt;Request(); delete target; Target *target2 = new Adapter2(); target-&gt;Request(); delete target2; return 0;&#125; Bridge(桥接模式)； Composite(组合模式)； Interpreter(解释器模式)； Command(命令模式)； Mediator(中介者模式)； Observer(观察者模式)； State(状态模式)； Proxy(代理模式)。 设计模式6大原则 单一职责原则(Single Responsibility Principle) 开放封闭原则（Open Close Principle） 里氏替换原则（Liskov Substitution Principle） 依赖倒置原则（Dependence Inversion Principle） 接口隔离原则（InterfaceSegregation Principles） 迪米特原则（Law of Demeter）也称最少知识原则 对编程规范的理解或认识编程规范可总结为： 可行性 可读性 可移植性 可测试性 代码示例 C++ 继承、多态、重载、友元","categories":[{"name":"CS","slug":"CS","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/CS/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/cpp/"}]},{"title":"Leetcode每日一题 - 2020年六月","slug":"LeetcodeDaily_June","date":"2020-06-01T08:00:00.000Z","updated":"2020-08-17T07:39:58.237Z","comments":true,"path":"2020/06/01/LeetcodeDaily_June/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2020/06/01/LeetcodeDaily_June/","excerpt":"","text":"6月1日 1431. 拥有最多糖果的孩子（简单）给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。示例： 123输入：candies = [4,2,1,1,2], extraCandies = 1输出：[true,false,false,false,false] 解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。 提示： 1232 &lt;= candies.length &lt;= 1001 &lt;= candies[i] &lt;= 1001 &lt;= extraCandies &lt;= 50 题解：如果采用暴力法，在每个孩子的糖果数上加上extraCandies再与其他孩子比，时间复杂度为O(n2)。可以先找出最大值most，遍历时与most-extraCandies比较，此时只需O(n)。找数组中的最大值可以自己实现，也可以使用STL实现。 12345678910111213141516171819int getMostCandies(vector&lt;int&gt;&amp; candies)&#123; int most = 0; for(int n:candies)&#123; if(n&gt;most) most = n; &#125; return most;&#125;vector&lt;bool&gt; kidsWithCandies(vector&lt;int&gt;&amp; candies, int extraCandies) &#123; int most = getMostCandies(candies); vector&lt;bool&gt; isMostCandies(candies.size()); for(int i=0;i&lt;candies.size();i++)&#123; if(most-candies[i]&gt;extraCandies) isMostCandies[i] = false; else isMostCandies[i] = true; &#125; return isMostCandies;&#125; 6月2日 剑指Offer面试题64. 求1+2+…+n求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。1 &lt;= n &lt;= 10000题解：通常实现递归的时候我们都会利用条件判断语句来决定递归的出口，但由于题目的限制我们不能使用条件判断语句，所以我们使用逻辑运算符的短路性质：以逻辑运算符 &amp;&amp; 为例，对于 A &amp;&amp; B 这个表达式，如果 A 表达式返回 False ，那么 A &amp;&amp; B 已经确定为 False ，此时不会去执行表达式 B。同理，对于逻辑运算符 ||， 对于 A || B 这个表达式，如果 A 表达式返回 True ，那么 A || B 已经确定为 True ，此时不会去执行表达式 B。 1234int sumNums(int n) &#123; n &amp;&amp; (n += sumNums(n-1)); return n;&#125; 6月3日 837. 新21点（中等）爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？示例： 12输入：N = 21, K = 17, W = 10输出：0.73278 提示： 120 &lt;= K &lt;= N &lt;= 100001 &lt;= W &lt;= 10000 题解：dp[x]为她已经获得的分数为x时，能获胜的概率。 dp[x] = (dp[x+1]+dp[x+2]+dp[x+3]...+dp[x+W])/W dp[x-1] = (dp[x]+dp[x+1]+dp[x+2]...+dp[x-1+W])/W dp[x-1]-dp[x] = (dp[x]-dp[x-1+W])/W 最后公式为： dp[x] = x &lt;= N ? 1 : 0&amp;emsp;&amp;emsp;K &lt;&#x3D; x &lt; K+W dp[K-1] = (dp[K]+dp[K+1]+dp[K+2]...+dp[K-1+W])/W dp[x-1] = dp[x] + (dp[x]-dp[x+W])/W&amp;emsp;&amp;emsp;0 &lt;&#x3D; x &lt; K-1 如果不求dp[x]与dp[x-1]的状态转移方程，可以用概率和的状态转移方程代替： sumOfW[x] = sumOfW[x+1] - dp[x+W] + dp[x] 因为抽取点数机会都是均等的，她能抽取的面值在[1,W]之间，所以将概率之和平均一下就是dp[x]的概率。她可能达到的最大牌面是K-1+W，而一开始她的牌面是0，所以我们用一个长度为K+W的dp数组来保存她在所有面值下的胜率。dp[0]就是最开始爱丽丝还没有抽牌时的胜率。 使用dp状态转移方程： 12345678910111213141516double new21Game(int N, int K, int W) &#123; if(K==0) return 1.0; vector&lt;double&gt; dp(K + W); double sumOfW = 0; for (int i = K; i &lt; K + W;i++)&#123; dp[i] = i &lt;= N ? 1.0 : 0.0; sumOfW += dp[i]; &#125; dp[K - 1] = sumOfW / W; for (int i = K - 2; i &gt;= 0; i--) &#123; dp[i] = dp[i + 1] + (dp[i + 1] - dp[i +1 + W]) / W; &#125; return dp[0];&#125; 使用概率和状态转移方程： 123456789101112131415double new21Game(int N, int K, int W) &#123; vector&lt;double&gt; dp(K + W + 1); double sumOfW = 0; for (int i = K; i &lt; K + W;i++)&#123; //不能抽牌时，超过N为0，不超过N为1 dp[i] = i &lt;= N ? 1 : 0; sumOfW += dp[i];//为了方便求sum(dp[x+1]...dp[x+W]) &#125; for (int i = K - 1; i &gt;= 0;i--)&#123; //使用分析中的公式 dp[i] = sumOfW / W; sumOfW = sumOfW - dp[i + W] + dp[i]; &#125; return dp[0];&#125; 6月4日 238. 除自身以外数组的乘积（中等）给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。示例: 12输入: [1,2,3,4]输出: [24,12,8,6] 提示： 题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。说明: 请不要使用除法（数组中有0时失效），且在 O(n) 时间复杂度内完成此题。 题解： 时间复杂度O(N)，空间复杂度O(N)的方法：利用左侧所有数字的乘积和右侧所有数字的乘积相乘得到：通过两次遍历（从前向后，从后向前）得到两个乘积表：productOfLeft(n)和productOfRight(n)productOfLeft(i) = productOfLeft[i-1] * nums[i-1]表示nums[i]左边所有数的乘积，其中productOfLeft(0)=1；productOfRight(i) = productOfRight[i+1] * nums[i+1]表示nums[i]右边所有数的乘积，其中productOfLeft(n-1)=1。123456789101112131415161718vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; productOfLeft(n,0), productOfRight(n,0), output(n,0); productOfLeft[0] = 1; for(int i=1;i&lt;n;i++) productOfLeft[i] = productOfLeft[i-1] * nums[i-1]; productOfRight[n-1] = 1; for(int i = n-2;i&gt;=0;i--) productOfRight[i] = productOfRight[i+1] * nums[i+1]; for(int i = 0;i&lt;n;i++) output[i] = productOfLeft[i] * productOfRight[i]; return output;&#125; 时间复杂度O(N)，空间复杂度O(1)的方法，这是对上面方法的优化：1）把productOfLeft(n)存放都output(n)中（输出数组不算占用空间）2）用一个int来代替productOfRight(n)1234567891011121314151617vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; output(n,0); output[0] = 1; for(int i=1;i&lt;n;i++) output[i] = output[i-1] * nums[i-1]; int productOfRight = 1; for(int i = n-1;i&gt;=0;i--)&#123; output[i] = output[i] * productOfRight; productOfRight *= nums[i]; &#125; return output;&#125; 6月5日 剑指Offer面试题29. 顺时针打印矩阵（简单）输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。示例： 12输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5] 题解：顺时针访问矩阵共有4个遍历方向，依次循环直到全部访问：1）从左到右；2）从上到下；3）从右到左；4）从下到上。关键是方向改变的判定条件。 可以设置一个hasVisited[row][col]数组来不标记访问过的元素。这需要这样的话空间复杂度为O(row*col)。 也可以使用4个int分别表示上下左右的访问边界，每次变换方向，就把该行&#x2F;列的边界向里面缩一行。 第二种方法的代码：时间复杂度O(row*col)：其中 row 和 col 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。空间复杂度：O(1)。除了输出数组以外，只需要4个int来表示边界。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; result; if(matrix.empty()) return result; int upWall = 0,downWall = matrix.size()-1,leftWall = 0,rightWall = matrix[0].size()-1; //1 L To R; 2 Up To D; 3R To L; 4 D To Up int dir = 1; int row = 0, col = 0; while(upWall&lt;=downWall &amp;&amp; leftWall&lt;=rightWall)&#123; result.push_back(matrix[row][col]); if(dir==1)&#123;//从左到右 if(col!=rightWall) col++; else&#123; row++; upWall++; dir = 2; &#125; &#125;else if(dir==2)&#123;//从上到下 if(row!=downWall) row++; else&#123; col--; rightWall--; dir = 3; &#125; &#125;else if(dir==3)&#123;//从右到左 if(col!=leftWall) col--; else&#123; row--; downWall--; dir = 4; &#125; &#125;else&#123;//从下到上 if(row!=upWall) row--; else&#123; col++; leftWall++; dir = 1; &#125; &#125; &#125; return result;&#125; 6月6日 128. 最长连续序列（困难）给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为 O(n)。示例: 123输入: [100, 4, 200, 1, 3, 2]输出: 4解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。 题解： 暴力枚举。最外层枚举每一个元素O(n)；每个数要找它的前一个和后一个连续数O(n)；在数组中定位一个元素，暴力法O(n)，map、set这些红黑树实现的O（lgn），哈希表O(1)。所以纯暴力法时间复杂度O(n3)，最优也是用哈希表的O(n2)。 排序。时间复杂度为O(n*lgn)。虽然不满足要求，但是提交能过。排序后用双指针，遍历一遍O(n)。（去重可以用stl库的unique函数，这里直接设置一个重复计数器eqNums，最后减掉重复数即可）123456789101112131415161718192021int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; sort(nums.begin(),nums.end()); int idxL = 0, idxR = 0, maxSub = 1, eqNums = 0; for(int i = 1;i&lt;nums.size();i++)&#123; if(nums[i]==nums[i-1])&#123; idxR++; eqNums++; &#125;else if(nums[i]==nums[i-1]+1)&#123; idxR++; maxSub = max(maxSub,idxR-idxL+1-eqNums); &#125;else&#123; maxSub = max(maxSub,idxR-idxL+1-eqNums); idxL = i; idxR = i; eqNums = 0; &#125; &#125; return maxSub;&#125; 使用哈希表(unordered_set)一遍遍历O(n)。在进入while循环，以当前数字为首增加currentSub时，先在哈希表中寻找前一位数字是否存在。只有前一位不存在，才开始以当前数字为首扩充子序列。123456789101112131415161718192021int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; num_set; for (const int&amp; num : nums) &#123; num_set.insert(num); &#125; int maxSub = 0; for (const int&amp; num : num_set) &#123; if (!num_set.count(num - 1)) &#123; int currentNum = num; int currentSub = 1; while (num_set.count(currentNum + 1)) &#123; currentNum += 1; currentSub += 1; &#125; maxSub = max(maxSub, currentSub); &#125; &#125; return maxSub; &#125; 并查集(视频讲解)什么是并查集代码：初始化的时候先把数组里每个元素初始化为他的下一个数；并的时候找他能到达的最远的数字就可以了。1234567891011121314unordered_map&lt;int,int&gt; a;int find(int x)&#123; return a.count(x)?a[x]=find(a[x]):x;&#125;int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; for(auto i:nums) a[i]=i+1; int maxSub=0; for(auto i:nums)&#123; int y=find(i+1); maxSub=max(maxSub,y-i); &#125; return maxSub;&#125; 6月7日 126. 单词接龙 II（困难）给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：每次转换只能改变一个字母；转换过程中的中间单词必须是字典中的单词。说明:如果不存在这样的转换序列，返回一个空列表。所有单词具有相同的长度。所有单词只由小写字母组成。字典中不存在重复的单词。你可以假设 beginWord 和 endWord 是非空的，且二者不相同。示例 1: 123456789输入:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]输出:[ [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;], [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]] 示例 2: 123456输入:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]输出: []解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。 题解： 回溯算法。先建图，然后找出所有路径，然后再从所有路径中找出最短路径。建图时间复杂度：建图需要外层枚举O(n)，里层遍历O(n)，两个单词之间的比较O(m)（m为单词的长度）。所以时间复杂度为O(n2*m)。但是在回溯算法找路径时，时间会随字典中的单词数成指数增长。下面代码能通过19&#x2F;39，最后超时 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374bool isConnection(string word1, string word2)&#123; int diff = 0; for (int i = 0; i &lt; word1.size() &amp;&amp; diff&lt;=1 ;i++)&#123; if(word1[i]!=word2[i]) diff++; &#125; return diff == 1;&#125;vector&lt;vector&lt;int&gt; &gt; buildGraphic(vector&lt;string&gt;&amp; wordList)&#123; int N = wordList.size(); vector&lt;vector&lt;int&gt; &gt; graphic(N); for (int i = 0; i &lt; N; i++)&#123; string curWord = wordList[i]; for (int j = 0; j &lt; N; j++) &#123; string nextWord = wordList[j]; if (isConnection(curWord,nextWord)) graphic[i].push_back(j); &#125; &#125; for(auto g:graphic)&#123; for(int n:g) cout &lt;&lt; n &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; cout &lt;&lt; &quot;build graphic done&quot; &lt;&lt; endl; return graphic;&#125;void backTracking(vector&lt;string&gt; &amp;wordList, vector&lt;vector&lt;int&gt; &gt; &amp;graphic, vector&lt;bool&gt; &amp;hasVisted, vector&lt;string&gt; &amp;preWord, vector&lt;vector&lt;string&gt; &gt; &amp;result, string endWord, int current)&#123; if (wordList[current] == endWord) &#123; result.push_back(preWord); return; &#125; for(int next : graphic[current])&#123; if(hasVisted[next]) continue; preWord.push_back(wordList[next]); hasVisted[next] = true; backTracking(wordList, graphic, hasVisted, preWord, result, endWord, next); hasVisted[next] = false; preWord.pop_back(); &#125;&#125;vector&lt;vector&lt;string&gt; &gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; vector&lt;vector&lt;string&gt; &gt; resultAll; vector&lt;string&gt;::iterator it = find(wordList.begin(), wordList.end(), endWord); if(it==wordList.end())//wordList中没有endWord return resultAll; wordList.push_back(beginWord); vector&lt;vector&lt;int&gt; &gt; graphic = buildGraphic(wordList); vector&lt;bool&gt; hasVisted(wordList.size(), false); hasVisted[wordList.size() - 1] = true;//beginWord vector&lt;string&gt; preWord; preWord.push_back(beginWord); backTracking(wordList, graphic, hasVisted, preWord, resultAll, endWord, wordList.size() - 1); int less = wordList.size(); vector&lt;vector&lt;string&gt; &gt; result; for (auto res : resultAll)//找长度最小值 less = res.size() &lt; less ? res.size() : less; for(auto res : resultAll)&#123;//过滤长度最小的 if(res.size()==less) result.push_back(res); &#125; return result;&#125; 先通过BFS找到最短路径长度（方法可以看我的算法总结：查找&#x2F;BFS 专题中的62题），然后再在方法1回溯的时候加上路径长度条件。虽然减少了一些分支，但是还是最坏情况的时间复杂度还是和1一样，与单词数成指数相关。21&#x2F;39个通过，最后超时 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990bool isConnection(string word1, string word2)&#123; int diff = 0; for (int i = 0; i &lt; word1.size() &amp;&amp; diff&lt;=1 ;i++)&#123; if(word1[i]!=word2[i]) diff++; &#125; return diff == 1;&#125;vector&lt;vector&lt;int&gt; &gt; buildGraphic(vector&lt;string&gt;&amp; wordList)&#123; int N = wordList.size(); vector&lt;vector&lt;int&gt; &gt; graphic(N); for (int i = 0; i &lt; N; i++)&#123; string curWord = wordList[i]; for (int j = 0; j &lt; N; j++) &#123; string nextWord = wordList[j]; if (isConnection(curWord,nextWord)) graphic[i].push_back(j); &#125; &#125; return graphic;&#125;int getShortestPath(vector&lt;string&gt; &amp;wordList, vector&lt;vector&lt;int&gt; &gt; &amp;graphic, string endWord)&#123; int N = graphic.size(); vector&lt;bool&gt; hasVisited(N, false); hasVisited[N - 1] = true; queue&lt;int&gt; que; que.push(N - 1);//beginWord int shortestPath = 1; while (!que.empty()) &#123; shortestPath++; int size = que.size(); while(size-- &gt; 0)&#123; int current = que.front(); que.pop(); for(int next : graphic[current])&#123; if(wordList[next]==endWord) return shortestPath; if(hasVisited[next]) continue; hasVisited[next] = true; que.push(next); &#125; &#125; &#125; return 0;&#125;void backTracking(vector&lt;string&gt; &amp;wordList, vector&lt;vector&lt;int&gt; &gt; &amp;graphic, vector&lt;bool&gt; &amp;hasVisted, vector&lt;string&gt; &amp;preWord, vector&lt;vector&lt;string&gt; &gt; &amp;result, string endWord, int current, int curPath, int shortestPath)&#123; if(curPath&gt;shortestPath) return; if (wordList[current] == endWord) &#123; result.push_back(preWord); return; &#125; for(int next : graphic[current])&#123; if(hasVisted[next]) continue; preWord.push_back(wordList[next]); hasVisted[next] = true; backTracking(wordList, graphic, hasVisted, preWord, result, endWord, next, curPath+1, shortestPath); hasVisted[next] = false; preWord.pop_back(); &#125;&#125;vector&lt;vector&lt;string&gt; &gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; vector&lt;vector&lt;string&gt; &gt; result; vector&lt;string&gt;::iterator it = find(wordList.begin(), wordList.end(), endWord); if(it==wordList.end())//wordList中没有endWord return result; wordList.push_back(beginWord); vector&lt;vector&lt;int&gt; &gt; graphic = buildGraphic(wordList); int shortestPath = getShortestPath(wordList, graphic, endWord); vector&lt;bool&gt; hasVisted(wordList.size(), false); hasVisted[wordList.size() - 1] = true;//beginWord vector&lt;string&gt; preWord; preWord.push_back(beginWord); backTracking(wordList, graphic, hasVisted, preWord, result, endWord, wordList.size() - 1, 1, shortestPath); return result;&#125; 反向BFS建图，从endWord开始向上BFS，同时记录每个结点的父结点。再从beginWord开始回溯。（代码略） 双向BFS建图。使用unordered_map&lt;string, vector&lt;string&gt; &gt; graphic来记录单词的子结点，string是wordList中的单词，vector&lt;string&gt;是可以与string连接的子结点（与这个string只有一个字母之差且存在与字典中的集合）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576vector&lt;vector&lt;string&gt; &gt; result;bool isConnection(string word1, string word2)&#123; int diff = 0; for (int i = 0; i &lt; word1.size() &amp;&amp; diff&lt;=1 ;i++)&#123; if(word1[i]!=word2[i]) diff++; &#125; return diff == 1;&#125;unordered_map&lt;string, vector&lt;string&gt; &gt; buildGraphic(vector&lt;string&gt;&amp; wordList, string beginWord, string endWord)&#123; unordered_map&lt;string, vector&lt;string&gt;&gt; graphic; //存储string能连接到的下一层结点 unordered_set&lt;string&gt; dict(wordList.begin(), wordList.end()); unordered_set&lt;string&gt; beginToEnd&#123;beginWord&#125;; unordered_set&lt;string&gt; endToBegin&#123;endWord&#125;; bool findShortest = false; //是否找到最短序列标志, bool dirction = 0; //方向标志。0:begin to end 1:end to begin while(!beginToEnd.empty())&#123; unordered_set&lt;string&gt; nextLayer; for (string s : beginToEnd) //把图里已经有的从list中删除 dict.erase(s); for(string curStr:beginToEnd)&#123;//建立下一层连接 for(string nextStr:dict)&#123; if(isConnection(curStr,nextStr))&#123; if(endToBegin.find(nextStr) != endToBegin.end())//双边遍历碰到了 findShortest = true; else nextLayer.insert(nextStr); dirction ? graphic[nextStr].push_back(curStr) : graphic[curStr].push_back(nextStr); &#125; &#125; &#125; if(findShortest) break; if(nextLayer.size()&lt;=endToBegin.size()) beginToEnd = nextLayer; else&#123; beginToEnd = endToBegin; endToBegin = nextLayer; dirction = !dirction;//end和begin反转，方向标志也要反转 &#125; &#125; return graphic;&#125;void backTracking(unordered_map&lt;string, vector&lt;string&gt; &gt; &amp;graphic, vector&lt;string&gt;&amp; preWords, string beginWord, string endWord)&#123; if (beginWord == endWord) &#123; result.push_back(preWords); return; &#125; if(graphic.find(beginWord) == graphic.end()) return; for(string str:graphic[beginWord])&#123; preWords.push_back(str); backTracking(graphic, preWords, str, endWord); preWords.pop_back(); &#125;&#125;vector&lt;vector&lt;string&gt; &gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; vector&lt;string&gt;::iterator it = find(wordList.begin(), wordList.end(), endWord); if(it==wordList.end())//wordList中没有endWord return result; unordered_map&lt;string, vector&lt;string&gt; &gt; graphic = buildGraphic(wordList, beginWord, endWord); vector&lt;string&gt; preWords = &#123;beginWord&#125;; backTracking(graphic, preWords, beginWord, endWord); return result;&#125; 时间复杂度：建图需要O(n^2)。建图时比较两个单词是否可以连接需要O(c)，c为单词的长度。普通BFS时间复杂度为O(n2)。回溯需要O(2^m)，m为建好的图中的单词数。普通BFS建图中单词数m&#x3D;n，双向BFS建图可以大大减少图中的单词数。 6月8日 990. 等式方程的可满足性（中等）给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：”a&#x3D;&#x3D;b” 或 “a!&#x3D;b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 示例 1： 123输入：[&quot;a==b&quot;,&quot;b!=a&quot;]输出：false解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。 示例 2： 123输出：[&quot;b==a&quot;,&quot;a==b&quot;]输入：true解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。 示例 3： 12输入：[&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]输出：true 示例 4： 12输入：[&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]输出：false 示例 5： 12输入：[&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]输出：true 提示： 123451 &lt;= equations.length &lt;= 500equations[i].length == 4equations[i][0] 和 equations[i][3] 是小写字母equations[i][1] 要么是 &#x27;=&#x27;，要么是 &#x27;!&#x27;equations[i][2] 是 &#x27;=&#x27; 题解：这题需要用到并查集，相关专题可以查看我的博客。把相等的左右两边放到一个子集里面，然后看不相等的是否在同一个子集里。如果在同一个子集的两个字母不相等返回false。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class UnionFind &#123;private: vector&lt;int&gt; parent;public: UnionFind() &#123; parent.resize(26); iota(parent.begin(), parent.end(), 0); &#125; int find(int index) &#123; if (index == parent[index]) &#123; return index; &#125; parent[index] = find(parent[index]); return parent[index]; &#125; void unite(int index1, int index2) &#123; parent[find(index1)] = find(index2); &#125;&#125;;class Solution &#123;public: bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123; UnionFind uf; for (const string&amp; str: equations) &#123; if (str[1] == &#x27;=&#x27;) &#123; int index1 = str[0] - &#x27;a&#x27;; int index2 = str[3] - &#x27;a&#x27;; uf.unite(index1, index2); &#125; &#125; for (const string&amp; str: equations) &#123; if (str[1] == &#x27;!&#x27;) &#123; int index1 = str[0] - &#x27;a&#x27;; int index2 = str[3] - &#x27;a&#x27;; if (uf.find(index1) == uf.find(index2)) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125;; 6月9日 剑指Offer面试题46. 把数字翻译成字符串（中等）给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。示例 1: 123输入: 12258输出: 5解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot; 提示： 10 &lt;= num &lt; 2^31 题解：典型的动态规划题，同类型例题可以看我的算法总结中的动态规划专题dp[i]表示第 i 位数字之前（含）的不同翻译种数，i&#x3D;[1,n]，dp[0]是为了递推方便初始化的，没有实际意义。有两种情况： dp[i] = dp[i-1]前2位中的第一位是为0，如求506的dp[3]时，前一位为0，所以dp[3] &#x3D; dp[2]；前面两位数字大于25，如535，其中35不能翻译为字母，所以dp[3]&#x3D;dp[2] dp[i] = dp[i-1] + dp[i-2]如516，dp[3]&#x3D;dp[2]+dp[1]：516的翻译方法等于5的翻译种数（尾巴添16），加上51的翻译方法种数（尾巴添6）。12345678910111213int translateNum(int num)&#123; string numStr = to_string(num); int n = numStr.size(); vector&lt;int&gt; dp(n + 1); dp[0] = 1, dp[1] = 1;//dp[i]表示第i数字之前（含）的不同翻译种数，i=[1,n]，dp[0]是为了递推方便初始化的，没有实际意义 for (int i = 2; i &lt;= n; i++) &#123; string pre1num = numStr.substr(i - 2, 1);//看前面2位中的第一位是否为0 string pre2num = numStr.substr(i - 2, 2); dp[i] = (stoi(pre2num) &gt; 25 || stoi(pre1num)==0) ? dp[i - 1] : dp[i - 1] + dp[i - 2]; &#125; return dp[n];&#125; 时间复杂度O(n)空间复杂度O(n)。因为只用到前面2个，所以可以优化为O(1)，只用dp[0],dp[1],dp[2]（代码略）。 6月10日 回文数（简单）判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 12输入: 121输出: true 示例 2: 123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 题解： 将数字转换为字符串，设置双指针idxL和idxR，分别指向字符串的头和尾。两个指针边比较边向中间移动。 12345678910111213141516bool isPalindrome(int x) &#123; if(x&lt;0) return false; string numStr = to_string(x); int idxL = 0, idxR = numStr.size() - 1; while (idxR&gt;idxL) &#123; if(numStr[idxL]!=numStr[idxR]) return false; else&#123; idxL++; idxR--; &#125; &#125; return true;&#125; 时间复杂度O(n)空间复杂度O(n)n是数字的位数 不转换成字符串。当x位数为偶数时只用看后一半反转后与前一半是否相等；当x位数为奇数时，我们可以通过 revertedNum&#x2F;10 去除处于中位的数字。 12345678910bool isPalindrome(int x) &#123; if(x&lt;0 || (x % 10 == 0 &amp;&amp; x != 0))//末尾是0的也不可能是回文 return false; int revertedNum = 0; while(x &gt; revertedNum)&#123;//已经到一半了 revertedNum = revertedNum * 10 + x % 10; x /= 10; &#125; return x == revertedNum || x == revertedNum / 10;&#125; 6月11日 739. 每日温度（中等）根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示： 1气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 题解： 纯暴力法（超时）。 123456789101112vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123; vector&lt;int&gt; res(T.size(),0); for(int i=0;i&lt;T.size();i++)&#123; for(int j=i+1;j&lt;T.size();j++)&#123; if(T[j]&gt;T[i])&#123; res[i] = j-i; break; &#125; &#125; &#125; return res;&#125; 时间复杂度O(n^2)。空间复杂度(1)。 温度数组加暴力。由于温度范围在[30, 100]之内，因此可以维护一个数组tempFirstPos记录每个温度第一次出现的下标。数组tempFirstPos中的元素初始化为n，因为数组的最大索引为n-1。在反向遍历温度列表的过程中更新 tempFirstPos 的值。 123456789101112131415vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123; int n = T.size(); vector&lt;int&gt; res(n), tempFirstPos(101, n); for (int i = n - 1; i &gt;= 0; i--) &#123; int warmerIndex = n;//最大值为数组长度 for (int t = T[i] + 1; t &lt;= 100; t++) &#123; warmerIndex = min(warmerIndex, tempFirstPos[t]); &#125; if (warmerIndex != n) &#123; res[i] = warmerIndex - i; &#125; tempFirstPos[T[i]] = i; &#125; return res;&#125; 时间复杂度O(n*m)，n是数组长度，m是温度的范围。空间复杂度O(n)。 单调栈。维护一个单调递减的栈，栈中元素为温度值的索引。当前温度比栈顶索引温度低时，直接进栈；当前温度比栈顶索引温度高时，两个索引之间的差就是栈顶索引值所求结果。视频讲解 1234567891011121314vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123; int n = T.size(); vector&lt;int&gt; res(n,0); stack&lt;int&gt; s; for (int i = 0; i &lt; n; ++i) &#123; while (!s.empty() &amp;&amp; T[i] &gt; T[s.top()]) &#123; int previousIndex = s.top(); res[previousIndex] = i - previousIndex; s.pop(); &#125; s.push(i); &#125; return res;&#125; 时间复杂度O(n)。空间复杂度O(n)。 6月12日 15. 三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 1234567给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 题解： 暴力（超时） 1234567891011121314151617181920212223242526vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); set&lt;vector&lt;int&gt; &gt; resultSet; vector&lt;vector&lt;int&gt; &gt; result; if (n &lt; 3) return result; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++)&#123; for (int k = j + 1; k &lt; n; k++)&#123; if(nums[i]+nums[j]+nums[k]==0)&#123; vector&lt;int&gt; tmp; tmp.push_back(nums[i]); tmp.push_back(nums[j]); tmp.push_back(nums[k]); sort(tmp.begin(), tmp.end()); resultSet.insert(tmp); &#125; &#125; &#125; &#125; for(auto s:resultSet)&#123; result.push_back(s); &#125; return result;&#125; 311 &#x2F; 313 个通过测试用例时间复杂度O(n^3)，空间复杂度O(1) 把最里面一层改为二分查找，需要先排序。还是超时。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253bool biSearch(int resNum, int &amp;idx, vector&lt;int&gt;&amp; nums)&#123; int idxL = 0, idxR = nums.size()-1; int mid = idxR / 2; while(idxL &lt;= idxR)&#123; if(resNum &gt; nums[mid])&#123; idxL = mid + 1; &#125;else if(resNum &lt; nums[mid])&#123; idxR = mid - 1; &#125;else&#123; idx = mid; return true; &#125; mid = (idxL+idxR)/2; &#125; return false;&#125;vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;vector&lt;int&gt; &gt; result; unordered_set&lt;vector&lt;int&gt; &gt; resultSet; sort(nums.begin(),nums.end()); if (n &lt; 3 || nums[0] &gt; 0 || nums[n-1] &lt; 0)//全正或全负 return result; if(nums[0] == 0 &amp;&amp; nums[n-1] == 0)&#123;//全是0 vector&lt;int&gt; tmp0 = &#123;0, 0, 0&#125;; result.push_back(tmp0); return result; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++)&#123; if(j == i) continue; int resNum = 0 - nums[i] - nums[j]; int idx = -1; if(biSearch(resNum,idx,nums) &amp;&amp; idx != i &amp;&amp; idx != j)&#123; vector&lt;int&gt; tmp; tmp.push_back(nums[i]); tmp.push_back(nums[j]); tmp.push_back(nums[idx]); sort(tmp.begin(), tmp.end()); resultSet.insert(tmp); &#125; &#125; &#125; for(auto s:resultSet)&#123; result.push_back(s); &#125; return result;&#125; 313 &#x2F; 313 个通过测试用例时间复杂度O(N^2 * logn)，空间复杂度O(1) 还可以在最里层用一个unordered_set&#x2F;map来查找。可以把时间复杂度降到O(n^2)。但是每次建立unordered_set都需要去掉nums[i] 和 nums[j] 的值，如果有重复，在查重的时候又要增加时间复杂度。 双指针。先排序O(nlong)。第一层循环O(n)，第二个数和第三个数是此消彼长的关系。所以左指针向右移动时，右指针也需要忘左缩进（因为随着第二个数的增加，第三个数必然会减小）。这样时间复杂度就从两层循环O(n^2)减少至只需要一层循环O(n)。123456789101112131415161718192021222324252627282930313233343536373839404142vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt; &gt; result; if (n &lt; 3 || nums[0] &gt; 0 || nums[n-1] &lt; 0)//全正或全负 return result; if(nums[0] == 0 &amp;&amp; nums[n-1] == 0)&#123;//全是0 vector&lt;int&gt; tmp0 = &#123;0, 0, 0&#125;; result.push_back(tmp0); return result; &#125; // 第一个数循环 for (int first = 0; first &lt; n; ++first) &#123; // 去重 if (first &gt; 0 &amp;&amp; nums[first] == nums[first - 1]) &#123; continue; &#125; // 第三个数对应的指针初始指向数组的最右端 int third = n - 1; int target = -nums[first]; // 第二层循环 for (int second = first + 1; second &lt; n; ++second) &#123; if (second &gt; first + 1 &amp;&amp; nums[second] == nums[second - 1]) &#123;// 去重 continue; &#125; // 需要保证第二个数指针在第三个数指针的左侧 while (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123; --third; &#125; // 如果指针重合，随着第二个数的增加，就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环 if (second == third) &#123; break; &#125; if (nums[second] + nums[third] == target) &#123; result.push_back(&#123;nums[first], nums[second], nums[third]&#125;); &#125; &#125; &#125; return result;&#125; 6月13日 70. 爬楼梯（简单）假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 题解：和6月9日的题一样，典型的dp问题。可以看我的算法总结里的dp专题。 一维dp问题。dp[i] = dp[i-1] + dp[i-2] 123456789int climbStairs(int n) &#123; vector&lt;int&gt; dp(n + 1); dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n;i++)&#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n];&#125; 时间复杂度O(n)空间复杂度O(n) 空间优化：实际上，只用到了前两个dp[i-1]，dp[i-2]。所以可以只用到3个int，把空间优化为O(1)。 1234567891011int climbStairs(int n) &#123; vector&lt;int&gt; dp(3); dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n;i++)&#123; dp[2] = dp[1] + dp[0]; dp[0] = dp[1]; dp[1] = dp[2]; &#125; return dp[1];&#125; 第28场双周赛 6.135420. 商品折扣后的最终价格（简单）给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j &gt; i 且 prices[j] &lt;&#x3D; prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。 示例： 1234567输入：prices = [8,4,6,2,3]输出：[4,2,4,2,3]解释：商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。商品 3 和 4 都没有折扣。 题解： 12345678910111213vector&lt;int&gt; finalPrices(vector&lt;int&gt;&amp; prices) &#123; vector&lt;int&gt; res = prices; for (int i = 0; i &lt; prices.size(); i++) &#123; for (int j = i + 1; j &lt; prices.size();j++)&#123; if(prices[j]&lt;=prices[i])&#123; res[i] = prices[i] - prices[j]; break; &#125; &#125; &#125; return res;&#125; 5423. 找两个和为目标值且不重叠的子数组（中等）给你一个整数数组 arr 和一个整数值 target 。请你在 arr 中找 两个互不重叠的子数组 且它们的和都等于 target 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。 示例 1： 123输入：arr = [3,2,2,4,3], target = 3输出：2解释：只有两个子数组和为 3 （[3] 和 [3]）。它们的长度和为 2 。 示例 2： 123输入：arr = [7,3,4,7], target = 7输出：2解释：尽管我们有 3 个互不重叠的子数组和为 7 （[7], [3,4] 和 [7]），但我们会选择第一个和第三个子数组，因为它们的长度和 2 是最小值。 示例 3： 123输入：arr = [4,3,2,6,2,3,4], target = 6输出：-1解释：我们只有一个和为 6 的子数组。 题解： 最容易想到的办法就是遍历数组得到所有sum为target的子数组，再从子数组列表中找出不重合的最小的两个子数组。找子数组处理重合的时候要很仔细。（代码略） 双指针（滑动窗口）。左右指针从右到左移动，同时用一个数组len记录后面的最小子数组。其中，len[i]表示i后面（含i）的最小子数组长度。12345678910111213141516int minSumOfLengths(vector&lt;int&gt;&amp; arr, int target) &#123; int sum = 0, r = arr.size() - 1, ans = 200000; vector&lt;int&gt; len(arr.size() + 1, 200000);//后面子数组的最小长度 for (int l = r; l &gt;= 0; --l) &#123; //l,r是滑动区间的左右坐标 sum += arr[l]; while (sum &gt; target) sum -= arr[r--]; if (sum == target) &#123; int cur = r - l + 1; //子数组长度 ans = min(ans, cur + len[r + 1]); //子数组长度 + r后面子数组的最小长度 len[l] = min(len[l + 1], r - l + 1); //更新l后面子数组的最小长度 &#125;else len[l] = len[l + 1]; //更新子数组的最小长度 &#125; return ans == 200000 ? -1 : ans;&#125; 5421. 安排邮筒（困难）给你一个房屋数组houses 和一个整数 k ，其中 houses[i] 是第 i 栋房子在一条街上的位置，现需要在这条街上安排 k 个邮筒。请你返回每栋房子与离它最近的邮筒之间的距离的 最小 总和。答案保证在 32 位有符号整数范围以内。 示例 1： 1234输入：houses = [1,4,8,10,20], k = 3输出：5解释：将邮筒分别安放在位置 3， 9 和 20 处。每个房子到最近邮筒的距离和为 |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 。 示例 2： 1234输入：houses = [2,3,5,12,18], k = 2输出：9解释：将邮筒分别安放在位置 3 和 14 处。每个房子到最近邮筒距离和为 |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9 。 示例 3： 12输入：houses = [7,4,6,1], k = 1输出：8 示例 4： 12输入：houses = [3,6,14,10], k = 4输出：0 提示： 12345n == houses.length1 &lt;= n &lt;= 1001 &lt;= houses[i] &lt;= 10^41 &lt;= k &lt;= n数组 houses 中的整数互不相同。 第193场周赛 6.145436. 一维数组的动态和（简单）题目难度Easy给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] &#x3D; sum(nums[0]…nums[i]) 。 请返回 nums 的动态和。 示例 1： 输入：nums &#x3D; [1,2,3,4]输出：[1,3,6,10]解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。示例 2： 输入：nums &#x3D; [1,1,1,1,1]输出：[1,2,3,4,5]解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。示例 3： 输入：nums &#x3D; [3,1,2,10,1]输出：[3,4,6,16,17] 1234567vector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res(nums.size(),0); res[0] = nums[0]; for (int i = 1; i &lt; nums.size(); i++) res[i] = res[i - 1] + nums[i]; return res;&#125; 5437. 不同整数的最少数目（Medium）给你一个整数数组 arr 和一个整数 k 。现需要从数组中恰好移除 k 个元素，请找出移除后数组中不同整数的最少数目。 示例 1： 123输入：arr = [5,5,4], k = 1输出：1解释：移除 1 个 4 ，数组中只剩下 5 一种整数。 示例 2： 123输入：arr = [4,3,1,1,3,3,2], k = 3输出：2解释：先移除 4、2 ，然后再移除两个 1 中的任意 1 个或者三个 3 中的任意 1 个，最后剩下 1 和 3 两种整数。 题解： 12345678910111213141516171819202122232425262728293031323334bool cmpByValue(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123;//注意！这个函数要在类外面定义 return a[1] &gt; b[1];//value降序&#125;int findLeastNumOfUniqueInts(vector&lt;int&gt;&amp; arr, int k) &#123; map&lt;int, int&gt; numMap; for(int n:arr)&#123; if(numMap.count(n) == 0) numMap.insert(pair&lt;int, int&gt;(n, 1)); else numMap[n]++; &#125; vector&lt;vector&lt;int&gt; &gt; numMapV; for (auto m : numMap) numMapV.push_back(&#123;m.first, m.second&#125;); sort(numMapV.begin(), numMapV.end(), cmpByValue); while (k &gt; 0 &amp;&amp; numMap.size() &gt; 0) &#123; vector&lt;int&gt; minNum = numMapV.back(); if (minNum[1] &gt; k) return numMap.size(); else if(minNum[1] == k) return numMap.size() - 1; else&#123; k = k - minNum[1]; numMap.erase(minNum[0]); numMapV.pop_back(); &#125; &#125; return numMap.size();&#125; 5438. 制作 m 束花所需的最少天数（Medium）给你一个整数数组 bloomDay，以及两个整数 m 和 k 。现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花。花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。 示例 1： 1234567输入：bloomDay = [1,10,3,10,2], m = 3, k = 1输出：3解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。现在需要制作 3 束花，每束只需要 1 朵。1 天后：[x, _, _, _, _] // 只能制作 1 束花2 天后：[x, _, _, _, x] // 只能制作 2 束花3 天后：[x, _, x, _, x] // 可以制作 3 束花，答案为 3 示例 2： 123输入：bloomDay = [1,10,3,10,2], m = 3, k = 2输出：-1解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。 示例 3： 12345678输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3输出：12解释：要制作 2 束花，每束需要 3 朵。花园在 7 天后和 12 天后的情况如下：7 天后：[x, x, x, x, _, x, x]可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。12 天后：[x, x, x, x, x, x, x]显然，我们可以用不同的方式制作两束花。 示例 4： 123输入：bloomDay = [1000000000,1000000000], m = 1, k = 1输出：1000000000解释：需要等 1000000000 天才能采到花来制作花束 示例 5： 12输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2输出：9 题解：（待补充） 5188. 树节点的第 K 个祖先（困难）给你一棵树，树上有 n 个节点，按从 0 到 n-1 编号。树以父节点数组的形式给出，其中 parent[i] 是节点 i 的父节点。树的根节点是编号为 0 的节点。请你设计并实现 getKthAncestor(int node, int k) 函数，函数返回节点 node 的第 k 个祖先节点。如果不存在这样的祖先节点，返回 -1 。树节点的第 k 个祖先节点是从该节点到根节点路径上的第 k 个节点。 示例： 12345678910111213输入：[&quot;TreeAncestor&quot;,&quot;getKthAncestor&quot;,&quot;getKthAncestor&quot;,&quot;getKthAncestor&quot;][[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]]输出：[null,1,0,-1]解释：TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);treeAncestor.getKthAncestor(3, 1); // 返回 1 ，它是 3 的父节点treeAncestor.getKthAncestor(5, 2); // 返回 0 ，它是 5 的祖父节点treeAncestor.getKthAncestor(6, 3); // 返回 -1 因为不存在满足要求的祖先节点 题解：（待补充） 6月14日 1300. 转变数组后最接近目标值的数组和（中等）给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近 target （最接近表示两者之差的绝对值最小）。如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。请注意，答案不一定是 arr 中的数字。 示例 1： 123输入：arr = [4,9,3], target = 10输出：3解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。 示例 2： 12输入：arr = [2,3,5], target = 10输出：5 示例 3： 12输入：arr = [60864,25176,27249,21296,20204], target = 56803输出：11361 提示： 121 &lt;= arr.length &lt;= 10^41 &lt;= arr[i], target &lt;= 10^5 题解： 其实就是从一个范围中找到一个数。这个范围的下界是0，因为arr[i]&gt;&#x3D;1，所以sum肯定是&gt;&#x3D;1的。上界是arr中的最大值maxNum，因为当value &gt; maxNum时，arr中的元素不会变，得到的sum是一样的。所以就是从[0, maxNum]中找到value。从排序的数组中查找，用二分查找来减少时间复杂度。初始条件 l=0, r=maxNum, mid=(l+r)/2， 判定条件是：当sum(mid)-target &gt; 0（value&#x3D;mid）时，值偏大，r = mid - 1；当sum(mid)-target &lt; 0时，值偏小，l = mid + 1；当sum(mid)-target == 0时mid为所寻找的值。循环条件为l&lt;=r &amp;&amp; sumArr != target。循环中需要用一个minAbs来保存最接近的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344int getSum(vector&lt;int&gt; arr, int value)&#123; int sumArr = 0; for (int i = 0; i &lt; arr.size();i++)&#123; if(arr[i]&lt;=value) sumArr += arr[i]; else sumArr += value; &#125; return sumArr;&#125;int findBestValue(vector&lt;int&gt;&amp; arr, int target) &#123; int maxNum = 0, sumArr = 0; for (int a : arr)&#123; sumArr += a; maxNum = max(maxNum, a); &#125; if(sumArr&lt;=target) return maxNum; int l = 0, r = maxNum, mid; int minAbs = sumArr - target &gt; 0 ? sumArr - target : target - sumArr; int value = maxNum; int diff, abs; while (l &lt;= r &amp;&amp; sumArr != target)&#123; mid = (l + r) / 2; sumArr = getSum(arr, mid);//看value==mid后的和 diff = sumArr - target; if(diff==0)&#123;//找到其中一个 value = min(value, mid); &#125;else if(diff&gt;0)&#123; r = mid - 1; &#125; else&#123;//diff&lt;0 l = mid + 1; &#125; abs = diff &gt; 0 ? diff : -diff; if(abs&lt;minAbs || (abs==minAbs &amp;&amp; mid&lt;value))&#123; value = mid; minAbs = abs; &#125; &#125; return value;&#125; 时间复杂度：O(logc*n)，c为最大值maxNum，n为数组长度。空间复杂度：O(1) 先排序，再从头遍历，当arr[i] &gt; (target-preSum[i]) / (n-i)时，就是不能再增大了，返回剩余的平均值。preSum[i]是 arr[i] 之前的所有数的和。注意小数部分的处理。 1234567891011121314151617181920212223242526int findBestValue(vector&lt;int&gt;&amp; arr, int target)&#123; int maxNum = 0, sumArr = 0; for (int a : arr)&#123; sumArr += a; maxNum = max(maxNum, a); &#125; if(sumArr&lt;=target) return maxNum; sort(arr.begin(), arr.end()); int preSum = 0, n = arr.size(); for (int i = 0; i &lt; n; i++) &#123; int x = (target - preSum) / (n - i); if (x &lt; arr[i]) &#123; double t = ((double)(target - preSum)) / (n - i); if (t - x &gt; 0.5) &#123; return x + 1; &#125; else &#123; return x; &#125; &#125; preSum += arr[i]; &#125; return arr[n - 1];&#125; 时间复杂度：排序O(nlogn)，遍历O(n)，所以是O(nlogn)。空间复杂度：O(1) 6月15日 14. 最长公共前缀（简单）编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 示例 1: 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2: 123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明: 1所有输入只包含小写字母 a-z 。 题解：一位一位比较。 123456789101112131415161718string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string res = &quot;&quot;; bool stop = false; for(int i = 0; !stop; i++)&#123; char cur = strs[0][i]; for(string s:strs)&#123; if(s.size()==i+1)//有一个str已经到最后一位了 stop = true; if(s[i]==cur)&#123; continue; &#125; else return res; &#125; res += cur; &#125; return res;&#125; 时间复杂度：O(m*n)，m 是 strs 中最短字符串的长度，n是字符串列表的长度。空间复杂度：O(1) 6月16日 297. 二叉树的序列化与反序列化（困难）序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 示例: 提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 说明: 不要使用类的成员 &#x2F; 全局 &#x2F; 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。 树的结构： 123456struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; 题解： 按照示例层序遍历，即BFS。可以使用队列来序列化，也可以使用递归。 先序遍历，即DFS。使用栈来系列化，也可以使用递归。 6月17日 1014. 最佳观光组合（中等）给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。返回一对观光景点能取得的最高分。 示例： 123输入：[8,1,5,2,6]输出：11解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11 题解： 暴力（超时） 12345678int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123; int maxScore = 0; for (int i = 0; i &lt; A.size();i++)&#123; for (int j = i + 1; j &lt; A.size();j++) maxScore = max(maxScore, A[i] + A[j] + i - j); &#125; return maxScore;&#125; 时间复杂度：O(n^2)空间复杂度：O(1) 把A[i]+A[j]+i-j分解为两部分：A[i]+i 和 A[j]-j。dpPre[j] = max(dpPre[j-1],A[j-1]+j-1)，表示索引j之前A[i]+i的最大值；dp[i] = max(dp[i-1],dpPre[i-1]+A[i]-i)。但是这需要O(n)的空间复杂度保存之前的最大值。因为dp只用到了之前的一个值，所以可以优化为只用两个 int 来保存前面的状态，遍历时同时更新dpPre和dp。用一个preMax保存j前面A[i]+i的最大值，maxScore保存答案。同时更新两个量，一遍遍历即可。 12345678int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123; int maxScore = 0, preMax = A[0] + 0; for (int j = 1; j &lt; A.size();j++)&#123; maxScore = max(maxScore, preMax + A[j] - j);//更新dp[j] preMax = max(preMax, A[j] + j);//更新下一次j的dpPre[j-1] &#125; return maxScore;&#125; 时间复杂度：O(n)空间复杂度：O(1) 6月18日 1028. 从先序遍历还原二叉树（困难）我们从二叉树的根节点 root 开始进行深度优先搜索。在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。如果节点只有一个子节点，那么保证该子节点为左子节点。给出遍历输出 S，还原树并返回其根节点 root。 示例1: 12输入：&quot;1-2--3--4-5--6--7&quot;输出：[1,2,5,3,4,6,7] 示例2: 12输入：&quot;1-2--3---4-5--6---7&quot;输出：[1,2,5,3,null,6,null,4,null,7] 示例 3： 12输入：&quot;1-401--349---90--88&quot;输出：[1,401,null,349,88,90] 题解：当前节点为T，上一个节点为S，只有两种情况： T 是 S 的左子节点； T 是根节点到 S 这一条路径上（不包括 S，因为题目中规定了如果节点只有一个子节点，那么保证该子节点为左子节点）某一个节点的右子节点。 所以，我们用一个栈保存根节点到当前节点的上一个节点的路径： 当前节点的深度刚好比栈的高度大1：当前节点正好是栈顶节点的左子节点；ps. 深度是从0开始，所以当深度的值和栈高度相等时，就是深度刚好比栈的高度大1 当前节点的深度小于等于栈的高度： 当前节点的深度刚和栈的高度相等：当前节点是栈顶节点右兄弟节点即栈顶节点父节点的右子节点； 当前节点的深度小于栈的高度：当前节点是根节点到栈顶节点路径上某一个节点的右子节点。一直弹出栈顶节点直到满足情况1。 *ps. 当前节点的深度刚和栈的高度相等 即 level=path.size()-1，也是需要弹出栈顶节点一次*12345678910111213141516171819202122232425262728293031TreeNode* recoverFromPreorder(string S) &#123; stack&lt;TreeNode *&gt; path; int pos = 0; while(pos&lt;S.size())&#123; int level = 0; while(S[pos]==&#x27;-&#x27;)&#123; level++; pos++; &#125; int value = 0; while (pos &lt; S.size() &amp;&amp; isdigit(S[pos]))&#123;//取当前节点的值 value = value * 10 + (S[pos] - &#x27;0&#x27;); pos++; &#125; TreeNode *node = new TreeNode(value); if(level==path.size())&#123;//第1种情况 if(!path.empty()) path.top()-&gt;left = node; &#125;else&#123;//第2种情况 while(level!=path.size()) path.pop(); path.top()-&gt;right = node; &#125; path.push(node); &#125; while(path.size()&gt;1) path.pop(); return path.top();&#125; 时间复杂度：O(n)。n为S的长度空间复杂度：O(h)。h为树的高度 6月19日 125. 验证回文串（简单）给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例 2: 12输入: &quot;race a car&quot;输出: false 题解：用一前一后双指针依次往中间遍历，直到指针碰见。可以在开始时用transform()先把字符串全部转换为小写字母，也可以在比较时使用toupper()/tolower()转单个字母。 12345678910111213141516171819bool isPalindrome(string s) &#123; // transform(s.begin(), s.end(), s.begin(), ::tolower); if (s.size() == 0) return true; int idxL = 0, idxR = s.size() - 1; while(idxL&lt;idxR)&#123; while(!isalnum(s[idxL]) &amp;&amp; idxL&lt;idxR) idxL++; while(!isalnum(s[idxR]) &amp;&amp; idxL&lt;idxR) idxR--; if(tolower(s[idxL]) != tolower(s[idxR])) return false; else&#123; idxL++; idxR--; &#125; &#125; return true;&#125; 时间复杂度：O(n)。n为字符串s的长度空间复杂度：O(1) 6月20日 10. 正则表达式匹配（困难）给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 123&#x27;.&#x27; 匹配任意单个字符&#x27;*&#x27; 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 说明: 12s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 1: 12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例 2: 12345输入:s = &quot;aa&quot;p = &quot;a*&quot;输出: true解释: 因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。 示例 3: 12345输入:s = &quot;ab&quot;p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。 示例 4: 12345输入:s = &quot;aab&quot;p = &quot;c*a*b&quot;输出: true解释: 因为 &#x27;*&#x27; 表示零个或多个，这里 &#x27;c&#x27; 为 0 个, &#x27;a&#x27; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 示例 5: 1234输入:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;输出: false 题解： 递归（超时）。需要用到有限状态机的思想。 当p索引的下一个字符是’*’时： 当前字符匹配：当作没有’*‘ || 转移状态，看s的下一位 ||’*‘匹配0个 当前字符不匹配：’*‘匹配0个，p索引向后移动两位 当p索引的下一个字符不是’*‘时。如果当前字符匹配，则都向后移动一位。12345678910111213141516171819202122232425bool matchCore(string s, string p, int idxS, int idxP)&#123; if(idxS==s.size() &amp;&amp; idxP==p.size()) return true; if(idxS&lt;s.size() &amp;&amp; idxP==p.size()) return false; if(p[idxP+1]==&#x27;*&#x27;)&#123;//p索引的下一个字符是&#x27;*&#x27; if(p[idxP]==s[idxS] || (p[idxP]==&#x27;.&#x27; &amp;&amp; idxS&lt;s.size())) //当前字符匹配 return matchCore(s, p, idxS + 1, idxP + 2)//当作没有* || matchCore(s, p, idxS + 1, idxP) // || matchCore(s, p, idxS, idxP + 2);//*匹配0个 else //当前字符不匹配 return matchCore(s, p, idxS, idxP + 2); &#125; if(s[idxS]==p[idxP] || (p[idxP]==&#x27;.&#x27; &amp;&amp; idxS&lt;s.size())) //p索引的下一个字符不是&#x27;*&#x27; return matchCore(s, p, idxS + 1, idxP + 1); return false;&#125;bool isMatch(string s, string p)&#123; return matchCore(s, p, 0, 0);&#125; dp。用 dp[i][j] 表示 s 的前 i 个字符与 p 中的前 j 个字符是否能够匹配。 p[j]不是’*‘ dp[i][j] = dp[i-1][j-1] (s[i] &#x3D;&#x3D; p[j] 含p[j]&#x3D;&#x3D;’.’的情况) false (s[i] !&#x3D; p[j]) p[j]是’*‘ dp[i][j] = dp[i-1][j](匹配s的该位字符) || dp[i][j-2](字母+星号不匹配任何字符) (s[i] &#x3D;&#x3D; p[j-1] s[i] &#x3D;&#x3D; p[j] 含p[j-1]&#x3D;&#x3D;’.’的情况) dp[i][j] = dp[i][j-2] (s[i]!&#x3D;p[j-1]) ps. 需要特别注意字符串的索引是从0开始的，和dp的索引相差1 12345678910111213141516171819202122232425262728293031323334353637bool isMatch(string s, string p)&#123; int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt; &gt; dp(m+1,vector&lt;bool&gt;(n+1)); //初始化很重要！！！ dp[0][0] = true; for (int i = 2; i &lt;= n; i++) &#123; if (p[i-1] == &#x27;*&#x27; &amp;&amp; dp[0][i - 2])&#123; // p[0]不可能是&#x27;\\*&#x27;，因为&#x27;\\*&#x27;必须依附前面的字符。 // p = &quot;a*c*b*a&quot;这种情况，dp[0][2/4/6]都为true dp[0][i] = true; &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if(p[j-1]!=&#x27;*&#x27;)&#123; if(s[i-1]==p[j-1] || p[j-1]==&#x27;.&#x27;) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = false; &#125;else&#123; if(s[i-1]==p[j-2] || p[j-2]==&#x27;.&#x27;)&#123; dp[i][j] = (dp[i - 1][j] || dp[i][j - 2]); &#125; else &#123; dp[i][j] = dp[i][j - 2]; &#125; &#125; &#125; &#125; return dp[m][n];&#125; 6月21日 124. 二叉树中的最大路径和（困难）给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 1: 1234567输入: [1,2,3] 1 / \\ 2 3输出: 6 示例 2: 12345678输入: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7输出: 42 题解：递归。一个节点处于最大路径上时，可能有两种情况： 他是最上层节点，不再父节点走。这时候需要求lANDr：当前节点和左右路径的最大值 他不是最上层，有父节点。这时候需要求lORr：当前节点往左子树还是子树和更大 递归函数返回的是左&#x2F;右子树的最大路径和。同时更新一个保存全局最大路径和的引用maxSum。 12345678910111213141516int getMaxPathSum(TreeNode* root, int &amp;maxSum)&#123; if(root==nullptr) return 0; int lPath = getMaxPathSum(root-&gt;left, maxSum); int rPath = getMaxPathSum(root-&gt;right, maxSum); int lANDr = root-&gt;val + max(0, lPath) + max(0, rPath); int lORr = root-&gt;val + max(0, max(lPath, rPath)); maxSum = max(maxSum, max(lANDr, lORr)); return lORr;&#125;int maxPathSum(TreeNode* root) &#123; int maxSum = INT_MIN; getMaxPathSum(root, maxSum); return maxSum;&#125; 时间复杂度：O(n)，其中 n 是二叉树中的节点个数。对每个节点访问不超过 2 次。空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用层数，最大层数等于二叉树的高度，最坏情况下，二叉树的高度等于二叉树中的节点个数。 第194场周赛 6.215440. 数组异或操作题目难度Easy给你两个整数，n 和 start 。 数组 nums 定义为：nums[i] &#x3D; start + 2*i（下标从 0 开始）且 n &#x3D;&#x3D; nums.length 。 请返回 nums 中所有元素按位异或（XOR）后得到的结果。 示例 1： 输入：n &#x3D; 5, start &#x3D; 0输出：8解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) &#x3D; 8 。 “^” 为按位异或 XOR 运算符。 12345678910int xorOperation(int n, int start) &#123; vector&lt;int&gt; nums(n); for (int i = 0; i &lt; n; i++) nums[i] = start + 2 * i; int res = nums[0]; for (int i = 1; i &lt; n;i++) res ^= nums[i]; return res;&#125; 5441. 保证文件名唯一（中等）给你一个长度为 n 的字符串数组 names 。你将会在文件系统中创建 n 个文件夹：在第 i 分钟，新建名为 names[i] 的文件夹。 由于两个文件 不能 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 (k) 的形式为新文件夹的文件名添加后缀，其中 k 是能保证文件名唯一的 最小正整数 。 返回长度为 n 的字符串数组，其中 ans[i] 是创建第 i 个文件夹时系统分配给该文件夹的实际名称。 示例 1： 1234567输入：names = [&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]输出：[&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]解释：文件系统将会这样创建文件名：&quot;pes&quot; --&gt; 之前未分配，仍为 &quot;pes&quot;&quot;fifa&quot; --&gt; 之前未分配，仍为 &quot;fifa&quot;&quot;gta&quot; --&gt; 之前未分配，仍为 &quot;gta&quot;&quot;pes(2019)&quot; --&gt; 之前未分配，仍为 &quot;pes(2019)&quot; 示例2: 123输入：names = [&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece&quot;]输出：[&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece(4)&quot;]解释：当创建最后一个文件夹时，最小的正有效 k 为 4 ，文件名变为 &quot;onepiece(4)&quot;。 示例 3： 123输入：names = [&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido&quot;,&quot;kaido(1)&quot;]输出：[&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido(2)&quot;,&quot;kaido(1)(1)&quot;]解释：注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。 题解： 12345678910111213141516171819202122vector&lt;string&gt; getFolderNames(vector&lt;string&gt;&amp; names) &#123; unordered_map&lt;string, int&gt; fileMap; vector&lt;string&gt; res; for (int i = 0; i &lt; names.size(); i++) &#123; int tmp = fileMap[names[i]]; //如果该key不存在，会自动创建一个&#123;key,0&#125;的插入map，并返回0 if (tmp == 0) &#123;//文件名不存在 res.push_back(names[i]); fileMap[names[i]] = 1; &#125; else &#123;//文件名已存在 while (fileMap.count(names[i]+&quot;(&quot;+to_string(tmp)+&quot;)&quot;)) tmp++; res.push_back(names[i]+&quot;(&quot;+to_string(tmp)+&quot;)&quot;); fileMap[names[i]] = tmp; fileMap[names[i]+&quot;(&quot;+to_string(tmp)+&quot;)&quot;] = 1; &#125; &#125; return res;&#125; 5442. 避免洪水泛滥（中等）你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 n 个湖泊下雨的时候，如果第 n 个湖泊是空的，那么它就会装满水，否则这个湖泊会发生洪水。你的目标是避免任意一个湖泊发生洪水。 给你一个整数数组 rains ，其中：rains[i] &gt; 0 表示第 i 天时，第rains[i]个湖泊会下雨。rains[i] &#x3D;&#x3D; 0 表示第 i 天没有湖泊会下雨，你可以选择一个湖泊并抽干这个湖泊的水。 请返回一个数组 ans ，满足：ans.length &#x3D;&#x3D; rains.length如果 rains[i] &gt; 0 ，那么ans[i] &#x3D;&#x3D; -1 。如果 rains[i] &#x3D;&#x3D; 0 ，ans[i] 是你第 i 天选择抽干的湖泊。如果有多种可行解，请返回它们中的任意一个 。如果没办法阻止洪水，请返回一个空的数组。 请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生（详情请看示例 4）。 示例 1： 1234567输入：rains = [1,2,3,4]输出：[-1,-1,-1,-1]解释：第一天后，装满水的湖泊包括 [1]第二天后，装满水的湖泊包括 [1,2]第三天后，装满水的湖泊包括 [1,2,3]第四天后，装满水的湖泊包括 [1,2,3,4]没有哪一天你可以抽干任何湖泊的水，也没有湖泊会发生洪水。 示例 2： 123456789输入：rains = [1,2,0,0,2,1]输出：[-1,-1,2,1,-1,-1]解释：第一天后，装满水的湖泊包括 [1]第二天后，装满水的湖泊包括 [1,2]第三天后，我们抽干湖泊 2 。所以剩下装满水的湖泊包括 [1]第四天后，我们抽干湖泊 1 。所以暂时没有装满水的湖泊了。第五天后，装满水的湖泊包括 [2]。第六天后，装满水的湖泊包括 [1,2]。可以看出，这个方案下不会有洪水发生。同时， [-1,-1,1,2,-1,-1] 也是另一个可行的没有洪水的方案。 示例 3： 1234输入：rains = [1,2,0,1,2]输出：[]解释：第二天后，装满水的湖泊包括 [1,2]。我们可以在第三天抽干一个湖泊的水。但第三天后，湖泊 1 和 2 都会再次下雨，所以不管我们第三天抽干哪个湖泊的水，另一个湖泊都会发生洪水。 示例 4： 123输入：rains = [69,0,0,0,69]输出：[-1,69,1,1,-1]解释：任何形如 [-1,69,x,y,-1], [-1,x,69,y,-1] 或者 [-1,x,y,69,-1] 都是可行的解，其中 1 &lt;= x,y &lt;= 10^9 示例 5： 123输入：rains = [10,20,20]输出：[]解释：由于湖泊 20 会连续下 2 天的雨，所以没有没有办法阻止洪水。 题解：lastRainDay保存了湖号(key)到目前的最后一天下雨的日期。set s 保存了前面未下雨的日期。 碰到rains[i]&#x3D;&#x3D;0后（没下雨），把未下雨的天数先存到s里，继续往后。 如果下雨 湖lakeNum未满，就更新lastRainDay[lakeNum]=i和res[i]=-1 湖lakeNum满了，就从未下雨的日期set s 中取出 湖lakeNum 最后下雨日期lastRainDay[lakeNum] 之后最近的未下雨的日期，在lastRainDay[lakeNum]当天把lakeNum抽干。 简单来说，就是在碰到水满之后，把最前面没下雨的一天用来抽该湖上次下的雨。（当然，抽水的日期要在下雨日期之后） 12345678910111213141516171819202122232425262728293031vector&lt;int&gt; avoidFlood(vector&lt;int&gt;&amp; rains) &#123; set&lt;int&gt; s; vector&lt;int&gt; res(rains.size(), 1); unordered_map&lt;int, int&gt; lastRainDay;//key是第i天下雨的湖号码，val是i for (int i = 0; i &lt; rains.size(); i++) &#123; int lakeNum = rains[i];//第i天下雨的湖号 //第i天没下雨 if (lakeNum == 0) &#123; s.insert(i); continue; &#125; //第i天下雨了 res[i] = -1; if (lastRainDay.find(lakeNum) == lastRainDay.end()) &#123;//湖里没水 lastRainDay[lakeNum] = i; continue; &#125; //湖里有水 auto lastDay = lastRainDay[lakeNum]; auto it = s.upper_bound(lastDay); if (it == s.end()) &#123; return vector&lt;int&gt;(); &#125; res[*it] = lakeNum; lastRainDay[lakeNum] = i; s.erase(it); &#125; return res;&#125; 6月22日 面试题 16.18. 模式匹配（中等）你有两个字符串，即pattern和value。 pattern字符串由字母”a”和”b”组成，用于描述字符串中的模式。例如，字符串”catcatgocatgo”匹配模式”aabab”（其中”cat”是”a”，”go”是”b”），该字符串也匹配像”a”、”ab”和”b”这样的模式。但需注意”a”和”b”不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。 示例 1： 12输入： pattern = &quot;abba&quot;, value = &quot;dogcatcatdog&quot;输出： true 示例 2： 12输入： pattern = &quot;abba&quot;, value = &quot;dogcatcatfish&quot;输出： false 示例 3： 12输入： pattern = &quot;aaaa&quot;, value = &quot;dogcatcatdog&quot;输出： false 示例 4： 123输入： pattern = &quot;abba&quot;, value = &quot;dogdogdogdog&quot;输出： true解释： &quot;a&quot;=&quot;dogdog&quot;,b=&quot;&quot;，反之也符合规则 题解：枚举模式a和b的长度lA 和 lB，在看该长度下的substr是否满足条件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273bool patternMatching(string pattern, string value) &#123; if(pattern==&quot;&quot; &amp;&amp; value!=&quot;&quot;) return false; if (pattern.size() == 1 || (pattern==&quot;&quot; &amp;&amp; value==&quot;&quot;)) return true; int cntA = 0, cntB = 0; for(char c:pattern)&#123;//统计pattern里种类的数量 if(c==&#x27;a&#x27;) cntA++; if(c==&#x27;b&#x27;) cntB++; &#125; if(cntA==0 || cntB==0)&#123;//只有1个模式 if(value.size()%pattern.size()!=0) return false; int n = pattern.size(); int nSub = value.size() / pattern.size(); for (int i = 1; i &lt; n; i++) &#123; int idx = i * nSub; for (int j = 0; j &lt; nSub;j++)&#123; if(value[j]!=value[idx+j]) return false; &#125; &#125; return true; &#125; else &#123; //2个模式 if(value.size()==0) return false; if(cntA==1 || cntB==1) return true; //枚举每个模式的字符串长度 for (int lA = 0; lA &lt;= value.size() / cntA; lA++) &#123; for (int lB = 0; lB &lt;= value.size() / cntB;lB++)&#123; if(lA*cntA + lB*cntB != value.size()) continue; map&lt;char, string&gt; pMap; int idxA = 0, idxB = 0; int a = 0, b = 0; while (pattern[a++] != &#x27;a&#x27;) &#123; idxA += lB; &#125; while(pattern[b++]!=&#x27;b&#x27;) idxB += lA; pMap[&#x27;a&#x27;] = value.substr(idxA, lA); pMap[&#x27;b&#x27;] = value.substr(idxB, lB); //按模式的长度lA和lB验证是否匹配 int pos = 0; for (int i = 0; i &lt; pattern.size(); i++) &#123; char cur = pattern[i]; int l = cur == &#x27;a&#x27; ? lA : lB; if (pMap[cur] == value.substr(pos,l))&#123; pos += l; continue; &#125; &#125; if(pos==value.size()) return true; &#125; &#125; return false; &#125;&#125; 6月23日 67. 二进制求和（简单）给你两个二进制字符串，返回它们的和（用二进制表示）。输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 12输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot; 示例 2: 12输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot; 题解： 数位法。和做大数乘法一样，处理每一位和进位。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162string addBinary(string a, string b) &#123; int carry = 0; int i = a.size() - 1, j = b.size() - 1; string endDigital = &quot;&quot;; while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; string curDigit = &quot;&quot;; if(carry == 0)&#123; if(a[i]==&#x27;1&#x27; &amp;&amp; b[j]==&#x27;1&#x27;)&#123; curDigit = &quot;0&quot;; carry = 1; &#125;else if((a[i]==&#x27;1&#x27; &amp;&amp; b[j]==&#x27;0&#x27;) || (a[i]==&#x27;0&#x27; &amp;&amp; b[j]==&#x27;1&#x27;))&#123; curDigit = &#x27;1&#x27;; &#125;else&#123; curDigit = &#x27;0&#x27;; &#125; &#125;else&#123; if(a[i]==&#x27;1&#x27; &amp;&amp; b[j]==&#x27;1&#x27;)&#123; curDigit = &quot;1&quot;; &#125;else if((a[i]==&#x27;1&#x27; &amp;&amp; b[j]==&#x27;0&#x27;) || (a[i]==&#x27;0&#x27; &amp;&amp; b[j]==&#x27;1&#x27;))&#123; curDigit = &#x27;0&#x27;; &#125;else&#123; curDigit = &#x27;1&#x27;; carry = 0; &#125; &#125; endDigital = curDigit + endDigital; i--; j--; &#125; while(i&gt;=0)&#123; if(carry==1)&#123; if(a[i]==&#x27;0&#x27;)&#123; endDigital = &#x27;1&#x27; + endDigital; carry = 0; &#125;else&#123; endDigital = &#x27;0&#x27; + endDigital; &#125; &#125;else&#123; endDigital = a[i] + endDigital; &#125; i--; &#125; while(j&gt;=0)&#123; if(carry==1)&#123; if(b[j]==&#x27;0&#x27;)&#123; endDigital = &#x27;1&#x27; + endDigital; carry = 0; &#125;else&#123; endDigital = &#x27;0&#x27; + endDigital; &#125; &#125;else&#123; endDigital = b[j] + endDigital; &#125; j--; &#125; if(carry == 1)&#123; endDigital = &quot;1&quot; + endDigital; &#125; return endDigital;&#125; 其实可以在短的前面添0补齐，就会方便一些。而且也可以通过 %2, /2 来得到更简洁的代码（前提是允许使用加减乘除）。 1234567891011121314151617181920string addBinary(string a, string b) &#123; string res; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); int n = max(a.size(), b.size()), carry = 0; for (int i = 0; i &lt; n; i++) &#123; carry += i &lt; a.size() ? (a[i] == &#x27;1&#x27;) : 0; carry += i &lt; b.size() ? (b[i] == &#x27;1&#x27;) : 0; res.push_back((carry % 2) ? &#x27;1&#x27; : &#x27;0&#x27;); carry /= 2; &#125; if (carry) &#123; res.push_back(&#x27;1&#x27;); &#125; reverse(res.begin(), res.end()); return res;&#125; 时间复杂度O(l)。l为最长的位数。空间复杂度O(1)。 先转为10进制运算后再转回来。但是如果有很多位，就会导致溢出。（代码略） 6月24日 16. 最接近的三数之和（中等）给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 示例： 123输入：nums = [-1,2,1,-4], target = 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 题解：排序+双指针。类似的题：15. 三数之和 暴力法的话时间复杂度是O(n^3)。我们需要想办法来降低时间复杂度：先枚举第一个数nums[i]，再剩下nums中找和最接近target-nums[i]。经过排序之后，可以用两数和与target-nums[i]的大小关系来决定两数和的变化趋势。 这样寻找后两个数是，只需遍历一遍，相当于把O(n^2)的时间降到了O(n)。 123456789101112131415161718192021222324int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size()==3) return nums[0] + nums[1] + nums[2]; sort(nums.begin(), nums.end()); int n = nums.size(); int diff = INT_MAX; for (int i = 0; i &lt; n-2;i++)&#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) //防止重复元素 continue; int find = target - nums[i]; int idxL = i + 1, idxR = n - 1; while (idxL &lt; idxR) &#123; int sumLR = nums[idxL] + nums[idxR]; if(sumLR == find) //如果相等，直接返回target return target; diff = abs(diff) &lt; abs(sumLR - find) ? diff : (sumLR - find);//更新最小差值 if (sumLR &gt; find) idxR--; else idxL++; &#125; &#125; return target + diff;&#125; 时间复杂度：O(n^2)。排序需要O(nlogn)，算法主体O(n^2)。空间复杂度：如果nums可以修改，则只需要排序算法的空间复杂度。如果nums不能修改，则需要O(n)来存储nums。 6月25日 [139. 单词拆分（中等）(https://leetcode-cn.com/problems/word-break/)给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 123输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。 示例 2： 1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。 注意你可以重复使用字典中的单词。 示例 3： 12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 题解： 存一个首字母map，用递归的方法查找。超时。1234567891011121314151617181920212223242526272829303132333435363738bool wordBreakCore(string s, vector&lt;string&gt;&amp; wordDict, int idx, unordered_map&lt;char, vector&lt;string&gt; &gt; &amp;alphaMap)&#123; if(idx==s.size()) return true; if(alphaMap.find(s[idx])==alphaMap.end()) return false; bool find = false; int initIdx = idx; for (string str : alphaMap[s[idx]]) &#123; idx = initIdx; if (idx + str.size() &gt; s.size()) continue; int nxtIdx = idx + str.size(); for (int i = 0; i &lt; str.size(); i++) &#123; if(str[i]!=s[idx]) break; else idx++; &#125; if(idx==nxtIdx) find = wordBreakCore(s, wordDict, idx, alphaMap); if(find) return true; &#125; return find;&#125;bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)&#123; unordered_map&lt;char, vector&lt;string&gt; &gt; alphaMap; for (auto word : wordDict) alphaMap[word[0]].push_back(word); return wordBreakCore(s, wordDict, 0, alphaMap);&#125; dp。dp[i]=dp[j] &amp;&amp; check(s[j..i−1])其中 dp[i] 表示字符串 s 前 i 个字符组成的字符串 s[0..i-1] 是否能被空格拆分成若干个字典中出现的单词。check(s[j..i-1]) 表示子串 s[j..i-1] 是否出现在字典中。可以记录set中单词的最大长度和最小长度，缩小j的遍历范围。但是不会减小时间复杂度 123456789101112131415161718192021bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)&#123; unordered_set&lt;string&gt; wordSet; int minLength = 0, maxLength = INT_MAX; for (string word : wordDict)&#123; wordSet.insert(word); minLength = word.size() &gt; minLength ? minLength : word.size(); maxLength = word.size() &lt; maxLength ? maxLength : word.size(); &#125; vector&lt;bool&gt; dp(s.size() + 1); dp[0] = true; for (int i = 1; i &lt;= s.size();i++)&#123; for (int j = max(0,i-maxLength); i-j&gt;=minLength;j++)&#123; if(dp[j] &amp;&amp; wordSet.find(s.substr(j,i-j))!=wordSet.end())&#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.size()];&#125; 时间复杂度：O(n^2)。n为字符串s的长度。空间复杂度：O(max{m,n})。m为wordDict的长度，n为s的长度。 6月26日 面试题 02.01. 移除重复节点（简单）编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。 示例1: 12输入：[1, 2, 3, 3, 2, 1]输出：[1, 2, 3] 示例2: 12输入：[1, 1, 1, 1, 2]输出：[1, 2] 题解：用一个哈希表(unordered_set)保存已有元素。 1234567891011121314151617181920212223ListNode* removeDuplicateNodes(ListNode* head) &#123; if(head==nullptr || head-&gt;next==nullptr) return head; unordered_set&lt;int&gt; valSet; ListNode *lastNode = head; ListNode *cur = head-&gt;next; valSet.insert(head-&gt;val); while (cur != nullptr) &#123; if(valSet.find(cur-&gt;val) == valSet.end())&#123;//非重复节点 valSet.insert(cur-&gt;val); lastNode-&gt;next = cur; lastNode = lastNode-&gt;next; cur = cur-&gt;next; &#125;else&#123;//重复节点 cur = cur-&gt;next; &#125; &#125; lastNode-&gt;next = cur;//nullptr return head;&#125; 时间复杂度：O(n)空间复杂度：O(n) ps. 在不允许用额外空间的情况下，可以用两重循环。时间O(n^2) ，空间o(1)。 6月27日 41. 缺失的第一个正数给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。 示例 1: 12输入: [1,2,0]输出: 3 示例 2: 12输入: [3,4,-1,1]输出: 2 示例 3: 12输入: [7,8,9,11,12]输出: 1 提示： 1你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。 题解： 排序之后用二分查找从1开始找，可以达到O(mlogn)的时间复杂度。m是缺失正整数的大小。（代码略） 用O(n)的时间把数组存入unordered_set，在从1开始查找，时间复杂度为O(max{m,n})，m是缺失正整数的大小，n是数组的长度。但是就得用O(n)的空间复杂度。（不符合要求，但是还是通过了哈哈哈） 123456789101112131415161718int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; unordered_set&lt;int&gt; numSet; int maxNum = INT_MIN; for (int n : nums) &#123; numSet.insert(n); maxNum = max(maxNum, n); &#125; for (int i = 1; i &lt; maxNum;i++)&#123; if(numSet.find(i)==numSet.end()) return i; &#125; return maxNum &lt; 0 ? 1 : maxNum + 1;&#125; 如果没有缺失，数组从1开始存放元素，则nums[i]==i+1。可以在遍历的时候把元素从idx==0开始放正确位置对应的数，再次遍历时第一个元素与位置不对应的索引即是最小的正整数。 123456789101112131415161718int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; for (int i = 0; i &lt; nums.size();i++)&#123; while(nums[i]!=i+1)&#123; if(nums[i]&lt;=0 || nums[i]&gt;nums.size() || nums[i] == nums[nums[i] - 1]) //如果 nums[i] == nums[rightPos] 相等，就会无限交换下去。 break; int rightPos = nums[i] - 1;//这个要在if后面，因为当nums[i]太大时，容易溢出 nums[i] = nums[rightPos]; nums[rightPos] = rightPos + 1; &#125; &#125; for (int i = 0; i &lt; nums.size(); i++)&#123; if(nums[i] != (i+1)) return i + 1; &#125; return nums.size() + 1;&#125; 第29场双周赛（6月27日）5432. 去掉最低工资和最高工资后的工资平均值（简单）给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。 示例 1： 1234输入：salary = [4000,3000,1000,2000]输出：2500.00000解释：最低工资和最高工资分别是 1000 和 4000 。去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500 题解： 12345678910double average(vector&lt;int&gt;&amp; salary) &#123; int maxS = INT_MIN, minS = INT_MAX; int sum = 0; for(int s:salary)&#123; sum += s; maxS = max(maxS, s); minS = min(minS, s); &#125; return (double)(sum - maxS - minS) / (salary.size() - 2);&#125; 5433. n 的第 k 个因子（中等）给你两个正整数 n 和 k 。如果正整数 i 满足 n % i &#x3D;&#x3D; 0 ，那么我们就说正整数 i 是整数 n 的因子。考虑整数 n 的所有因子，将它们 升序排列 。请你返回第 k 个因子。如果 n 的因子数少于 k ，请你返回 -1 。 示例 1： 123输入：n = 12, k = 3输出：3解释：因子列表包括 [1, 2, 3, 4, 6, 12]，第 3 个因子是 3 。 题解： 123456789101112int kthFactor(int n, int k) &#123; vector&lt;int&gt; factors; for (int i = 1; i &lt;= n; i++) &#123; if(n%i==0) factors.push_back(i); &#125; if(factors.size()&lt;k) return -1; return factors[k - 1];&#125; 5434. 删掉一个元素以后全为 1 的最长子数组（中等）给你一个二进制数组 nums ，你需要从中删掉一个元素。请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。如果不存在这样的子数组，请返回 0 。 示例 1： 123输入：nums = [1,1,0,1]输出：3解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。 示例 2： 123输入：nums = [0,1,1,1,0,1,1,0,1]输出：5解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。 示例 3： 123输入：nums = [1,1,1]输出：2解释：你必须要删除一个元素。 示例 4： 12输入：nums = [1,1,0,0,1,1,1,0,1]输出：4 示例 5： 12输入：nums = [0,0,0]输出：0 题解：找到0，之后双指针分别往前和往后直到碰到下一个0。 123456789101112131415161718int longestSubarray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int sum = 0; for (int i = 0; i &lt; n; ++i) sum += nums[i]; if (sum == n) return n-1; int res = 0; for (int i = 0; i &lt; n; ++i) &#123; if (nums[i] == 1) continue; int L = i, R = i; while (L-1 &gt;= 0 &amp;&amp; nums[L-1] == 1) -- L; while (R+1 &lt; n &amp;&amp; nums[R+1] == 1) ++ R; res = max(res, R-L); &#125; return res;&#125; 6月28日 209. 长度最小的子数组（中等）给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。 示例: 123输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 题解：双指针。i是左边的指针，j是右边的指针。sum&lt;s时，j++ ，sum&gt;=s时，i++。 12345678910111213141516171819int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int i = 0, j = 0, sum = nums[0], minSub = INT_MAX; while(j&lt;nums.size())&#123; if(sum&lt;s)&#123; j++; if(j&lt;nums.size()) sum += nums[j]; &#125;else&#123; minSub = min(minSub, j - i + 1); sum -= nums[i]; i++; &#125; if(minSub==1) return 1; &#125; return minSub == INT_MAX ? 0 : minSub;&#125; 时间复杂度O(n)空间复杂度O(1) 6月29日 215. 数组中的第K个最大元素（中等）在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 12输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 1你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 题解： 排序。时间复杂度O(nlogn)。12345678910int findKthLargest(vector&lt;int&gt; &amp;nums, int k) &#123; int size = nums.size(); //默认的升序 sort(begin(nums), end(nums)); return nums[size - k]; // 降序 // sort(begin(nums), end(nums), greater&lt;int&gt;()); // return nums[k-1]; &#125; 快排的partition函数（可以看这篇博客中的算法类例题——排序）。每次可以找到一个正确的位置i，当k&gt;i时，在 i 的右边找；当k&lt;i时，在 i 的左边找；当k==i时，直接输出nums[i]。123456789101112131415161718192021222324252627282930313233343536int Partition(vector&lt;int&gt; &amp;arr, int start, int end)&#123; if(arr.size()&lt;2 || start&lt;0 || end&gt;arr.size()) return -1; int pivot = arr[start]; //除了选择第一个，也可以随机选择一个元素作为pivot while (start&lt;end) &#123; while(start&lt;end &amp;&amp; arr[end]&gt;=pivot) end--; arr[start] = arr[end]; while (start &lt; end &amp;&amp; arr[start] &lt;= pivot) start++; arr[end] = arr[start]; &#125; arr[start] = pivot; return start;&#125;int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); int left = 0; int right = len - 1; int target = len - k; while (left&lt;right) &#123; int index = Partition(nums, left, right); if (index == target) &#123; return nums[index]; &#125; else if (index &lt; target) &#123; left = index + 1; &#125; else &#123; right = index - 1; &#125; &#125; return nums[left];&#125; 时间复杂度：O(n)。证明过程可以参考 算法导论 9.2：期望为线性的选择算法空间复杂度：O(1) 6月30日 剑指 Offer 09. 用两个栈实现队列用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 1234输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1] 题解：一个栈入，一个栈出。当要插入数据时，直接插入入栈；当要取出数据时，如果出栈不为空，则从入栈依次取出放入出栈，直到入栈为空。这样就能保证后进先出。 123456789101112131415161718192021222324252627282930class CQueue &#123; stack&lt;int&gt; inputStack, outputStack;public: CQueue() &#123; while(!inputStack.empty()) inputStack.pop(); while(!outputStack.empty()) outputStack.pop(); &#125; void appendTail(int value) &#123; inputStack.push(value); &#125; int deleteHead() &#123; if(outputStack.empty())&#123; while(!inputStack.empty())&#123; outputStack.push(inputStack.top()); inputStack.pop(); &#125; &#125; if(outputStack.empty()) return -1; else&#123; int output = outputStack.top(); outputStack.pop(); return output; &#125; &#125;&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/Algorithm/"}],"tags":[{"name":"Leetcode daily","slug":"Leetcode-daily","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Leetcode-daily/"}]},{"title":"自动驾驶学习笔记","slug":"autonomousDriving","date":"2020-05-29T04:45:00.000Z","updated":"2020-08-17T07:34:37.898Z","comments":true,"path":"2020/05/29/autonomousDriving/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2020/05/29/autonomousDriving/","excerpt":"Apollo入门课程无人驾驶概览自动驾驶等级 Base level 驾驶员完全控制车辆 Driver Assistance Partial Automation Conditional Automation No Human Interference Full Automation","text":"Apollo入门课程无人驾驶概览自动驾驶等级 Base level 驾驶员完全控制车辆 Driver Assistance Partial Automation Conditional Automation No Human Interference Full Automation 无人车的运作方式 硬件平台 控制器区域网络(Controller Area Network, CAN) GPS IMU Lidar：(Light)光波 Radar：(Radio)无线电波 软件平台 实时操作系统(RTOS): ubuntu+apollo 去中心化：多Node Protobuf替代ROS Messagr增加兼容性 运行时框架 应用程序模块层 云服务 HD Map Simulation Data Platform Security OTA(空中软件升级) DuerOS(智能语音系统) 高精度地图ROI可以提高精度和寻找速度Apollo高清地图格式：OpenDRIVE 高清地图组成 数据采集 数据处理 对象检测 手动验证 地图发布 定位 GNSS(Gloval Navigation Satellite System) RTK(实时运动定位) Satellite Control Station Receivers ps：GPS是GNSS的一种 惯性导航(Inertial Navigation) 可达1000Hz 容易飘 激光雷达Lidar ICP 滤波算法 直方图滤波Histogram Filter (有时候称Sum of Squared Difference, SSD) 卡尔曼滤波 粒子滤波 视觉定位 优点：图像易获得 缺点：没有三维信心 Apollo定位 GPS、IMU、LiDar 感知 检测 Detection 分类 Classification 跟踪 Tracking 语义分割 Segmentation 计算机视觉 摄像头图像 LiDAR图像 机器学习 监督学习 无监督学习 半监督学习 强化学习 检测与分类 YOLO SSD Apollo感知 ROI在高精度地图 Detection Network 检测和跟踪 YOLO车道线检测、目标跟踪 传感器比较 感知融合策略： 卡尔曼滤波 同步融合 异步融合 预测 基于模型的预测 数据驱动预测 Apollo预测基于车道序列方法神经网络预测车道序列结合车辆物理元素，轨迹生成：可以用多项式拟合 规划输入： map location destination搜索：讲地图转化为图（graph） 搜索算法A* 轨迹评估 无障碍 乘客舒服 轨迹实际可行的 轨迹应该遵守交通规则 轨迹选择成本函数(cost function)。不同路况、场景的成本函数不同 Frenet坐标系 路径-速度解耦规则 路径规划 速度规划 ST图 障碍物阻挡的ST图：法律限制、速度限制、汽车物理限制等等来筛选曲线 二次规划来平滑轨迹 路径规划—&gt;ST图轨迹选择—&gt;二次规划轨迹平滑 Lattice规划ST轨迹（纵向偏移）SL轨迹（横向偏移） ST轨迹的3组状态： 巡航(Cruising)：定速行驶 跟随(Following) 停止(Stoping) SL轨迹的状态： SL曲线一阶二阶导数都应该为零 控制 比例积分微分控制PID P——proportional I——integral D——derivative 线性二次调节器LQR Apollo用来横向控制 模型预测控制MPC（精确，但是慢、难实现） 建立车辆模型 车辆物理运动模型 预测 使用优化引擎计算有限时间范围内的控制输入 执行第一组控制输入 Apollo进阶课程定位 GNSS 激光点云 视觉 捷连惯性导航及组合导航 GNSS需要4个卫星的信号才能定位：因为GPS接收器（比如手机）的时间是不准的，所以把t看作未知数。或者说需要加多一颗来减小误差。 常用坐标系 地心惯性坐标系（ECI）i系：地心为原点，Z轴指向北极，XY轴位于赤道平面，分别指向两颗恒星。IMU使用这个坐标系 地心地固坐标系（ECEF）e系：地心为原点，Z轴指向北极，X轴位于赤道平面和格林威治子午面的交线上，Y轴在赤道平面，满足右手法则。 当地水平坐标系（n系）：东-北-天(E-N-U)和北-东-地(N-E-D)。导航坐标系 通用横轴墨卡托投影(UTM投影) 车体坐标系 相机坐标系 激光雷达坐标系 载波定位：RTK、PPP 点云的定位 基于Histogram Filter的激光点云定位 SSD(Sum of Squared Difference) 视觉定位技术 算法流程 特征匹配 粒子滤波 捷联惯性导航系统： 初始对准 惯导解算 组合导航： 高精度地图主流通用格式规范： NDS(Navigation Data Standard) OpenDrive OMP公司： HERE MobilEye Google Waymo TomTom地图制作流程： 数据采集 数据处理 点云拼接 底图产生 元素识别 基于深度学习的识别 基于深度学习的点云分类 人工验证 车道线、路沿 信号灯、标志牌 虚拟道路、逻辑关系 感知 传感器标定算法 感知算法 Lidar感知（检测） 启发式方法：Ncut DL方法：CNNSeg 视觉 DL检测和分割 跟踪，2d-to-3d，多相机融合 红绿灯（感知与地图交互） Radar感知（检测） Ultrasonic感知（检测） 规划运动规划方法 环境建模 RRT Lattice 自动驾驶的现代方法 Darpa Challenge Approaches Lattice in Frenet Frame Spiral, Polynomial and Splines Functional Optimization 路径限制类型 Local Constraint，例如避免和障碍物碰撞 Differential Constraint，比如边界曲率 Global Constraint，比如最短路径 自动驾驶中传统的轨迹生成方法： Configuration Space Lattice approach RRT based approach 改进和现在的方法 Lattice in Frenet Frame Splines Functional Optimization 控制自动驾驶系统是否满足性能要求可以从三个角度去评测 时域 频域 discrete domain（离散域） PID控制：PID控制的基础是比例控制；积分控制可消除稳态误差，但可能增加超调；微分控制可加快大惯性系统响应速度以及减弱超调趋势。 比例单元P 积分单元I 微分单元D 控制器的类型： 开环控制 前馈环控制 Optimal Control（优化控制） Adaptive Control（自适应控制） Robust Control（鲁棒性控制） LQR&#x2F;LTR控制器 后馈环控制 传感器融合计算机视觉、激光雷达、毫米波雷达的比较 多传感器信息融合总结","categories":[{"name":"robot","slug":"robot","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/robot/"}],"tags":[{"name":"autonomous driving","slug":"autonomous-driving","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/autonomous-driving/"}]},{"title":"SOUSIC的algorithm总结","slug":"algorithm","date":"2020-05-25T08:00:00.000Z","updated":"2020-10-16T07:13:15.716Z","comments":true,"path":"2020/05/25/algorithm/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2020/05/25/algorithm/","excerpt":"一、算法基础 大部分是Leecode中的典型题目，也有笔试中的真题和剑指Offer中的题目。题解使用C++，代码均由本人在参考题解之后所写。相关github","text":"一、算法基础 大部分是Leecode中的典型题目，也有笔试中的真题和剑指Offer中的题目。题解使用C++，代码均由本人在参考题解之后所写。相关github 1.1 常用数据结构1.1.1 链表链表又分为单链表（线性链表）、双向链表、循环链表 1.1.2 栈和队列栈：后进先出（last-in,first-out,LIFO）队列：先进先出（first-in,first-out,FIFO）双端队列：一种特殊的队列，两端都可以进出 1.1.3 二叉树是树型结构的一种特殊形式。二叉树中，刷题中用到的有 二叉搜索树/二叉查找树，即左子树中的结点都比父结点小，右子树中的结点都比父结点大。 平衡树二叉树（AVL树），就是在二叉树的基础上，若树中每棵子树都满足其左子树和右子树的深度差都不超过 1，则这棵二叉树就是平衡二叉树。 按照访问结点顺序的不同，可以将二叉树的遍历分为 前序遍历、中序遍历、后序遍历。 1.1.4 图图是由顶点和边构成的数据结构，一般来说，顶点表示的是数据，边表示数据之间的联系。图可以简单的分为有向图和无向图。可以用二维数组来存储一个图。 1.1.5 堆 大根堆 小根堆 1.2 时间复杂度、空间复杂度算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，把算法的执行时间记为T(n)&#x3D;O(f(n))，他们的增长率相同，称做算法的渐进时间复杂度，简称时间复杂度。相似的，空间复杂度S(n)&#x3D;O(f(n))用来度量算法所需的存储空间。 1.3 排序（Sorting）、查找&#x2F;搜索（Search）1.3.1 排序常用的八大排序： 插入排序 希尔排序 选择排序 冒泡排序 快速排序 堆排序 归并排序 基数排序 1.3.2 查找&#x2F;搜索顺序查找：一般情况下步长为1。根据不同的要求，会设置不同的步长。时间复杂度为O(n)。二分查找（Binary Search，又叫折半查找）：每次都与一个中点 mid = (low+hight)/2 相比较，时间复杂度为O(logn)。二叉搜索/查找树：见1.1.3。中序遍历二叉搜索树可以有序的输出关键字。树的遍历：前序遍历（根、左、右）、中序遍历（左、根、右）、后序遍历（左、右、根）。广度优先搜索（BFS）：类似于树的层序遍历，先访问最近一层所有的结点，再访问下一层的。深度优先（DFS）：类似于树的先序遍历，直到没有下一个结点才返回父结点。 1.4 递归简单来说，递归的基本思想就是自己调用自己，这样就把问题变成了更小的子问题。需要注意的是，递归函数中需要设置一个终止条件，以保证子问题最小时不再往下递归。 1.5 分治分治策略中，需要递归的求解一个问题，在每层递归中会用到三个步骤[算法导论]： 分解(Divide)：将原问题划分为规模更小的子问题。 解决(Conquer)：递归的求解子问题。如果子问题足够小，停止递归直接求解。 合并(Combine)：将子问题的解合成原问题的解。 二、数据结构类例题主要从Leetcode的题中选出的代表性例题，也包括笔试或者其他资料上看到的比较好的题目。解答使用的cpp。 2.1 栈单调栈1. 739. 每日温度（中等）根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示： 1气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 题解：维护一个单调递减的栈，栈中元素为温度值的索引。当前温度比栈顶索引温度低时，直接进栈；当前温度比栈顶索引温度高时，两个索引之间的差就是栈顶索引值所求结果。视频讲解 1234567891011121314vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123; int n = T.size(); vector&lt;int&gt; res(n,0); stack&lt;int&gt; s; for (int i = 0; i &lt; n; ++i) &#123; while (!s.empty() &amp;&amp; T[i] &gt; T[s.top()]) &#123; int previousIndex = s.top(); res[previousIndex] = i - previousIndex; s.pop(); &#125; s.push(i); &#125; return res;&#125; 时间复杂度O(n)。空间复杂度O(n)。 两个栈实现队列剑指 Offer 09. 用两个栈实现队列用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 1234输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1] 题解：一个栈入，一个栈出。当要插入数据时，直接插入入栈；当要取出数据时，如果出栈不为空，则从入栈依次取出放入出栈，直到入栈为空。这样就能保证后进先出。 123456789101112131415161718192021222324252627282930class CQueue &#123; stack&lt;int&gt; inputStack, outputStack;public: CQueue() &#123; while(!inputStack.empty()) inputStack.pop(); while(!outputStack.empty()) outputStack.pop(); &#125; void appendTail(int value) &#123; inputStack.push(value); &#125; int deleteHead() &#123; if(outputStack.empty())&#123; while(!inputStack.empty())&#123; outputStack.push(inputStack.top()); inputStack.pop(); &#125; &#125; if(outputStack.empty()) return -1; else&#123; int output = outputStack.top(); outputStack.pop(); return output; &#125; &#125;&#125;; 栈排序使用两个栈进行排序（或着说使用一个辅助栈对栈进行排序）每次都往辅助栈中放如当前剩余的最大的值，最后直到当前栈空了，再把辅助栈转移回去就可以完成排序。 弹出一个数： 辅助栈为空，push 辅助栈不为空，如果弹出值大于辅助栈顶，则弹出辅助栈的元素放入当前栈，直到遇到小于或等于的就push进辅助栈。123456789101112131415161718//栈顶最大void sortStackByStack(stack&lt;int&gt; &amp;st)&#123; stack&lt;int&gt; help; while(!st.empty())&#123; int curr=st.top(); st.pop(); while(!help.empty() &amp;&amp; curr&gt;help.top() )&#123; st.push(help.top()); help.pop(); &#125; help.push(curr); &#125; while(!help.empty())&#123; int tmp=help.top(); help.pop(); st.push(tmp); &#125;&#125; 2.2 二叉树二叉树的遍历二叉树的遍历可以实现很多树相关的操作，如二叉树的序列化。二叉树的序列化本质上是对其值进行编码，更重要的是对其结构进行编码。可以遍历树来完成。 二叉树遍历的cpp实现 我们一般有两个策略： BFS（即层序遍历）：BFS 可以按照层次的顺序从上到下遍历所有的节点1234567891011121314void levelOrder(BinaryTree *root)&#123; queue&lt;BinaryTree *&gt; que; que.push(root); while(!que.empty())&#123; BinaryTree *curNode = que.front(); cout &lt;&lt; curNode-&gt;val &lt;&lt; &quot; &quot;; que.pop(); if(curNode-&gt;lc!=nullptr) que.push(curNode-&gt;lc); if(curNode-&gt;rc!=nullptr) que.push(curNode-&gt;rc); &#125;&#125; DFS：DFS 可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将DFS策略区分为：先序遍历12345678910111213141516171819202122232425//递归void preOrder_recursion(BinaryTree *root)&#123; if(root==nullptr) return; cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;; preOrder_recursion(root-&gt;lc); preOrder_recursion(root-&gt;rc);&#125;//非递归void preOrder_non_recursion(BinaryTree *root)&#123; stack&lt;BinaryTree *&gt; st; while(root!=nullptr || !st.empty())&#123; if(root!=nullptr)&#123; cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;; st.push(root); root = root-&gt;lc; &#125;else&#123; root = st.top(); st.pop(); root = root-&gt;rc; &#125; &#125;&#125; 中序遍历12345678910111213141516171819202122232425//递归void inOrder_recursion(BinaryTree *root)&#123; if(root==nullptr) return; inOrder_recursion(root-&gt;lc); cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;; inOrder_recursion(root-&gt;rc);&#125;//非递归void inOrder_non_recursion(BinaryTree *root)&#123; stack&lt;BinaryTree *&gt; st; while(root!=nullptr || !st.empty())&#123; if(root!=nullptr)&#123; st.push(root); root = root-&gt;lc; &#125;else&#123; root = st.top(); st.pop(); cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;; root = root-&gt;rc; &#125; &#125;&#125; 后序遍历12345678910111213141516171819202122232425262728293031//递归void posOrder_recursion(BinaryTree *root)&#123; if(root==nullptr) return; posOrder_recursion(root-&gt;lc); posOrder_recursion(root-&gt;rc); cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;&#125;//非递归void posOrder_non_recursion(BinaryTree *root)&#123; stack&lt;BinaryTree *&gt; st; BinaryTree *lastVisited = root; while(root!=nullptr || !st.empty())&#123; if(root!=nullptr)&#123; st.push(root); root = root-&gt;lc; &#125;else&#123; root = st.top(); if(root-&gt;lc == nullptr || root-&gt;rc == lastVisited)&#123; cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;; st.pop(); lastVisited = root; root = nullptr; &#125;else&#123; root = root-&gt;rc; &#125; &#125; &#125;&#125; Z形遍历&#x2F;锯齿形遍历Leetcode 103. 二叉树的锯齿形层次遍历（中等）在层序遍历的基础上加了一个reverse标记，reverse为true时反向遍历。由于头和尾都要插入和弹出，使用双端队列deque会好一些，使用vector的insert比较耗时。 123456789101112131415161718192021222324252627282930vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; if(root==nullptr) return &#123;&#125;; vector&lt;vector&lt;int&gt; &gt; res; deque&lt;TreeNode *&gt; dque; dque.push_back(root); bool reverse = false; while(!dque.empty())&#123; int n = dque.size(); vector&lt;int&gt; tmp; TreeNode *cur; while(n--)&#123; if(reverse)&#123;//后取前放 cur = dque.back(); dque.pop_back(); if(cur-&gt;right) dque.push_front(cur-&gt;right);//先右再左 if(cur-&gt;left) dque.push_front(cur-&gt;left); &#125;else&#123;//前取后放 cur = dque.front(); dque.pop_front(); if(cur-&gt;left) dque.push_back(cur-&gt;left);//先左再右 if(cur-&gt;right) dque.push_back(cur-&gt;right); &#125; tmp.push_back(cur-&gt;val); &#125; res.push_back(tmp); reverse = !reverse; &#125; return res;&#125; 时间复杂度：O(n)空间复杂度：O(n) 1. 1028. 从先序遍历还原二叉树（困难）我们从二叉树的根节点 root 开始进行深度优先搜索。在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。如果节点只有一个子节点，那么保证该子节点为左子节点。给出遍历输出 S，还原树并返回其根节点 root。 示例1: 12输入：&quot;1-2--3--4-5--6--7&quot;输出：[1,2,5,3,4,6,7] 示例2: 12输入：&quot;1-2--3---4-5--6---7&quot;输出：[1,2,5,3,null,6,null,4,null,7] 示例 3： 12输入：&quot;1-401--349---90--88&quot;输出：[1,401,null,349,88,90] 题解：当前节点为T，上一个节点为S，只有两种情况： T 是 S 的左子节点； T 是根节点到 S 这一条路径上（不包括 S，因为题目中规定了如果节点只有一个子节点，那么保证该子节点为左子节点）某一个节点的右子节点。 所以，我们用一个栈保存根节点到当前节点的上一个节点的路径： 当前节点的深度刚好比栈的高度大1：当前节点正好是栈顶节点的左子节点；ps. 深度是从0开始，所以当深度的值和栈高度相等时，就是深度刚好比栈的高度大1 当前节点的深度小于等于栈的高度： 当前节点的深度刚和栈的高度相等：当前节点是栈顶节点右兄弟节点即栈顶节点父节点的右子节点； 当前节点的深度小于栈的高度：当前节点是根节点到栈顶节点路径上某一个节点的右子节点。一直弹出栈顶节点直到满足情况1。 *ps. 当前节点的深度刚和栈的高度相等 即 level=path.size()-1，也是需要弹出栈顶节点一次*12345678910111213141516171819202122232425262728293031TreeNode* recoverFromPreorder(string S) &#123; stack&lt;TreeNode *&gt; path; int pos = 0; while(pos&lt;S.size())&#123; int level = 0; while(S[pos]==&#x27;-&#x27;)&#123; level++; pos++; &#125; int value = 0; while (pos &lt; S.size() &amp;&amp; isdigit(S[pos]))&#123;//取当前节点的值 value = value * 10 + (S[pos] - &#x27;0&#x27;); pos++; &#125; TreeNode *node = new TreeNode(value); if(level==path.size())&#123;//第1种情况 if(!path.empty()) path.top()-&gt;left = node; &#125;else&#123;//第2种情况 while(level!=path.size()) path.pop(); path.top()-&gt;right = node; &#125; path.push(node); &#125; while(path.size()&gt;1) path.pop(); return path.top();&#125; 时间复杂度：O(n)。n为S的长度空间复杂度：O(h)。h为树的高度 2. 104. 二叉树的最大深度（简单）给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 1234567给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7返回它的最大深度 3 。 题解： 层序遍历（BFS）。 123456789101112131415161718192021int maxDepth(TreeNode* root)&#123; if(root==nullptr) return 0; queue&lt;TreeNode*&gt; que; que.push(root); int hight = 0; while(!que.empty())&#123; hight++; int n = que.size(); for (int i = 0; i &lt; n; i++) &#123; TreeNode *curNode = que.front(); que.pop(); if(curNode-&gt;left!=nullptr) que.push(curNode-&gt;left); if(curNode-&gt;right!=nullptr) que.push(curNode-&gt;right); &#125; &#125; return hight;&#125; 时间复杂度：O(n)空间复杂度：O(n) 递归。 12345int maxDepth(TreeNode* root)&#123; if(root==nullptr) return 0; return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;&#125; 时间复杂度：O(n)空间复杂度：O(hight) 3. 110. 平衡二叉树（简单）给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 示例 1: 1234567给定二叉树 [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7返回 true 。 示例 2: 123456789给定二叉树 [1,2,2,3,3,null,null,4,4] 1 / \\ 2 2 / \\ 3 3 / \\ 4 4返回 false 。 题解：用到上一题的求深度。 自上而下递归。 12345678910111213int getHight(TreeNode *root)&#123; if(root==nullptr) return 0; return max(getHight(root-&gt;left),getHight(root-&gt;right))+1;&#125;bool isBalanced(TreeNode* root) &#123; if(root==nullptr) return true; return abs(getHight(root-&gt;left)-getHight(root-&gt;right))&lt;2 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);&#125; 时间复杂度：O(nlogn)空间复杂度：O(n) 自下而上递归。加了一个hight记录子树高度。 123456789101112131415161718bool helper(TreeNode *root, int &amp;height)&#123; if(root==nullptr)&#123; height = -1; return true; &#125; int left,right; if(helper(root-&gt;left,left) &amp;&amp; helper(root-&gt;right,right) &amp;&amp; abs(left-right)&lt;2)&#123; height = max(left,right)+1; return true; &#125; return false;&#125;bool isBalanced(TreeNode* root) &#123; int height; return helper(root,height);&#125; 时间复杂度：O(n)空间复杂度：O(n) 4. 530. 二叉搜索树的最小绝对差（简单）给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。 示例： 12345678910111213输入： 1 \\ 3 / 2输出：1解释：最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。 题解：搜索二叉树的中序遍历就是升序排列，所以中序遍历是记录上一个节点的值，就可以求差值，维护一个最小值可以一边遍历得到答案。 1234567891011121314151617int res = INT_MAX;void midOrder(TreeNode* root, int &amp;last)&#123; //注意last要用引用，不然弹栈的时候上一个节点的值不能被记录 if(!root) return; midOrder(root-&gt;left, last); if(last==-1) last = root-&gt;val; else res = min(res, abs(root-&gt;val-last)); last = root-&gt;val; midOrder(root-&gt;right, last);&#125;int getMinimumDifference(TreeNode* root) &#123; int last = -1; midOrder(root, last); return res;&#125; 时间复杂度：O(n)空间复杂度：O(n)，搜索二叉树可以会退化成链 5. 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先（简单）给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 示例： 12345678910输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 6 / \\ 2 8 /\\ /\\0 4 7 9 /\\ 3 5 题解：要判断一个节点的左子树里有p，右子树里有q，那么当前节点就是最近公共祖先。从上往下遍历的时候，如果(p-&gt;val &lt;= cur-&gt;val &amp;&amp; cur-&gt;val &lt;= q-&gt;val)则说明该节点cur就是最近公共祖先了。 1234567891011TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; while(root)&#123; if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) root = root-&gt;left; else if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) root = root-&gt;right; else return root; &#125; return nullptr;&#125; 时间复杂度：O(n)空间复杂度：O(1) 6. 236. 二叉树的最近公共祖先（中等）给定一个二叉树, 找到该树中两个指定节点的最近公共祖先 Lowest Common Ancestor(LCA)。上一题是二叉搜索树。 示例： 1234567891011输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 3 / \\ 5 1 /\\ /\\6 2 0 8 /\\ 7 4 题解： 递归。 1234567891011121314TreeNode* ans;bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == nullptr) return false; bool lson = dfs(root-&gt;left, p, q); bool rson = dfs(root-&gt;right, p, q); if ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson)))&#123;// (左右都包含p/q) || (一边子树包含另p/q + 一边root节点是p/q) ans = root; &#125; return lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val); //左子树包含||右子树包含||root为p/q&#125;TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; dfs(root, p, q); return ans;&#125; 时间复杂度：O(n)空间复杂度：O(n) 可以用哈希表存储所有节点的父节点，然后就可以利用节点的父节点信息从 p 结点开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。 12345678910111213141516171819202122232425unordered_map&lt;int, TreeNode*&gt; parents;unordered_map&lt;int, bool&gt; visited;void dfs(TreeNode* root)&#123;//记录父节点 if (root-&gt;left != nullptr) &#123; parents[root-&gt;left-&gt;val] = root; dfs(root-&gt;left); &#125; if (root-&gt;right != nullptr) &#123; parents[root-&gt;right-&gt;val] = root; dfs(root-&gt;right); &#125;&#125;TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; parents[root-&gt;val] = nullptr; dfs(root); while (p != nullptr) &#123;//从p往上走，也可以从q visited[p-&gt;val] = true; p = parents[p-&gt;val]; &#125; while (q != nullptr) &#123; if (visited[q-&gt;val]) return q; q = parents[q-&gt;val];//从q往上走，碰到的第一个已经访问过的节点即为LCA节点 &#125; return nullptr;&#125; 时间复杂度：O(n)空间复杂度：O(n) 2.3 链表面试题 02.01. 移除重复节点（简单）编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。 示例1: 12输入：[1, 2, 3, 3, 2, 1]输出：[1, 2, 3] 示例2: 12输入：[1, 1, 1, 1, 2]输出：[1, 2] 题解：用一个哈希表(unordered_set)保存已有元素。 1234567891011121314151617181920212223ListNode* removeDuplicateNodes(ListNode* head) &#123; if(head==nullptr || head-&gt;next==nullptr) return head; unordered_set&lt;int&gt; valSet; ListNode *lastNode = head; ListNode *cur = head-&gt;next; valSet.insert(head-&gt;val); while (cur != nullptr) &#123; if(valSet.find(cur-&gt;val) == valSet.end())&#123;//非重复节点 valSet.insert(cur-&gt;val); lastNode-&gt;next = cur; lastNode = lastNode-&gt;next; cur = cur-&gt;next; &#125;else&#123;//重复节点 cur = cur-&gt;next; &#125; &#125; lastNode-&gt;next = cur;//nullptr return head;&#125; 时间复杂度：O(n)空间复杂度：O(n) ps. 在不允许用额外空间的情况下，可以用两重循环。时间O(n^2) ，空间o(1)。 206. 反转链表（简单）反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 题解： 遍历反转。 12345678910111213ListNode* reverseList(ListNode* head) &#123; if(head==nullptr || head-&gt;next==nullptr) return head; ListNode *pre = nullptr; ListNode *cur = head; while(cur!=nullptr)&#123; ListNode *tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; return pre;&#125; 时间复杂度：O(n)空间复杂度：O(1) 递归。 12345678ListNode* reverseList(ListNode* head) &#123; if(head==nullptr || head-&gt;next==nullptr) return head; ListNode *cur = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return cur;&#125; 时间复杂度：O(n)空间复杂度：O(n) 25. K 个一组翻转链表（困难）给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 示例： 12345给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 题解： 123456789101112131415161718192021222324252627282930313233343536pair&lt;ListNode*, ListNode*&gt; reverseList(ListNode* head, ListNode* rear)&#123; ListNode *pre = rear-&gt;next; ListNode *cur = head; while(pre != rear)&#123; ListNode *tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; return &#123;rear, head&#125;;//非递归反转链表并返回新链表头尾&#125;ListNode* reverseKGroup(ListNode* head, int k) &#123; ListNode *res = new ListNode(0); res-&gt;next = head; ListNode *preNode = res, *L = head; ListNode *R, *nextNode; while(L)&#123; R = preNode; for (int i = 0; i &lt; k; i++)&#123; //选出要反转的k个 R = R-&gt;next; if(R==nullptr)//剩下的不足k个直接返回 return res-&gt;next; &#125; nextNode = R-&gt;next; auto ret = reverseList(L, R); L = ret.first; R = ret.second; //把子链表重新接回原链表 preNode-&gt;next = L; R-&gt;next = nextNode; preNode = R; L = R-&gt;next; &#125; return res-&gt;next;&#125; 时间复杂度：O(n)空间复杂度：O(1) 92. 反转链表 II（中等）反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明:1 ≤ m ≤ n ≤ 链表长度。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 题解： 遍历交换。 123456789101112131415161718192021222324252627282930313233ListNode* reverseBetween(ListNode* head, int m, int n) &#123; if(m==n) return head; if(m==1)&#123; ListNode *lastRevers = head; ListNode *pre = lastRevers; ListNode *cur = pre-&gt;next; for(int i=m;i&lt;n;i++)&#123; ListNode *tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; lastRevers-&gt;next = cur; return pre; &#125;else&#123; ListNode *before = head; for(int i=1;i&lt;m-1;i++) before = before-&gt;next; ListNode *lastRevers = before-&gt;next; ListNode *pre = lastRevers; ListNode *cur = pre-&gt;next; for(int i=m;i&lt;n;i++)&#123; ListNode *tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; before-&gt;next = pre; lastRevers-&gt;next = cur; return head; &#125;&#125; 时间复杂度：O(n)空间复杂度：O(1) 头插法。双指针，一个指针 A 指向要反转的前一个节点m-1，一个指针 B 指向要反转的第一个节点m。B在往后移动时，不停的把B后面的一个节点移到A后面，一直到n-1结束。这时已经反转了要求的链表。ps. new一个节点指向头节点，就可以解决m=1的情况 1234567891011121314151617181920212223ListNode* reverseBetween(ListNode* head, int m, int n) &#123; ListNode *preHead = new ListNode(0); preHead-&gt;next = head; ListNode *A = preHead; ListNode *B = head; int step = 0; while (step &lt; m - 1) &#123; A = A-&gt;next; B = B-&gt;next; step++; &#125; for (int i = 0; i &lt; n - m; i++) &#123; ListNode *removed = B-&gt;next; B-&gt;next = B-&gt;next-&gt;next; removed-&gt;next = A-&gt;next; A-&gt;next = removed; &#125; return preHead-&gt;next;&#125; 时间复杂度：O(n)空间复杂度：O(1) 142. 环形链表 II（中等）给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 题解： 哈希表。 12345678910ListNode *detectCycle(ListNode *head) &#123; unordered_map&lt;ListNode*,int&gt; nodeMap; ListNode *cur = head; while(cur)&#123; if(++nodeMap[cur]&gt;1) return cur; cur = cur-&gt;next; &#125; return nullptr;&#125; 时间复杂度：O(n)空间复杂度：O(n) 快慢指针。快指针一次走2步，慢指针一次走一步。 快指针走到nullptr，说明无环 快指针慢指针第一次相遇节点记为mark，这时把慢指针移到头节点，快指针不变。他们都继续移动，都是一次走一步。当两个指针再次相遇时，就是头节点。123456789101112131415161718ListNode *detectCycle(ListNode *head) &#123; if(head == nullptr || head-&gt;next == nullptr) return nullptr; ListNode *fast = head, *slow = head; do&#123; if(fast == nullptr || fast-&gt;next == nullptr) return nullptr; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125;while(fast!=slow); slow = head; while(fast!=slow)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return fast;&#125; 时间复杂度：O(n)空间复杂度：O(1) 2.4 图1. 5211. 概率最大的路径（中等）给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 edges[i] &#x3D; [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。 指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。 如果不存在从 start 到 end 的路径，请 返回 0 。只要答案与标准答案的误差不超过 1e-5 ，就会被视作正确答案。 示例 1： 123输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2输出：0.25000解释：从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25 题解： 先建图。graph[i] 表示第 i 个节点能够到达的下一个节点及概率。 bfs把与当前节点有连接的节点存入一个大根堆。（如果只用队列会出错） hasVisited[i] 表示 i 节点是否被访问过 循环直到堆为空 其实就是 Dijkstra 算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445const double zero = 1e-8;vector&lt;vector&lt;pair&lt;int,double&gt; &gt; &gt; buildGrapg(vector&lt;vector&lt;int&gt; &gt; &amp;edges, vector&lt;double&gt;&amp; succProb, int n)&#123; vector&lt;vector&lt;pair&lt;int,double&gt; &gt; &gt; graph(n); for (int i = 0; i &lt; edges.size();i++) &#123; graph[edges[i][0]].emplace_back(edges[i][1],succProb[i]); graph[edges[i][1]].emplace_back(edges[i][0],succProb[i]); &#125; return graph;&#125;double maxProbability(int n, vector&lt;vector&lt;int&gt; &gt;&amp; edges, vector&lt;double&gt;&amp; succProb, int start, int end) &#123; if(edges.empty()) return 0.0; vector&lt;vector&lt;pair&lt;int,double&gt; &gt; &gt; graph = buildGrapg(edges, succProb, n); if(graph[end].empty() || graph[start].empty()) return 0.0; vector&lt;double&gt; prob(n, 0.0); //从start到每个节点的最大概率 prob[start] = 1; priority_queue&lt;pair&lt;double, int&gt; &gt; que; vector&lt;bool&gt; hasVisited(n， false); que.push(&#123;1, start&#125;); while(!que.empty())&#123; auto cur = que.top(); que.pop(); double p = cur.first; int node = cur.second; if(hasVisited[node]) continue; hasVisited[node] = true; if(p&lt;zero) continue; for(auto edge:graph[node])&#123; int v = edge.first; double curProb = p * edge.second; if(prob[v]&lt;curProb)&#123; prob[v] = curProb; que.push(&#123;prob[v], v&#125;); &#125; &#125; &#125; return prob[end];&#125; 2. 207. 课程表（中等）有向图的拓扑排序你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1] 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？ 示例 1: 123输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例 2: 123输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 提示： 123输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。你可以假定输入的先决条件中没有重复的边。1 &lt;= numCourses &lt;= 10^5 题解： 有向图的dfs遍历。visited[i]表示第i和节点的状态，0表示没有被访问过，1表示正在被访问，2表示访问结束的节点。circle表示有向图有环。使用dfs遍历有向图： 当正在访问的节点（visited[i]&#x3D;1）又被访问时，说明有向图存在环，返回false。 全部节点访问完毕，返回true12345678910111213141516171819202122232425262728293031323334bool circle = false;void dfs(int u, vector&lt;vector&lt;int&gt; &gt; &amp;graph, vector&lt;int&gt; &amp;visited)&#123; visited[u] = 1;//正在访问该节点 for(int v:graph[u])&#123; if(visited[v]==0)&#123; dfs(v, graph, visited); if(circle) return; &#125;else if(visited[v]==1)&#123; circle = true; return; &#125; &#125; visited[u] = 2;&#125;bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123; if(prerequisites.empty()) return true; vector&lt;vector&lt;int&gt; &gt; graph(numCourses); for (auto course : prerequisites) &#123;//build graph graph[course[1]].push_back(course[0]); &#125; vector&lt;int&gt; visited(numCourses); for (int i = 0; i &lt; numCourses &amp;&amp; !circle; i++) &#123; if(!visited[i]) dfs(i, graph, visited); &#125; return !circle;&#125; 时间复杂度：O(m+n)。m是有向图的边，n是有向图的节点。空间复杂度：O(m+n) bfs入度为0的点拓扑排序中，起点都是入度为0的点。把所有入度为0的节点放入队列，依次访问队列中的节点。访问的时候把所有从该节点出去的边都删掉，即该节点出发连接的边的入度都减1。再把入度减到0的点加入队列。1234567891011121314151617181920212223242526272829303132bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123; if(prerequisites.empty()) return true; vector&lt;vector&lt;int&gt; &gt; graph(numCourses); vector&lt;int&gt; inDegree(numCourses, 0); for (auto course : prerequisites) &#123;//build graph graph[course[1]].push_back(course[0]); inDegree[course[0]]++; &#125; queue&lt;int&gt; que; for (int i = 0; i &lt; numCourses;i++) &#123; if(inDegree[i]==0) que.push(i); &#125; int visited = 0; while (!que.empty()) &#123; visited++; int u = que.front(); que.pop(); for(int v:graph[u])&#123; inDegree[v]--; if(inDegree[v]==0) que.push(v); &#125; &#125; return visited == numCourses;&#125; 时间复杂度：O(m+n)。m是有向图的边，n是有向图的节点。空间复杂度：O(m+n) 3.210. 课程表 II（中等）现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。 可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。 示例 1: 123输入: 2, [[1,0]] 输出: [0,1]解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。 示例 2: 1234输入: 4, [[1,0],[2,0],[3,1],[3,2]]输出: [0,1,2,3] or [0,2,1,3]解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。 说明: 12输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。你可以假定输入的先决条件中没有重复的边。 提示: 123这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。拓扑排序也可以通过 BFS 完成。 题解： dfs。和上一题基本相同，只需要在节点访问完成时放入结果向量，因为dfs先访问的是最后的节点，所以需要把向量反转一下。12345678910111213141516171819202122232425262728293031323334353637bool circle = false;vector&lt;int&gt; res;void dfs(int u, vector&lt;vector&lt;int&gt; &gt; &amp;graph, vector&lt;int&gt; &amp;visited)&#123; visited[u] = 1;//正在访问该节点 for(int v:graph[u])&#123; if(visited[v]==0)&#123; dfs(v, graph, visited); if(circle) return; &#125;else if(visited[v]==1)&#123; circle = true; return; &#125; &#125; visited[u] = 2; res.push_back(u);&#125;vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123; vector&lt;vector&lt;int&gt; &gt; graph(numCourses); for (auto course : prerequisites) &#123;//build graph graph[course[1]].push_back(course[0]); &#125; vector&lt;int&gt; visited(numCourses); for (int i = 0; i &lt; numCourses &amp;&amp; !circle; i++) &#123; if(!visited[i]) dfs(i, graph, visited); &#125; if(circle) return &#123;&#125;; reverse(res.begin(), res.end()); return res;&#125; bfs。同上题，只需要在节点访问完成时放入结果向量。时空复杂度与上题相同。1234567891011121314151617181920212223242526272829303132333435vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123; vector&lt;vector&lt;int&gt; &gt; graph(numCourses); vector&lt;int&gt; inDegree(numCourses, 0); for (auto course : prerequisites) &#123;//build graph graph[course[1]].push_back(course[0]); inDegree[course[0]]++; &#125; queue&lt;int&gt; que; for (int i = 0; i &lt; numCourses;i++) &#123; if(inDegree[i]==0) que.push(i); &#125; vector&lt;int&gt; res; int visited = 0; while (!que.empty()) &#123; visited++; int u = que.front(); que.pop(); res.push_back(u); for (int v : graph[u]) &#123; inDegree[v]--; if(inDegree[v]==0) que.push(v); &#125; &#125; if(visited!=numCourses) return &#123;&#125;; return res;&#125; 4.133. 克隆图（中等）给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。 图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。 1234class Node &#123; public int val; public List&lt;Node&gt; neighbors;&#125; 题解： bfs 123456789101112131415161718192021222324252627282930313233Node* cloneGraph(Node* node) &#123; if (node == nullptr) &#123; return node; &#125; unordered_map&lt;Node*, Node*&gt; visited; // 将题目给定的节点添加到队列 queue&lt;Node*&gt; que; que.push(node); // 克隆第一个节点并存储到哈希表中 visited[node] = new Node(node-&gt;val); // 广度优先搜索 while (!que.empty()) &#123; // 取出队列的头节点 auto curNode = que.front(); que.pop(); // 遍历该节点的邻居 for (auto&amp; neighbor: curNode-&gt;neighbors) &#123; if (visited.find(neighbor) == visited.end()) &#123; // 如果没有被访问过，就克隆并存储在哈希表中 visited[neighbor] = new Node(neighbor-&gt;val); // 将邻居节点加入队列中 que.push(neighbor); &#125; // 更新当前节点的邻居列表 visited[curNode]-&gt;neighbors.emplace_back(visited[neighbor]); &#125; &#125; return visited[node];&#125; 时间复杂度：O(n)空间复杂度：O(n) dfs12345678910111213141516171819unordered_map&lt;Node*, Node*&gt; visited;Node* cloneGraph(Node* node) &#123; if (node == nullptr) &#123; return node; &#125; if(visited.find(node) != visited.end()) return visited[node]; Node *cloneNode = new Node(node-&gt;val); visited[node] = cloneNode; for(auto &amp;neighbor:node-&gt;neighbors)&#123; cloneNode-&gt;neighbors.push_back(cloneGraph(neighbor)); &#125; return visited[node];&#125; 时间复杂度：O(n)空间复杂度：O(n) 2.5 堆1. 给一个数组h，h有n个元素；每次可以给数组h中最小的元素加x；总共可以加m次。求m次运算后的数组最小值。示例： 123输入：a = &#123;1,2,3&#125;, n = 3, x = 1, m =2输出：2 题解：维护一个小根堆。每次从堆顶取出最小值，加上x后在放入堆中。 1234567891011121314int minimalAfterAdd(vector&lt;int&gt; &amp;h, int n, int m, int x)&#123; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; pq; for(int i:h) pq.push(i); while(m&gt;0)&#123; int tmp = pq.top(); pq.pop(); pq.push(tmp + x); m--; &#125; return pq.top();&#125; 2. 重复数组变换 题解：用一个map&lt;int,索引小根堆&gt;来保存数组元素和索引。map是默认是按key升序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445bool repeat(map&lt;int, priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; &gt; &amp;numMap, map&lt;int, priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; &gt;::iterator &amp;iter)&#123; /*检查有没有重复的元素，并返回了重复元素的 it*/ for (auto it = numMap.begin(); it != numMap.end();it++) &#123; if(it-&gt;second.size()&gt;1)&#123; iter = it; return true; &#125; &#125; return false;&#125;vector&lt;int&gt; delRepeat(vector&lt;int&gt; &amp;a)&#123; int n = a.size(); //map&lt;元素，索引小根堆&gt; map&lt;int, priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; &gt; numMap; for (int i = 0; i &lt; n; i++) numMap[a[i]].push(i); auto it = numMap.begin(); while (repeat(numMap,it)) &#123; //it: &#123;第一个重复的元素,索引堆&#125; it-&gt;second.pop(); int idx = it-&gt;second.top(); it-&gt;second.pop(); numMap[it-&gt;first * 2].push(idx); a[idx] *= 2; &#125; set&lt;int&gt; sIdx; for (auto m : numMap) &#123; if(!m.second.empty())&#123; sIdx.insert(m.second.top()); &#125; &#125; vector&lt;int&gt; res; for(int i:sIdx)&#123; res.push_back(a[i]); &#125; return res;&#125; 三、算法类例题主要从Leetcode的题中选出的代表性例题，也包括笔试或者其他资料上看到的比较好的题目。ps: 题解使用的 cpp 3.1 分治算法（Divide and conquer）Leetcode 241. 为运算表达式设计优先级（中等）给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。 1234Input: &quot;2-1-1&quot; ((2-1)-1) = 0(2-(1-1)) = 2Output : [0, 2] 题解：符号分开成左右两边，递归求出左右两边的结果，再排列组合成新结果。 123456789101112131415161718192021222324vector&lt;int&gt; diffWaysToCompute(string s)&#123; vector&lt;int&gt; res; for (int i = 0; i &lt; s.size();i++)&#123; if(s[i]==&#x27;+&#x27; || s[i]==&#x27;-&#x27; || s[i]==&#x27;*&#x27;)&#123; vector&lt;int&gt; left = diffWaysToCompute(s.substr(0, i)); vector&lt;int&gt; right = diffWaysToCompute(s.substr(i + 1)); for(int l:left)&#123; for(int r:right)&#123; if(s[i]==&#x27;+&#x27;)&#123; res.push_back(l + r); &#125;else if (s[i] == &#x27;-&#x27;)&#123; res.push_back(l - r); &#125; else if (s[i] == &#x27;*&#x27;)&#123; res.push_back(l * r); &#125; &#125; &#125; &#125; &#125; if(res.empty()) res.push_back(stoi(s)); return res;&#125; Leetcode 95. 不同的二叉搜索树 II（中等）给定一个数字 n，要求生成所有值为 1…n 的二叉搜索树。 123456789101112131415161718Input: 3 Output: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]Explanation: The above output corresponds to the 5 unique BST&#x27;s shown below: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 题解：把每一个节点当作父节点，递归求解左右子数，在把每个左右子树组合起来。 1234567891011121314151617181920212223242526272829303132struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;vector&lt;TreeNode *&gt; generateTreesCore(int start, int end)&#123; if(start &gt; end) return &#123;nullptr&#125;; vector&lt;TreeNode *&gt; res; for (int i = start; i &lt;= end;i++)&#123; vector&lt;TreeNode *&gt; left = generateTreesCore(start, i - 1); vector&lt;TreeNode *&gt; right = generateTreesCore(i + 1, end); for(auto l:left)&#123; for(auto r:right)&#123; TreeNode *root = new TreeNode(i); root-&gt;left = l; root-&gt;right = r; res.push_back(root); &#125; &#125; &#125; return res;&#125;vector&lt;TreeNode *&gt; generateTrees(int n)&#123; if(n==0) return &#123;&#125;; return generateTreesCore(1, n); cout &lt;&lt; &quot;visual tree by debug.&quot; &lt;&lt; endl;&#125; 3.2 动态规划（Dynamic programming）递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。递归一般是自上而下——从愿问题开始，逐步往下求解；动态规划一般是自下而上——从最小子问题开始，逐步扩大问题规模。（这里写一个动态规划算法伪代码模版） 3.2.1 斐波那契数列（fabonacci）Leetcode 70. 爬楼梯（简单）题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。 题解：dp。dp[i] 表示走到第 i 个楼梯的方法数目。第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。dp[i] = dp[i - 1] + dp[i - 2] 空间复杂度O(n)的方法 1234567int climbStairs(int n)&#123; vector&lt;int&gt; dp(n+1, 1);//dp[0]=1, dp[1]=1 for (int i = 2; i &lt;= n;i++) dp[i] = dp[i - 1] + dp[i - 2]; return dp[n];&#125; 时间复杂度：O(n)空间复杂度：O(n) 空间复杂度O(1)的方法 12345678910int climbStairs(int n)&#123; vector&lt;int&gt; dp(3, 1);//dp[0]=1, dp[1]=1 for (int i = 2; i &lt;= n;i++)&#123; dp[2] = dp[1] + dp[0]; dp[0] = dp[1]; dp[1] = dp[2]; &#125; return dp[1];&#125; 时间复杂度：O(n)空间复杂度：O(1) Leetcode 198. 打家劫舍（简单）题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。 示例： 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 题解：dp。dp[i] 表示抢到第 i 个住户时的最大抢劫量。由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以：dp[i] = max(dp[i-2]+nums[i],dp[i-1]) 12345678910111213int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return 0; vector&lt;int&gt; dp(3, 0); dp[1] = nums[0]; for (int i = 2; i &lt;= n; i++)&#123; dp[2] = max(dp[0] + nums[i - 1], dp[1]); dp[0] = dp[1]; dp[1] = dp[2]; &#125; return dp[1];//防止只有一个元素的情况&#125; 时间复杂度：O(n)空间复杂度：O(1) Leetcode 213. House Robber II （中等）强盗在环形街区抢劫 示例： 123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 题解：在上一题的基础上，分成两个数组，一个包含第一家不包含最后一家，另一个不包含第一家但包含最后一家。分别 dp 求 max。 1234567891011121314151617181920212223int helper(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return 0; vector&lt;int&gt; dp(3, 0); dp[1] = nums[0]; for (int i = 2; i &lt;= n; i++)&#123; dp[2] = max(dp[0] + nums[i - 1], dp[1]); dp[0] = dp[1]; dp[1] = dp[2]; &#125; return dp[1];&#125;int rob(vector&lt;int&gt;&amp; nums)&#123; if(nums.empty()) return 0; if(nums.size()==1) return nums[0]; vector&lt;int&gt; nums1(nums.begin(), nums.end() - 1); vector&lt;int&gt; nums2(nums.begin()+1, nums.end()); return max(helper(nums1), helper(nums2));&#125; 时间复杂度：O(2n)空间复杂度：O(1) Leetcode 634. 寻找数组的错位排列（中等，会员题）题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量（所有信封都没有装各自的信）。 题解：定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。 假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况： i == k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。 i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。 dp[i] = (i-1)*dp[i-2] + (i-1)*dp[i-1] 12345678910111213int wrongLetterRank(int n)&#123; if(n&lt;2) return n; vector&lt;int&gt; dp(3, 0); dp[1] = 1; for (int i = 2; i &lt;= n;i++)&#123; dp[2] = (i - 1) * dp[0] + (i - 1) * dp[1]; dp[0] = dp[1]; dp[1] = dp[2]; &#125; return dp[1];&#125; 时间复杂度：O(n)空间复杂度：O(1) 母牛生小牛问题题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。 题解：dp[i]表示第 i 年成熟的牛的数量： dp[i] = dp[i-1] + dp[i-3]123456789101112131415int cowProduce(int n)&#123; if(n&lt;=4) return n; vector&lt;int&gt; dp(4, 1); //dp[0] = 1; dp[1] = 2; dp[2] = 3; for (int i = 4; i &lt;= n;i++)&#123; dp[3] = dp[2] + dp[0]; dp[0] = dp[1]; dp[1] = dp[2]; dp[2] = dp[3]; &#125; return dp[2];&#125; 时间复杂度：O(n)空间复杂度：O(1) 3.2.2 二维dp：二维网格路径问题Leetcode 64. 最小路径和（中等）给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例： 12345678输入：[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 题解： 二维dp。 12345678910111213141516171819int minPathSum(vector&lt;vector&lt;int&gt; &gt;&amp; grid) &#123; if(grid.empty()) return 0; int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt; &gt; dp(m, vector&lt;int&gt;(n,0)); dp[0][0] = grid[0][0]; for (int i = 1; i &lt; m; i++) dp[i][0] = dp[i-1][0] + grid[i][0]; for (int j = 1; j &lt; n; j++) dp[0][j] = dp[0][j-1] + grid[0][j]; for (int i = 1; i &lt; m;i++)&#123; for (int j = 1; j &lt; n;j++)&#123; dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; &#125; &#125; return dp[m - 1][n - 1];&#125; 时间复杂度：O(m*n)空间复杂度：O(m*n) 一维dp。 1234567891011121314151617181920int minPathSum(vector&lt;vector&lt;int&gt; &gt;&amp; grid) &#123; if(grid.empty()) return 0; int m = grid.size(), n = grid[0].size(); vector&lt;int&gt; dp(n, 0); dp[0] = grid[0][0]; for(int i = 1;i&lt;n;i++) dp[i] = dp[i - 1] + grid[0][i]; for (int i = 1; i &lt; m; i++)&#123; for (int j = 0; j &lt; n; j++)&#123; if(j == 0) dp[j] = dp[j] + grid[i][0]; else dp[j] = min(dp[j - 1], dp[j]) + grid[i][j]; &#125; &#125; return dp[n-1];&#125; 时间复杂度：O(m*n)空间复杂度：O(n) Leetcode 62. 不同路径（中等）题目描述：统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移 dp[i][j] = dp[i-1][j] + dp[i][j-1] 只用一行存储，空间复杂度可以优化为O(col) 也可以直接用数学公式求解，这是一个组合问题。机器人总共移动的次数 S&#x3D;m+n-2，向下移动的次数 D&#x3D;m-1，那么问题可以看成从 S 中取出 D 个位置的组合数量，这个问题的解为 C(S, D)。 题解：一维dp。 12345678int uniquePaths(int m, int n) &#123; vector&lt;int&gt; dp(n + 1, 1); //dp[0]==1 最左边一列都是1 for (int i = 1; i &lt; m;i++)&#123;//从第二行开始 for (int j = 1; j &lt; n;j++) dp[j] = dp[j - 1] + dp[j]; &#125; return dp[n-1];&#125; 时间复杂度：O(m*n)空间复杂度：O(n) 3.2.3 子序列&#x2F;子集&#x2F;子数组&#x2F;子矩阵！！！注意！！！：子序列 和 子串并不相等，子序列&#x2F;子集可以不连续，字串是连续的。 Leetcode 303. 区域和检索 - 数组不可变（简单）给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 示例： 12345给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 题解：前缀和。 1234567891011121314151617class NumArray &#123;public: NumArray(vector&lt;int&gt;&amp; nums) &#123; sums = new int[nums.size() + 1]; sums[0] = 0; for (int i = 0; i &lt; nums.size();i++) sums[i + 1] = sums[i] + nums[i]; &#125; ~NumArray() &#123; delete[] sums; &#125; int sumRange(int i, int j) &#123; return sums[j + 1] - sums[i]; &#125;private: int *sums;&#125;; Leetcode 413. 等差数列划分（中等）函数要返回数组 A 中所有为等差数组的子数组个数。 示例1： 123A = [1, 2, 3, 4]返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。 示例2： 12345678A = [0, 1, 2, 3, 4] return: 6, for 3 arithmetic slices in A: [0, 1, 2], [1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3, 4], [ 1, 2, 3, 4], [2, 3, 4] 题解：dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。 当 A[i] - A[i-1] &#x3D;&#x3D; A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。 dp[2] &#x3D; 1[0, 1, 2] dp[3] &#x3D; dp[2] + 1 &#x3D; 2[0, 1, 2, 3], &#x2F;&#x2F; [0, 1, 2] 之后加一个 3[1, 2, 3] &#x2F;&#x2F; 新的递增子区间 dp[4] &#x3D; dp[3] + 1 &#x3D; 3[0, 1, 2, 3, 4], &#x2F;&#x2F; [0, 1, 2, 3] 之后加一个 4[1, 2, 3, 4], &#x2F;&#x2F; [1, 2, 3] 之后加一个 4[2, 3, 4] &#x2F;&#x2F; 新的递增子区间 综上，在 A[i] - A[i-1] &#x3D;&#x3D; A[i-1] - A[i-2] 时，dp[i] &#x3D; dp[i-1] + 1。因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 dp 数组累加的结果。 1234567891011121314int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A)&#123; if(A.size()&lt;3) return 0; vector&lt;int&gt; dp(A.size(), 0); for (int i = 2; i &lt; dp.size(); i++)&#123; if(A[i]-A[i-1] == A[i-1]-A[i-2]) dp[i] = dp[i - 1] + 1; &#125; int res = 0; for(auto dpi:dp)&#123; res += dpi; &#125; return res;&#125; 时间复杂度：O(n)空间复杂度：O(n) Leetcode 343. 整数拆分（中等）给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 就是割绳子问题，剑指offer也有 For example, given n &#x3D; 2, return 1 (2 &#x3D; 1 + 1); given n &#x3D; 10, return 36 (10 &#x3D; 3 + 3 + 4). 题解：dp。dp[i]表示 i 能分割出的最大积 当 i ≥ 2 时，假设对正整数 i 拆分出的其中一个正整数是 j(1 ≤ j &lt; i)，则有两种情况： 将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j×(i−j)； 将 i 拆分成 j 和 i-j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j×dp[i−j]。 当固定时：dp[i] = max(j * dp[i - j], j * (i - j))，所以遍历 j 的可能值，就可以求出 dp[i] 1234567891011int integerBreak(int n)&#123; vector&lt;int&gt; dp(n+1,0); for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j])); &#125; &#125; return dp[n];&#125; 时间复杂度：O(n^2)空间复杂度：O(n) Leetcode 279. 完全平方数（中等）给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 For example, given n &#x3D; 12, return 3 because 12 &#x3D; 4 + 4 + 4;given n &#x3D; 13, return 2 because 13 &#x3D; 4 + 9. 题解：dp。dp[i]表示组成和的完全平方数最少的个数： dp[i] = dp[i-sqr] + 1 可以用四平方定理减少运算次数：任何一个正整数都可以表示成不超过四个整数的平方之和 12345678910int numSquares(int n) &#123; vector&lt;int&gt; dp(n + 1, 5); //四平方定理 dp[0] = 0; for (int i = 1; i &lt;= n;i++)&#123; for (int j = 1; j * j &lt;= i;j++)&#123; dp[i] = min(dp[i], dp[i - j * j] + 1); &#125; &#125; return dp[n];&#125; 时间复杂度：O(n * √n)空间复杂度：O(n) Leetcode 91.解码方法（中等）一条包含字母 A-Z 的消息通过以下方式进行了编码： 1234&#x27;A&#x27; -&gt; 1&#x27;B&#x27; -&gt; 2...&#x27;Z&#x27; -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 Given encoded message “12”, return 2It could be decoded as “AB” (1 2) or “L” (12). The number of ways decoding “12” is 2. 题解：二维dp。dp[i]表示前i个字符有几种解码方式。分几种情况： s[i-1]!&#x3D;0 &amp;&amp; s[i-2]&#x3D;&#x3D;0 如“101”，最近两位为”01”不能解码，所以dp[i] &#x3D; dp[i-1] s[i-1]&#x3D;&#x3D;0 &amp;&amp; s[i-2]&#x3D;&#x3D;0 即有两个连续的零，如“100” 则不可能转为字符，dp[i] &#x3D; 0 dp[i-2]dp[i-1]组成的数字 &gt;26：dp[i] &#x3D; dp[i-1] dp[i-2]dp[i-1]组成的数字 &lt;&#x3D;26：dp[i] &#x3D; dp[i-1] + dp[i-2]123456789101112131415161718int numDecodings(string s)&#123; vector&lt;int&gt; dp(s.size()+1, 0); dp[0] = 1; dp[1] = s[0] == &#x27;0&#x27; ? 0 : 1; for (int i = 2; i &lt;= s.size();i++)&#123; //s[i-1]!=0 &amp;&amp; s[i-2]==0 如“101”，最近两位为&quot;01&quot;不能解码，所以dp[i] = dp[i-1]; //s[i-1]==0 &amp;&amp; s[i-2]==0 即有两个连续的零，如“100” 则不可能转为字符，dp[i] = 0。 if(s[i-1]!=&#x27;0&#x27;) dp[i] = dp[i - 1]; if(s[i-2]==&#x27;0&#x27;) continue; //根据最近两位的大小判断能不能解码 int two = stoi(s.substr(i - 2, 2)); //= (s[i - 1] - &#x27;0&#x27;) * 10 + (s[i] - &#x27;0&#x27;); if (two &lt;= 26) dp[i] += dp[i - 2]; &#125; return dp[s.size()];&#125; 时间复杂度：O(n)空间复杂度：O(n) 一维dp。 123456789101112131415161718192021222324int numDecodings(string s)&#123; vector&lt;int&gt; dp(3, 0); dp[0] = 1; dp[1] = s[0] == &#x27;0&#x27; ? 0 : 1; for (int i = 2; i &lt;= s.size();i++)&#123; //s[i-1]!=0 &amp;&amp; s[i-2]==0 如“101”，最近两位为&quot;01&quot;不能解码，所以dp[i] = dp[i-1]; //s[i-1]==0 &amp;&amp; s[i-2]==0 即有两个连续的零，如“100” 则不可能转为字符，dp[i] = 0。 dp[2] = 0; if(s[i - 1] != &#x27;0&#x27;) dp[2] = dp[1]; if (s[i - 2] == &#x27;0&#x27;)&#123; dp[0] = dp[1]; dp[1] = dp[2]; continue; &#125; //根据最近两位的大小判断能不能解码 int two = stoi(s.substr(i - 2, 2)); //= (s[i - 1] - &#x27;0&#x27;) * 10 + (s[i] - &#x27;0&#x27;); if (two &lt;= 26) dp[2] += dp[0]; dp[0] = dp[1]; dp[1] = dp[2]; &#125; return dp[1];&#125; 时间复杂度：O(n)空间复杂度：O(1) 和为 k 的 子序列&#x2F;子数组和为 k 的 子数组 Leetcode 560. 和为K的子数组（中等） 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 : 12输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 题解：前缀和。 123456789101112int subArrySumCnt(vector&lt;int&gt; &amp;A, int &amp;d)&#123; unordered_map&lt;int, int&gt; umap; //key:前缀和 val:出现次数 int pre = 0, cnt = 0; umap[0] = 1; for (int &amp;a : A)&#123; pre += a; if(umap.find(pre-d) != umap.end()) cnt += umap[pre - d]; umap[pre]++; &#125; return cnt;&#125; 时间复杂度：O(n)空间复杂度：O(n) 在 1. 的基础上，输出每一个子数组 题解：保留索引的前缀和。 1234567891011121314151617181920212223vector&lt;vector&lt;int&gt; &gt; subArrySum(vector&lt;int&gt; &amp;A, int &amp;d)&#123; unordered_map&lt;int, vector&lt;pair&lt;int,int&gt; &gt; &gt; umap; //key:前缀和 val:出现的开始和结束索引 序列 int pre = 0; umap[0].push_back(&#123;0, -1&#125;); vector&lt;pair&lt;int, int&gt; &gt; idxs; for (int i = 0; i &lt; A.size(); i++)&#123; pre += A[i]; if(umap.find(pre-d) != umap.end())&#123; for(auto &amp;p : umap[pre-d])//记录满足的索引 idxs.push_back(&#123;p.second + 1, i&#125;); &#125; umap[pre].push_back(&#123;0, i&#125;); &#125; vector&lt;vector&lt;int&gt; &gt; res; for(auto &amp;idx : idxs)&#123; vector&lt;int&gt; tmp; for (int i = idx.first; i &lt;= idx.second; i++) tmp.push_back(A[i]); res.push_back(tmp); &#125; return res;&#125; 和为 k 的 子集合&#x2F;子序列题解：剪枝回溯，当和&gt;k时丢弃该分支。 12345678910111213141516171819202122232425262728set&lt;vector&lt;int&gt; &gt; resSet;void backtracking(vector&lt;int&gt; &amp;pre, int preSum, int idx, vector&lt;int&gt; &amp;nums, int &amp;k)&#123; if(preSum &gt; k) return; if(preSum == k)&#123; sort(pre.begin(), pre.end()); resSet.insert(pre); return; &#125; int curSum = preSum; for (int i = idx; i &lt; nums.size(); i++)&#123; pre.push_back(nums[i]); curSum += nums[i]; backtracking(pre, curSum, i + 1, nums, k); curSum -= nums[i]; pre.erase(pre.end() - 1, pre.end()); &#125; return;&#125;vector&lt;vector&lt;int&gt; &gt; subSetSum(vector&lt;int&gt; &amp;nums, int &amp;k)&#123;//子集 vector&lt;int&gt; pre; backtracking(pre, 0, 0, nums, k); vector&lt;vector&lt;int&gt; &gt; res(resSet.begin(), resSet.end()); return res;&#125; 递增子序列&amp;emsp;&amp;emsp;已知一个序列 {S1, S2,…,Sn}，取出若干数组成新的序列 {Si1, Si2,…, Sim}，其中 i1、i2 … im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个子序列。如果在子序列中，当下标 ix &gt; iy 时，Six &gt; Siy，称子序列为原序列的一个递增子序列。&amp;emsp;&amp;emsp;定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 Sn 结尾的序列的最长递增子序列长度。对于一个递增子序列 {Si1, Si2,…,Sim}，如果 im &lt; n 并且 Sim &lt; Sn，此时 {Si1, Si2,…, Sim, Sn} 为一个递增子序列，递增子序列的长度增加 1。&amp;emsp;&amp;emsp;满足上述条件的递增子序列中，长度最长的那个递增子序列就是要找的，在长度最长的递增子序列上加上 Sn 就构成了以 Sn 为结尾的最长递增子序列。&amp;emsp;&amp;emsp;因此 dp[n] = max&#123; dp[i]+1 | Si &lt; Sn &amp;&amp; i &lt; n&#125;&amp;emsp;&amp;emsp;因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 {Sn} 就构成了递增子序列，需要对前面的求解方程做修改，令 dp[n] 最小为 1，即： dp[n] = max&#123;1, dp[i] + 1 | Si &lt; Sn &amp;&amp; i &lt; n&#125;&amp;emsp;&amp;emsp;对于一个长度为 N 的序列，最长递增子序列并不一定会以 SN 为结尾，因此 dp[N] 不是序列的最长递增子序列的长度，需要遍历 dp 数组找出最大值才是所要的结果，max&#123; dp[i] | 1 &lt;= i &lt;= N&#125; 即为所求。 ref. 最长递增子序列的三种算法 以上解法的时间复杂度为 O(N2) 可以使用二分查找将时间复杂度降低为 O(NlogN) 也可以用最长公共子序列法：查找原序列和排序后的序列的最长公共自序列，具体参见链接 Leetcode 300. 最长上升（递增）子序列（中等）给定一个无序的整数数组，找到其中最长上升子序列的长度。 题解： dp。 12345678910111213int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; dp(nums.size(), 1); //至少是自身，1个 for (int i = 0; i &lt; nums.size();i++)&#123; for (int j = 0; j &lt; i;j++)&#123; if(nums[j]&lt;nums[i]) dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; int res = 0; for(int n:dp) res = max(res, n); return res;&#125; 时间复杂度：O(n^2)空间复杂度：O(n) 二分查找+贪心。 12345678910111213141516171819202122232425262728293031323334int BinarySearch(vector&lt;int&gt; &amp;tails,int len,int num)&#123; int left = 0; int right = len - 1; int mid; while(left&lt;=right)&#123; mid = (left + right) / 2; if (tails[mid]&gt;num) right = mid - 1; else if(tails[mid]&lt;num) left = mid + 1; else return mid; &#125; return left;//数组中不存在该元素，则返回该元素应该插入的位置&#125;int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; //tails[i]表示长度为 i+1 的最长上升子序列的末尾元素的最小值 if(nums.empty()) return 0; vector&lt;int&gt; tails(nums.size(), 0); int res = 1; tails[0] = nums[0]; for (int i = 1; i &lt; nums.size(); i++) &#123; if(nums[i]&gt;tails[res-1])&#123; tails[res] = nums[i]; res++; &#125;else&#123; int pos = BinarySearch(tails,res,nums[i]); tails[pos] = nums[i]; &#125; &#125; return res;&#125; 时间复杂度：O(nlogn)空间复杂度：O(n) Leetcode 646. 最长数对链（中等）给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。 现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。 给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。 说明：对于 (a, b) 和 (c, d) ，如果 b &lt; c，则它们可以构成一条链。求一组整数对能够构成的最长链。 示例： 123Input: [[1,2], [2,3], [3,4]] Output: 2 Explanation: The longest chain is [1,2] -&gt; [3,4] 题解：和最长递增子序列很像。 dp。dp[i]是以i结尾时的最长链长度：dp[i] = max&#123;dp[j]+1 | j~(1,i) &amp;&amp; pairs[i][0]&gt;pairs[j][1]&#125; 12345678910111213141516171819202122232425bool cmp(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b)&#123; if(a[0]==b[0]) return a[1] &lt; b[1]; return a[0] &lt; b[0];&#125;int findLongestChain(vector&lt;vector&lt;int&gt; &gt;&amp; pairs) &#123; if(pairs.size()&lt;2) return pairs.size(); sort(pairs.begin(), pairs.end(), cmp); vector&lt;int&gt; dp(pairs.size(), 1); for (int i = 1; i &lt; pairs.size(); i++)&#123; for (int j = 0; j &lt; i;j++)&#123; if (pairs[i][0] &gt; pairs[j][1]) dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; int res = 0; for(auto d:dp) res = max(res, d); return res;&#125; 时间复杂度：O(n^2)空间复杂度：O(n) 二分+贪心。 1234567891011121314151617181920212223242526272829303132333435363738394041424344int BinarySearch(vector&lt; vector&lt;int&gt; &gt; &amp;tails,int len,vector&lt;int&gt; inputPair)&#123; int left = 0; int right = len-1; int mid; while (left&lt;=right) &#123; mid = (left + right) / 2; if(tails[mid][1]&lt;inputPair[0]) left = mid + 1; else if(tails[mid][0]&gt;inputPair[1]) right = mid - 1; else return mid; &#125; return left;&#125;bool cmp(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b)&#123; if(a[0]==b[0]) return a[1] &lt; b[1]; return a[0] &lt; b[0];&#125;int findLongestChain(vector&lt;vector&lt;int&gt; &gt;&amp; pairs) &#123; if(pairs.size()&lt;2) return pairs.size(); sort(pairs.begin(), pairs.end(), cmp); vector&lt; vector&lt;int&gt; &gt; tails(pairs.size(),vector&lt;int&gt;(2,0)); tails[0] = pairs[0]; int res = 1; for (int i = 1; i &lt; pairs.size();i++) &#123; if(pairs[i][0]&gt;tails[res-1][1])&#123; tails[res] = pairs[i]; res++; &#125;else&#123; int pos = BinarySearch(tails,res,pairs[i]); if(tails[pos][1]&gt;pairs[i][1]) tails[pos] = pairs[i]; &#125; &#125; return res;&#125; 时间复杂度：O(nlogn)空间复杂度：O(n) Leetcode 376. 摆动序列（中等）如果一个序列中连续的数之间的差值在正数和负数之间来回交替，那么这个序列被称作摆动序列。如果存在第一个差值的话，可能为正数或者负数。长度小于2的序列被认为是摆动序列。 例如：[1,7,4,9,2,5]为摆动序列。而[1,4,7,2,5] 和[1,7,4,5,5]不是摆动序列 给定一组数，返回最长的摆动子序列。注意序列是由原数组删除一些元素(也可以不删除)并且保留元素顺序得到的。 示例： 12345678Input: [1,7,4,9,2,5] Output: 6 The entire sequence is a wiggle sequence. Input: [1,17,5,10,13,15,10,5,16,8] Output: 7 There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8]. Input: [1,2,3,4,5,6,7,8,9] Output: 2 题解： dp。用两个分别保存上升和下降的最长长度。 dpUp[i] 表示 i 之前上升序列最长的子序列长度 dpDown[i] 表示 i 之前下降序列最长的子序列长度 123456789101112131415161718192021222324252627int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; vector&lt;int&gt; dpUp(nums.size()); vector&lt;int&gt; dpDown(nums.size()); dpUp[0] = 1; dpDown[0] = 1; for (int i = 1; i &lt; nums.size(); i++) &#123; if(nums[i]&gt;nums[i-1])&#123;//状态是上升,应该接下降，并改状态 dpUp[i] = dpDown[i - 1] + 1; dpDown[i] = dpDown[i - 1]; &#125;else if(nums[i]&lt;nums[i-1])&#123;//状态是下降，应该接上升，并改状态 dpDown[i] = dpUp[i - 1] + 1; dpUp[i] = dpUp[i - 1]; &#125;else&#123; dpUp[i] = dpUp[i - 1]; dpDown[i] = dpDown[i - 1]; &#125; &#125; int res = 0; for(auto d:dpUp) res = max(res, d); for(auto d:dpDown) res = max(res, d); return res;&#125; 时间复杂度：O(2n)空间复杂度：O(2n) 因为只用到了前一个值，所以可以优化空间复杂度。 123456789101112int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int up = 1, down = 1; for (int i = 1; i &lt; nums.size();i++)&#123; if(nums[i]&gt;nums[i-1]) up = down + 1; else if(nums[i]&lt;nums[i-1]) down = up + 1; &#125; return max(up, down);&#125; 时间复杂度：O(n)空间复杂度：O(1) 公共子序列dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。 考虑 S1[i] 与 S2j 值是否相等，分为两种情况： 当 S1[i] == S2[j] 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1。 当 S1[i] != S2[j] 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 dp[i][j] = max&#123;dp[i-1][j], dp[i][j-1]&#125;。 对于长度为 N 的序列 S1 和长度为 M 的序列 S2，dp[N][M] 就是序列 S1 和序列 S2 的最长公共子序列长度。 Leetcode 1143. 最长公共子序列Longest Common Subsequence（中等）求最长公共子序列 示例： 123输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3 解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。 题解： 二维dp。dp[i][j]表示第一个字符串的前 i 个和第二个字符串的前 j 个字符的LCS。 当s1[i-1] == s2[j-1]时，dp[i][j] = dp[i - 1][j - 1] + 1 当s1[i-1] != s2[j-1]时，dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) 123456789101112131415int longestCommonSubsequence(string text1, string text2) &#123; if(text1.size()==0||text2.size()==0) return 0; vector&lt; vector&lt;int&gt; &gt; dp(text1.size()+1,vector&lt;int&gt;(text2.size()+1)); for (int i = 1; i &lt;= text1.size();i++)&#123; for (int j = 1; j &lt;= text2.size();j++)&#123; if(text2[j-1]==text1[i-1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; return dp[text1.size()][text2.size()];&#125; 时间复杂度：O(mn)空间复杂度：O(mn) 一维dp。注意：使用一维dp的时候，需要上一行的前一个数，所以不能使用上一个数和前一个数更新，还要保留上一行。 1234567891011121314151617int longestCommonSubsequence(string text1, string text2) &#123; if(text1.size()==0||text2.size()==0) return 0; vector&lt;int&gt; dp(text2.size()+1, 0); vector&lt;int&gt; last(text2.size()+1, 0); for (int i = 1; i &lt;= text1.size();i++)&#123; for (int j = 1; j &lt;= text2.size();j++)&#123; if(text2[j-1]==text1[i-1]) dp[j] = last[j - 1] + 1; else dp[j] = max(last[j], dp[j - 1]); &#125; last = dp; &#125; return dp[text2.size()];&#125; 时间复杂度：O(mn)空间复杂度：O(2n) Leetcode 583. 两个字符串的删除操作（中等）给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。 示例： 123输入: &quot;sea&quot;, &quot;eat&quot;输出: 2解释: 第一步将&quot;sea&quot;变为&quot;ea&quot;，第二步将&quot;eat&quot;变为&quot;ea&quot; 题解：其实就是算最长公共子序列。 二维dp 123456789101112131415161718int minDistance(string word1, string word2) &#123; if(word1.empty()) return word2.size(); if(word2.empty()) return word1.size(); int m = word1.size(), n = word2.size(); vector&lt;vector&lt;int&gt; &gt; dp(m+1,vector&lt;int&gt;(n+1, 0)); for(int i=1;i&lt;=m;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(word1[i-1]==word2[j-1]) dp[i][j] = dp[i-1][j-1]+1; else dp[i][j] = max(dp[i-1][j],dp[i][j-1]); &#125; &#125; return m+n-2*dp[m][n];&#125; 时间复杂度：O(mn)空间复杂度：O(mn) 一维dp。注意：使用一维dp的时候，需要上一行的前一个数，所以不能使用上一个数和前一个数更新，还要保留上一行。 123456789101112131415161718192021int minDistance(string word1, string word2) &#123; if(word1.empty()) return word2.size(); if(word2.empty()) return word1.size(); int m = word1.size(), n = word2.size(); vector&lt;int&gt; dp(n+1); vector&lt;int&gt; last(n+1); for(int i=1;i&lt;=m;i++)&#123; for (int j = 1; j &lt;= n; j++) &#123; if (word1[i - 1] == word2[j - 1]) dp[j] = last[j-1] + 1; else dp[j] = max(last[j],dp[j-1]); &#125; last = dp; &#125; return m+n-2*dp[n];&#125; 时间复杂度：O(mn)空间复杂度：O(2n) 最大连续子数组Leetcode 53. 最大子序和（简单）给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 题解：dp。优化空间复杂度为O(1)。 12345678int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int pre = 0, res = nums[0]; for (const auto &amp;x: nums) &#123; pre = max(pre + x, x); res = max(res, pre); &#125; return res;&#125; 时间复杂度：O(n)空间复杂度：O(1) 返回最大子数组在上题的基础上，要返回这个最大子数组，不只是和。 题解：对于dp[i]=max(dp[i-1]+nums[i], nums[i]) 当dp[i-1]&lt;0时，nums[i]大 当dp[i-1]&gt;0时，dp[i-1]+nums[i]大因为要返回数组，所以在状态转移时需要更新一下开始索引。12345678910111213141516171819202122232425vector&lt;int&gt; maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int pre = nums[0], start = 0; int maxSum = INT_MIN; vector&lt;int&gt; resIdx(2); for (int i = 1; i &lt; nums.size(); i++) &#123; if(pre &gt; 0)&#123; //如果返回最长的子数组，这个就应该是 if(pre &gt;= 0) pre = pre + nums[i]; &#125;else&#123;//子数组的开始索引要更新了 pre = nums[i]; start = i; &#125; if(pre &gt; maxSum)&#123;//更新答案 maxSum = pre; resIdx[0] = start; resIdx[1] = i; &#125; &#125; vector&lt;int&gt; res; for (int i = resIdx[0]; i &lt;= resIdx[1]; i++)&#123; res.push_back(nums[i]); &#125; return res;&#125; 时间复杂度：O(n)空间复杂度：O(1) 旋转数组的最大连续子数组旋转连续子数组和给定一个旋转数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 注意： 12旋转数组为首位相连的数组，如：[1,2,3] 的子数组有 [1,2],[2,3],[3,1] 题解：以[2,1,3]为例，最大子数组可能位于 中间(如[1,3]) 或者 两边([3,2])。 若最大子数组在中间，则用上题方法可得； 若最大子数组在两边，使用dp求出位于中间的最小子数组的和，就得到了位于两边的最大子数组和。因为数组和是一定的，中间的子数组和越小，位于两边的子数组和越大。 1234567891011121314151617181920212223int maxSubArray(vector&lt;int&gt;&amp; nums)&#123; //位于中间 最大和 的 子数组 int pre = 0, maxMid = nums[0]; for (const int n : nums) &#123; pre = max(n, pre + n); maxMid = max(maxMid, pre); &#125; //位于两边 最大和 的 子数组 //中间最小和 pre = nums[0]; int minMid = nums[0], sumn = nums[0]; for (int i = 1; i &lt; nums.size(); i++) &#123; pre = min(nums[i], pre + nums[i]); minMid = min(minMid, pre); sumn += nums[i]; &#125; int maxSide = sumn - minMid; //两边 最大和 return maxMid &gt; maxSide ? maxMid : maxSide;&#125; 时间复杂度：O(n)空间复杂度：O(1) 返回最大和的旋转连续子数组给定一个旋转数组nums，返回一个具有最大和的连续子数组，不只是和。题解：在上题状态转移的基础上，增加了索引的记录。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364vector&lt;int&gt; maxSubArray(vector&lt;int&gt;&amp; nums) &#123; //位于中间 最大和 的 子数组 int pre = nums[0], start = 0; int maxMid = INT_MIN; vector&lt;int&gt; maxIdx(2); for (int i = 1; i &lt; nums.size(); i++) &#123; if(pre &gt; 0)&#123; //如果返回最长的子数组，这个就应该是 if(pre &gt;= 0) pre = pre + nums[i]; &#125;else&#123;//子数组的开始索引要更新了 pre = nums[i]; start = i; &#125; if(pre &gt; maxMid)&#123;//更新答案 maxMid = pre; maxIdx[0] = start; maxIdx[1] = i; &#125; &#125; //位于两边 最大和 的 子数组 //中间最小和 pre = nums[0]; start = 0; int minMid = nums[0], sumn = nums[0]; vector&lt;int&gt; minIdx(2); for (int i = 1; i &lt; nums.size(); i++) &#123; sumn += nums[i]; if(pre &lt; 0)&#123; pre = pre + nums[i]; &#125;else&#123; pre = nums[i]; start = i; &#125; if(pre &lt; minMid)&#123; minMid = pre; minIdx[0] = start; minIdx[1] = i; &#125; &#125; vector&lt;int&gt; resIdx(2); vector&lt;int&gt; res; if(maxMid &gt; (sumn - minMid))&#123;//子数组在中间 resIdx = maxIdx; for (int i = resIdx[0]; i &lt;= resIdx[1]; i++)&#123; res.push_back(nums[i]); &#125; &#125; else&#123;//子数组在两边 resIdx[0] = (minIdx[1] + 1) % nums.size(); resIdx[1] = (minIdx[0] - 1 + nums.size()) % nums.size(); for (int i = resIdx[0]; i &lt; nums.size(); i++)&#123; res.push_back(nums[i]); &#125; for (int i = 0; i &lt;= resIdx[1]; i++)&#123; res.push_back(nums[i]); &#125; &#125; return res;&#125; 时间复杂度：O(n)空间复杂度：O(1) 二维矩阵最大子矩阵和最大子矩阵和给定一个正整数和负整数组成的矩阵matrix，返回元素总和最大的子矩阵。 题解：我们在前面已经会求最大子数组和，最大矩阵和只需要把二维矩阵压缩为一维数组，再用之前求最大子数组和的方法，就可以得到最大矩阵和。 我们把矩阵垂直压缩成一维数组，如： 123456789matrix = [[1,2,3], [1,2,3]]可以压缩成：nums = [2,4,6]其中: nums[0] = matrix[0][0] + matrix[1][0]nums[1] = matrix[0][1] + matrix[1][1]nums[2] = matrix[0][2] + matrix[1][2] 123456789101112131415161718192021222324252627282930int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int pre = 0, res = nums[0]; for (const auto &amp;x: nums) &#123; pre = max(pre + x, x); res = max(res, pre); &#125; return res;&#125;int maxSubMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)&#123; if(matrix.empty()) return 0; int rows = matrix.size(); int cols = matrix[0].size(); int res = INT_MIN; for (int up = 0; up &lt; rows; up++)//上界 &#123; vector&lt;int&gt; nums(cols, 0);//压缩为一维数组 for (int buttom = up; buttom &lt; rows; buttom++)//下界 &#123; for (int i = 0; i &lt; cols;i++)//每次往下一行，就只需在之前的nums上加上这一行 nums[i] += matrix[buttom][i]; int maxArr = maxSubArray(nums); res = max(maxArr, res); &#125; &#125; return res;&#125; 返回最大子矩阵在更新最大和的时候记录左上角和右下角的索引。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int maxSubArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt; &amp;maxIdx) &#123; int pre = nums[0], start = 0; int maxSum = INT_MIN; for (int i = 1; i &lt; nums.size(); i++) &#123; if(pre &gt; 0)&#123; //如果返回最长的子数组，这个就应该是 if(pre &gt;= 0) pre = pre + nums[i]; &#125;else&#123;//子数组的开始索引要更新了 pre = nums[i]; start = i; &#125; if(pre &gt; maxSum)&#123;//更新答案 maxSum = pre; maxIdx[0] = start; maxIdx[1] = i; &#125; &#125; return maxSum;&#125;vector&lt;vector&lt;int&gt; &gt; maxSubMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)&#123; if(matrix.empty()) return matrix; int rows = matrix.size(); int cols = matrix[0].size(); int maxArr = INT_MIN; vector&lt;int&gt; maxIdx(4);//0上、1左、2下、3右 for (int up = 0; up &lt; rows; up++)//上界 &#123; vector&lt;int&gt; nums(cols, 0);//压缩为一维数组 for (int down = up; down &lt; rows; down++)//下界 &#123; for (int i = 0; i &lt; cols;i++)//每次往下一行，就只需在之前的nums上加上这一行 nums[i] += matrix[down][i]; vector&lt;int&gt; tmpIdx(2); int tmp = maxSubArray(nums, tmpIdx); if(tmp &gt; maxArr)&#123; maxArr = tmp; maxIdx[0] = up; maxIdx[1] = tmpIdx[0]; maxIdx[2] = down; maxIdx[3] = tmpIdx[1]; &#125; &#125; &#125; int subRows = maxIdx[2] - maxIdx[0] + 1; int subCols = maxIdx[3] - maxIdx[1] + 1; vector&lt;vector&lt;int&gt; &gt; res(subRows,vector&lt;int&gt;(subCols)); for (int row = maxIdx[0], i = 0; row &lt;= maxIdx[2]; row++, i++) &#123; for (int col = maxIdx[1], j = 0; col &lt;= maxIdx[3]; col++, j++) &#123; res[i][j] = matrix[row][col]; &#125; &#125; return res;&#125; 二维矩阵最大旋转子矩阵最旋转大子矩阵和给定一个正整数和负整数组成的旋转矩阵matrix，返回元素总和最大的子矩阵。 题解：只需要把上题求最大子数组和的函数换为上面提到的最大旋转子数组的函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445int maxSubArray(vector&lt;int&gt;&amp; nums)&#123; //位于中间 最大和 的 子数组 int pre = 0, maxMid = nums[0]; for (const int n : nums) &#123; pre = max(n, pre + n); maxMid = max(maxMid, pre); &#125; //位于两边 最大和 的 子数组 //中间最小和 pre = nums[0]; int minMid = nums[0], sumn = nums[0]; for (int i = 1; i &lt; nums.size(); i++) &#123; pre = min(nums[i], pre + nums[i]); minMid = min(minMid, pre); sumn += nums[i]; &#125; int maxSide = sumn - minMid; return maxMid &gt; maxSide ? maxMid : maxSide;&#125;int maxSubMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)&#123; if(matrix.empty()) return 0; int rows = matrix.size(); int cols = matrix[0].size(); int res = INT_MIN; for (int up = 0; up &lt; rows; up++)//上界 &#123; vector&lt;int&gt; nums(cols, 0);//压缩为一维数组 for (int buttom = up; buttom &lt; rows; buttom++)//下界 &#123; for (int i = 0; i &lt; cols;i++)//每次往下一行，就只需在之前的nums上加上这一行 nums[i] += matrix[buttom][i]; int maxArr = maxSubArray(nums); res = max(maxArr, res); &#125; &#125; return res;&#125; 返回最大旋转子矩阵在上题的基础上记录坐标。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107int maxSubArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt; &amp;resIdx) &#123; //位于中间 最大和 的 子数组 int pre = nums[0], start = 0; int maxMid = INT_MIN; vector&lt;int&gt; maxIdx(2); for (int i = 1; i &lt; nums.size(); i++) &#123; if(pre &gt; 0)&#123; //如果返回最长的子数组，这个就应该是 if(pre &gt;= 0) pre = pre + nums[i]; &#125;else&#123;//子数组的开始索引要更新了 pre = nums[i]; start = i; &#125; if(pre &gt; maxMid)&#123;//更新答案 maxMid = pre; maxIdx[0] = start; maxIdx[1] = i; &#125; &#125; //位于两边 最大和 的 子数组 //中间最小和 pre = nums[0]; start = 0; int minMid = nums[0], sumn = nums[0]; vector&lt;int&gt; minIdx(2); for (int i = 1; i &lt; nums.size(); i++) &#123; sumn += nums[i]; if(pre &lt; 0)&#123; pre = pre + nums[i]; &#125;else&#123; pre = nums[i]; start = i; &#125; if(pre &lt; minMid)&#123; minMid = pre; minIdx[0] = start; minIdx[1] = i; &#125; &#125; int maxArr = sumn - minMid; if (maxMid &gt; maxArr)&#123; //子数组在中间 resIdx = maxIdx; maxArr = maxMid; &#125;else&#123;//子数组在两边 resIdx[0] = (minIdx[1] + 1) % nums.size(); resIdx[1] = (minIdx[0] - 1 + nums.size()) % nums.size(); &#125; return maxArr;&#125;vector&lt;vector&lt;int&gt; &gt; maxSubMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)&#123; if(matrix.empty()) return matrix; int rows = matrix.size(); int cols = matrix[0].size(); int maxArr = INT_MIN; vector&lt;int&gt; maxIdx(4);//0上、1左、2下、3右 for (int up = 0; up &lt; rows; up++)//上界 &#123; vector&lt;int&gt; nums(cols, 0);//压缩为一维数组 for (int down = up; down &lt; rows; down++)//下界 &#123; for (int i = 0; i &lt; cols;i++)//每次往下一行，就只需在之前的nums上加上这一行 nums[i] += matrix[down][i]; vector&lt;int&gt; tmpIdx(2); int tmp = maxSubArray(nums, tmpIdx); if(tmp &gt; maxArr)&#123; maxArr = tmp; maxIdx[0] = up; maxIdx[1] = tmpIdx[0]; maxIdx[2] = down; maxIdx[3] = tmpIdx[1]; &#125; &#125; &#125; int subRows = maxIdx[2] - maxIdx[0] + 1; vector&lt;vector&lt;int&gt; &gt; res; if (maxIdx[3] &gt;= maxIdx[1]) &#123; //子矩阵在中间 int subCols = maxIdx[3] - maxIdx[1] + 1; // vector&lt;int&gt; tmpVec(subCols); res.resize(subRows, vector&lt;int&gt;(subCols)); for (int row = maxIdx[0], i = 0; row &lt;= maxIdx[2]; row++, i++)&#123; for (int col = maxIdx[1], j = 0; col &lt;= maxIdx[3]; col++, j++) res[i][j] = matrix[row][col]; &#125; &#125; else &#123; //子矩阵在两边 int subCols = cols - (maxIdx[1] - maxIdx[3] - 1); res.resize(subRows,vector&lt;int&gt;(subCols)); for (int row = maxIdx[0], i = 0; row &lt;= maxIdx[2]; row++, i++)&#123; int j = 0; for (int col = maxIdx[1]; col &lt; cols; col++, j++) res[i][j] = matrix[row][col]; for (int col = 0; col &lt;= maxIdx[3]; col++,j++) res[i][j] = matrix[row][col]; &#125; &#125; return res;&#125; 3.2.4 0-1背包问题&amp;emsp;&amp;emsp;有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。&amp;emsp;设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论： 第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。 第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。 &amp;emsp;&amp;emsp;第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为： dp[i][j]=max(dp[i-1][j],dp[i-1][j-w]+v) 二维dp 0-1 背包dp[i][j]表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。 1234567891011121314151617int knapsack(vector&lt;vector&lt;int&gt; &gt; &amp;nums, int N)&#123; //nums = &#123; &#123;5,12&#125;,&#123;4,3&#125;,&#123;7,10&#125;,&#123;2,3&#125;,&#123;6,6&#125; &#125;;//&#123;wight,val&#125; //N = 15; vector&lt;vector&lt;int&gt; &gt; dp(nums.size()+1,vector&lt;int&gt;(N+1)); for (int i = 1; i &lt;= nums.size(); i++) &#123; for (int j = 1; j &lt;= N;j++)&#123; int weight = nums[i - 1][0]; int val = nums[i - 1][1]; if (j &gt;= weight) dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight] + val); else dp[i][j] = dp[i - 1][j]; &#125; &#125; return dp[nums.size()][N];&#125; 时间复杂度：O(mn)空间复杂度：O(mn) 空间优化：一维dp 0-1 背包观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。 d[j] = max(d[j],d[j-w]+v) 因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，防止将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。 123456789101112int knapsack(vector&lt;vector&lt;int&gt; &gt; &amp;nums, int N)&#123; vector&lt;int&gt; dp(N+1); for (int i = 1; i &lt;=nums.size();i++)&#123; int weight = nums[i - 1][0]; int val = nums[i - 1][1]; for (int j = N; j &gt;= 1;j--)&#123; if(j&gt;=weight) dp[j] = max(dp[j], dp[j - weight] + val); &#125; &#125; return dp[N];&#125; 时间复杂度：O(mn)空间复杂度：O(n) Leetcode 416. 分割等和子集（中等）给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 示例： 123Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. 题解：可以看成一个背包大小为 sum&#x2F;2 的 0-1 背包问题。 二维dp。 12345678910111213141516171819202122bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; for (int i = 0; i &lt; nums.size();i++) sum += nums[i]; if(sum &amp; 1)//奇数 return false; int W = sum / 2; vector&lt;vector&lt;bool&gt; &gt; dp(nums.size()+1,vector&lt;bool&gt;(W+1,false)); for (int m = 0; m &lt; nums.size();m++) dp[m][0] = true; for (int i = 1; i &lt;= nums.size(); i++) &#123; for (int j = 1; j &lt;= W; j++) &#123; dp[i][j] = dp[i - 1][j]; if((!dp[i][j]) &amp;&amp; j&gt;=nums[i-1]) dp[i][j] = dp[i - 1][j - nums[i - 1]]; &#125; &#125; return dp[nums.size()][W];&#125; 一维dp。 12345678910111213141516bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; for (int i = 0; i &lt; nums.size();i++) sum += nums[i]; if(sum &amp; 1)//奇数 return false; int W = sum / 2; vector&lt;bool&gt; dp1(W + 1,false); dp1[0] = true; for(auto num:nums)&#123; for (int j = W; j &gt;= num;j--) dp1[j] = dp1[j] || dp1[j - num]; &#125; return dp1[W];&#125; leetcode 494. 目标和（中等）给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 示例： 123456789Input: nums is [1, 1, 1, 1, 1], S is 3. Output: 5 Explanation: -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3 There are 5 ways to assign symbols to make the sum of nums be target 3. 题解：该问题可以转换为 Subset Sum 问题，从而使用 0-1 背包的方法来求解。 可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导： sum(P) - sum(N) &#x3D; target sum(P) + sum(N) + sum(P) - sum(N) &#x3D; target + sum(P) + sum(N) 2 * sum(P) &#x3D; target + sum(nums) 因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))&#x2F;2，就证明存在解。 12345678910111213int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; long sum = 0; for (const int &amp;num : nums) sum += num; if ((S + sum) % 2 == 1 || S &gt; sum) return 0; S = (S + sum) / 2; vector&lt;int&gt; dp(S+1); dp[0] = 1; for (const int &amp;num : nums) &#123; for (int j = S; j &gt;= num; j--) dp[j] += dp[j - num]; &#125; return dp[S];&#125; 时间复杂度：O(nW)空间复杂度：O(W) 0-1 背包问题无法使用贪心算法的解释0-1 背包问题无法使用贪心算法来求解，也就是说不能按照先添加性价比最高的物品来达到最优，这是因为这种方式可能造成背包空间的浪费，从而无法达到最优。考虑下面的物品和一个容量为 5 的背包，如果先添加物品 0 再添加物品 1，那么只能存放的价值为 16，浪费了大小为 2 的空间。最优的方式是存放物品 1 和物品 2，价值为 22. id w v v&#x2F;w 0 1 6 6 1 2 10 5 2 3 12 4 变种 完全背包：物品数量为无限个 多重背包：物品数量有限制 多维费用背包：物品不仅有重量，还有体积，同时考虑这两种限制 其它：物品之间相互约束或者依赖 3.2.5 股票问题Leetcode 121. 买卖股票的最佳时机（简单）给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 示例： 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 题解：用minPrices来记录历史最低价，res目前的最大收益。 12345678910int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; int minPrices = prices[0], res = 0; for(int &amp;p:prices)&#123; res = max(res, p - minPrices); minPrices = min(p,minPrices); &#125; return res;&#125; 时间复杂度：O(n)空间复杂度：O(1) Leetcode 122. 买卖股票的最佳时机 II（简单）给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 示例： 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 题解： 贪心。只要第二天价格有上升，就可以获利。 12345678int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0; for (int i = 1; i &lt; prices.size(); i++) &#123; if (prices[i] &gt; prices[i - 1]) res += prices[i] - prices[i - 1]; &#125; return res;&#125; 时间复杂度：O(n)空间复杂度：O(1) 空间优化dp。 1234567891011121314int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.empty()) return 0; int dp0 = 0, dp1 = -prices[0]; int n = prices.size(); for (int i = 1; i &lt; n; i++) &#123; int dp0_new = max(dp0, dp1 + prices[i]); int dp1_new = max(dp1, dp0 - prices[i]); dp0 = dp0_new; dp1 = dp1_new; &#125; return dp0;&#125; 时间复杂度：O(n)空间复杂度：O(1) Leetcode 123. 买卖股票的最佳时机 III（困难）给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 示例： 1234567891011输入: [3,3,5,0,0,3,1,4] 输出: 6 解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出,这笔交易所能获得利润 = 5-1 = 4。`注意`你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 输入: [7,6,4,3,1] 输出: 0 解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。 题解： dp。 123456789101112131415161718int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.empty()) return 0; int n = prices.size(); vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; dp(n,vector&lt;vector&lt;int&gt; &gt;(3, vector&lt;int&gt;(2))); dp[0][1][0] = 0; dp[0][1][1] = -prices[0]; dp[0][2][0] = 0; dp[0][2][1] = -prices[0]; for (int i = 1; i &lt; n; i++) &#123; dp[i][2][0] = max(dp[i - 1][2][0], dp[i - 1][2][1] + prices[i]); dp[i][2][1] = max(dp[i - 1][2][1], dp[i - 1][1][0] - prices[i]); dp[i][1][0] = max(dp[i - 1][1][0], dp[i - 1][1][1] + prices[i]); dp[i][1][1] = max(dp[i - 1][1][1], dp[i - 1][0][0] - prices[i]); &#125; return dp[n - 1][2][0];&#125; 时间复杂度：O(n)空间复杂度：O(n) 空间优化dp 1234567891011121314151617int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.empty()) return 0; int n = prices.size(); int dp10 = 0; int dp11 = -prices[0]; int dp20 = 0; int dp21 = -prices[0]; for (int i = 1; i &lt; n; i++) &#123; dp20 = max(dp20, dp21 + prices[i]); dp21 = max(dp21, dp10 - prices[i]); dp10 = max(dp10, dp11 + prices[i]); dp11 = max(dp11, -prices[i]); &#125; return dp20;&#125; 时间复杂度：O(n)空间复杂度：O(1) Leetcode 188. 买卖股票的最佳时机 IV（困难）给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 示例： 123输入: [2,4,1], k = 2输出: 2解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 题解：一个有收益的交易至少需要两天（在前一天买入，在后一天卖出，前提是买入价格低于卖出价格）。如果股票价格数组的长度为 n，则有收益的交易的数量最多为 n &#x2F; 2（整数除法）。因此 k 的临界值是 n &#x2F; 2。如果给定的 k 不小于临界值，即 k &gt;&#x3D; n &#x2F; 2，则可以将 k 扩展为正无穷，此时问题等价于Leetcode 122。 其中用到了函数重载。 dp。 1234567891011121314151617181920212223242526272829int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0; for (int i = 1; i &lt; prices.size(); i++) &#123; if (prices[i] &gt; prices[i - 1]) res += prices[i] - prices[i - 1]; &#125; return res;&#125;int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if (prices.empty()) return 0; int n = prices.size(); if (k &gt;= n / 2) return maxProfit(prices); vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; dp(n,vector&lt;vector&lt;int&gt; &gt;(k+1, vector&lt;int&gt;(2))); for (int i = 1; i &lt;= k; i++) &#123; dp[0][i][0] = 0; dp[0][i][1] = -prices[0]; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = k; j &gt; 0; j--) &#123; dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]); dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]); &#125; &#125; return dp[n - 1][k][0];&#125; 时间复杂度：O(nk)空间复杂度：O(nk) 空间优化。 123456789101112131415161718192021222324252627282930int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0; for (int i = 1; i &lt; prices.size(); i++) &#123; if (prices[i] &gt; prices[i - 1]) res += prices[i] - prices[i - 1]; &#125; return res;&#125;int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if (prices.empty()) return 0; int n = prices.size(); if (k &gt;= n / 2) return maxProfit(prices); vector&lt;vector&lt;int&gt; &gt; dp(k+1, vector&lt;int&gt;(2)); for (int i = 1; i &lt;= k; i++) &#123; dp[i][0] = 0; dp[i][1] = -prices[0]; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = k; j &gt; 0; j--) &#123; dp[j][0] = max(dp[j][0], dp[j][1] + prices[i]); dp[j][1] = max(dp[j][1], dp[j - 1][0] - prices[i]); &#125; &#125; return dp[k][0];&#125; 时间复杂度：O(nk)空间复杂度：O(n) Leetcode 309. 最佳买卖股票时机含冷冻期（中等）给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例： 123输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 题解： dp。dp[i]表示第 i 天结束之后的累计最大收益。 dp[i][0]表示目前持有一支股票，对应的累计最大收益 dp[i][1]表示目前不持有任何股票，并且处于冷冻期中，对应的累计最大收益 dp[i][2]表示目前不持有任何股票，并且不处于冷冻期中，对应的累计最大收益 123456789101112int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; vector&lt;vector&lt;int&gt; &gt; dp(prices.size(), vector&lt;int&gt;(3)); dp[0][0] = -prices[0]; //dp[0][1] = dp[0][2] = 0 for (int i = 1; i &lt; prices.size();i++)&#123; dp[i][0] = max(dp[i - 1][2] - prices[i], dp[i - 1][0]); //买了，或者没有买。不可能从冷却期直接到持有 dp[i][1] = dp[i - 1][0] + prices[i]; //卖了 dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]); //冷却期过度，或者没有买 &#125; return max(dp[prices.size() - 1][1], dp[prices.size() - 1][2]);&#125; 时间复杂度：O(n)空间复杂度：O(n) 空间优化。 1234567891011121314151617int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; int dp0 = -prices[0]; int dp1 = 0; int dp2 = 0; for (int i = 1; i &lt; prices.size(); ++i) &#123; int dp0_new = max(dp0, dp2 - prices[i]); int dp1_new = dp0 + prices[i]; int dp2_new = max(dp1, dp2); dp0 = dp0_new; dp1 = dp1_new; dp2 = dp2_new; &#125; return max(dp1, dp2);&#125; 时间复杂度：O(n)空间复杂度：O(1) Leetcode 714. 买卖股票的最佳时机含手续费（中等）给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 示例： 12345678Input: prices = [1, 3, 2, 8, 4, 9], fee = 2 Output: 8 Explanation: The maximum profit can be achieved by: Buying at prices[0] = 1 Selling at prices[3] = 8 Buying at prices[4] = 4 Selling at prices[5] = 9 The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8. 题解： dp。 1234567891011121314int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; if (prices.empty()) return 0; int n = prices.size(); vector&lt;vector&lt;int&gt; &gt; dp(n,vector&lt;int&gt;(2)); dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i = 1; i &lt; n; i++) &#123; dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee); dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); &#125; return dp[n - 1][0];&#125; 时间复杂度：O(n)空间复杂度：O(n) 空间优化。 123456789101112131415int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; if (prices.empty()) return 0; int n = prices.size(); int dp0 = 0; int dp1 = -prices[0]; for (int i = 1; i &lt; n; i++) &#123; int dp0_new = max(dp0, dp1 + prices[i] - fee); int dp1_new = max(dp1, dp0 - prices[i]); dp0 = dp0_new; dp1 = dp1_new; &#125; return dp0;&#125; 时间复杂度：O(n)空间复杂度：O(1) res股票问题系列通解 3.2.6 字符串问题Leetcode 650. 只有两个键的键盘（中等）最开始只有一个字符 A，问需要多少次操作能够得到 n 个字符 A，每次操作可以复制当前所有的字符，或者粘贴。 示例： 1234567输入: 3输出: 3解释:最初, 我们只有一个字符 &#x27;A&#x27;。第 1 步, 我们使用 Copy All 操作。第 2 步, 我们使用 Paste 操作来获得 &#x27;AA&#x27;。第 3 步, 我们使用 Paste 操作来获得 &#x27;AAA&#x27;。 题解：dp。dp[i]表示通过复制粘贴操作，得到 i 个字符，最少需要几步操作。 如果一个数是素数，那么最少操作就是一开始复制一个，最后一个个粘贴；如果一个数不是素数，那么最少操作就可以按它的因数分解一下，简化操作。 比如12，可以分解为 以下几种情况： 12 &#x3D; 2*6, 需要操作CPCPPPPP总共8步 12 &#x3D; 3*4, 需要操作CPPCPPP总共7步 12 &#x3D; 4*3, 需要操作CPPPCPP总共7步 12 &#x3D; 6*2, 需要操作CPPPPPCP总共8步 其实可以发现，因子相同的情况下，交换因子相乘的顺序，需要的步骤是一样的。所以我们可以简化一下分解的步骤，只需要找到小于sqrt(n)的因子即可。假设找到的因子是 j ，那么需要的最小步骤就是 dp[j] + dp[i/j]，其中，dp[j]表示需要多少步生成这个因子，dp[i/j]表示需要多少步基于这个因子得到 i。 1234567891011121314int minSteps(int n)&#123; vector&lt;int&gt; dp(n + 1); int h = sqrt(n); for (int i = 2; i &lt;= n;i++)&#123; dp[i] = i; for (int j = 2; j &lt;= h; j++)&#123; if(i%j==0)&#123; dp[i] = dp[j] + dp[i / j]; break; &#125; &#125; &#125; return dp[n];&#125; 时间复杂度：O(n^(1&#x2F;2))空间复杂度：O(1) 3.3 贪心算法(greedy)每次都选择局部最优的策略，最后达到全局最优。但是，有的问题使用贪心算法不能保证达到全局最优，如 0-1背包问题。 Leetcode 455. 分发饼干（简单）每个孩子都有一个满足度 grid，每个饼干都有一个大小 size，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。 示例： 12Input: grid[1,3], size[1,2,4] Output: 2 题解：给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。 1234567891011121314int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; sort(g.begin(), g.end()); sort(s.begin(), s.end()); int m = g.size(); int n = s.size(); int idxG = 0, idxS = 0; while(idxG&lt;m &amp;&amp; idxS&lt;n)&#123; if(g[idxG]&lt;=s[idxS]) idxG++; idxS++; &#125; return idxG;&#125; 时间复杂度：O(nlogn)，因为要排序空间复杂度：O(1) 上一题的变体要求出满足最多孩子的方法中每个孩子得到的的饼干编号。 示例： 123输入：grid = &#123;90, 33, 16&#125; size = &#123;9, 20, 50, 40, 99, 1&#125;输出： 5 4 2 题解：使用了map的自动key排序功能。 1234567891011121314151617181920vector&lt;int&gt; cookiesAssign2(vector&lt;int&gt; &amp;grid, vector&lt;int&gt; &amp;size)&#123; map&lt;int, int&gt; sizeMap; //key: grid val: idx map&lt;int, int&gt; gridMap; //key: size val: idx for (int i = 0; i &lt; grid.size(); i++) gridMap.insert(&#123;grid[i], i&#125;); for (int i = 0; i &lt; size.size();i++) sizeMap.insert(&#123;size[i], i&#125;); vector&lt;int&gt; res(grid.size(), -1); for (auto itG = gridMap.begin(), itS = sizeMap.begin(); itG != gridMap.end() &amp;&amp; itS!=sizeMap.end(); itG++, itS++) &#123; while(itS!=sizeMap.end() &amp;&amp; itS-&gt;first &lt; itG-&gt;first) itS++; if(itS==sizeMap.end()) break; res[itG-&gt;second] = itS-&gt;second; &#125; return res;&#125; Leetcode 435. 无重叠区间（中等）给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 示例： 123456Input: [ [1,2], [1,2], [1,2] ] Output: 2 Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping. Input: [ [1,2], [2,3] ] Output: 0 Explanation: You don&#x27;t need to remove any of the intervals since they&#x27;re already non-overlapping. 题解：先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。 1234567891011121314151617bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123; return a[1] &lt; b[1];&#125;int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals)&#123; if(intervals.empty()) return 0; sort(intervals.begin(), intervals.end(), cmp); int cnt = 0; int end = intervals[0][0]; for(auto num:intervals)&#123; if(num[0]&gt;=end)&#123; cnt++; end = num[1]; &#125; &#125; return intervals.size()-cnt;&#125; 时间复杂度：O(nlogn)，因为要排序空间复杂度：O(1) Leetcode 452. 用最少数量的箭引爆气球（中等）气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。 示例： 12Input:[[10,16], [2,8], [1,6], [7,12]] Output:2 题解：求解最小的投飞镖次数使所有气球都被刺破。也是计算不重叠的区间个数，不过和 Leetcode 435 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。所以if判定条件不要”&#x3D;”，end初始化要比points[0][0]小。 1234567891011121314151617bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123; return a[1] &lt; b[1];&#125;int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; if(points.empty()) return 0; sort(points.begin(), points.end(), cmp); int cnt = 0; long end = (long)points[0][0]-1; for(auto num:points)&#123; if(num[0]&gt;end)&#123; cnt++; end = num[1]; &#125; &#125; return cnt;&#125; 时间复杂度：O(nlogn)，因为要排序空间复杂度：O(1) Leetcode 406. 根据身高重建队列（中等）乱序重建：一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。 示例： 12Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 题解：为了使插入操作不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置。身高 h 降序、个数 k 值升序，然后将某个学生插入队列的第 k 个位置中。 12345678910111213141516bool cmp0aca1dec(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123; return a[0] == b[0] ? a[1] &lt;= b[1] : a[0] &gt; b[0];&#125;vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123; if(people.empty()) return &#123;&#125;; sort(people.begin(), people.end(), cmp0aca1dec); vector&lt;vector&lt;int&gt; &gt; res; for (int i = 0; i &lt; people.size(); i++)&#123; auto pos = res.begin(); res.insert(pos+people[i][1], people[i]); &#125; return res;&#125; Leetcode 605. 种花问题（简单）flowerbed 数组中 1 表示已经种下了花朵。花朵之间至少需要一个单位的间隔，求解是否能种下 n 朵花。 示例： 12Input: flowerbed = [1,0,0,0,1], n = 1 Output: True 题解： 1234567891011121314151617181920bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123; int nFlower = flowerbed.size(); if(n==0) return true; for (int i = 0; i &lt; nFlower; i++) &#123; if(flowerbed[i]==1) continue; int pre = i-1 &gt;= 0 ? flowerbed[i - 1] : 0; //第一个位置? int next = i+1 &lt;= nFlower-1 ? flowerbed[i + 1] : flowerbed[nFlower-1];//最后一个位置? if(pre==0 &amp;&amp; next==0 )&#123; flowerbed[i] = 1; n--; &#125; if(n==0) return true; &#125; return false;&#125; 时间复杂度：O(n)空间复杂度：O(1) Leetcode 392.判断子序列（简单）判断是否为子序列 示例： 12s = &quot;abc&quot;, t = &quot;ahbgdc&quot; Return true. 题解：双指针。 12345678910111213141516bool isSubsequence(string s, string t) &#123; if(t.empty())&#123; if(s.empty()) return true; else return false; &#125; int idxS=0,idxT=0; while(idxS&lt;s.size() &amp;&amp; idxT&lt;t.size())&#123; if(s[idxS]==t[idxT]) idxS++; idxT++; &#125; return idxS==s.size();&#125; 时间复杂度：O(m+n)空间复杂度：O(1) Leetcode 665. 非递减数列（简单）判断一个数组是否能只修改一个数就成为非递减数组。 示例： 123Input: [4,2,3] Output: True Explanation: You could modify the first 4 to 1 to get a non-decreasing array. 题解：如果下一个点有下降，我们当前点称为拐点，如[1,3,2]中的3。 如果拐点前一个数小于等于拐点后一个数，如[1,3,2,4,5]中1&lt;2，则改变拐点的数，把 3 变成 2 能保证数列不减，且不改变前后的拐点数。 如果拐点前一个数大于拐点后一个数，如[2,3,1,4,5]中2&gt;1，则改变拐点后的数，把 1 变成 3 能保证数列不减，且不改变前后的拐点数。 12345678910111213bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123; int cnt = 0; for (int i = 1; i &lt; nums.size() &amp;&amp; cnt &lt; 2;i++)&#123; if(nums[i]&gt;=nums[i-1]) continue; cnt++; if(i&gt;=2 &amp;&amp; nums[i-2]&gt;nums[i]) nums[i] = nums[i - 1]; else nums[i - 1] = nums[i]; &#125; return (cnt &lt;= 1);&#125; 时间复杂度：O(n)空间复杂度：O(1) Leetcode 763. 划分字母区间（中等）字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。 示例： 12345Input: S = &quot;ababcbacadefegdehijhklij&quot; Output: [9,7,8] Explanation: The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;. This is a partition so that each letter appears in at most one part. A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts. 题解：策略就是不断地选择从最左边起最小的区间。 可以从第一个字母开始分析，假设第一个字母是 ‘a’，那么第一个区间一定包含最后一次出现的 ‘a’。但第一个出现的 ‘a’ 和最后一个出现的 ‘a’ 之间可能还有其他字母，这些字母会让区间变大。举个例子，在 “abccaddbeffe” 字符串中，第一个最小的区间是 “abccaddb”。 通过以上的分析，我们可以得出一个算法：对于遇到的每一个字母，去找这个字母最后一次出现的位置，用来更新当前的最小区间。如果要输出所有子串，把备注取消就可以。 123456789101112131415161718192021vector&lt;int&gt; partitionLabels(string S) &#123; vector&lt;int&gt; alphabet(26); for (int i = 0; i &lt; S.size();i++) alphabet[S[i] - &#x27;a&#x27;] = i; int startIdx = 0, lastIdx = 0; //vector&lt;string&gt; subS; vector&lt;int&gt; res; for (int i = 0; i &lt; S.size(); i++)&#123; char tmp = S[i]; lastIdx = max(alphabet[tmp - &#x27;a&#x27;], lastIdx); if(lastIdx==i)&#123; res.push_back(lastIdx - startIdx + 1); //string tmpStr = S.substr(startIdx, lastIdx - startIdx + 1); //subS.push_back(tmpStr); startIdx = i + 1; lastIdx = i + 1; &#125; &#125; return res;&#125; 时间复杂度：O(n)空间复杂度：O(1) 3.4 双指针双指针主要用于遍历数组，两个指针指向不同的位置，协同完成任务。 （剑指offer的双指针操作） Leetcode 167. 两数之和 II - 输入有序数组（简单）给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例： 12Input: numbers=&#123;2, 7, 11, 15&#125;, target=9 Output: index1=1, index2=2 题解： 使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历： 如果两个指针指向元素的和 sum &#x3D;&#x3D; target，那么得到要求的结果； 如果 sum &gt; target，移动较大的元素，使 sum 变小一些； 如果 sum &lt; target，移动较小的元素，使 sum 变大一些。 123456789101112131415vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; if(numbers.empty()) return &#123;&#125;; int start = 0; int end = numbers.size()-1; while(start&lt;end)&#123; if(numbers[start]+numbers[end] == target) return &#123;start+1, end+1&#125;; if(numbers[start]+numbers[end]&gt;target) end --; else if(numbers[start]+numbers[end]&lt;target) start ++; &#125; return &#123;&#125;;&#125; 时间复杂度：O(n)空间复杂度：O(1) 哈希表。无序的序列也适用。 123456789101112vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; unordered_map&lt;int, int&gt; numMap; for (int i = 0; i &lt; numbers.size();i++) numMap[numbers[i]] = i; for (int i = 0; i &lt; numbers.size();i++)&#123; auto it = numMap.find(target - numbers[i]); if (it != numMap.end()) return &#123;i + 1, it-&gt;second+1&#125;; &#125; return &#123;&#125;;&#125; 时间复杂度：O(n)空间复杂度：O(n) Leetcode 633. 平方数之和（简单）给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 &#x3D; c 。 示例： 123Input: 5 Output: True Explanation: 1 * 1 + 2 * 2 = 5 题解：本题和 「167. 两数之和 II - 输入有序数组」 类似，只有一个明显区别：一个是和为 target，一个是平方和为 target。本题同样可以使用双指针得到两个数，使其平方和为 target。本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 0^2 + x^2 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。因为最多只需要遍历一次 0-sqrt(target)，所以时间复杂度为 O(sqrt(target))。又因为只使用了两个额外的变量，因此空间复杂度为 O(1)。 123456789101112131415bool judgeSquareSum(int c) &#123; if(c &lt; 0) return false; int start = 0; int end = sqrt(c); while(start&lt;=end)&#123; if((long)start*start + (long)end*end == (long)c) return true; else if((long)start*start + (long)end*end &gt; (long)c) end--; else start++; &#125; return false;&#125; 时间复杂度：O(c^(1&#x2F;2))空间复杂度：O(1) Leetcode 345. 反转字符串中的元音字母（简单）反转字符串中的元音字符 示例： 1Given s = &quot;Leetcode&quot;, return &quot;Leotcede&quot;. 题解：使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。为了快速判断一个字符是不是元音字符，我们将全部元音字符添加到集合 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。 1234567891011121314151617181920string reverseVowels(string s) &#123; unordered_set&lt;char&gt; hs = &#123;&#x27;a&#x27;,&#x27;e&#x27;,&#x27;i&#x27;,&#x27;o&#x27;,&#x27;u&#x27;,&#x27;A&#x27;,&#x27;E&#x27;,&#x27;I&#x27;,&#x27;O&#x27;,&#x27;U&#x27;&#125;;//c++11之后才可以这样初始化 int start = 0; int end = s.size() - 1; string res = s; while (start&lt;end) &#123; char tmp_start = s[start]; char tmp_end = s[end]; if (hs.find(tmp_start)==hs.end())//tmp不在hs中 res[start++] = tmp_start; else if(hs.find(tmp_end)==hs.end()) res[end--] = tmp_end; else&#123; res[start++] = tmp_end; res[end--] = tmp_start; &#125; &#125; return res;&#125; 时间复杂度：O(n)空间复杂度：O(1) Leetcode 680. 验证回文字符串 Ⅱ（简单）给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例： 123Input: &quot;abca&quot; Output: True Explanation: You could delete the character &#x27;c&#x27;. 题解：使用双指针可以很容易判断一个字符串是否是回文字符串：令一个指针从左到右遍历，一个指针从右到左遍历，这两个指针同时移动一个位置，每次都判断两个指针指向的字符是否相同，如果都相同，字符串才是具有左右对称性质的回文字符串。在判断是否为回文字符串时，我们不需要判断整个字符串，因为左指针左边和右指针右边的字符之前已经判断过具有对称性质，所以只需要判断中间的子字符串即可。在试着删除字符时，我们既可以删除左指针指向的字符，也可以删除右指针指向的字符。 12345678910111213141516171819202122232425bool isPalindrome(string s,int start,int end)&#123; while(start &lt; end)&#123; if (s[start++]!=s[end--]) return false; &#125; return true;&#125;bool validPalindrome(string s) &#123; if(s.size()&lt;=1) return true; int start = 0; int end = s.size() - 1; bool res = true; while (start &lt; end) &#123; if (s[start] != s[end]) &#123; res = isPalindrome(s, start + 1, end) || isPalindrome(s, start, end - 1); return res; &#125; start++; end--; &#125; return res;&#125; 时间复杂度：O(n)空间复杂度：O(1) Leetcode 88. 合并两个有序数组（简单）归并两个有序数组，把归并结果存到第一个数组上。 示例： 1234Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] 题解：需要从尾开始遍历，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值。 123456789101112131415void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int idx1 = m - 1; int idx2 = n - 1; int idx = m + n - 1; while (idx1&gt;=0 || idx2&gt;=0)&#123; if(idx1&lt;0) nums1[idx--] = nums2[idx2--]; else if(idx2&lt;0)//这时候nums2已经插完，其实可以直接return nums1了 nums1[idx--] = nums1[idx1--]; else if(nums1[idx1]&gt;nums2[idx2]) nums1[idx--] = nums1[idx1--]; else nums1[idx--] = nums2[idx2--]; &#125;&#125; 时间复杂度：O(m+n)空间复杂度：O(1) Leetcode 141. 环形链表（简单）判断链表是否存在环 双指针（快慢指针），一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。 12345678910111213bool hasCycle(ListNode *head) &#123; if(head == nullptr || head-&gt;next == nullptr) return false; ListNode *p1 = head-&gt;next; ListNode *p2 = head-&gt;next-&gt;next; while(p2!=nullptr &amp;&amp; p2-&gt;next!=nullptr)&#123; if(p1-&gt;val == p2-&gt;val) return true; p1 = p1-&gt;next; p2 = p2-&gt;next-&gt;next; &#125; return false;&#125; 时间复杂度：O(n)空间复杂度：O(1) 哈希表。 123456789101112bool hasCycle(ListNode *head) &#123; if(head == nullptr || head-&gt;next == nullptr) return false; unordered_set&lt;ListNode *&gt; us; while (head != nullptr)&#123; if (us.count(head)) return true; us.insert(head); head = head-&gt;next; &#125; return false;&#125; 时间复杂度：O(n)空间复杂度：O(n) Leetcode 524. 通过删除字母匹配到字典里最长单词（中等）给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。 示例： 12Input: s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;] Output: &quot;apple&quot; 题解：可以使用双指针来判断一个字符串是否为另一个字符串的子序列。 123456789101112131415161718192021bool isSubstr(string s, string d)&#123; int i = 0; int j = 0; while(i&lt;s.size() &amp;&amp; j&lt;d.size())&#123; if(s[i]==d[j])&#123; j++; &#125; i++; &#125; return j == d.size();&#125;string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123; string res = &quot;&quot;; for (string cur:d)&#123; if(res.size()&gt;cur.size() || (res.size()==cur.size() &amp;&amp; res&lt;cur)) continue; if (isSubstr(s, cur)) res = cur; &#125; return res;&#125; 时间复杂度：O(nl)，l 是字典里字符串的平均长度空间复杂度：O(n) Leetcode 75. 颜色分类（中等）给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 示例： 12Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] 题解： 12345678910111213void sortColors(vector&lt;int&gt;&amp; nums) &#123; int zero = -1; int one = 0; int two = nums.size(); while(one&lt;two)&#123; if(nums[one]==0) swap(nums[++zero],nums[one++]); else if(nums[one]==2) swap(nums[--two], nums[one]); //从后面换上来的可能是0，所以one不能往后移动 else one++; &#125;&#125; 时间复杂度：O(n)空间复杂度：O(1) Leetcode 42. 接雨水（困难）给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例： 12输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 题解： 用left_max[i] 和 right_max[i] 表示 i 左边和右边的最大值。这样就把暴力法时间复杂度的O(n^2)降为O(n)。 1234567891011121314151617181920int trap(vector&lt;int&gt;&amp; height)&#123; if (height.empty()) return 0; int res = 0; int n = height.size(); vector&lt;int&gt; left_max(n), right_max(n); left_max[0] = height[0]; for (int i = 1; i &lt; n; i++) &#123; left_max[i] = max(height[i], left_max[i - 1]); &#125; right_max[n - 1] = height[n - 1]; for (int i = n - 2; i &gt;= 0; i--) &#123; right_max[i] = max(height[i], right_max[i + 1]); &#125; for (int i = 1; i &lt; n - 1; i++) &#123; res += min(left_max[i], right_max[i]) - height[i]; &#125; return res;&#125; 时间复杂度：O(n)空间复杂度：O(n) 双指针。 1234567891011121314151617int trap(vector&lt;int&gt;&amp; height)&#123; int left = 0, right = height.size() - 1; int res = 0; int left_max = 0, right_max = 0; while (left &lt; right) &#123; if (height[left] &lt; height[right]) &#123; height[left] &gt;= left_max ? (left_max = height[left]) : res += (left_max - height[left]); left++; &#125; else &#123; height[right] &gt;= right_max ? (right_max = height[right]) : res += (right_max - height[right]); right--; &#125; &#125; return res;&#125; 时间复杂度：O(n)空间复杂度：O(1) 3.5 排序（Sorting）python实现的八大排序 cpp实现八大排序： 插入排序 希尔排序 选择排序 冒泡排序 快速排序 堆排序 归并排序 基数排序 快排变为稳定排序的方法。三遍扫描原序列： 第一遍先把小于pivot的元素按先后顺序放到tmp里，然后把pivot放到它的正确位置tmp[k]； 第二遍把大于pivot的元素按先后顺序追加在tmp里，这样除了pivot以前的其他元素，都保持了和原序列中一样的顺序； 第三遍把tmp赋值回原数组A。 3.5.1 Partition函数Partition函数可以用在快排中，也可以用来实现在长度为n的数组中查找第k大的数字。 12345678910111213141516171819int Partition(std::vector&lt;int&gt; &amp;nums, int start, int end)&#123; if (nums.size() &lt; 2 || start&lt;0 || end&gt;nums.size()) return -1; int idx = start + std::rand() % (end - start + 1);//随机生成一个[start,end]的整数 int pivot = nums[idx]; nums[idx] = nums[start];//相当于把nums[idx]换到首位 while (start &lt; end) &#123; while (start &lt; end &amp;&amp; nums[end] &gt;= pivot) end--; nums[start] = nums[end]; while (start &lt; end &amp;&amp; nums[start] &lt;= pivot) start++; nums[end] = nums[start]; &#125; nums[start] = pivot; return start;&#125; 快排（cpp）递归版123456789void QuickSort(vector&lt;int&gt; &amp;arr, int start, int end)&#123; if(start==end) return; int mid = Partition(arr, start, end); if(mid&gt;start) QuickSort(arr, start, mid - 1); if(mid&lt;end) QuickSort(arr, mid + 1, end);&#125; 非递归版123456789101112131415161718192021222324void QuickSort(vector&lt;int&gt; &amp;nums)&#123; if (nums.empty()) return; stack&lt;int&gt; stk; stk.push(nums.size()-1);//先压右指针 stk.push(0);//再压左指针 while (!stk.empty())&#123; int start = stk.top();//先弹出左指针 stk.pop(); int end = stk.top();//再弹出右指针 stk.pop(); if (start &lt; end)&#123; int mid = Partition(nums, start, end); if (mid &gt; start)&#123;//保存中间变量 stk.push(mid - 1); stk.push(start); &#125; if (end &gt; mid)&#123; stk.push(end); stk.push(mid + 1); &#125; &#125; &#125;&#125; 3.5.2 例题TOP K 问题 排序 ：时间复杂度 O(NlogN)，空间复杂度 O(1) 堆 ：时间复杂度 O(NlogK)，空间复杂度 O(K) 快速选择 ：时间复杂度 O(N)，空间复杂度 O(1) Leetcode 215. 数组中的第K个最大元素（中等）在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例： 123Input: [3,2,1,5,6,4] and k = 2 Output: 5 Kth Element, 在排序数组中 == 找到倒数第 k 个的元素。 题解： 快排变形。 123456789101112131415int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int target = nums.size()-k; int l = 0; int r = nums.size()-1; while(l&lt;r)&#123; int m = Partition(nums,l,r); if(m==target) return nums[m]; else if(m&lt;target) l = m+1; else r = m-1; &#125; return nums[l];&#125; 时间复杂度：O(n)空间复杂度：O(logn)，递归的栈深度 堆 1234567891011121314151617181920212223242526272829303132333435void adjustHeap(std::vector&lt;int&gt; &amp;nums, int parents, int end)&#123; //非叶子结点parents的两个子节点（假设都存在） int lchild = 2 * parents + 1; int rchild = 2 * parents + 2; int maxIdx = parents; if (lchild &lt;= end &amp;&amp; nums[maxIdx] &lt; nums[lchild]) maxIdx = lchild; if (rchild &lt;= end &amp;&amp; nums[maxIdx] &lt; nums[rchild]) maxIdx = rchild; if (maxIdx != parents) &#123; swap(nums[parents],nums[maxIdx]); //交换之后，nums[maxIdx]应该是较小的元素，所以应该向下继续调整 adjustHeap(nums, maxIdx, end); &#125;&#125;void buildHeap(std::vector&lt;int&gt; &amp;nums)&#123;//建堆 for (int i = nums.size() / 2 - 1; i &gt;= 0; i--) &#123; //从倒数第一个非叶子结点开始调整 adjustHeap(nums, i, nums.size() - 1); &#125;&#125;int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int end = nums.size()-1; buildHeap(nums); for (int i = nums.size() - 1; i &gt;= nums.size() - k + 1; i--) &#123; swap(nums[0], nums[i]); end--; adjustHeap(nums, 0, end); &#125; return nums[0];&#125; 时间复杂度：O(nlogn)，建堆的时间代价是 O(n)，删除的总代价是 O(klogn)。因为k &lt; n，所以是O(nlogn)空间复杂度：O(logn) BFPRT也可以用BFPRT算法，具体实现如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162int BFPRT(vector&lt;int&gt; &amp;nums, int start, int end, int k); //因为findMidIdx与BFPRT互相调用，所以最好在前面声明int findMidIdx(vector&lt;int&gt; &amp;nums, int start, int end);int selectSort(vector&lt;int&gt; &amp;nums,int start,int end)&#123;//选择排序，返回中位数下标 int temp; for (int i = start; i &lt; end; i++)&#123; for (int j = i + 1; j &lt;= end; j++) &#123; if (nums[i] &gt; nums[j]) swap(nums[i], nums[j]); &#125; &#125; return (((end - start) / 2) + start);&#125;int findMidIdx(vector&lt;int&gt; &amp;nums,int start,int end)&#123;//返回中位数的中位数下标 if (end - start &lt; 5) return (selectSort(nums, start, end));//插入排序也可以 int subRIdx = start - 1; for (int i = start; i + 4 &lt;= end; i += 5) &#123; int index = selectSort(nums, i, i + 4); //找到五个元素的中位数的下标 swap(nums[++subRIdx], nums[index]); //依次放在左侧 &#125; return BFPRT(nums, start, subRIdx, ((subRIdx - start + 1) / 2) + 1);&#125;int Partition(vector&lt;int&gt; &amp;nums,int start,int end,int pivotIdx)&#123; swap(nums[pivotIdx], nums[end]); int divideIdx = start; for (int i = start; i &lt; end; i++) &#123; if (nums[i]&lt;nums[end]) swap(nums[divideIdx++], nums[i]); &#125; swap(nums[divideIdx], nums[end]); return divideIdx;&#125;int BFPRT(vector&lt;int&gt; &amp;nums, int start,int end,int k)&#123; /* 求第k小，返回其位置的下标。 如果求TOP K，改变大小于符号，或者返回 n-K+1 */ int pivotIdx = findMidIdx(nums, start, end); //得到中位数的中位数下标 int divideIdx = Partition(nums, start, end, pivotIdx); //进行划分，返回划分边界 int n = divideIdx - start + 1; if (n == k) return divideIdx; else if (n &gt; k) return BFPRT(nums, start, divideIdx - 1, k); else return BFPRT(nums, divideIdx + 1, end, k - n);&#125; Leetcode 347. 前 K 个高频元素（中等）给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例： 1Given [1,1,1,2,2,3] and k = 2, return [1,2]. Leetcode提交的答案： 12345678910111213141516171819202122232425class cmp&#123;public: bool operator()(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b)&#123; return a.second &gt; b.second; &#125;&#125;;vector&lt;int&gt; topKFrequent(vector&lt;int&gt; &amp;nums, int k)&#123; map&lt;int, int&gt; numMap; for(int n:nums) numMap[n]++; priority_queue&lt;pair&lt;int, int&gt;,vector&lt;pair&lt;int,int&gt; &gt;, cmp &gt; pq; for (auto it = numMap.begin(); it != numMap.end(); it++)&#123; pq.push(*it); if(pq.size()&gt;k) pq.pop(); &#125; vector&lt;int&gt; res(k); for (int i = k - 1; i &gt;= 0; i--) &#123; res[i] = pq.top().first; pq.pop(); &#125; return res;&#125; 小根堆： 遍历数组，哈希表录入频率 遍历哈希表，维护一个出现频率前k多的小根堆 优先队列已满，需要判断当前元素的频率是否大于优先队列的最小频率元素的频率，如果大于，则替换。 优先队列未满，进队即可 桶：设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445void topKFrequent()&#123;//小根堆 vector&lt;int&gt; nums = &#123;1, 1, 1, 2, 2, 3&#125;; int k = 2; //map里面是（元素，频率） unordered_map&lt;int,int&gt; freq; for (int i = 0; i &lt; nums.size();i++)&#123; freq[nums[i]]++; //可以验证，freq[nums[i]]初始化为0哦 &#125; //优先队列中，按频率排序，所以数据对是(频率，元素)形式 priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; pq; for (auto it = freq.begin(); it != freq.end();it++)&#123; if(pq.size()==k)&#123;//队列满了 if(pq.top().first &lt; it-&gt;second)&#123; pq.pop(); pq.push(make_pair(it-&gt;second,it-&gt;first)); &#125; &#125; else&#123; pq.push(make_pair(it-&gt;second, it-&gt;first)); &#125; &#125; vector&lt;int&gt; result; while(!pq.empty())&#123; result.push_back(pq.top().second); // cout &lt;&lt; pq.top().second &lt;&lt; endl; pq.pop(); &#125; //桶 int n = nums.size()+1; vector&lt; vector&lt;int&gt; &gt; buckets(n); for (auto it = freq.begin(); it != freq.end(); it++) &#123; buckets[it-&gt;second].push_back(it-&gt;first); &#125; vector&lt;int&gt; topK; for (int i = buckets.size() - 1; i &gt; 0 &amp;&amp; topK.size()&lt;k; i--)&#123; if(buckets[i].size()==0) continue; for (int j = 0; j &lt; buckets[i].size() &amp;&amp; topK.size() &lt; k;j++)&#123; topK.push_back(buckets[i].back()); buckets[i].pop_back(); &#125; &#125;&#125; Leetcode 451. 根据字符出现频率排序（中等）给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 示例1： 123456789输入:&quot;cccaaa&quot;输出:&quot;cccaaa&quot;解释:&#x27;c&#x27;和&#x27;a&#x27;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。 示例2: 123456789输入:&quot;Aabb&quot;输出:&quot;bbAa&quot;解释:此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。注意&#x27;A&#x27;和&#x27;a&#x27;被认为是两种不同的字符。 题解： 桶。 12345678910111213141516171819202122string frequencySort(string s) &#123; unordered_map&lt;char, int&gt; freq; for (int i = 0; i &lt; s.size();i++) freq[s[i]]++; //桶 int n = s.size(); vector&lt;vector&lt;char&gt; &gt; buckets(n + 1); for (auto it = freq.begin(); it != freq.end();it++)&#123; buckets[it-&gt;second].push_back(it-&gt;first); &#125; string res = &quot;&quot;; for (int i = buckets.size() - 1; i &gt; 0; i--) &#123; if(buckets[i].size()==0) continue; for(auto s : buckets[i])&#123; for (int j = 0; j &lt; i; j++) res += s; &#125; &#125; return res;&#125; 时间复杂度：O(n)空间复杂度：O(n) 堆。方法同Leetcode 347。 1234567891011121314151617string frequencySort(string s) &#123; unordered_map&lt;char, int&gt; ump; for (char &amp;c : s) ump[c]++; priority_queue&lt;pair&lt;int, char&gt;&gt; pq; for (auto &amp;m : ump) pq.push(&#123;m.second, m.first&#125;); string res; while (!pq.empty()) &#123; auto tmp = pq.top(); pq.pop(); res.append(tmp.first, tmp.second); &#125; return res;&#125; 时间复杂度：O(n)空间复杂度：O(k)，k为不同字母的数量，最大为26 范围排序给一个无序不重复的数组nums，两个整数int a和int b，其中a &lt;= b &lt;= nums.size()-1。返回第a到第b个排序子数组。 示例： 123nums = &#123;3,5,4,1,2&#125;, a = 2, b = 4输出：[2,3,4] 题解：快排的变形。Partition找位置i，再根据i与a、b的比较来递归往下排序。 12345678910111213141516171819202122232425//Partition函数在上面void quickSort(vector&lt;int&gt; &amp;nums, int start, int end, int a, int b)&#123; if(start &gt; end) return; int mid = Partition(nums, start, end); if(mid&gt;=b-1) quickSort(nums, start, mid - 1, a, b); if(mid&lt;=a-1) quickSort(nums, mid + 1, end, a, b); if(mid&gt;a-1 &amp;&amp; mid&lt;b-1)&#123; quickSort(nums, start, mid - 1, a, b); quickSort(nums, mid + 1, end, a, b); &#125;&#125;vector&lt;int&gt; getVec(vector&lt;int&gt; &amp;nums, int a, int b)&#123; quickSort(nums, 0, nums.size() - 1, a, b); vector&lt;int&gt; res; for (int i = a-1; i &lt;= b-1; i++) res.push_back(nums[i]); return res;&#125; 特殊规则排序有一种排序算法：每次只能把一个元素提到数组的开头。输入一个乱序数组，输出最少需要多少次操作才能是数组升序排列。 示例： 12345输入： [2,1,3,4]输出： 1解释：把 1 提到开头就能满足要求 题解：只需求有多少个数已经按升序的顺序位于数组中就可以了。 12345678910111213int timesToAsc(vector&lt;int&gt; &amp;nums)&#123; vector&lt;int&gt; finalNum = nums; sort(finalNum.begin(), finalNum.end()); int i, j , cnt = 0; i = j = nums.size() - 1; for (; i &gt;= 0;i--)&#123; if(finalNum[j] == nums[i])&#123; j--; cnt++; &#125; &#125; return nums.size() - cnt;&#125; 3.6 查找&#x2F;搜索（Search）3.6.1 回溯算法（backtracking）回溯法框架123456789result = []def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 Leetcode 17. 电话号码的字母组合（中等）给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例： 12Input: &quot;23&quot; Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 题解： 回溯。 12345678910111213141516171819202122232425map&lt;char, string&gt; keys = &#123; &#123;&#x27;2&#x27;, &quot;abc&quot;&#125;, &#123;&#x27;3&#x27;, &quot;def&quot;&#125;, &#123;&#x27;4&#x27;, &quot;ghi&quot;&#125;, &#123;&#x27;5&#x27;, &quot;jkl&quot;&#125;, &#123;&#x27;6&#x27;, &quot;mno&quot;&#125;, &#123;&#x27;7&#x27;, &quot;pqrs&quot;&#125;, &#123;&#x27;8&#x27;, &quot;tuv&quot;&#125;, &#123;&#x27;9&#x27;, &quot;wxyz&quot;&#125;&#125;;void backtracking(string preStr, vector&lt;string&gt; &amp;combinations, const string &amp;digits)&#123; if(preStr.size()==digits.size())&#123; combinations.push_back(preStr); return; &#125; int curIdx = preStr.size(); char curDigital = digits[curIdx]; string curKeys = keys[curDigital]; for(char &amp;k : curKeys)&#123; preStr += k; backtracking(preStr,combinations,digits); preStr.erase(preStr.size()-1); &#125;&#125;vector&lt;string&gt; letterCombinations(string digits) &#123; if(digits.empty()) return &#123;&#125;; vector&lt;string&gt; res; backtracking(&quot;&quot;, res, digits); return res;&#125; 时间复杂度：O(3^m * 4^n)，其中 m 是输入中对应 3 个字母的数字个数（包括数字 2、3、4、5、6、8），n 是输入中对应 4 个字母的数字个数（包括数字 7、9），m+n 是输入数字的总个数。空间复杂度：O(m+n) 队列1234567891011121314151617181920212223242526272829303132map&lt;char, string&gt; keys = &#123; &#123;&#x27;2&#x27;, &quot;abc&quot;&#125;, &#123;&#x27;3&#x27;, &quot;def&quot;&#125;, &#123;&#x27;4&#x27;, &quot;ghi&quot;&#125;, &#123;&#x27;5&#x27;, &quot;jkl&quot;&#125;, &#123;&#x27;6&#x27;, &quot;mno&quot;&#125;, &#123;&#x27;7&#x27;, &quot;pqrs&quot;&#125;, &#123;&#x27;8&#x27;, &quot;tuv&quot;&#125;, &#123;&#x27;9&#x27;, &quot;wxyz&quot;&#125;&#125;;vector&lt;string&gt; letterCombinations(string digits) &#123; queue&lt;string&gt; que; for (int idx = 0; idx &lt; digits.size();idx++) &#123; char s = digits[idx]; string key = keys[s]; if(que.empty())&#123; for(auto k:key)&#123; string tmp(1, k); que.push(tmp); &#125; &#125;else&#123; while(que.front().size()&lt;=idx)&#123; string preStr = que.front(); que.pop(); for(auto k:key) que.push(preStr + k); &#125; &#125; &#125; vector&lt;string&gt; res; while (!que.empty())&#123; res.push_back(que.front()); que.pop(); &#125; return res;&#125; Leetcode 93. 复原IP地址（中等）给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。 示例： 12Given &quot;25525511135&quot;, return [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]. 题解：回溯。 123456789101112131415161718192021222324void backtracking(int k, string preIp, string resStr, vector&lt;string&gt; &amp;addresses)&#123; if(k==4 || resStr.size()==0)&#123; if(k==4 &amp;&amp; resStr.size()==0) addresses.push_back(preIp); return; &#125; for (int i = 0; i &lt; resStr.size() &amp;&amp; i &lt; 3;i++)&#123; if(i!=0 &amp;&amp; resStr[0]==&#x27;0&#x27;) break; string part = resStr.substr(0, i + 1); if(stoi(part)&lt;=255)&#123; if(preIp.size()!=0) part = &#x27;.&#x27; + part; preIp = preIp + part; backtracking(k + 1, preIp, resStr.substr(i + 1), addresses); preIp = preIp.erase(preIp.size() - part.size()); &#125; &#125;&#125;vector&lt;string&gt; restoreIpAddresses(string s) &#123; vector&lt;string&gt; res; backtracking(0, &quot;&quot;, s, res); return res;&#125; huawei 真题求最大递归调用链栈总和 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455vector&lt;vector&lt;int&gt; &gt; inputStack = &#123; &#123;5,2,3,1,0,0&#125;, &#123;1,20,2,3&#125;, &#123;2,30,3,4,5&#125;, &#123;3,50,4&#125;, &#123;4,60&#125;, &#123;5,80&#125; &#125;;void backtracking(int fun, vector&lt;bool&gt; &amp;isHead, bool &amp;isRecursive, vector&lt;bool&gt; &amp;hasVisited, vector&lt;int&gt; &amp;preChain, vector&lt;vector&lt;int&gt; &gt; &amp;callChains)&#123; if(isRecursive) return; if (inputStack[0][fun] == 0) &#123; callChains.push_back(preChain); return; &#125; for (int i = 2; i &lt; inputStack[fun].size();i++)&#123; int nextFun = inputStack[fun][i]; if(hasVisited[nextFun])&#123; isRecursive = true; return; &#125; isHead[nextFun] = false; hasVisited[nextFun] = true; preChain.push_back(nextFun); backtracking(nextFun, isHead, isRecursive, hasVisited, preChain, callChains); preChain.pop_back(); hasVisited[nextFun] = false; &#125;&#125;void maxStack()&#123; vector&lt;vector&lt;int&gt; &gt; callChains; vector&lt;int&gt; preChain; vector&lt;bool&gt; isHead(inputStack[0][0]+1,true); bool isRecursive = false; //注意！ 如果这个变量不是放在main函数前的全局变量，递归函数传值就必须传引用，不然会因为函数参数传值的复制造成递归的时候不能改变 for (int i = 1; i &lt;= inputStack[0][0]; i++) &#123; if(isHead[i])&#123; vector&lt;bool&gt; hasVisited(inputStack[0][0] + 1, false); preChain.push_back(i); hasVisited[i] = true; backtracking(i, isHead, isRecursive, hasVisited, preChain, callChains); &#125; &#125; if(isRecursive) cout &lt;&lt; &#x27;R&#x27; &lt;&lt; endl; else&#123; for (auto cc : callChains) &#123; for(int c:cc) cout &lt;&lt; c &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; &#125;&#125; Leetcode 46. 全排列（中等）给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例： 12345678[1,2,3] have the following permutations: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 题解：回溯。 123456789101112131415161718192021void backtracking(vector&lt;int&gt; &amp;resNums, vector&lt;int&gt; &amp;preNum, vector&lt;vector&lt;int&gt; &gt; &amp;permuteList)&#123; if(resNums.size()==0)&#123; permuteList.push_back(preNum); return; &#125; for (int i = 0; i &lt; resNums.size();i++)&#123; int curNum = resNums[i]; auto it = resNums.begin(); resNums.erase(it + i); preNum.push_back(curNum); backtracking(resNums, preNum, permuteList); preNum.pop_back(); resNums.insert(it + i, curNum); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; preNum; backtracking(nums, preNum, res); return res;&#125; 时间复杂度：O(n*n!)空间复杂度：O(n) Leetcode 77. 组合（中等）给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例： 12345678If n = 4 and k = 2, a solution is:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 题解： 123456789101112131415161718void combinationsCore(int n, int k, int start, vector&lt;int&gt; &amp;preRes, vector&lt;vector&lt;int&gt; &gt; &amp;res)&#123; if(preRes.size()==k)&#123; res.push_back(preRes); return; &#125; for (int i = start; i &lt;= n; i++) &#123; preRes.push_back(i); combinationsCore(n, k, i + 1, preRes, res); preRes.pop_back(); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; preRes; combinationsCore(n, k, 1, preRes, res); return res;&#125; Leetcode 39.组合总和（中等）给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 示例： 12given candidate set [2, 3, 6, 7] and target 7, A solution set is: [ [7],[2, 2, 3] ] 题解：回溯。 12345678910111213141516171819202122void backtracking(int target, vector&lt;int&gt; &amp;preCombination, int start, vector&lt;vector&lt;int&gt; &gt; &amp;combination, vector&lt;int&gt; &amp;candidates)&#123; if(target==0)&#123; combination.push_back(preCombination); return; &#125; for (int i = start; i &lt; candidates.size();i++) &#123; int curNum = candidates[i]; if (target &gt;= curNum) &#123; preCombination.push_back(curNum); backtracking(target - curNum, preCombination, i, combination, candidates); preCombination.pop_back(); &#125; &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; preCombination; backtracking(target, preCombination, 0, res, candidates); return res;&#125; Leetcode 40. 组合总和 II（中等）给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 示例： 123456For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 题解：回溯 12345678910111213141516171819202122232425void backtracking(int target, vector&lt;int&gt; &amp;preCombination, int start, vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;candidates)&#123; if(target==0)&#123; auto it = find(res.begin(), res.end(), preCombination); if(it==res.end())&#123;//因为candidates中有重复元素，会导致重复的解，所以查找是否有重复解，没有再放到解集中 res.push_back(preCombination); return; &#125; &#125; for (int i = start; i &lt; candidates.size();i++)&#123; int curNum = candidates[i]; if(curNum&lt;=target)&#123; preCombination.push_back(curNum); backtracking(target - curNum, preCombination, i + 1, res, candidates); preCombination.pop_back(); &#125; &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; sort(candidates.begin(),candidates.end());//先排序才好查重复解 vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; preCombination; vector&lt;bool&gt; hasVisited(candidates.size(),false); backtracking(target, preCombination, 0, res, candidates); return res;&#125; Leetcode 216. 组合总和 III（中等）找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 示例： 1234Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]] 从 1-9 数字中选出 k 个数不重复的数，使得它们的和为 n。 题解： 123456789101112131415161718192021222324void backtracking(int k, int target, int start, vector&lt;int&gt; &amp;preCombination, vector&lt;vector&lt;int&gt; &gt; &amp;res)&#123; // if(target&lt;0) // return; if (target == 0 &amp;&amp; k == 0) &#123; res.push_back(preCombination); return; &#125; if(target==0 || k==0) return; for (int i = start; i &lt;= 9;i++)&#123; if(target&lt;i)//后面的都大于target，不用再往后找了。如果上面用了target&lt;0的判断，这里可以不用，但是下面的调用次数会多一些 break; preCombination.push_back(i); backtracking(k - 1, target - i, i+1, preCombination, res); preCombination.pop_back(); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; preCombination; backtracking(k, n, 1, preCombination, res); return res;&#125; Leetcode 78. 子集（中等）给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例： 1234567891011找出集合的所有子集，子集不能重复，[1, 2] 和 [2, 1] 这种子集算重复 输入: nums = [1,2,3] 输出: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 题解：回溯。 123456789101112131415161718void backtracking(int start, int size, vector&lt;int&gt; &amp;preSet, vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;nums)&#123; if(preSet.size()==size)&#123; res.push_back(preSet); return; &#125; for (int i = start; i &lt; nums.size();i++)&#123; preSet.push_back(nums[i]); backtracking(i + 1, size, preSet, res, nums); preSet.pop_back(); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; preSet; vector&lt;vector&lt;int&gt; &gt; res; for (int size = 0; size &lt;= nums.size();size++)//子集的大小 backtracking(0, size, preSet, res, nums); return res;&#125; Leetcode 90. 子集 II（中等）给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例： 12345678输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 题解：回溯。 123456789101112131415161718192021void backtracking(int start, int size, vector&lt;int&gt; &amp;preSet, vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;nums)&#123; if(preSet.size()==size)&#123; res.push_back(preSet); return; &#125; for (int i = start; i &lt; nums.size();i++)&#123; preSet.push_back(nums[i]); backtracking(i + 1, size, preSet, res, nums); preSet.pop_back(); while(i&lt;nums.size()-1 &amp;&amp; nums[i+1]==nums[i])//后面的数字如果相等要跳过，不然会导致重复 i++; &#125;&#125;vector&lt;vector&lt;int&gt; &gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;int&gt; preSet; vector&lt;vector&lt;int&gt; &gt; res; for (int size = 0; size &lt;= nums.size(); size++) backtracking(0, size, preSet, res, nums); return res;&#125; Leetcode 131. 分割回文串（中等）给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例： 1234For example, given s = &quot;aab&quot;, Return [ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;] ] 题解：回溯。 1234567891011121314151617181920212223242526bool isPalindrome(string s, int start, int end)&#123; while(start&lt;end)&#123; if(s[start++]!=s[end--]) return false; &#125; return true;&#125;void partitioning(string s, vector&lt;string&gt; &amp;prePartition, vector&lt;vector&lt;string&gt; &gt; &amp;result)&#123; if(s.size()==0)&#123; result.push_back(prePartition); return; &#125; for (int i = 0; i &lt; s.size();i++)&#123; if(isPalindrome(s,0,i))&#123; prePartition.push_back(s.substr(0, i + 1)); partitioning(s.substr(i + 1, s.size() - (i + 1)), prePartition, result); prePartition.pop_back(); &#125; &#125;&#125;vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;string&gt; prePartition; vector&lt;vector&lt;string&gt; &gt; res; partitioning(s, prePartition, res); return res;&#125; Leetcode 37. 解数独（困难）通过填充空格来解决数独问题。 一个数独的解法需遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 空白格用 ‘.’ 表示。 题解：回溯。 12345678910111213141516171819202122232425262728293031323334353637383940414243int cube(int i, int j)&#123; return (i / 3) * 3 + j / 3; //0-8&#125;bool backtracking(int row, int col, vector&lt;vector&lt;bool&gt; &gt; &amp;rowUsed, vector&lt;vector&lt;bool&gt; &gt; colUsed, vector&lt;vector&lt;bool&gt; &gt; cubeUsed, vector&lt;vector&lt;char&gt; &gt; &amp;board)&#123; while (row &lt; 9 &amp;&amp; board[row][col]!=&#x27;.&#x27;)&#123; row = col == 8 ? row + 1 : row; col = col == 8 ? 0 : col + 1; &#125; if(row==9)//全部填完 return true; for (int num = 1; num &lt;= 9;num++)&#123; if(rowUsed[row][num] || colUsed[col][num] || cubeUsed[cube(row,col)][num]) continue; rowUsed[row][num] = true; colUsed[col][num] = true; cubeUsed[cube(row, col)][num] = true; board[row][col] = &#x27;0&#x27; + num; if(backtracking(row,col,rowUsed,colUsed,cubeUsed,board)) return true; board[row][col] = &#x27;.&#x27;; rowUsed[row][num] = false; colUsed[col][num] = false; cubeUsed[cube(row, col)][num] = false; &#125; return false;&#125;void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; vector&lt;vector&lt;bool&gt; &gt; rowUsed(9,vector&lt;bool&gt;(10,false)); vector&lt;vector&lt;bool&gt; &gt; colUsed(9,vector&lt;bool&gt;(10,false)); vector&lt;vector&lt;bool&gt; &gt; cubeUsed(9,vector&lt;bool&gt;(10,false)); for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9;j++)&#123; if(board[i][j]==&#x27;.&#x27;) continue; int num = board[i][j] - &#x27;0&#x27;; rowUsed[i][num] = true; colUsed[j][num] = true; cubeUsed[cube(i,j)][num] = true; &#125; &#125; backtracking(0, 0, rowUsed, colUsed, cubeUsed, board);&#125; N皇后问题输入n，输出解法的数量。（下一题还需要输出解法） 123456789101112131415161718192021222324void solveNQueen(int n, int row, vector&lt;bool&gt; &amp;diagonal45, vector&lt;bool&gt; &amp;diagonal135, vector&lt;bool&gt; &amp;colUsed, int &amp;res)&#123; if(row == n)&#123; res++; return; &#125; for (int col = 0; col &lt; n;col++)&#123; int idx45 = row + col; int idx135 = n - 1 - (row - col); if(colUsed[col] || diagonal135[idx135] || diagonal45[idx45]) continue; colUsed[col] = diagonal45[idx45] = diagonal135[idx135] = true; solveNQueen(n, row + 1, diagonal45, diagonal135, colUsed, res); colUsed[col] = diagonal45[idx45] = diagonal135[idx135] = false; &#125;&#125;int NQueen(int n)&#123; int res = 0; vector&lt;bool&gt; diagonal45(2 * n - 1, false); vector&lt;bool&gt; diagonal135(2 * n - 1, false); vector&lt;bool&gt; colUsed(n, false); solveNQueen(n, 0, diagonal45, diagonal135, colUsed, res); return res;&#125; Leetcode 51. N皇后（困难）给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 示例： 12345678910111213输入: 4 输出: [ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;] ] 解释: 4 皇后问题存在两个不同的解法。 题解：回溯。 123456789101112131415161718192021222324252627282930void backtracking(int n, int row, vector&lt;bool&gt; &amp;diagonal45, vector&lt;bool&gt; &amp;diagonal135, vector&lt;bool&gt; &amp;colUsed, vector&lt;string&gt; &amp;oneSolution, vector&lt;vector&lt;string&gt; &gt; &amp;res)&#123; if(row==n)&#123; res.push_back(oneSolution); return; &#125; for (int col = 0; col &lt; n;col++)&#123; int idx45 = row + col; int idx135 = n - 1 - (row - col); if(colUsed[col] || diagonal135[idx135] || diagonal45[idx45]) continue; oneSolution[row][col] = &#x27;Q&#x27;; colUsed[col] = diagonal135[idx135] = diagonal45[idx45] = true; backtracking(n, row + 1, diagonal45, diagonal135, colUsed, oneSolution, res); colUsed[col] = diagonal135[idx135] = diagonal45[idx45] = false; oneSolution[row][col] = &#x27;.&#x27;; &#125;&#125;vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt; &gt; res; string tmp = &quot;&quot;; for (int i = 0; i &lt; n;i++) tmp += &quot;.&quot;; vector&lt;string&gt; oneSolution(n, tmp); vector&lt;bool&gt; diagonal45(2*n-1,false); vector&lt;bool&gt; diagonal135(2*n-1,false); vector&lt;bool&gt; colUsed(n,false); backtracking(n, 0, diagonal45, diagonal135, colUsed, oneSolution, res); return res;&#125; 3.6.2 广度优先（BFS）Leetcode 1091. 二进制矩阵中的最短路径（中等）可以往8个方向走，0 表示可以经过某个位置，求解从左上角到右下角的最短路径长度。 示例： 12345input: 0 0 0 1 1 0 1 1 0 output: 4 ([0,0],[0,1],[1,2],[2,2]) 题解：队列实现“层序遍历”，bfs。 123456789101112131415161718192021222324252627282930313233343536373839int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int rows = grid.size(); int cols = grid[0].size(); if (rows==0 || cols==0 || grid[0][0]==1 || grid[cols-1][rows-1]==1) return -1; //从当前点的右边开始逆时针 int direction[8][2] = &#123; &#123;0, 1&#125;, &#123;1, 1&#125;, &#123;1, 0&#125;, &#123;1, -1&#125;, &#123;0, -1&#125;, &#123;-1, -1&#125;, &#123;-1, 0&#125;, &#123;-1, 1&#125; &#125;; queue&lt;vector&lt;int&gt; &gt; que; que.push(&#123;0,0&#125;); int res = 0; while (!que.empty()) &#123; int size = que.size();//这一层有多少节点 res++; while(size-- &gt;0)&#123;//把这一层的节点处理完 vector&lt;int&gt; cur = que.front(); que.pop(); if(grid[cur[0]][cur[1]]==1)//已经经过的点 //由于加入队列的顺序的原因，有些在待处理队列里面的为0的点，会被重复加入队列。 //如果这里不判断的话，已经更新为1的节点还是会被重复处理 continue; if (cur[0] == rows - 1 &amp;&amp; cur[1] == cols - 1) return res; grid[cur[0]][cur[1]] = 1;//走过的路标记为1 for(auto d:direction)&#123; int row = cur[0] + d[0]; int col = cur[1] + d[1]; if(row&lt;0 || row&gt;=rows || col&lt;0 || col&gt;=cols || grid[row][col]) //超过了上下左右边界 || 不能经过或者已经经过的点 continue; vector&lt;int&gt; tmp = &#123;row, col&#125;; que.push(tmp); &#125; &#125; &#125; return -1;&#125; Leetcode 279. 完全平方数（中等）给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例： 1234567given n = 12return 3because 12 = 4 + 4 + 4; given n = 13return 2 because 13 = 4 + 9. 题解：bfs。可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。本题也可以用动态规划求解，在之前动态规划部分中已经出现。 123456789101112131415161718192021222324252627282930int numSquares(int n) &#123; queue&lt;int&gt; que; que.push(n); //从n开始或者从1开始都行 bool marked[n]; for (int i = 0; i &lt; n;i++) marked[i] = 0;//false int res = 0; while(!que.empty())&#123; res++; int size = que.size(); while(size-- &gt; 0)&#123; int cur = que.front(); que.pop(); for(int i = 1; i * i &lt;= n; i++)&#123; int next = cur - i*i; if(next&lt;0) break; if(next==0) return res; if(marked[next]) continue; marked[next] = 1; que.push(next); &#125; &#125; &#125; return 0;&#125; Leetcode 127. 单词接龙（中等）给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则： 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回 0。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 示例1： 12345678Input: beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;] Output: 5 Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, return its length 5. 示例2： 123456789Input: beginWord = &quot;hit&quot; endWord = &quot;cog&quot; wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;] Output: 0 Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation. 题目描述：找出一条从 beginWord 到 endWord 的最短路径，每次移动规定为改变一个字符，并且改变之后的字符串必须在 wordList 中。 题解：bfs。官方双向bfs的C++版本。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int n;unordered_map&lt;string, vector&lt;string&gt; &gt; umap;int bfs(queue&lt;pair&lt;string, int&gt; &gt; &amp;curQueue, unordered_map&lt;string, int&gt;&amp; visited, unordered_map&lt;string, int&gt;&amp; anoVisited)&#123; string curWord = curQueue.front().first; int len = curQueue.front().second; curQueue.pop(); for(int i = 0; i &lt; n; ++i)&#123; string index = curWord.substr(0, i)+&quot;*&quot;+curWord.substr(i+1, n); for(string str : umap[index])&#123; if(anoVisited[str]) return len + anoVisited[str]; if(!visited[str])&#123; curQueue.push(make_pair(str, len+1)); visited[str] = len+1; &#125; &#125; &#125; return -1;&#125;int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; n = beginWord.size(); bool flag = false; for(string str : wordList)&#123; for(int i = 0; i &lt; n; ++i)&#123; string tp = str.substr(0,i)+&quot;*&quot;+str.substr(i+1, n); umap[tp].push_back(str); &#125; if(str == endWord) flag = true; &#125; if(!flag) return 0;//endWord不在wordList里 unordered_map&lt;string, int&gt; beginVisited, endVisited; queue&lt;pair&lt;string, int&gt; &gt; begQueue, endQueue; begQueue.push(make_pair(beginWord, 1)); endQueue.push(make_pair(endWord, 1)); beginVisited[beginWord] = 1; endVisited[endWord] = 1; while(!begQueue.empty() &amp;&amp; !endQueue.empty())&#123; int curlen = bfs(begQueue, beginVisited, endVisited); if(curlen != -1) return curlen; curlen = bfs(endQueue, endVisited, beginVisited); if(curlen != -1) return curlen; &#125; return 0;&#125; 3.6.3 深度优先（DFS）Leetcode 695. 岛屿的最大面积（中等）查找最大的连通面积。一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设grid的四个边缘都被 0（代表水）包围着。 示例： 123456789[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0] output: 6 题解： DFS STL栈实现 1234567891011121314151617181920212223242526272829303132333435int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;vector&lt;int&gt; &gt; direction = &#123; &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125; &#125;; int res = 0; for (int i = 0; i &lt; grid.size(); i++) &#123; for (int j = 0; j &lt; grid[0].size();j++)&#123; int res_ij = 0; stack&lt;vector&lt;int&gt; &gt; st; vector&lt;int&gt; tmp = &#123;i, j&#125;; st.push(tmp); while (!st.empty()) &#123; int cur_i = st.top()[0]; int cur_j = st.top()[1]; st.pop(); if(cur_i&lt;0 || cur_j&lt;0 || cur_i&gt;=grid.size() || cur_j&gt;=grid[0].size() || grid[cur_i][cur_j]!=1 )//这个条件一定要放到最后，要先满足坐标的条件，不然grid会越界 continue; grid[cur_i][cur_j] = 0; res_ij++; for (auto dir : direction) &#123; int next_i = cur_i + dir[0]; int next_j = cur_j + dir[1]; vector&lt;int&gt; tmp2 = &#123;next_i, next_j&#125;; st.push(tmp2); &#125; &#125; res = max(res, res_ij); &#125; &#125; return res;&#125;&#125; 递归。 12345678910111213141516171819202122int dfs(vector&lt;vector&lt;int&gt; &gt; &amp;grid,int cur_i, int cur_j)&#123; if(cur_i&lt;0 || cur_j&lt;0 || cur_i &gt;= grid.size() || cur_j &gt;= grid[0].size() || grid[cur_i][cur_j] != 1) return 0; grid[cur_i][cur_j] = 0; int res = 1; int dir_i[] = &#123;1, 0, 0, -1&#125;; int dir_j[] = &#123;0, 1, -1, 0&#125;; for (int i = 0; i &lt; 4;i++)&#123; int next_i = cur_i + dir_i[i]; int next_j = cur_j + dir_j[i]; res += dfs(grid, next_i, next_j); &#125; return res;&#125;int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int res = 0; for (int i = 0; i &lt; grid.size();i++)&#123; for (int j = 0; j &lt; grid[0].size();j++) res = max(res, dfs(grid, i, j)); &#125; return res;&#125; BFS也可以把栈改为队列就行 12345678910111213141516171819202122232425262728293031323334int maxAreaOfIsland(vector&lt;vector&lt;int&gt; &gt; &amp;grid)&#123; vector&lt;vector&lt;int&gt; &gt; direction = &#123; &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125; &#125;; int res = 0; for (int i = 0; i &lt; grid.size(); i++) &#123; for (int j = 0; j &lt; grid[0].size();j++)&#123; int res_ij = 0; queue&lt;vector&lt;int&gt; &gt; st; vector&lt;int&gt; tmp = &#123;i, j&#125;; st.push(tmp); while (!st.empty()) &#123; int cur_i = st.front()[0]; int cur_j = st.front()[1]; st.pop(); if(cur_i&lt;0 || cur_j&lt;0 || cur_i&gt;=grid.size() || cur_j&gt;=grid[0].size() || grid[cur_i][cur_j]!=1 )//这个条件一定要放到最后，要先满足坐标的条件，不然grid会越界 continue; grid[cur_i][cur_j] = 0; res_ij++; for (auto dir : direction) &#123; int next_i = cur_i + dir[0]; int next_j = cur_j + dir[1]; vector&lt;int&gt; tmp2 = &#123;next_i, next_j&#125;; st.push(tmp2); &#125; &#125; res = max(res, res_ij); &#125; &#125; return res;&#125; Leetcode 200. 岛屿数量（中等）给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例： 123456789Input: [ [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;], [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;], [&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;], [&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;1&#x27;]]Output: 3 题解：dfs。求矩阵中的连通分量数目。可以将矩阵表示看成一张有向图。 1234567891011121314151617181920212223void dfs(vector&lt;vector&lt;char&gt; &gt; &amp;grid, int i, int j)&#123; if(i&lt;0 || i&gt;=grid.size() || j&lt;0 || j&gt;=grid[0].size() || grid[i][j]==&#x27;0&#x27;) return; vector&lt;vector&lt;int&gt; &gt; directions = &#123; &#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125; &#125;; grid[i][j] = &#x27;0&#x27;; for(auto d:directions)&#123; int next_i = i + d[0]; int next_j = j + d[1]; dfs(grid, next_i, next_j); &#125;&#125;int numIslands(vector&lt;vector&lt;char&gt; &gt;&amp; grid) &#123; int res = 0; for (int i = 0; i &lt; grid.size();i++)&#123; for (int j = 0; j &lt; grid[0].size();j++)&#123; if(grid[i][j] != &#x27;0&#x27;)&#123; res++; dfs(grid, i, j); &#125; &#125; &#125; return res;&#125; bfs也可以（待补充） Leetcode 547. 朋友圈（中等）好友关系可以看成是一个无向图，例如第 0 个人与第 1 个人是好友，那么 M[0][1] 和 M[1][0] 的值都为 1。求朋友圈的个数。 示例： 123456789Input: [[1,1,0], [1,1,0], [0,0,1]]Output: 2 已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回 2 。 题解：dfs。 1234567891011121314151617181920void dfs(vector&lt;vector&lt;int&gt; &gt; &amp;nums, int i, vector&lt;bool&gt; &amp;isFriend)&#123; isFriend[i] = true; for (int j = 0; j &lt; nums.size();j++)&#123; if(!isFriend[j] &amp;&amp; nums[i][j]==1)&#123; dfs(nums, j, isFriend); &#125; &#125;&#125;int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; int res = 0; vector&lt;bool&gt; isFriend(M.size()); for (int i = 0; i &lt; M.size(); i++) &#123; if(!isFriend[i])&#123; res++; dfs(M, i, isFriend); &#125; &#125; return res;&#125; Leetcode 130. 被围绕的区域（中等）使被 ‘X’ 包围的 ‘O’ 转换为 ‘X’。任何边界上的 ‘O’ 都不会被填充为 ‘X’。 示例： 12345678910For example, X X X X X O O X X X O X X O X X After running your function, the board should be: X X X X X X X X X X X X X O X X 题解： dfs方法一。先把和最外侧的’O’相连的’O’用dfs找出来标记成其他，剩下的就是里侧的需要填充的了。填充的时候顺便把不需要填充的’O’换回来 1234567891011121314151617181920212223242526272829303132void dfs(vector&lt;vector&lt;char&gt; &gt; &amp;board, int i, int j)&#123; if(i&lt;0 || i&gt;= board.size() || j&lt;0 || j&gt;=board[0].size() || board[i][j] != &#x27;O&#x27;) return; board[i][j] = &#x27;*&#x27;; vector&lt;vector&lt;int&gt; &gt; directions = &#123; &#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;1,0&#125; &#125;; for(auto d:directions) dfs(board, i + d[0], j + d[1]); return;&#125;void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if(board.empty()) return; for (int i = 0; i &lt; board[0].size();i++)&#123; dfs(board, 0, i); dfs(board, board.size() - 1, i); &#125; for (int i = 0; i &lt; board.size();i++)&#123; dfs(board, i, 0); dfs(board, i, board[0].size() - 1); &#125; for (int i = 0; i &lt; board.size(); i++)&#123; for (int j = 0; j &lt; board[0].size(); j++)&#123; if(board[i][j]==&#x27;O&#x27;) board[i][j] = &#x27;X&#x27;; else if (board[i][j]== &#x27;*&#x27;) board[i][j] = &#x27;O&#x27;; &#125; &#125; return;&#125; dfs方法二 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,vector&lt;int&gt; &amp; s,vector&lt;vector&lt;bool&gt; &gt; &amp;marked)&#123; int x=s[0],y=s[1]; if(board[x][y]==&#x27;X&#x27; || marked[x][y]) return; marked[x][y] = true; for(auto d:dirs)&#123; int next_i = x+d[0], next_j = y+d[1]; vector&lt;int&gt; tmp = &#123;next_i,next_j&#125;; if((next_i &gt; 0 &amp;&amp; next_i &lt; board.size()) &amp;&amp; (next_j &gt; 0 &amp;&amp; next_j &lt; board[0].size())) dfs(board,tmp,marked); &#125; return;&#125;void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if(board.empty()) return; int m = board.size(),n = board[0].size(); vector&lt;vector&lt;bool&gt; &gt; marked(m,vector&lt;bool&gt;(n, false)); vector&lt;vector&lt;int&gt; &gt; side; for(int i=0;i&lt;n;i++)&#123; if(board[0][i]==&#x27;O&#x27;)&#123; side.push_back(&#123;0,i&#125;); //marked[0][i] = true; &#125; if(board[m-1][i]==&#x27;O&#x27;)&#123; side.push_back(&#123;m-1,i&#125;); //marked[m-1][i] = true; &#125; &#125; for(int i=1;i&lt;m-1;i++)&#123; if(board[i][0]==&#x27;O&#x27;)&#123; side.push_back(&#123;i,0&#125;); //marked[i][0] = true; &#125; if(board[i][n-1]==&#x27;O&#x27;)&#123; side.push_back(&#123;i,n-1&#125;); //marked[i][n-1] = true; &#125; &#125; for(auto s:side)&#123; dfs(board,s,marked); &#125; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(!marked[i][j] &amp;&amp; board[i][j]==&#x27;O&#x27;) board[i][j] = &#x27;X&#x27;; &#125; &#125; return;&#125; Leetcode 417. 太平洋大西洋水流问题（中等）左边和上边是太平洋，右边和下边是大西洋，内部的数字代表海拔，海拔高的地方的水能够流到低的地方，求解水能够流到太平洋和大西洋的所有位置。 示例： 12345678910111213Given the following 5x5 matrix:Pacific ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) * ~ 3 2 3 (4) (4) * ~ 2 4 (5) 3 1 * ~ (6) (7) 1 4 5 * ~ (5) 1 1 2 4 * * * * * * AtlanticReturn: [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix). 题解：从边缘逆流dfs，P逆流能到达的地方的标记，A逆流能到达的地方标记，都为1的位置即所求位置 12345678910111213141516171819202122232425262728293031323334353637383940414243void dfs(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int i, int j, vector&lt;vector&lt;bool&gt; &gt; &amp;canTo)&#123; if(canTo[i][j]) return; canTo[i][j] = true; vector&lt;vector&lt;int&gt; &gt; directions = &#123; &#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125; &#125;; for(auto d:directions)&#123; int next_i = i + d[0]; int next_j = j + d[1]; if(next_i&lt;0 || next_i&gt;=matrix.size() || next_j&lt;0 || next_j&gt;=matrix[0].size() || matrix[next_i][next_j]&lt;matrix[i][j])&#123;//这里i j一定要看清楚！因为i j调了一个小时！ continue; &#125; dfs(matrix, next_i, next_j, canTo); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty()) return &#123;&#125;; int m = matrix.size(); int n = matrix[0].size(); vector&lt;vector&lt;bool&gt; &gt; canToAtlatic(m, vector&lt;bool&gt;(n, false)); vector&lt;vector&lt;bool&gt; &gt; canToPacific(m,vector&lt;bool&gt;(n,false)); for (int i = 0; i &lt; m; i++)&#123; dfs(matrix, i, 0, canToPacific); dfs(matrix, i, n - 1, canToAtlatic); &#125; for (int i = 0; i &lt; n; i++)&#123; dfs(matrix, 0, i, canToPacific); dfs(matrix, m - 1, i, canToAtlatic); &#125; vector&lt;vector&lt;int&gt; &gt; res; for (int i = 0; i &lt; m; i++)&#123; for (int j = 0; j &lt; n;j++)&#123; if(canToAtlatic[i][j] &amp;&amp; canToPacific[i][j])&#123; vector&lt;int&gt; tmp = &#123;i, j&#125;; res.push_back(tmp); &#125; &#125; &#125; return res;&#125; Leetcode 329. 矩阵中的最长递增路径（困难）给定一个整数矩阵，找出最长递增路径的长度。 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。 示例 1: 12345678输入: nums = [ [9,9,4], [6,6,8], [2,1,1]] 输出: 4 解释: 最长递增路径为 [1, 2, 6, 9]。 示例 2: 12345678输入: nums = [ [3,4,5], [3,2,6], [2,2,1]] 输出: 4 解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。 题解：有记忆的dfs。普通dfs会超时，所以加了二位矩阵来记录已经得到的最长序列。 12345678910111213141516171819202122232425262728vector&lt;vector&lt;int&gt; &gt; dirs = &#123; &#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;int dfs(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int i, int j, vector&lt;vector&lt;int&gt; &gt; &amp;memo)&#123; if(memo[i][j]!=0) return memo[i][j]; memo[i][j] = 1; for(auto d:dirs)&#123; if (i + d[0] &gt;= 0 &amp;&amp; i + d[0] &lt; matrix.size() &amp;&amp; j + d[1] &gt;= 0 &amp;&amp; j + d[1] &lt; matrix[0].size() &amp;&amp; matrix[i + d[0]][j + d[1]] &gt; matrix[i][j]) memo[i][j] = max(memo[i][j], dfs(matrix, i + d[0], j + d[1], memo) + 1); &#125; return memo[i][j];&#125;int longestIncreasingPath(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123; if(matrix.empty()) return 0; int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt; &gt; memo(m, vector&lt;int&gt;(n, 0)); int res = 0; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; res = max(res, dfs(matrix, i, j, memo)); &#125; &#125; return res;&#125; 时间复杂度：O(mn)空间复杂度：O(mn) Leetcode 79. 单词搜索（中等）给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例： 12345678For example, Given board = [ [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;], [&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;], [&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;] ] word = &quot;ABCCED&quot;, -&gt; returns true, word = &quot;SEE&quot;, -&gt; returns true, word = &quot;ABCB&quot;, -&gt; returns false. 题解： 1234567891011121314151617181920212223242526bool dfs(vector&lt;vector&lt;char&gt; &gt; &amp;board, string resWord, vector&lt;vector&lt;bool&gt; &gt; &amp;hasVisited, int i, int j)&#123; if(resWord.size()==0) return true; if(i&lt;0 || i&gt;=board.size() || j&lt;0 || j&gt;=board[0].size() || board[i][j]!=resWord[0] || hasVisited[i][j]) return false; hasVisited[i][j] = true; vector&lt;vector&lt;int&gt; &gt; directions = &#123; &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125; &#125;; for(auto d:directions)&#123; if(dfs(board,resWord.substr(1,resWord.size()-1),hasVisited,i+d[0],j+d[1])) return true; &#125; hasVisited[i][j] = false; return false;&#125;bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; vector&lt;vector&lt;bool&gt; &gt; hasVisited(board.size(),vector&lt;bool&gt;(board[0].size(),false)); for (int i = 0; i &lt; board.size(); i++) &#123; for (int j = 0; j &lt; board[0].size();j++)&#123; if(dfs(board, word, hasVisited, i, j)) return true; &#125; &#125; return false;&#125; Leetcode 257. 二叉树的所有路径（简单）给定一个二叉树，返回所有从根节点到叶子节点的路径。 示例： 12345678输入： 1 / \\ 2 3 \\ 5 输出：[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;] 题解： 1234567891011121314151617181920212223242526272829struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;vector&lt;string&gt; res;void dfs(TreeNode *biTree, string prePath, TreeNode *curNode)&#123; if(curNode==NULL) return; string curStr = to_string(curNode-&gt;val); if (prePath.size() != 0) curStr = &quot;-&gt;&quot; + curStr; prePath = prePath + curStr; if (curNode-&gt;left == NULL &amp;&amp; curNode-&gt;right == NULL) &#123; res.push_back(prePath); return; &#125;else&#123; dfs(biTree, prePath, curNode-&gt;left); dfs(biTree, prePath, curNode-&gt;right); &#125; prePath = prePath.erase(prePath.size()-curStr.size());&#125;vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; dfs(root, &quot;&quot;, root); return res;&#125; 时间复杂度：O(n^2)空间复杂度：O(n^2) 3.6.4 滑动窗口滑动窗口算法框架12345678910111213int left = 0, right = 0;while (right &lt; s.size()) &#123;` // 增大窗口 window.add(s[right]); right++; while (window needs shrink) &#123; // 缩小窗口 window.remove(s[left]); left++; &#125;&#125; Leetcode 424.替换后的最长重复字符给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。 在执行上述操作后，找到包含重复字母的最长子串的长度。 题解： 123456789101112131415int characterReplacement(string s, int k) &#123; vector&lt;int&gt; numOfAlpha(26); int left = 0, right = 0, res = 0, maxCount = 0; while(right&lt;s.size())&#123; numOfAlpha[s[right] - &#x27;A&#x27;]++; maxCount = max(maxCount, numOfAlpha[s[right]-&#x27;A&#x27;]); if(right-left+1 - maxCount &gt;k)&#123; numOfAlpha[s[left] - &#x27;A&#x27;]--; left++; &#125; res = max(res, right - left + 1); right++; &#125; return res;&#125; Leetcode 567. 字符串的排列（中等）给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。 换句话说，第一个字符串的排列之一是第二个字符串的子串。 示例1: 123输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;输出: True解释: s2 包含 s1 的排列之一 (&quot;ba&quot;). 示例2: 123输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;输出: False 题解：用一个哈希表保存字母出现的个数，然后使用滑动窗口。 123456789101112131415bool checkInclusion(string s1, string s2) &#123; unordered_map&lt;char, int&gt; cmap; for(char &amp;c:s1) cmap[c]++; int idxL = 0, idxR = 0; while(idxR &lt; s2.size())&#123; char c = s2[idxR++]; //窗口右边增大 cmap[c]--; while(idxL&lt;idxR &amp;&amp; cmap[c]&lt;0) //窗口左边减小 cmap[s2[idxL++]]++; if(idxR - idxL == s1.size()) return true; &#125; return false;&#125; 3.6.5 二分查找&#x2F;折半查找二分查找框架123456789101112131415int binarySearch(int[] nums, int target) &#123; int left = 0, right = ...; while(...) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; ... &#125; else if (nums[mid] &lt; target) &#123; left = ... &#125; else if (nums[mid] &gt; target) &#123; right = ... &#125; &#125; return ...;&#125; 有两种计算中值 m 的方式：m &#x3D; (l + h) &#x2F; 2m &#x3D; l + (h - l) &#x2F; 2l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。 Leetcode 69. x 的平方根（简单）实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例： 123456Input: 4 Output: 2 Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated. 题解：后面 面试高频 中有返回不是int的实现。 12345678910111213141516int mySqrt(int x) &#123; if(x&lt;=1) return x; int low = 1, hight = x; while(low&lt;=hight)&#123; int mid = low + (hight - low) / 2; if((long)mid * mid==x) return mid; else if((long)mid * mid&gt;x) hight = mid - 1; else low = mid + 1; &#125; return hight;&#125; 时间复杂度：O(logx)空间复杂度：O(1) Leetcode 744. 寻找比目标字母大的最小字母给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。 示例： 12345678Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;d&quot; Output: &quot;f&quot; Input: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;k&quot; Output: &quot;c&quot; 题解： 12345678910111213char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123; int n = letters.size(); int low = 0, hight = n-1; while(low&lt;=hight)&#123; int mid = low + (hight - low) / 2; if(letters[mid]&lt;=target) low = mid + 1; else hight = mid - 1; &#125; char res = low &lt; n ? letters[low] : letters[0]; return res;&#125; 时间复杂度：O(logn)空间复杂度：O(1) Leetcode 540. 有序数组中的单一元素（中等）给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。要求以 O(logN) 时间复杂度进行求解，因此不能遍历数组并进行异或操作来求解，这么做的时间复杂度为 O(N)。 示例： 12Input: [1, 1, 2, 3, 3, 4, 4, 8, 8] Output: 2 题解：令 index 为 Single Element 在数组中的位置。在 index 之后，数组中原来存在的成对状态被改变。如果 m 为偶数，并且 m + 1 &lt; index，那么 nums[m] &#x3D;&#x3D; nums[m + 1]；m + 1 &gt;&#x3D; index，那么 nums[m] !&#x3D; nums[m + 1]。 从上面的规律可以知道，如果 nums[m] &#x3D;&#x3D; nums[m + 1]，那么 index 所在的数组位置为 [m + 2, h]，此时令 l &#x3D; m + 2；如果 nums[m] !&#x3D; nums[m + 1]，那么 index 所在的数组位置为 [l, m]，此时令 h &#x3D; m。因为 h 的赋值表达式为 h &#x3D; m，那么循环条件也就只能使用 l &lt; h 这种形式。 12345678910111213int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123; int low = 0, hight = nums.size() - 1; while(low&lt;hight)&#123; int mid = low + (hight - low) / 2; if(mid%2==1) //保证m为偶数 mid--; if(nums[mid] == nums[mid+1]) low = mid + 2; else hight = mid; &#125; return nums[low];&#125; 时间复杂度：O(logn)空间复杂度：O(1) 类似的题 Leetcode 136. 只出现一次的数字（简单）给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 示例： 12输入: [4,1,2,1,2]输出: 4 题解：任何数和其自身做异或运算结果是0，任何数和 0 做异或运算结果仍然是原来的数。所以依次异或就能得到。无序的话也不能用二分来做。 1234567int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for (int num : nums) &#123; res ^= num; &#125; return res;&#125; 时间复杂度：O(n)空间复杂度：O(1) Leetcode 137. 只出现一次的数字 II（中等）给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 示例： 12输入: [0,1,0,1,0,1,99]输出: 99 题解：哈希表的话空间复杂度为O(n)，但是我们需要空间复杂度为O(1)。具体看题解。 12345678int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int seenOnce = 0, seenTwice = 0; for (int num : nums) &#123; seenOnce = ~seenTwice &amp; (seenOnce ^ num); seenTwice = ~seenOnce &amp; (seenTwice ^ num); &#125; return seenOnce;&#125; 时间复杂度：O(n)空间复杂度：O(1) Leetcode 278. 第一个错误的版本（简单）给定一个元素 n 代表有 [1, 2, …, n] 版本，在第 x 位置开始出现错误版本，导致后面的版本都错误。 如果第 m 个版本出错，则表示第一个错误的版本在 [l, m] 之间，令 h &#x3D; m；否则第一个错误的版本在 [m + 1, h] 之间，令 l &#x3D; m + 1。因为 h 的赋值表达式为 h &#x3D; m，因此循环条件为 l &lt; h。 示例： 1234567给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。 题解：二分法。 1234567891011int firstBadVersion(int n) &#123; int low = 1, hight = n; while(low &lt; hight)&#123; int mid = low + (hight - low) / 2; if(isBadVersion(mid)) hight = mid; else low = mid + 1; &#125; return low;&#125; 时间复杂度：O(logn)空间复杂度：O(1) Leetcode 153. 寻找旋转排序数组中的最小值（中等）假设按照升序排序的数组在预先未知的某个点上进行了旋转。(例如，数组[0,1,2,4,5,6,7]可能变为[4,5,6,7,0,1,2]) 示例： 12输入: [3,4,5,1,2]输出: 1 题解：二分法。 1234567891011int findMin(vector&lt;int&gt;&amp; nums) &#123; int low = 0, hight = nums.size() - 1; while(low &lt; hight)&#123; int mid = low + (hight - low) / 2; if(nums[mid] &lt;= nums[hight]) hight = mid; else low = mid + 1; &#125; return nums[low];&#125; 时间复杂度：O(logn)空间复杂度：O(1) Leetcode 34. 在排序数组中查找元素的第一个和最后一个位置（中等）给定一个有序数组 nums 和一个目标 target，要求找到 target 在 nums 中的第一个位置和最后一个位置。 示例： 1234Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] 题解：可以用二分查找找出第一个位置和最后一个位置，但是寻找的方法有所不同，需要实现两个二分查找。 我们将寻找 target 最后一个位置，转换成寻找 target+1 第一个位置，再往前移动一个位置。这样我们只需要实现一个二分查找代码即可。 123456789101112131415161718192021222324252627282930int findFirst(vector&lt;int&gt; &amp;nums, int target)&#123; int low = 0, hight = nums.size() - 1; if(target&gt;nums[hight])&#123; return -1; &#125; while(low&lt;hight)&#123; int mid = low + (hight - low) / 2; if(nums[mid]&gt;=target) hight = mid; else low = mid + 1; &#125; return low;&#125;vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target)&#123; if(nums.empty() || target&lt;nums[0] || target&gt;nums[nums.size()-1]) return &#123;-1, -1&#125;; int first = findFirst(nums, target); int next = findFirst(nums, target + 1); if (first == -1 || nums[first] != target) return &#123;-1, -1&#125;; int last = 0; if (next == -1) last = nums.size() - 1; else last = next - 1; return &#123;first, last&#125;;&#125; 时间复杂度：O(logn)空间复杂度：O(1) Leetcode 315. 计算右侧小于当前元素的个数给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。 示例： 1234567输入：nums = [5,2,6,1]输出：[2,1,1,0] 解释：5 的右侧有 2 个更小的元素 (2 和 1)2 的右侧仅有 1 个更小的元素 (1)6 的右侧有 1 个更小的元素 (1)1 的右侧有 0 个更小的元素 题解： 归并排序。归并的过程中记录右边比左边小的个数和索引。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667vector&lt;int&gt; indexs; //原始索引vector&lt;int&gt; ans; //要求的答案vector&lt;int&gt; ordered; //存排好序的临时数组vector&lt;int&gt; orderedIndex; //存排好序的临时数组索引void Merge(vector&lt;int&gt; &amp;nums, int l, int mid, int r)&#123; int i = l, j = mid + 1, p = l; while (i &lt;= mid &amp;&amp; j &lt;= r)&#123; if (nums[i] &lt;= nums[j])&#123; ordered[p] = nums[i]; orderedIndex[p] = indexs[i]; ans[indexs[i]] += (j - mid - 1); i++; p++; &#125;else&#123; ordered[p] = nums[j]; orderedIndex[p] = indexs[j]; j++; p++; &#125; &#125; while (i &lt;= mid) &#123; ordered[p] = nums[i]; orderedIndex[p] = indexs[i]; ans[indexs[i]] += (j - mid - 1); i++; p++; &#125; while (j &lt;= r)&#123; ordered[p] = nums[j]; orderedIndex[p] = indexs[j]; j++; p++; &#125; for (int k = l; k &lt;= r; k++)&#123; indexs[k] = orderedIndex[k]; nums[k] = ordered[k]; &#125;&#125; void MergeSort(vector&lt;int&gt; &amp;a, int L, int R)&#123; if (L &gt;= R) return; int mid = (L + R) &gt;&gt; 1; MergeSort(a, L, mid); MergeSort(a, mid + 1, R); Merge(a, L, mid, R);&#125;vector&lt;int&gt; countSmaller(vector&lt;int&gt; &amp;nums)&#123; int n = nums.size(); indexs.resize(n); ans.resize(n); ordered.resize(n); orderedIndex.resize(n); for(int i = 0; i &lt; n; ++i) indexs[i] = i; MergeSort(nums, 0, n - 1); return ans;&#125; 时间复杂度：O(nlogn)空间复杂度：O(n) 把数组从后往前的元素依次插入一个初始为空的排序数组，插入的索引即为该元素右侧比它小的元素个数。如： 123456789示例 [5,2,6,1] 排序数组step1 [1] return 0step2 [1,6] return 1step3 [1,2,6] return 1step4 [1,2,5,6] return 2所以最后答案为 [2,1,1,0] 1234567891011121314151617181920212223242526272829303132333435363738int insertNums(vector&lt;int&gt; &amp;sorted, int num)&#123; if(sorted.size()==1)&#123; if(num&gt;sorted[0])&#123; sorted.push_back(num); return 1; &#125; else&#123; sorted.insert(sorted.begin(),num); return 0; &#125; &#125; int l = 0, r = sorted.size()-1; int mid = (l + r) / 2; while (l &lt;= r) &#123; if(sorted[mid]&lt;num) l = mid + 1; else r = mid - 1; mid = (l+r)/2; &#125; sorted.insert(sorted.begin()+l, num); return l;&#125;vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return &#123;&#125;; vector&lt;int&gt; sorted; vector&lt;int&gt; res(nums.size()); sorted.push_back(nums[nums.size()-1]); for(int i=nums.size()-2;i&gt;=0;i--)&#123; int idx = insertNums(sorted, nums[i]); res[i] = idx; &#125; return res;&#125; 时间复杂度：一开始以为是O(nlogn)，后来发现insert是O(n)的复杂度，所以是O(n^2)，就是插入排序的复杂度。但是Leetcode还是过了空间复杂度：O(n) 3.7 字符串字符串的统计字符串给定一个字符串str，返回str的统计字符串。例如“aaabbbbcccd”的统计字符串为“a_3_b_4_c_3_d_1”。 题解： 12345678910111213141516171819string calcuChar(string s)&#123; char c = s[0]; int cnt = 1; string res = &quot;&quot;; string cur_s; for (int i = 1; i &lt; s.size(); i++)&#123; if(s[i] == c) cnt++; else&#123; cur_s = c; res += (cur_s + &quot;_&quot; + to_string(cnt) + &quot;_&quot;); c = s[i]; cnt = 1; &#125; &#125; cur_s = c; res += (cur_s + &quot;_&quot; + to_string(cnt)); return res;&#125; 暴力匹配暴力匹配算法框架123456789101112131415int search(String pat, String txt) &#123; int M = pat.length; int N = txt.length; for (int i = 0; i &lt;= N - M; i++) &#123; int j; for (j = 0; j &lt; M; j++) &#123; if (pat[j] != txt[i+j]) break; &#125; // pat 全都匹配了 if (j == M) return i; &#125; // txt 中不存在 pat 子串 return -1;&#125; KMP算法从头到尾彻底理解KMP Leetcode 28. 实现 strStr()给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。示例 1:输入: haystack &#x3D; “hello”, needle &#x3D; “ll”输出: 2示例 2:输入: haystack &#x3D; “aaaaa”, needle &#x3D; “bba”输出: -1 1（待完善） BM算法（待完善） 3.8 并查集（联合-查找算法 Union-find Algorithm）并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（Union-find Algorithm）定义了两个用于此数据结构的操作： Union：将两个子集合并成同一个集合。由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（Union-find Data Structure）或合并-查找集合（Merge-find Set）。 Find：找到元素的root结点，每个root结点代表了一个子集。就能确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 Leetcode并查集题库 路径压缩我们在查询过程中只关心根结点是什么，并不关心这棵树的形态(有一些题除外)。因此我们可以在查询操作的时候将访问过的每个点都指向树根，这样的方法叫做路径压缩，单次操作复杂度为𝑂(𝑙𝑜𝑔𝑁)。 代码模版 初始化：把每个元素单独成为一个集合，即自己是自己的父结点12for(int i=1;i&lt;=n;i++) pre[i]=i; 查询（含路径压缩）1234int Find(int x)&#123; if(x==pre[x]) return x; return pre[x]=Find(pre[x]);&#125; 合并123456void merge(int x,int y)&#123; int rootX=Find(x),rootY=Find(y); if(rootX!=rootY) pre[rootX]=rootY;&#125;//主函数内merge(a,b); 76. 亲戚规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。输入格式第一行：三个整数n,m,p，（n&lt;&#x3D;5000,m&lt;&#x3D;5000,p&lt;&#x3D;5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。以下m行：每行两个数Mi，Mj，1&lt;&#x3D;Mi，Mj&lt;&#x3D;N，表示Mi和Mj具有亲戚关系。接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。输出格式P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。 输入 1234567896 5 31 21 53 45 21 31 42 35 6 输出 123YesYesNo 题解（略） Leetcode每日一题-2020年六月：6月8日四、面试高频题4.1 自己实现atoi这个相当高频，面试遇到过至少2次 1234567891011121314151617int myAtoi(const string &amp;str)&#123; string s = str; int flag = 1; if(str[0]==&#x27;-&#x27;)&#123; s = s.substr(1, s.size() - 1); flag = -1; &#125; long res = 0; for (int i = 0; i &lt; s.size();i++)&#123; res = res * 10 + (s[i] - &#x27;0&#x27;); if(res&gt;=INT_MAX &amp;&amp; flag==1) return INT_MAX; if(res&gt;INT_MAX &amp;&amp; flag==-1) return INT_MIN; &#125; return (int)res * flag;&#125; 4.2 string模拟数字运算大数相乘1234567891011121314151617181920212223242526272829303132string bigMultiple(string num1, string num2)&#123; int m = num1.size(), n = num2.size(); vector&lt;long long&gt; num(m + n - 1, 0); //m位*n位 最小是 m+n-1 位，进位插到前面 for (int i = 0; i &lt; m;i++)&#123;//前面是高位，后面是低位 int a = num1[i] - &#x27;0&#x27;; for (int j = 0; j &lt; n; j++) &#123; int b = num2[j] - &#x27;0&#x27;; num[i + j] += a * b; &#125; &#125; int carry = 0; for (int i = num.size() - 1; i &gt;= 0;i--)&#123;//前面是高位，后面是低位 int cur = num[i] + carry; num[i] = cur % 10; carry = cur / 10; &#125; while(carry!=0)&#123; int cur = carry % 10; carry /= 10; num.insert(num.begin(), cur); &#125; string res = &quot;&quot;; for (auto a : num) &#123; res += to_string(a); &#125; return res;&#125; 时间复杂度：O(m*n)空间复杂度：O(m+n) 大数相加12345678910111213141516string bigAdd(string &amp;num1, string &amp;num2)&#123; int i = num1.size() - 1, j = num2.size() - 1; int carry = 0; string res = &quot;&quot;; while(i&gt;=0 || j&gt;=0 || carry!=0)&#123; int n1 = i &gt;= 0 ? num1[i] - &#x27;0&#x27; : 0; int n2 = j &gt;= 0 ? num2[j] - &#x27;0&#x27; : 0; int tmp = n1 + n2 + carry; res.push_back(&#x27;0&#x27; + tmp % 10); carry = tmp / 10; i--; j--; &#125; reverse(res.begin(), res.end()); return res;&#125; 大数相减12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788string bigAdd(string &amp;num1, string &amp;num2)&#123; int i = num1.size() - 1, j = num2.size() - 1; int carry = 0; string res = &quot;&quot;; while(i&gt;=0 || j&gt;=0 || carry!=0)&#123; int n1 = i &gt;= 0 ? num1[i] - &#x27;0&#x27; : 0; int n2 = j &gt;= 0 ? num2[j] - &#x27;0&#x27; : 0; int tmp = n1 + n2 + carry; res.push_back(&#x27;0&#x27; + tmp % 10); carry = tmp / 10; i--; j--; &#125; reverse(res.begin(), res.end()); return res;&#125;string GreaterMinSmaller(string num1, string num2)&#123; int borrow = 0; string res = &quot;&quot;; int i = num1.size() - 1, j = num2.size() - 1; while(i&gt;=0)&#123; int cur1 = num1[i] - &#x27;0&#x27; - borrow; borrow = 0; int cur2 = j &gt;= 0 ? num2[j] - &#x27;0&#x27; : 0; if(cur1 &lt; cur2)&#123; cur1 += 10; borrow = 1; &#125; res.push_back(&#x27;0&#x27; + (cur1 - cur2)); i--; j--; &#125; reverse(res.begin(), res.end()); int not0 = 0; while(res[not0]==&#x27;0&#x27;) not0++; return res.substr(not0);&#125;string bigMinis(string &amp;num1, string &amp;num2)&#123; if(num1 == num2) return &quot;0&quot;; int flag1 = 1, flag2 = 1; string s1 = num1, s2 = num2; if (num1[0] == &#x27;-&#x27;) &#123; s1 = s1.substr(1); flag1 = -1; &#125; if (num2[0] == &#x27;-&#x27;) &#123; s2 = s2.substr(1); flag2 = -1; &#125; if(flag1==-1 &amp;&amp; flag2==1) return &quot;-&quot; + bigAdd(s1, s2); else if (flag1 == 1 &amp;&amp; flag2 == -1) return bigAdd(s1, s2); else if (flag1 == 1 &amp;&amp; flag2 == 1) &#123; bool flag = true; if(s1.size()&lt;s2.size())&#123; flag = false; &#125;else if(s1.size()==s2.size())&#123; int idx = 0; while(s1[idx]==s2[idx]) idx++; if(s1[idx]&gt;s2[idx]) flag = true; else flag = false; &#125; if(flag) return GreaterMinSmaller(s1, s2); else return &quot;-&quot; + GreaterMinSmaller(s2, s1); &#125; else if (flag1 == -1 &amp;&amp; flag2 == -1) &#123;//(-a)-(-b) = -(a-b) string res = bigMinis(s1, s2); if(res[0]==&#x27;-&#x27;) return res.substr(1); else return &quot;-&quot; + res; &#125; return &quot;&quot;;&#125; 4.3 位操作奇偶位交换(unsigned int)只要把奇数位（从低到高）拿出来左移1位，偶数位拿出来右移1位，再相或。 0xAAAA 的偶数位都为1，0x5555的奇数位都为1，分别相与可以得到奇数位和偶数位。 123void swapBit(unsigned int &amp;num)&#123; num = ((num &amp; 0xAAAA) &gt;&gt; 1) | ((num &amp; 0x5555) &lt;&lt; 1);&#125; 4.4 实现sqrt函数二分查找1234567891011121314151617181920212223float sqrtBiSearch(float n)&#123; if(n&lt;0) return 0.0; float eps = 1e-8; float left, right; if (n &gt; 1)&#123; left = 0; right = n; &#125;else&#123; left = n; right = 1; &#125; float mid = (left + right) / 2, last; while(abs(mid-last) &gt; eps)&#123; if(mid*mid &gt; n) right = mid; else left = mid; last = mid; mid = (left + right) / 2; &#125; return mid;&#125; 牛顿迭代x_n+1 = x_n - f(x_n)/f&#39;(x_n)。因为f(x) = x^2 - n，所以f&#39;(x) = 2x，即x = (x + n/x)/2 1234567891011float sqrtNewton(float n)&#123; float eps = 1e-8; if(abs(n-0.0) &gt; eps) return 0.0; float x = n ,last = 0 ; while (abs(x-last) &gt; eps)&#123; last = x ; x = (x + n / x) / 2.0 ; &#125; return x;&#125; 4.5 抢红包的实现 每次把需要剩下的保证后面的人至少都有最低金额的钱减掉（比如还剩下10个人，每个人至少1分钱，就需要留下至少0.1元）。把金额*100后用int来做，最后 &#x2F;100 就能保证 2 位小数。最后一个人为剩下的所有钱。 1234567891011121314151617vector&lt;float&gt; redBag(const float &amp;money, int cnt)&#123; int Money = money * 100; int minMoney = 1; int lastMoney = Money; int lastCnt = cnt; int maxMoney = lastMoney - lastCnt*minMoney; vector&lt;float&gt; res; for (int i = 0; i &lt; cnt-1; i++)&#123; int cur = rand() % maxMoney; res.push_back(cur/100.0); lastMoney -= cur; lastCnt--; maxMoney = lastMoney - lastCnt*minMoney; &#125; res.push_back(lastMoney/100.0); return res;&#125; 随机生产cnt个整数，这些整数加起来的和为sums，每个人分到的钱就为x/sums * money。((float)(int)(cur * 100) / 100.0)能保证两位小数。最后一个人得到剩下的所有。 1234567891011121314151617vector&lt;float&gt; redBag(const float &amp;money, int cnt)&#123; vector&lt;float&gt; res(cnt); int sums = 0; for (int i = 0; i &lt; cnt; i++)&#123; res[i] = rand() % cnt; sums += res[i]; &#125; float sumM = 0.0; for (int i = 0; i &lt; cnt - 1; i++)&#123; float cur = (res[i] / sums) * money; cur = ((float)(int)(cur * 100) / 100.0); sumM += cur; res[i] = cur; &#125; res[cnt - 1] = money - sumM; return res;&#125; Reference 严蔚敏, 吴伟民. 数据结构（C语言版）. 清华大学出版社 算法导论（中文版）. 机械工业出版社 Leetcode 何海涛. 剑指 Offer: 名企面试官精讲典型编程题. 电子工业出版社 CyC2018 labuladong的算法小抄 并查集 通俗易懂的并查集讲解","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Algorithm/"}]},{"title":"Nginx搭建基于Hexo的Blog","slug":"blogBuild","date":"2019-08-02T07:37:22.000Z","updated":"2020-10-16T02:54:45.224Z","comments":true,"path":"2019/08/02/blogBuild/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2019/08/02/blogBuild/","excerpt":"一、基础知识 框架有三种选择：(Jekyll、Hexo、WordPress) Hexo主题 NexT主题 Nginx是一款轻量级的Web 服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器，简单来说就是你输入ip&#x2F;域名时帮你打开网页文件的。","text":"一、基础知识 框架有三种选择：(Jekyll、Hexo、WordPress) Hexo主题 NexT主题 Nginx是一款轻量级的Web 服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器，简单来说就是你输入ip&#x2F;域名时帮你打开网页文件的。 二、本地环境MacOS 、Linux 、Window安装过程不同，具体请看Hexo官网教程。本篇以MacOS为例。 1. 安装Git1) MacOS:1brew install git 2) Linux Ubuntu,Debian: sudo apt-get install git-core CentOS: sudo yum install git-core 验证是否安装成功：git --version 2. 安装NodeJsNodeJS官网有提供安装包：https://nodejs.org/en/download/ 下载安装即可验证是否安装成功：node --version如果出现版本信息即安装成功 3. 安装Hexo1) 安装1npm install -g hexo-cli 有的是用npm install -g hexo 他们的不同之处请看Hexo 与 Hexo-cli 的关系、入门教程 2) 使用本地创建一个文件夹存放Hexo的博客源码，cd进该文件夹后输入: hexo init ProjectName（这里的ProjectName就是你的项目文件名称，如 hexo init blog）。完成后源文件夹会出现如下目录结构： cd 进该文件夹(如blog)后输入hexo s -debug或者hexo server 就能启动项目了。如果启动成功会出现以下提示： 在浏览器输入localhost:4000 就能访问项目了。 初始使用是Hexo的默认主题，我们也可以使下载NexT的主题配置，将下载后的next文件夹直接丢到themes文件夹中即可，具体使用方法请查看NexT官网。或者下载其他hexo主题 三、服务器ps:如果使用github.io，只需以 github用户名.github.io 为名建立一个仓库就行了，之后可以用 github用户名.github.io 访问博客 服务器，域名，备案等自行查看参考文章。 1. SSH连接远程服务器1ssh USERNAME@IP USERNAME为服务器用户名，一般阿里的的服务器初始用户名为root，IP为你的公网IP地址，如：ssh root@111.111.111.111 2. 配置SSH公钥1) 生成公钥1ssh-keygen 键入这个命令后，会提示让你给这个公钥配置密码（passphrase），我们既然是为了避免多次输入密码， 这里为什么还要给公钥配置密码呢，所以我们要一路回车，不理他（会出现三次） 2) 将本地公钥拷贝到服务器1ssh-copy-id USERNAME@IP 如果之前已经生成过的，用以下命令： 1ssh-copy-id -i sshPATH USERNAME@IP 如:ssh-copy-id -i .ssh/id_rsa.pub root@111.111.111 id_rsa是私钥，id_rsa.pub是公钥，要传到服务器的是公钥.pub（参考三、1） 3) 只需要在步骤最后输入一次服务器密码，以后再连接SSH就不需要输入密码了3. 安装Git1sudo apt-get install git-core 4. 安装Nginx1sudo apt-get install nginx 启动nginx： 1service nginx start 然后你在浏览器中输入自己的公网IP，可以看到如下就证明nginx安装成功： 5. 创建一个网站的根目录（用于存放网站的部署的静态文件）1mkdir /var/www/blog 6. nginx的配置我的Nginx版本是1.10.3，一般nginx配置文件夹是在&#x2F;etc&#x2F;nginx&#x2F;下的，如果是其他版本的，先搞清楚自己的配置文件夹在哪里的，有的是在&#x2F;usr&#x2F;下。 目前找到三种配置的办法1) 网上大部分教程都是在 &#x2F;etc&#x2F;nginx&#x2F;conf.d 这个文件夹下 vim FILENAME.conf.d 来创建一个配置文件，在里面写入12345678server&#123; listen 80;//端口号 server_name _;//域名 root /var/www/blog;/*网站根目录，出于权限问题考虑，建议把网站配置在www文件目录下*/ location / &#123; index index.htm index.html &#125;&#125; 但是我试了很多次都没有成功，不太清楚conf.d目录下的配置怎么载入的。 2) 修改总配置文件首先备份一下nginx.conf ： 12cd /etc/nginxcp nginx.conf nginx.conf.bak 然后vim修改 &#x2F;etc&#x2F;nginx&#x2F;nginx.conf ，把server模块里的端口号(listen)、域名(server_name)、根目录(root)改为和1）相同。因为nginx.conf是总配置文件，某个小错误可能会导致网站打不开，所以更推荐第三种。 3) 修改 &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;defaultvim &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default同上，把server把server模块里root后面改为你的网页根目录。本例是改为root &#x2F;var&#x2F;www&#x2F;blog;注：如果需要配置多个虚拟主机，需要用ln -sf /etc/nginx/sites-available/* /etc/nginx/sites-enabled创建软连接，具体请查看参考 然后重启Nginx1service nginx restart 7. Git的建仓与配置建仓：第1）步和第2）步有两种方法 方法一：1) 创建一个文件夹存作为git仓库1mkdir PATH/FILENAME 如：mkdir ~/blog.git然后 cd ~/blog.git 2) 建仓1git init --bare 方法二：1）1cd ~ 2）1git init --bare FILENAME 如：git init --bare blog.git 3）如果新建了用户，或者不是root（管理员）账号，还需要修改仓库的权限：1chown -R USERNAME:GROUP FILENAME 比如新建了一个用户git来建站，则 chown -R git:git ~/blog.git本例没有这一步，就略过修改权限配置hooks： 12cd ~/blog.gitvim post-receive 在post-receive中写入： 123#!/bin/bashrm -rf /var/www/bloggit clone /root/blog.git /var/www/blog 或者： 12#!/bin/bashgit --work-tree=/var/www/blog --git-dir=/root/blog.git checkout -f 赋予这个文件夹权限： 1chmod +x ~/blog.git/hooks/post-receive 四、本地Hexo配置回到本地的机器上，进入你的hexo文件夹（就是你完成hexo init的那个）找到_config.yml, 修改里面的deploy： 1234deploy: type: git repo: USERNAME@IP:GitPath //如：root@111.111.111.111:/root/blog.git branch: master 注：USERNAME指的是你的服务器用户名，本例是root IP是指你服务器的公网IP GitPath是服务器上的Git仓库路上，按上面的流程应该是：&#x2F;root&#x2F;blog.git 如果使用的是github.io，那么整个repo就改为你的github仓库地址，如：https://xxx.github.io 五、发布项目1.cd进你的hexo根目录（就是你完成hexo init的那个）12hexo generatehexo deploy 或者hexo g -d 如果显示not fount git，是因为我们没有在这个项目中安装git插件： 1npm install hexo-deployer-git —save 安装完后再来一遍 hexo g -d 然后会让你输入你公网IP对应服务器的密码，输入完成后会生成一堆静态文件，并部署到远程服务器上 如果上述一切都操作成功，你就可以在浏览器输入IP或域名查看你的项目了 Hexo基本命令1.新建文章1hexo new &quot;文章名&quot; 2.刷新(目的是删除原来的public文件夹，避免污染)1hexo clean 3.生成&amp;&amp;部署1hexo g -d 主题配置 Hexo博客使用valine评论系统无效果及终极解决方案 NexT主题配置相关博客 还不错的主题 melody 参考： 搭建步骤 搭建步骤 搭建步骤 很多个性化主题教程链接 hexo的安装和使用 服务器，域名 ssh Nginx安装 Nginx配置 Nginx目录说明 Nginx多个虚拟主机 ps:如果想在首页不显示某篇文章，只在分类中显示，可以修改 themes/next/layout/index.swig 文件，把 123456&#123;% block content %&#125; &lt;section id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &#123;%- for post in page.posts %&#125; &#123;&#123; partial(&#x27;_macro/post.swig&#x27;, &#123;is_index: true&#125;) &#125;&#125; &#123;%- endfor %&#125; &lt;/section&gt; 改为 12345678&#123;% block content %&#125; &lt;section id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &#123;%- for post in page.posts %&#125; &#123;%- if post.hide != true %&#125; &#123;&#123; partial(&#x27;_macro/post.swig&#x27;, &#123;is_index: true&#125;) &#125;&#125; &#123;%- endif %&#125; &#123;%- endfor %&#125; &lt;/section&gt; 然后在要隐藏文章的md文件的front-matter中加上hide: true","categories":[{"name":"web前端","slug":"web前端","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Hexo/"},{"name":"Nginx","slug":"Nginx","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Nginx/"}]},{"title":"imss","slug":"imss","date":"2019-08-02T05:12:04.000Z","updated":"2020-08-17T07:43:32.799Z","comments":true,"path":"2019/08/02/imss/","link":"","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/2019/08/02/imss/","excerpt":"","text":"标题一级爱你标题二级爱你标题三级爱你标题四级爱你标题五级爱你标题六级爱你标题一级爱你标题二级爱你加粗字体爱你 斜体字体爱你 斜体与加粗爱你 这里添加引用文字爱你 带有多个段落的块引用爱你爱你带有多个段落的块引用爱你 嵌套引用1. 嵌套引用2. 标题四级 段落一 段落二. 斜体 与 加粗. 条目一 条目二 条目三 条目四 缩进一 前面4个空格 缩进二 前面4个空格 缩进三 或双Tab 条目五 我的主页-无备注我的主页-有备注 [我的主页-无备注][1][我的主页-无备注] [1][我的主页-有备注][a][我的主页-有备注][A][1]: https://suzhilong.github.io/[A]: https://suzhilong.github.io/ “备注信息”[A]: https://suzhilong.github.io/ ‘备注信息’[A]: https://suzhilong.github.io/ (备注信息)[A]: https://suzhilong.github.io/ “备注信息”[a]: https://suzhilong.github.io/ ‘备注信息’[a]: https://suzhilong.github.io/ (备注信息) 标题 内容 备注 标题1 内容1 备注1 标题2 内容2 备注2 此段内容删除 这是一个简短的脚注，^1 和一个较长的脚注。^bignote 缩进段落以将其包含在脚注中。 `&#123; my code &#125;` 添加任意数量的段落。 反引号行内码 1代码块 代码块","categories":[{"name":"web前端","slug":"web前端","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[]}],"categories":[{"name":"Tool","slug":"Tool","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/Tool/"},{"name":"CS","slug":"CS","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/CS/"},{"name":"robot","slug":"robot","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/robot/"},{"name":"SLAM","slug":"robot/SLAM","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/robot/SLAM/"},{"name":"OS","slug":"OS","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/OS/"},{"name":"web前端","slug":"web前端","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"back-end","slug":"back-end","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/back-end/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/categories/Algorithm/"}],"tags":[{"name":"Barrier","slug":"Barrier","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Barrier/"},{"name":"Architecture","slug":"Architecture","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Architecture/"},{"name":"Computer vision","slug":"Computer-vision","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Computer-vision/"},{"name":"wiki","slug":"wiki","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/wiki/"},{"name":"Drone","slug":"Drone","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Drone/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/ubuntu/"},{"name":"Docker","slug":"Docker","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Docker/"},{"name":"vue","slug":"vue","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/vue/"},{"name":"后端","slug":"后端","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/%E5%90%8E%E7%AB%AF/"},{"name":"OS","slug":"OS","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/OS/"},{"name":"Leetcode daily","slug":"Leetcode-daily","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Leetcode-daily/"},{"name":"cpp","slug":"cpp","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/cpp/"},{"name":"data structure","slug":"data-structure","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/data-structure/"},{"name":"database","slug":"database","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/database/"},{"name":"Network","slug":"Network","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Network/"},{"name":"autonomous driving","slug":"autonomous-driving","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/autonomous-driving/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Algorithm/"},{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Hexo/"},{"name":"Nginx","slug":"Nginx","permalink":"https://github.com/suzhilong/suzhilong.github.io.git/tags/Nginx/"}]}