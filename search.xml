<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker使用记录</title>
    <url>/2021/01/13/Docker/</url>
    <content><![CDATA[<h1 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h1><span id="more"></span>


<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul>
<li><a href="https://yeasy.gitbook.io/docker_practice/">Docker——从入门到实践</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/85664330">MacOS通过Docker使用ROS</a></li>
<li><a href="https://hub.docker.com/r/ct2034/vnc-ros-kinetic-full?ref=login">可以通过GUI打开gazebo, rviz, rqt等工具的镜像</a></li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>光流法</title>
    <url>/2020/07/05/OpticalFlow/</url>
    <content><![CDATA[<h1 id="光流法"><a href="#光流法" class="headerlink" title="光流法"></a>光流法</h1><p>光流法是利用图像序列中的像素强度数据的时域变化和相关性来确定各自像素位置的“运动”。简单说来说，光流法的目的是找到灰度图中各像素在连续图像中的移动方向和速度。</p>
<p>光流法的实现要求满足几个基本假设：  </p>
<ol>
<li>相邻帧之间的亮度恒定；</li>
<li>相邻视频帧的取帧时间连续，或者，相邻帧之间物体的运动比较“微小”；</li>
<li>保持空间一致性；即，同一子图像的像素点具有相同的运动。</li>
</ol>
<span id="more"></span>
<h2 id="光流法的分类"><a href="#光流法的分类" class="headerlink" title="光流法的分类"></a>光流法的分类</h2><h3 id="基于梯度（微分法）"><a href="#基于梯度（微分法）" class="headerlink" title="基于梯度（微分法）"></a>基于梯度（微分法）</h3><h4 id="Horn-Schunck光流法"><a href="#Horn-Schunck光流法" class="headerlink" title="Horn-Schunck光流法"></a>Horn-Schunck光流法</h4><p>Horn-Schunck光流法基于全局平滑假设，即运动物体内部的光流场是相同的，因此物体内部光流场的梯度应该为零，也就是说物体内部的光流场应当是平滑的，故得到一个二阶梯度为0的约束方程。</p>
<p><strong>特点</strong>：稠密光流，二阶导，计算量大</p>
<p><strong>论文</strong>：Horn B K P, Schunck B G. Determining optical flow[J]. Artificial intelligence, 1981, 17(1-3): 185-203</p>
<h4 id="Lucas-Kanade光流法"><a href="#Lucas-Kanade光流法" class="headerlink" title="Lucas-Kanade光流法"></a>Lucas-Kanade光流法</h4><p>Lucas-Kanade算法认为：一个像素周围的相邻像素的光流场应该和中心的像素光流场一致。因此可以得到一系列等式，可以用最小二乘法求解。</p>
<p><strong>特点</strong>：稀疏光流</p>
<p><strong>论文</strong>：Baker S, Matthews I. Lucas-kanade 20 years on: A unifying framework[J]. International journal of computer vision, 2004, 56(3): 221-255.</p>
<h4 id="基于图像金字塔的Lucas-Kanade光流法"><a href="#基于图像金字塔的Lucas-Kanade光流法" class="headerlink" title="基于图像金字塔的Lucas-Kanade光流法"></a>基于图像金字塔的Lucas-Kanade光流法</h4><p>普通的光流算法有一个问题——<strong>孔径问题</strong>。</p>
<p>同时，LK算法的约束条件——小速度，亮度不变以及区域一致性——都是较强的假设，并不很容易得到满足。如当物体运动速度较快时，假设不成立，那么后续的假设就会有较大的偏差，使得最终求出的光流值有较大的误差。</p>
<p>图像金字塔可以解决这个问题。</p>
<p><strong>特点</strong>：稀疏光流</p>
<p><strong>论文</strong>：Pyramidal Implementation of the Lucas Kanade Feature TrackerDescription of the algorithm</p>
<h3 id="基于块匹配"><a href="#基于块匹配" class="headerlink" title="基于块匹配"></a>基于块匹配</h3><p>先找出原图中的<strong>特征点</strong>，再在待匹配的图中的同一个位置附近区域使用<strong>块匹配</strong>的方法寻找最匹配的块。</p>
<h4 id="块匹配的主要方法："><a href="#块匹配的主要方法：" class="headerlink" title="块匹配的主要方法："></a>块匹配的主要方法：</h4><ul>
<li>SAD（绝对误差和）</li>
<li>MAD（平均绝对差)</li>
<li>SSD（误差平方和）</li>
<li>MSD（平均误差平方和）</li>
</ul>
<h1 id="OpenCV中的光流法函数"><a href="#OpenCV中的光流法函数" class="headerlink" title="OpenCV中的光流法函数"></a>OpenCV中的光流法函数</h1><p>具体API可以查看<a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowfarneback">OpenCV官方文档</a></p>
<h2 id="CalcOpticalFlowHS"><a href="#CalcOpticalFlowHS" class="headerlink" title="CalcOpticalFlowHS"></a>CalcOpticalFlowHS</h2><p>HS光流法的实现</p>
<h2 id="calcOpticalFlowPyrLK"><a href="#calcOpticalFlowPyrLK" class="headerlink" title="calcOpticalFlowPyrLK"></a>calcOpticalFlowPyrLK</h2><p>基于图像金字塔的Lucas-Kanade光流法的实现</p>
<h2 id="CalcOpticalFlowBM"><a href="#CalcOpticalFlowBM" class="headerlink" title="CalcOpticalFlowBM"></a>CalcOpticalFlowBM</h2><p>通过块匹配的方法来计算光流</p>
<h2 id="calcOpticalFlowFarneback"><a href="#calcOpticalFlowFarneback" class="headerlink" title="calcOpticalFlowFarneback"></a>calcOpticalFlowFarneback</h2><p>用Gunnar Farneback 的算法计算稠密光流（即图像上所有像素点的光流都计算出来）。</p>
<p><strong>论文</strong>：Two-Frame Motion Estimation Based on PolynomialExpansion</p>
<h2 id="calcOpticalFlowSF"><a href="#calcOpticalFlowSF" class="headerlink" title="calcOpticalFlowSF"></a>calcOpticalFlowSF</h2><p><strong>论文</strong>：SimpleFlow: A Non-iterative, Sublinear Optical FlowAlgorithm</p>
<h1 id="px4flow源码笔记"><a href="#px4flow源码笔记" class="headerlink" title="px4flow源码笔记"></a>px4flow源码笔记</h1><p><a href="https://github.com/PX4/Flow/blob/master/src/modules/flow/flow.c">flow.c文件地址</a></p>
<p><a href="https://github.com/PX4/OpticalFlow">px4flow cpp项目地址</a></p>
<h2 id="只用图像信息"><a href="#只用图像信息" class="headerlink" title="只用图像信息"></a>只用图像信息</h2><p><a href="https://github.com/suzhilong/Optical-Flow/tree/master/flow_c_test">c代码</a>：去掉角速度，用随机生成的二维矩阵测试</p>
<h2 id="compute-flow函数"><a href="#compute-flow函数" class="headerlink" title="compute_flow函数"></a>compute_flow函数</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>参数：*image1,*image2,x_rate,y_rate,z_rate,*pixel_flow_x, *pixel_flow_y</p>
<p>意义：图像1，图像2，绕x轴旋旋转速度，绕y轴旋转速度，绕z轴旋转速度，x轴像素移动，y轴像素移动</p>
<h3 id="加了备注"><a href="#加了备注" class="headerlink" title="加了备注"></a>加了备注</h3><ul>
<li><p><a href="https://github.com/suzhilong/Optical-Flow/blob/master/flow.c">c代码</a></p>
</li>
<li><p><a href="https://github.com/suzhilong/Optical-Flow/blob/master/flow.cpp">cpp代码</a></p>
</li>
</ul>
<h3 id="函数伪码："><a href="#函数伪码：" class="headerlink" title="函数伪码："></a>函数伪码：</h3><details>
  <summary>点击查看伪码</summary>
  <pre><code>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def compute_flow():</span><br><span class="line">    for block_mid_pix in img1://步长为block的大小</span><br><span class="line">        diff = compute_diff()</span><br><span class="line">        if(diff&lt;THRESHOLD): continue</span><br><span class="line">    </span><br><span class="line">    for pix_in_win in img2:</span><br><span class="line">        temp_dist = ABSDIFF()</span><br><span class="line">        if(temp_dist&lt;dist):</span><br><span class="line">        sumx = x偏移量</span><br><span class="line">        sumy = y偏移量</span><br><span class="line">        dist = temp_dist</span><br><span class="line"></span><br><span class="line">    if(dist&lt;MIN_SAD):</span><br><span class="line">        meanflowx += sumx</span><br><span class="line">        meanflowy += sumy</span><br><span class="line">        compute_subpixel();//计算半像素</span><br><span class="line">        得到具有最小SAD的半像素方向mindir</span><br><span class="line">        dirsx[meancount] = sumx</span><br><span class="line">        dirsy[meancount] = sumy</span><br><span class="line">        subdirs[meancount] = mindir</span><br><span class="line">        meancount++</span><br><span class="line">        统计4个方向（类似坐标系的4个象限）的直方图</span><br><span class="line">        </span><br><span class="line">    if(meancount&gt;10)://特征点超过10个点</span><br><span class="line">        meanflowx /= meancount</span><br><span class="line">        meanflowy /= meancount</span><br><span class="line">        从直方图中找到4个方向中出现最多的方向</span><br><span class="line"></span><br><span class="line">    if(滤波)：</span><br><span class="line">        滤波法</span><br><span class="line">    else：</span><br><span class="line">        平均法</span><br><span class="line"></span><br><span class="line">    //NUM_BLOCKS是一个维度被分成了几块</span><br><span class="line">    计算qual=meancount * 255 / (NUM_BLOCKS*NUM_BLOCKS) </span><br></pre></td></tr></table></figure>
<p>  </code></pre></p>
</details>


<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>计算特征点使用了<code>compute_diff</code>函数，计算光流用的是SAD块匹配。</p>
<h4 id="compute-diff-image-offX-offY-row-size"><a href="#compute-diff-image-offX-offY-row-size" class="headerlink" title="compute_diff(*image, offX, offY, row_size)"></a>compute_diff(*image, offX, offY, row_size)</h4><p>参数：图像，图像左上角像素的x坐标，图像左上角像素的y坐标</p>
<h4 id="compute-subpixelcompute-subpixel-image1-image2-off1X-off1Y-off2X-off2Y-acc-row-size"><a href="#compute-subpixelcompute-subpixel-image1-image2-off1X-off1Y-off2X-off2Y-acc-row-size" class="headerlink" title="compute_subpixelcompute_subpixel(*image1,*image2,off1X,off1Y,off2X, off2Y,*acc,row_size)"></a>compute_subpixelcompute_subpixel(*image1,*image2,off1X,off1Y,off2X, off2Y,*acc,row_size)</h4><p>参数：图像1，图像2，图像1左上角像素的x坐标，图像1左上角像素的y坐标，图像2左上角像素的x坐标，图像2左上角像素的y坐标，</p>
<h4 id="计算流程"><a href="#计算流程" class="headerlink" title="计算流程"></a>计算流程</h4><ul>
<li>重要参数含义<br><img src="https://i.loli.net/2020/07/05/Jdl7qp3uvegcB6F.png" alt="参数含义"></li>
<li>筛选特征点<br><img src="https://i.loli.net/2020/07/05/9zsJfOIGwWDE7Ag.png" alt="compute_diff"></li>
<li>在附近搜索“距离”最近的块<br><img src="https://i.loli.net/2020/07/05/xhJoKFy2OAuZeBa.png" alt="块匹配"></li>
<li>半像素增加精度<br><img src="https://i.loli.net/2020/07/05/SKXiEp8h27TmjqN.png" alt="compute_subpixel"></li>
<li>直方图统计<br><img src="https://i.loli.net/2020/07/05/IKe4kJVFCzR6aGn.png" alt="直方图统计"></li>
<li>进一步计算：直方图法用统计数量峰值的前后两个像素数据（共5个）来取平均；平均法全部加起来取平均。<br><img src="https://i.loli.net/2020/07/05/eVqPZx6KTILCEaU.png" alt="meancount大于10"></li>
<li>角速度补偿<br><img src="https://i.loli.net/2020/07/05/sHc83t2OoK57kXg.png" alt="角速度补偿"></li>
</ul>
<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul>
<li><a href="https://blog.csdn.net/ReadAir/article/details/88073068">光流法的过去，现在和发展趋势</a></li>
<li><a href="https://blog.csdn.net/qq_41368247/article/details/82562165">计算机视觉–光流法(optical flow)简介</a></li>
<li><a href="https://blog.csdn.net/hujingshuang/article/details/47759579">基于灰度的模板匹配算法（一）：MAD、SAD、SSD、MSD、NCC、SSDA、SATD算法</a></li>
<li><a href="https://blog.csdn.net/crzy_sparrow/article/details/7407604">Opencv学习笔记（九）光流法</a></li>
<li><a href="https://blog.csdn.net/zouxy09/article/details/8683859">光流Optical Flow介绍与OpenCV实现</a></li>
<li><a href="https://blog.csdn.net/zhashuiguangzi/article/details/75788010">ABSDIFF和USADA8的汇编代码</a></li>
<li><a href="https://blog.csdn.net/Zhaohui1995_Yang/article/details/51346695">Px4 flow分析</a></li>
<li><a href="https://blog.csdn.net/qq_25394511/article/details/79437850">PX4FLOW flow.c函数流程详细解析</a></li>
<li><a href="https://blog.csdn.net/sev_en77/article/details/70226083">px4flow源码分析</a></li>
</ul>
]]></content>
      <categories>
        <category>robot</category>
      </categories>
      <tags>
        <tag>Computer vision</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu找不到ttyUSB*</title>
    <url>/2021/01/17/UbuntuNoUSB/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在使用dji妙算（arm架构ubuntu14.04）连接激光雷达（ <a href="https://www.cnblogs.com/wanghuixi/p/6476984.html">ubuntu RPLIDAR A2的使用</a>）时，出现不能调用端口的错误，经过搜索后发现，是因为没有ttyUSB*驱动。</p>
<span id="more"></span>

<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>（待补充）</p>
<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul>
<li><a href="https://www.cnblogs.com/huang-y-x/p/10747849.html">Ubuntu下找不到ttyUSB*问题解决</a></li>
<li><a href="https://mlog.club/article/4510928">为您的内核版本构建cp210x</a></li>
<li><a href="https://www.cnblogs.com/CZM-/p/5985601.html">ubuntu arm妙算加载cp210x驱动</a></li>
<li><a href="https://elixir.bootlin.com/linux/v4.15/source/drivers/usb/serial">cp210x&#x2F;ch340等驱动地址</a></li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu开机失败——ACPI Error</title>
    <url>/2021/01/13/acpiError/</url>
    <content><![CDATA[<h1 id="开机循环进入GNU-GRUB-或者-黑屏"><a href="#开机循环进入GNU-GRUB-或者-黑屏" class="headerlink" title="开机循环进入GNU GRUB 或者 黑屏"></a>开机循环进入GNU GRUB 或者 黑屏</h1><span id="more"></span>
<p>有提示ACPI Error错误如图：<br><img src="https://i.loli.net/2021/01/13/iOJXvaWPxGmF95Z.jpg" alt="ACPI错误"></p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><h2 id="1）先用下面方法进入系统"><a href="#1）先用下面方法进入系统" class="headerlink" title="1）先用下面方法进入系统"></a>1）先用下面方法进入系统</h2><ul>
<li>在GUN GRUB界面，选择ubuntu，按<code>e</code>开启编辑；</li>
<li>在开头为<code>linux</code>的一行最后，加上<code>apci=off</code></li>
<li>按<code>f10</code>重启</li>
</ul>
<h2 id="2）更改grub"><a href="#2）更改grub" class="headerlink" title="2）更改grub"></a>2）更改grub</h2><ul>
<li>修改<code>grub</code>文件：<code>sudo vim /etc/default/grub</code></li>
<li>把<code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;</code>改为<code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash acpi=off&quot;</code>(vim的使用方法请自行搜索)</li>
<li><code>sudo update-grub</code></li>
</ul>
<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul>
<li>这是由于acpi和ubuntu版本不兼容：<a href="https://askubuntu.com/questions/139157/booting-ubuntu-with-acpi-off-grub-parameter">Booting Ubuntu with “acpi&#x3D;off” grub parameter</a></li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶学习笔记</title>
    <url>/2020/05/29/autonomousDriving/</url>
    <content><![CDATA[<h1 id="Apollo入门课程"><a href="#Apollo入门课程" class="headerlink" title="Apollo入门课程"></a><a href="https://apollo.auto/devcenter/coursetable_cn.html?target=1">Apollo入门课程</a></h1><h2 id="无人驾驶概览"><a href="#无人驾驶概览" class="headerlink" title="无人驾驶概览"></a>无人驾驶概览</h2><h3 id="自动驾驶等级"><a href="#自动驾驶等级" class="headerlink" title="自动驾驶等级"></a>自动驾驶等级</h3><ol start="0">
<li>Base level 驾驶员完全控制车辆</li>
<li>Driver Assistance</li>
<li>Partial Automation</li>
<li>Conditional Automation</li>
<li>No Human Interference</li>
<li>Full Automation<span id="more"></span>
<img src="https://i.loli.net/2020/05/29/bHOoJ6BejlM8KRk.png" alt="自动驾驶等级"><br><img src="https://i.loli.net/2020/05/29/73nypHI6sVFRj1B.png" alt="自动驾驶等级"></li>
</ol>
<h3 id="无人车的运作方式"><a href="#无人车的运作方式" class="headerlink" title="无人车的运作方式"></a>无人车的运作方式</h3><p><img src="https://i.loli.net/2020/05/29/FKImlxCi4wkb5PD.png" alt="无人车的运作方式">  </p>
<h3 id="硬件平台"><a href="#硬件平台" class="headerlink" title="硬件平台"></a>硬件平台</h3><p><img src="https://i.loli.net/2020/05/29/lGRJrT8bH9McOPL.png" alt="硬件平台">  </p>
<ul>
<li>控制器区域网络(Controller Area Network, CAN)<br><img src="https://i.loli.net/2020/05/29/ptsd3iNUulVxXRg.png"></li>
<li>GPS</li>
<li>IMU</li>
<li>Lidar：(Light)光波</li>
<li>Radar：(Radio)无线电波</li>
</ul>
<h3 id="软件平台"><a href="#软件平台" class="headerlink" title="软件平台"></a>软件平台</h3><ul>
<li>实时操作系统(RTOS): ubuntu+apollo<ul>
<li>去中心化：多Node</li>
<li>Protobuf替代ROS Messagr增加兼容性</li>
</ul>
</li>
<li>运行时框架</li>
<li>应用程序模块层<br><img src="https://i.loli.net/2020/05/29/bocxUA1Xq6j79CV.png"></li>
</ul>
<h3 id="云服务"><a href="#云服务" class="headerlink" title="云服务"></a>云服务</h3><ul>
<li>HD Map</li>
<li>Simulation</li>
<li>Data Platform</li>
<li>Security</li>
<li>OTA(空中软件升级)</li>
<li>DuerOS(智能语音系统)</li>
</ul>
<h2 id="高精度地图"><a href="#高精度地图" class="headerlink" title="高精度地图"></a>高精度地图</h2><p>ROI可以提高精度和寻找速度<br>Apollo高清地图格式：OpenDRIVE  </p>
<h3 id="高清地图组成"><a href="#高清地图组成" class="headerlink" title="高清地图组成"></a>高清地图组成</h3><ul>
<li>数据采集</li>
<li>数据处理</li>
<li>对象检测</li>
<li>手动验证</li>
<li>地图发布<br><img src="https://i.loli.net/2020/05/29/Zrlgpf5BKaWcxoM.png" alt="高清地图组成"></li>
</ul>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><ul>
<li>GNSS(Gloval Navigation Satellite System) RTK(实时运动定位)<ul>
<li>Satellite</li>
<li>Control Station</li>
<li>Receivers</li>
<li>ps：GPS是GNSS的一种</li>
</ul>
</li>
<li>惯性导航(Inertial Navigation) 可达1000Hz<ul>
<li>容易飘</li>
</ul>
</li>
<li>激光雷达Lidar<ul>
<li>ICP</li>
<li>滤波算法<ul>
<li>直方图滤波Histogram Filter (有时候称Sum of Squared Difference, SSD)</li>
<li>卡尔曼滤波</li>
<li>粒子滤波</li>
</ul>
</li>
</ul>
</li>
<li>视觉定位<ul>
<li>优点：图像易获得</li>
<li>缺点：没有三维信心</li>
</ul>
</li>
<li>Apollo定位<ul>
<li>GPS、IMU、LiDar</li>
<li><img src="https://i.loli.net/2020/05/29/Q2iBlDWvAm7Xad8.png" alt="卡尔曼滤波"></li>
</ul>
</li>
</ul>
<h2 id="感知"><a href="#感知" class="headerlink" title="感知"></a>感知</h2><ol>
<li>检测 Detection</li>
<li>分类 Classification</li>
<li>跟踪 Tracking</li>
<li>语义分割 Segmentation</li>
</ol>
<h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h3><ul>
<li>摄像头图像</li>
<li>LiDAR图像<br><img src="https://i.loli.net/2020/05/29/owXGPtS7LbvrU2k.png"></li>
</ul>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><ul>
<li>监督学习</li>
<li>无监督学习</li>
<li>半监督学习</li>
<li>强化学习</li>
</ul>
<h3 id="检测与分类"><a href="#检测与分类" class="headerlink" title="检测与分类"></a>检测与分类</h3><ul>
<li>YOLO</li>
<li>SSD</li>
</ul>
<h3 id="Apollo感知"><a href="#Apollo感知" class="headerlink" title="Apollo感知"></a>Apollo感知</h3><ul>
<li>ROI在高精度地图</li>
<li>Detection Network</li>
<li>检测和跟踪</li>
<li>YOLO车道线检测、目标跟踪</li>
<li><img src="https://i.loli.net/2020/05/29/2ujw1ozqaCJVsgr.png"></li>
</ul>
<h3 id="传感器比较"><a href="#传感器比较" class="headerlink" title="传感器比较"></a>传感器比较</h3><p><img src="https://i.loli.net/2020/05/29/HVZicw9xelEjUhG.png" alt="传感器比较"></p>
<h3 id="感知融合策略："><a href="#感知融合策略：" class="headerlink" title="感知融合策略："></a>感知融合策略：</h3><ul>
<li>卡尔曼滤波<ul>
<li>同步融合</li>
<li>异步融合</li>
</ul>
</li>
</ul>
<h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><ul>
<li>基于模型的预测</li>
<li>数据驱动预测</li>
</ul>
<h3 id="Apollo预测"><a href="#Apollo预测" class="headerlink" title="Apollo预测"></a>Apollo预测</h3><p>基于车道序列方法<br><img src="https://i.loli.net/2020/05/29/2yZuS95M8zNcHCe.png" alt="基于车道序列方法"><br>神经网络预测车道序列<br>结合车辆物理元素，轨迹生成：可以用多项式拟合  </p>
<h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>输入：</p>
<ul>
<li>map</li>
<li>location</li>
<li>destination<br>搜索：讲地图转化为图（graph）</li>
</ul>
<h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><p>A*<br><img src="https://i.loli.net/2020/05/29/waeNQVpZzq5vcjX.png"></p>
<h3 id="轨迹评估"><a href="#轨迹评估" class="headerlink" title="轨迹评估"></a>轨迹评估</h3><ul>
<li>无障碍</li>
<li>乘客舒服</li>
<li>轨迹实际可行的</li>
<li>轨迹应该遵守交通规则</li>
</ul>
<h3 id="轨迹选择"><a href="#轨迹选择" class="headerlink" title="轨迹选择"></a>轨迹选择</h3><p>成本函数(cost function)。不同路况、场景的成本函数不同</p>
<h3 id="Frenet坐标系"><a href="#Frenet坐标系" class="headerlink" title="Frenet坐标系"></a>Frenet坐标系</h3><p><img src="https://i.loli.net/2020/05/29/Pwzamb1N8KOLnM3.png" alt="Frenet坐标系"></p>
<h3 id="路径-速度解耦规则"><a href="#路径-速度解耦规则" class="headerlink" title="路径-速度解耦规则"></a>路径-速度解耦规则</h3><ol>
<li>路径规划  </li>
<li>速度规划<ul>
<li>ST图<br> <img src="https://i.loli.net/2020/05/29/3XQ5JKzaDehpglV.png" alt="ST图"></li>
<li>障碍物阻挡的ST图：法律限制、速度限制、汽车物理限制等等来筛选曲线<br> <img src="https://i.loli.net/2020/05/29/rkhCI2YJ7DwNHtV.png" alt="障碍物阻挡的ST图"></li>
<li>二次规划来平滑轨迹</li>
</ul>
</li>
</ol>
<p>路径规划—&gt;ST图轨迹选择—&gt;二次规划轨迹平滑</p>
<h3 id="Lattice规划"><a href="#Lattice规划" class="headerlink" title="Lattice规划"></a>Lattice规划</h3><p>ST轨迹（纵向偏移）<br>SL轨迹（横向偏移）<br><img src="https://i.loli.net/2020/05/29/983YTOsjMDvukLy.png" alt="ST_SL">  </p>
<h3 id="ST轨迹的3组状态："><a href="#ST轨迹的3组状态：" class="headerlink" title="ST轨迹的3组状态："></a>ST轨迹的3组状态：</h3><ul>
<li>巡航(Cruising)：定速行驶</li>
<li>跟随(Following)</li>
<li>停止(Stoping)</li>
</ul>
<h3 id="SL轨迹的状态："><a href="#SL轨迹的状态：" class="headerlink" title="SL轨迹的状态："></a>SL轨迹的状态：</h3><ul>
<li>SL曲线一阶二阶导数都应该为零</li>
</ul>
<h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><ul>
<li>比例积分微分控制PID<ul>
<li><img src="https://i.loli.net/2020/05/29/c9vpyuYgtlOG4Lk.png">  </li>
<li>P——proportional</li>
<li>I——integral</li>
<li>D——derivative</li>
</ul>
</li>
<li>线性二次调节器LQR<ul>
<li>Apollo用来横向控制</li>
<li><img src="https://i.loli.net/2020/05/29/c15SuOisv3IHQfh.png">  </li>
<li><img src="https://i.loli.net/2020/05/29/9Sh64Qzj57Wekvt.png">  </li>
<li><img src="https://i.loli.net/2020/05/29/BUAse7goTrk34wc.png"></li>
</ul>
</li>
<li>模型预测控制MPC（精确，但是慢、难实现）<ol>
<li>建立车辆模型<ul>
<li>车辆物理运动模型</li>
<li>预测</li>
</ul>
</li>
<li>使用优化引擎计算有限时间范围内的控制输入</li>
<li>执行第一组控制输入</li>
</ol>
</li>
</ul>
<h1 id="Apollo进阶课程"><a href="#Apollo进阶课程" class="headerlink" title="Apollo进阶课程"></a><a href="https://apollo.auto/devcenter/coursetable_cn.html?target=2">Apollo进阶课程</a></h1><h2 id="定位-1"><a href="#定位-1" class="headerlink" title="定位"></a>定位</h2><ul>
<li>GNSS</li>
<li>激光点云</li>
<li>视觉</li>
<li>捷连惯性导航及组合导航</li>
</ul>
<p>GNSS需要4个卫星的信号才能定位：因为GPS接收器（比如手机）的时间是不准的，所以把t看作未知数。或者说需要加多一颗来减小误差。</p>
<h3 id="常用坐标系"><a href="#常用坐标系" class="headerlink" title="常用坐标系"></a>常用坐标系</h3><ul>
<li>地心惯性坐标系（ECI）i系：地心为原点，Z轴指向北极，XY轴位于赤道平面，分别指向两颗恒星。IMU使用这个坐标系</li>
<li>地心地固坐标系（ECEF）e系：地心为原点，Z轴指向北极，X轴位于赤道平面和格林威治子午面的交线上，Y轴在赤道平面，满足右手法则。</li>
<li>当地水平坐标系（n系）：东-北-天(E-N-U)和北-东-地(N-E-D)。导航坐标系</li>
<li>通用横轴墨卡托投影(UTM投影)</li>
<li>车体坐标系</li>
<li>相机坐标系</li>
<li>激光雷达坐标系</li>
</ul>
<h3 id="载波定位：RTK、PPP"><a href="#载波定位：RTK、PPP" class="headerlink" title="载波定位：RTK、PPP"></a>载波定位：RTK、PPP</h3><p><img src="https://i.loli.net/2020/05/29/3InHB1tAyQegoiv.png"></p>
<h3 id="点云的定位"><a href="#点云的定位" class="headerlink" title="点云的定位"></a>点云的定位</h3><ul>
<li>基于Histogram Filter的激光点云定位<ul>
<li>SSD(Sum of Squared Difference)</li>
</ul>
</li>
</ul>
<h3 id="视觉定位技术"><a href="#视觉定位技术" class="headerlink" title="视觉定位技术"></a>视觉定位技术</h3><ul>
<li>算法流程<ul>
<li><img src="https://i.loli.net/2020/05/29/8YR5Dxpe9lizWHP.png"></li>
</ul>
</li>
<li>特征匹配<ul>
<li>粒子滤波</li>
</ul>
</li>
</ul>
<h3 id="捷联惯性导航系统："><a href="#捷联惯性导航系统：" class="headerlink" title="捷联惯性导航系统："></a>捷联惯性导航系统：</h3><ul>
<li>初始对准</li>
<li>惯导解算<ul>
<li><img src="https://i.loli.net/2020/05/29/R8o1svtFTbLiKAG.png"></li>
</ul>
</li>
</ul>
<h3 id="组合导航："><a href="#组合导航：" class="headerlink" title="组合导航："></a>组合导航：</h3><ul>
<li><img src="https://i.loli.net/2020/05/29/xH8elwav6W9oizd.png"></li>
</ul>
<h3 id="高精度地图-1"><a href="#高精度地图-1" class="headerlink" title="高精度地图"></a>高精度地图</h3><p>主流通用格式规范：</p>
<ul>
<li>NDS(Navigation Data Standard)</li>
<li>OpenDrive</li>
<li>OMP<br>公司：</li>
<li>HERE</li>
<li>MobilEye</li>
<li>Google Waymo</li>
<li>TomTom<br>地图制作流程：</li>
<li>数据采集</li>
<li>数据处理<ul>
<li>点云拼接</li>
<li>底图产生</li>
</ul>
</li>
<li>元素识别<ul>
<li>基于深度学习的识别</li>
<li>基于深度学习的点云分类</li>
</ul>
</li>
<li>人工验证<ul>
<li>车道线、路沿</li>
<li>信号灯、标志牌</li>
<li>虚拟道路、逻辑关系</li>
</ul>
</li>
</ul>
<h2 id="感知-1"><a href="#感知-1" class="headerlink" title="感知"></a>感知</h2><p><img src="https://i.loli.net/2020/05/29/evTVtO2wZDBk6sA.png" alt="感知技术模块"><br><img src="https://i.loli.net/2020/05/29/Kfng4Jab5N1x3Th.png" alt="传感器对比"></p>
<h3 id="传感器标定算法"><a href="#传感器标定算法" class="headerlink" title="传感器标定算法"></a>传感器标定算法</h3><p><img src="https://i.loli.net/2020/05/29/3gGdxrCHf6Mwk7a.png" alt="传感器标定算法"></p>
<h3 id="感知算法"><a href="#感知算法" class="headerlink" title="感知算法"></a>感知算法</h3><ul>
<li>Lidar感知（检测）<ul>
<li>启发式方法：Ncut</li>
<li>DL方法：CNNSeg</li>
</ul>
</li>
<li>视觉<ul>
<li>DL检测和分割</li>
<li>跟踪，2d-to-3d，多相机融合</li>
<li>红绿灯（感知与地图交互）<img src="https://i.loli.net/2020/05/29/RsJbuftcgOIMm2n.png"></li>
</ul>
</li>
<li>Radar感知（检测）</li>
<li>Ultrasonic感知（检测）</li>
</ul>
<h2 id="规划-1"><a href="#规划-1" class="headerlink" title="规划"></a>规划</h2><h3 id="运动规划方法"><a href="#运动规划方法" class="headerlink" title="运动规划方法"></a>运动规划方法</h3><ul>
<li>环境建模<ul>
<li>RRT</li>
<li>Lattice</li>
</ul>
</li>
<li>自动驾驶的现代方法<ul>
<li>Darpa Challenge Approaches</li>
<li>Lattice in Frenet Frame</li>
<li>Spiral, Polynomial and Splines</li>
<li>Functional Optimization</li>
</ul>
</li>
<li>路径限制类型<ul>
<li>Local Constraint，例如避免和障碍物碰撞</li>
<li>Differential Constraint，比如边界曲率</li>
<li>Global Constraint，比如最短路径</li>
</ul>
</li>
<li>自动驾驶中传统的轨迹生成方法：<ul>
<li>Configuration Space</li>
<li>Lattice approach</li>
<li>RRT based approach</li>
</ul>
</li>
<li>改进和现在的方法<ul>
<li>Lattice in Frenet Frame</li>
<li>Splines</li>
<li>Functional Optimization</li>
</ul>
</li>
</ul>
<h2 id="控制-1"><a href="#控制-1" class="headerlink" title="控制"></a>控制</h2><h3 id="自动驾驶系统是否满足性能要求可以从三个角度去评测"><a href="#自动驾驶系统是否满足性能要求可以从三个角度去评测" class="headerlink" title="自动驾驶系统是否满足性能要求可以从三个角度去评测"></a>自动驾驶系统是否满足性能要求可以从三个角度去评测</h3><ul>
<li>时域</li>
<li>频域</li>
<li>discrete domain（离散域）</li>
</ul>
<h3 id="PID控制：PID控制的基础是比例控制；积分控制可消除稳态误差，但可能增加超调；微分控制可加快大惯性系统响应速度以及减弱超调趋势。"><a href="#PID控制：PID控制的基础是比例控制；积分控制可消除稳态误差，但可能增加超调；微分控制可加快大惯性系统响应速度以及减弱超调趋势。" class="headerlink" title="PID控制：PID控制的基础是比例控制；积分控制可消除稳态误差，但可能增加超调；微分控制可加快大惯性系统响应速度以及减弱超调趋势。"></a>PID控制：PID控制的基础是比例控制；积分控制可消除稳态误差，但可能增加超调；微分控制可加快大惯性系统响应速度以及减弱超调趋势。</h3><ul>
<li>比例单元P</li>
<li>积分单元I</li>
<li>微分单元D</li>
</ul>
<h3 id="控制器的类型："><a href="#控制器的类型：" class="headerlink" title="控制器的类型："></a>控制器的类型：</h3><ul>
<li>开环控制</li>
<li>前馈环控制<ul>
<li>Optimal Control（优化控制）<ul>
<li><img src="https://i.loli.net/2020/05/29/GCQowiTvbJ9MZN4.png" alt="优化控制"></li>
</ul>
</li>
<li>Adaptive Control（自适应控制）</li>
<li>Robust Control（鲁棒性控制）<ul>
<li>LQR&#x2F;LTR控制器</li>
</ul>
</li>
</ul>
</li>
<li>后馈环控制</li>
</ul>
<h1 id="传感器融合"><a href="#传感器融合" class="headerlink" title="传感器融合"></a>传感器融合</h1><h2 id="计算机视觉、激光雷达、毫米波雷达的比较"><a href="#计算机视觉、激光雷达、毫米波雷达的比较" class="headerlink" title="计算机视觉、激光雷达、毫米波雷达的比较"></a>计算机视觉、激光雷达、毫米波雷达的比较</h2><p><img src="https://i.loli.net/2020/05/29/yHuUCpiabecJZrS.png" alt="计算机视觉、激光雷达、毫米波雷达的比较"></p>
<h2 id="多传感器信息融合总结"><a href="#多传感器信息融合总结" class="headerlink" title="多传感器信息融合总结"></a><a href="https://zhuanlan.zhihu.com/p/96881390">多传感器信息融合总结</a></h2>]]></content>
      <categories>
        <category>robot</category>
      </categories>
      <tags>
        <tag>autonomous driving</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx搭建基于Hexo的Blog</title>
    <url>/2019/08/02/blogBuild/</url>
    <content><![CDATA[<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><ol>
<li>框架有三种选择：(Jekyll、<a href="https://hexo.io/zh-cn/docs/">Hexo</a>、WordPress)</li>
</ol>
<ul>
<li><a href="https://hexo.io/themes/">Hexo主题</a></li>
<li><a href="http://theme-next.iissnan.com/">NexT主题</a></li>
</ul>
<ol start="2">
<li>Nginx是一款轻量级的Web 服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器，简单来说就是你输入ip&#x2F;域名时帮你打开网页文件的。</li>
</ol>
<span id="more"></span>

<h1 id="二、本地环境"><a href="#二、本地环境" class="headerlink" title="二、本地环境"></a>二、本地环境</h1><p>MacOS 、Linux 、Window安装过程不同，具体请看Hexo官网教程。本篇以MacOS为例。</p>
<h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1. 安装Git"></a>1. 安装Git</h2><h3 id="1-MacOS"><a href="#1-MacOS" class="headerlink" title="1) MacOS:"></a>1) MacOS:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure>

<h3 id="2-Linux"><a href="#2-Linux" class="headerlink" title="2) Linux"></a>2) Linux</h3><ul>
<li>Ubuntu,Debian: <code>sudo apt-get install git-core</code></li>
<li>CentOS: <code>sudo yum install git-core</code></li>
<li>验证是否安装成功：<code>git --version</code></li>
</ul>
<h2 id="2-安装NodeJs"><a href="#2-安装NodeJs" class="headerlink" title="2. 安装NodeJs"></a>2. 安装NodeJs</h2><p>NodeJS官网有提供安装包：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a> 下载安装即可<br>验证是否安装成功：<code>node --version</code><br>如果出现版本信息即安装成功</p>
<h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3. 安装Hexo"></a>3. 安装Hexo</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1) 安装"></a>1) 安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>有的是用<code>npm install -g hexo</code></p>
<p>他们的不同之处请看<a href="https://one-more-tech.gitlab.io/Hexo-%E4%B8%8E-Hexo-cli-%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%81%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/index/">Hexo 与 Hexo-cli 的关系、入门教程</a></p>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2) 使用"></a>2) 使用</h3><p>本地创建一个文件夹存放Hexo的博客源码，cd进该文件夹后输入: <code>hexo init </code>ProjectName（这里的ProjectName就是你的项目文件名称，如 <code>hexo init </code>blog）。完成后源文件夹会出现如下目录结构：</p>
<p><img src="https://b2.bmp.ovh/imgs/2019/08/6b7b2fef7377b680.png" alt="目录"></p>
<p>cd 进该文件夹(如blog)后输入<code>hexo s -debug</code>或者<code>hexo server</code> 就能启动项目了。如果启动成功会出现以下提示：<br><img src="https://b2.bmp.ovh/imgs/2019/08/6d84089d158f5b9b.png"></p>
<p>在浏览器输入<code>localhost:4000</code> 就能访问项目了。</p>
<p>初始使用是Hexo的默认主题，我们也可以使下载NexT的主题配置，将下载后的next文件夹直接丢到themes文件夹中即可，具体使用方法请查看<a href="http://theme-next.iissnan.com/">NexT官网</a>。或者下载<a href="https://hexo.io/themes/">其他hexo主题</a></p>
<h1 id="三、服务器"><a href="#三、服务器" class="headerlink" title="三、服务器"></a>三、服务器</h1><p><em>ps:如果使用github.io，只需以 github用户名.github.io 为名建立一个仓库就行了，之后可以用 github用户名.github.io 访问博客</em></p>
<p>服务器，域名，备案等自行查看参考文章。</p>
<h2 id="1-SSH连接远程服务器"><a href="#1-SSH连接远程服务器" class="headerlink" title="1. SSH连接远程服务器"></a>1. SSH连接远程服务器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh USERNAME@IP</span><br></pre></td></tr></table></figure>
<p>USERNAME为服务器用户名，一般阿里的的服务器初始用户名为root，IP为你的公网IP地址，如：<code>ssh root@111.111.111.111</code></p>
<h2 id="2-配置SSH公钥"><a href="#2-配置SSH公钥" class="headerlink" title="2. 配置SSH公钥"></a>2. 配置SSH公钥</h2><h3 id="1-生成公钥"><a href="#1-生成公钥" class="headerlink" title="1) 生成公钥"></a>1) 生成公钥</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<p>键入这个命令后，会提示让你给这个公钥配置密码（passphrase），我们既然是为了避免多次输入密码， 这里为什么还要给公钥配置密码呢，所以我们要一路回车，不理他（会出现三次）</p>
<h3 id="2-将本地公钥拷贝到服务器"><a href="#2-将本地公钥拷贝到服务器" class="headerlink" title="2) 将本地公钥拷贝到服务器"></a>2) 将本地公钥拷贝到服务器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-copy-id USERNAME@IP</span><br></pre></td></tr></table></figure>
<p>如果之前已经生成过的，用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i sshPATH USERNAME@IP</span><br></pre></td></tr></table></figure>
<p>如:<code>ssh-copy-id -i .ssh/id_rsa.pub root@111.111.111</code></p>
<p>id_rsa是私钥，id_rsa.pub是公钥，要传到服务器的是公钥.pub（参考三、1）</p>
<h3 id="3-只需要在步骤最后输入一次服务器密码，以后再连接SSH就不需要输入密码了"><a href="#3-只需要在步骤最后输入一次服务器密码，以后再连接SSH就不需要输入密码了" class="headerlink" title="3) 只需要在步骤最后输入一次服务器密码，以后再连接SSH就不需要输入密码了"></a>3) 只需要在步骤最后输入一次服务器密码，以后再连接SSH就不需要输入密码了</h3><h2 id="3-安装Git"><a href="#3-安装Git" class="headerlink" title="3. 安装Git"></a>3. 安装Git</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git-core</span><br></pre></td></tr></table></figure>

<h2 id="4-安装Nginx"><a href="#4-安装Nginx" class="headerlink" title="4. 安装Nginx"></a>4. 安装Nginx</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure>
<p>启动nginx：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service nginx start</span><br></pre></td></tr></table></figure>
<p>然后你在浏览器中输入自己的公网IP，可以看到如下就证明nginx安装成功：<br><img src="https://b2.bmp.ovh/imgs/2019/08/44d040e51ec0ae1e.png"></p>
<h2 id="5-创建一个网站的根目录（用于存放网站的部署的静态文件）"><a href="#5-创建一个网站的根目录（用于存放网站的部署的静态文件）" class="headerlink" title="5. 创建一个网站的根目录（用于存放网站的部署的静态文件）"></a>5. 创建一个网站的根目录（用于存放网站的部署的静态文件）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /var/www/blog</span><br></pre></td></tr></table></figure>
<h2 id="6-nginx的配置"><a href="#6-nginx的配置" class="headerlink" title="6. nginx的配置"></a>6. nginx的配置</h2><p>我的Nginx版本是1.10.3，一般nginx配置文件夹是在&#x2F;etc&#x2F;nginx&#x2F;下的，如果是其他版本的，先搞清楚自己的配置文件夹在哪里的，有的是在&#x2F;usr&#x2F;下。</p>
<h3 id="目前找到三种配置的办法"><a href="#目前找到三种配置的办法" class="headerlink" title="目前找到三种配置的办法"></a>目前找到三种配置的办法</h3><h4 id="1-网上大部分教程都是在-x2F-etc-x2F-nginx-x2F-conf-d-这个文件夹下-vim-FILENAME-conf-d-来创建一个配置文件，在里面写入"><a href="#1-网上大部分教程都是在-x2F-etc-x2F-nginx-x2F-conf-d-这个文件夹下-vim-FILENAME-conf-d-来创建一个配置文件，在里面写入" class="headerlink" title="1) 网上大部分教程都是在 &#x2F;etc&#x2F;nginx&#x2F;conf.d 这个文件夹下 vim FILENAME.conf.d 来创建一个配置文件，在里面写入"></a>1) 网上大部分教程都是在 &#x2F;etc&#x2F;nginx&#x2F;conf.d 这个文件夹下 vim FILENAME.conf.d 来创建一个配置文件，在里面写入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80;//端口号</span><br><span class="line">    server_name _;//域名</span><br><span class="line">    root /var/www/blog;/*网站根目录，出于权限问题考虑，建议把网站配置在www文件目录下*/</span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.htm index.html</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我试了很多次都没有成功，不太清楚conf.d目录下的配置怎么载入的。</p>
<h4 id="2-修改总配置文件"><a href="#2-修改总配置文件" class="headerlink" title="2) 修改总配置文件"></a>2) 修改总配置文件</h4><p>首先备份一下nginx.conf ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/nginx</span><br><span class="line">cp nginx.conf nginx.conf.bak</span><br></pre></td></tr></table></figure>
<p>然后vim修改  &#x2F;etc&#x2F;nginx&#x2F;nginx.conf ，把server模块里的端口号(listen)、域名(server_name)、根目录(root)改为和1）相同。<br>因为nginx.conf是总配置文件，某个小错误可能会导致网站打不开，所以更推荐第三种。</p>
<h4 id="3-修改-x2F-etc-x2F-nginx-x2F-sites-available-x2F-default"><a href="#3-修改-x2F-etc-x2F-nginx-x2F-sites-available-x2F-default" class="headerlink" title="3) 修改 &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default"></a>3) 修改 &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default</h4><p>vim &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default<br>同上，把server把server模块里root后面改为你的网页根目录。本例是改为root &#x2F;var&#x2F;www&#x2F;blog;<br>注：如果需要配置多个虚拟主机，需要用<code>ln -sf /etc/nginx/sites-available/* /etc/nginx/sites-enabled</code>创建软连接，具体请查看参考</p>
<h4 id="然后重启Nginx"><a href="#然后重启Nginx" class="headerlink" title="然后重启Nginx"></a>然后重启Nginx</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>

<h2 id="7-Git的建仓与配置"><a href="#7-Git的建仓与配置" class="headerlink" title="7. Git的建仓与配置"></a>7. Git的建仓与配置</h2><p>建仓：<br>第1）步和第2）步有两种方法</p>
<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><h4 id="1-创建一个文件夹存作为git仓库"><a href="#1-创建一个文件夹存作为git仓库" class="headerlink" title="1) 创建一个文件夹存作为git仓库"></a>1) 创建一个文件夹存作为git仓库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir PATH/FILENAME</span><br></pre></td></tr></table></figure>
<p>如：<code>mkdir ~/blog.git</code><br>然后 <code>cd ~/blog.git</code></p>
<h4 id="2-建仓"><a href="#2-建仓" class="headerlink" title="2) 建仓"></a>2) 建仓</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init --bare</span><br></pre></td></tr></table></figure>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><h4 id="1）"><a href="#1）" class="headerlink" title="1）"></a>1）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure>
<h4 id="2）"><a href="#2）" class="headerlink" title="2）"></a>2）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init --bare FILENAME    </span><br></pre></td></tr></table></figure>
<p>如：<code>git init --bare blog.git</code></p>
<h3 id="3）如果新建了用户，或者不是root（管理员）账号，还需要修改仓库的权限："><a href="#3）如果新建了用户，或者不是root（管理员）账号，还需要修改仓库的权限：" class="headerlink" title="3）如果新建了用户，或者不是root（管理员）账号，还需要修改仓库的权限："></a>3）如果新建了用户，或者不是root（管理员）账号，还需要修改仓库的权限：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -R USERNAME:GROUP FILENAME</span><br></pre></td></tr></table></figure>
<p>比如新建了一个用户git来建站，则 <code>chown -R git:git ~/blog.git</code><br>本例没有这一步，就略过修改权限<br>配置hooks：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/blog.git</span><br><span class="line">vim post-receive</span><br></pre></td></tr></table></figure>
<p>在post-receive中写入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">rm -rf /var/www/blog</span><br><span class="line">git clone /root/blog.git /var/www/blog</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">git --work-tree=/var/www/blog --git-dir=/root/blog.git checkout -f</span><br></pre></td></tr></table></figure>
<p>赋予这个文件夹权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x ~/blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<h1 id="四、本地Hexo配置"><a href="#四、本地Hexo配置" class="headerlink" title="四、本地Hexo配置"></a>四、本地Hexo配置</h1><p>回到本地的机器上，进入你的hexo文件夹（就是你完成hexo init的那个）<br>找到_config.yml, 修改里面的deploy：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: USERNAME@IP:GitPath //如：root@111.111.111.111:/root/blog.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p><em>注：USERNAME指的是你的服务器用户名，本例是root</em><br>     <em>IP是指你服务器的公网IP</em><br>     <em>GitPath是服务器上的Git仓库路上，按上面的流程应该是：&#x2F;root&#x2F;blog.git</em></p>
<p><em>如果使用的是github.io，那么整个repo就改为你的github仓库地址，如：<a href="https://xxx.github.io/">https://xxx.github.io</a></em></p>
<h1 id="五、发布项目"><a href="#五、发布项目" class="headerlink" title="五、发布项目"></a>五、发布项目</h1><h2 id="1-cd进你的hexo根目录（就是你完成hexo-init的那个）"><a href="#1-cd进你的hexo根目录（就是你完成hexo-init的那个）" class="headerlink" title="1.cd进你的hexo根目录（就是你完成hexo init的那个）"></a>1.cd进你的hexo根目录（就是你完成hexo init的那个）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>或者<code>hexo g -d</code>  </p>
<p>如果显示not fount git，是因为我们没有在这个项目中安装git插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git —save</span><br></pre></td></tr></table></figure>
<p>安装完后再来一遍 <code>hexo g -d</code></p>
<p>然后会让你输入你公网IP对应服务器的密码，输入完成后会生成一堆静态文件，并部署到远程服务器上</p>
<p>如果上述一切都操作成功，你就可以在浏览器输入IP或域名查看你的项目了</p>
<h1 id="Hexo基本命令"><a href="#Hexo基本命令" class="headerlink" title="Hexo基本命令"></a>Hexo基本命令</h1><h2 id="1-新建文章"><a href="#1-新建文章" class="headerlink" title="1.新建文章"></a>1.新建文章</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;文章名&quot;</span><br></pre></td></tr></table></figure>

<h2 id="2-刷新-目的是删除原来的public文件夹，避免污染"><a href="#2-刷新-目的是删除原来的public文件夹，避免污染" class="headerlink" title="2.刷新(目的是删除原来的public文件夹，避免污染)"></a>2.刷新(目的是删除原来的public文件夹，避免污染)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<h2 id="3-生成-amp-amp-部署"><a href="#3-生成-amp-amp-部署" class="headerlink" title="3.生成&amp;&amp;部署"></a>3.生成&amp;&amp;部署</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><ul>
<li><a href="https://www.jianshu.com/p/f4658df66a15">Hexo博客使用valine评论系统无效果及终极解决方案</a></li>
<li><a href="https://tding.top/tags/NexT/">NexT主题配置相关博客</a></li>
</ul>
<h2 id="还不错的主题"><a href="#还不错的主题" class="headerlink" title="还不错的主题"></a>还不错的主题</h2><ul>
<li><a href="https://github.com/Molunerfinn/hexo-theme-melody">melody</a></li>
</ul>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><a href="https://tycoding.cn/2018/04/27/other/%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EHexo%E7%9A%84Blog/">搭建步骤</a></li>
<li><a href="http://blog.clannadbred.com/2017/10/28/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CNginx%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/">搭建步骤</a></li>
<li><a href="https://www.jianshu.com/p/43889e748b89">搭建步骤</a></li>
<li><a href="https://www.jianshu.com/p/e03e363713f9">很多个性化主题教程链接</a></li>
<li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/">hexo的安装和使用</a></li>
<li><a href="https://hackwork.org/handbook/website/56/">服务器，域名</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">ssh</a></li>
<li><a href="https://segmentfault.com/a/1190000014027697">Nginx安装</a></li>
<li><a href="https://www.jianshu.com/p/849343f679aa">Nginx配置</a></li>
<li><a href="https://www.jianshu.com/p/fd25a9c008a0">Nginx目录说明</a></li>
<li><a href="https://www.jianshu.com/p/efab29b6c3b0">Nginx多个虚拟主机</a></li>
</ul>
<h1 id="ps"><a href="#ps" class="headerlink" title="ps:"></a>ps:</h1><p>如果想在首页不显示某篇文章，只在分类中显示，可以修改 <code>themes/next/layout/index.swig</code> 文件，把</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">  &lt;section id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt;</span><br><span class="line">    &#123;%- for post in page.posts %&#125;</span><br><span class="line">      &#123;&#123; partial(&#x27;_macro/post.swig&#x27;, &#123;is_index: true&#125;) &#125;&#125;</span><br><span class="line">    &#123;%- endfor %&#125;</span><br><span class="line">  &lt;/section&gt;</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">  &lt;section id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt;</span><br><span class="line">    &#123;%- for post in page.posts %&#125;</span><br><span class="line">      &#123;%- if post.hide != true %&#125;</span><br><span class="line">        &#123;&#123; partial(&#x27;_macro/post.swig&#x27;, &#123;is_index: true&#125;) &#125;&#125;</span><br><span class="line">      &#123;%- endif %&#125;</span><br><span class="line">    &#123;%- endfor %&#125;</span><br><span class="line">  &lt;/section&gt;</span><br></pre></td></tr></table></figure>
<p>然后在要隐藏文章的md文件的front-matter中加上<code>hide: true</code></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2020/06/20/dataStructure/</url>
    <content><![CDATA[<h1 id="链表和数组的区别在哪里？"><a href="#链表和数组的区别在哪里？" class="headerlink" title="链表和数组的区别在哪里？"></a>链表和数组的区别在哪里？</h1><p>链表和数组都可以叫线性表，数组又叫顺序表，主要区别在于：</p>
<ul>
<li>存储形式：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间，长度可变，每个结点要保存相邻结点指针。</li>
<li>数据查找：数组的线性查找速度快，查找操作直接使用偏移地址。链表需要按顺序检索结点，效率低。</li>
<li>数据插入或删除：链表可以快速插入和删除结点，而数组则可能需要大量数据移动。</li>
<li>越界问题：链表不存在越界问题，数组有越界问题。</li>
</ul>
<p><em>说明：在选择数组或链表数据结构时，一定要根据实际需要进行选择。数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。</em></p>
<h1 id="hash冲突怎么办"><a href="#hash冲突怎么办" class="headerlink" title="hash冲突怎么办"></a>hash冲突怎么办</h1><ol>
<li>开放地址法<ul>
<li>线性探测</li>
<li>二次探测：左右左右…</li>
<li>伪随机数</li>
</ul>
</li>
<li>再哈希法</li>
<li>链地址法</li>
<li>建立公共溢出区</li>
</ol>
<h1 id="HashMap扩容机制"><a href="#HashMap扩容机制" class="headerlink" title="HashMap扩容机制"></a>HashMap扩容机制</h1><p>HashMap的容量是有限的。当经过多次元素插入的时候，使得HashMap达到一定的饱和度，Key映射位置的几率不断变大。这个时候（扩容因子&#x3D;0.75），HashMap就需要扩容了，也就是Resize。一般是增加1倍。</p>
<p><em>扩容因子：数组中元素的个数&#x2F;数组容量</em></p>
<h1 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h1><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树是一颗多路平衡查找树。</p>
<ul>
<li>每个节点最多有m-1个关键字（可以存有的键值对）。</li>
<li>根节点最少可以只有1个关键字。</li>
<li>非根节点至少有m&#x2F;2个关键字。</li>
<li>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li>
<li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。</li>
<li>每个节点都存有索引和数据，也就是对应的key和value。</li>
</ul>
<p>所以，根节点的关键字数量范围：1 &lt;&#x3D; k &lt;&#x3D; m-1，非根节点的关键字数量范围：m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m-1。</p>
<p>另外，我们需要注意一个概念，描述一颗B树时需要指定它的阶数，阶数表示了一个节点最多有多少个孩子节点，一般用字母m表示阶数。</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树其实和B树是非常相似的。</p>
<p>相同点：</p>
<ul>
<li>根节点至少一个元素</li>
<li>非根节点元素范围：m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m-1</li>
</ul>
<p>不同点：</p>
<ul>
<li>B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。</li>
<li>内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。</li>
<li>每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>父节点存有右孩子的第一个元素的索引。</li>
</ul>
<h2 id="B-树相对于B树的优势"><a href="#B-树相对于B树的优势" class="headerlink" title="B+树相对于B树的优势"></a>B+树相对于B树的优势</h2><p>可以归结为下面几点：</p>
<ul>
<li>单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。</li>
<li>所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。</li>
<li>所有的叶子节点形成了一个有序链表，更加便于查找。</li>
<li>叶子结点连起来还可以范围查询。</li>
</ul>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p><strong>平衡二叉树</strong>就是为了解决<strong>二叉查找树</strong>退化成一颗链表而诞生。</p>
<p>虽然<strong>平衡树</strong>解决了<strong>二叉查找树</strong>退化为近似链表的缺点，能够把查找时间控制在 O(logn)，不过却不是最佳的，因为平衡树要求每个节点的左子树和右子树的高度差至多等于1，这个要求实在是太严了，导致每次进行插入&#x2F;删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的<strong>平衡树</strong>。</p>
<p>显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了<strong>红黑树</strong>，<strong>红黑树</strong>具有如下特点：</p>
<ol>
<li>具有二叉查找树的特点；</li>
<li>根节点是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据；</li>
<li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的(但是黑色节点可以相连)；</li>
<li>每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。</li>
</ol>
<h2 id="红黑树和AVL树的区别："><a href="#红黑树和AVL树的区别：" class="headerlink" title="红黑树和AVL树的区别："></a>红黑树和AVL树的区别：</h2><p>AVL 和 RBT 都是二叉查找树的优化。其性能要远远好于二叉查找树。他们之间都有自己的优势，其应用上也有不同。</p>
<ul>
<li>结构对比：AVL的结构高度平衡，RBT的结构基本平衡。平衡度AVL &gt; RBT.</li>
<li>查找对比：AVL 查找时间复杂度最好，最坏情况都是O(logN)。RBT 查找时间复杂度最好为O(logN)，最坏情况下比AVL略差。</li>
<li>插入删除对比：<ol>
<li>AVL的插入和删除结点很容易造成树结构的不平衡，而RBT的平衡度要求较低。因此在大量数据插入的情况下，RBT需要通过旋转变色操作来重新达到平衡的频度要小于AVL。</li>
<li>如果需要平衡处理时，RBT比AVL多一种变色操作，而且变色的时间复杂度在O(logN)数量级上。但是由于操作简单，所以在实践中这种变色仍然是非常快速的。</li>
<li>当插入一个结点都引起了树的不平衡，AVL和RBT都最多需要2次旋转操作。但删除一个结点引起不平衡后，AVL最多需要logN 次旋转操作，而RBT最多只需要3次。因此两者插入一个结点的代价差不多，但删除一个结点的代价RBT要低一些。</li>
<li>AVL和RBT的插入删除代价主要还是消耗在查找待操作的结点上。因此时间复杂度基本上都是与O(logN) 成正比的。</li>
</ol>
</li>
</ul>
<h1 id="3老鼠确定8瓶子原理"><a href="#3老鼠确定8瓶子原理" class="headerlink" title="3老鼠确定8瓶子原理"></a>3老鼠确定8瓶子原理</h1><ol>
<li>二分法：每次取一半混合给小鼠喝。但是瓶子太多就不好混合了。</li>
<li>二进制：每只老鼠代表一位，n只老鼠可以检测2^n个瓶子。</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/2020/06/20/database/</url>
    <content><![CDATA[<h1 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h1><ul>
<li><p>1NF(第一范式)<br>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。1NF是所有关系型数据库的最基本要求 ，也就是说关系型数据库中创建的表一定满足第一范式。</p>
</li>
<li><p>2NF(第二范式)<br>2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p>
</li>
<li><p>3NF(第三范式)<br>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖 。符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系R(学号 ,姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合3NF的要求。</p>
</li>
<li><p>总结</p>
<ul>
<li>1NF：属性不可再分。</li>
<li>2NF：1NF的基础之上，消除了非主属性对于码的部分函数依赖。</li>
<li>3NF：3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖 。</li>
</ul>
</li>
</ul>
<p>ref.</p>
<ul>
<li><a href="https://blog.csdn.net/Wenco1/article/details/88077279?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase">详解第一范式、第二范式、第三范式、BCNF范式</a></li>
<li><a href="https://blog.csdn.net/wyh7280/article/details/83350722?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.nonecase">范式通俗理解：1NF、2NF、3NF和BNCF</a></li>
</ul>
<h1 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h1><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p>关系型数据库，是指采用了<strong>关系模型</strong>来组织数据的数据库。</p>
<p>主要代表：SQL Server, Oracle, Mysql, PostgreSQL</p>
<p>关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。关系模型中常用的概念：</p>
<ul>
<li>关系：可以理解为一张二维表，每个关系都具有一个关系名，就是通常说的表名</li>
<li>元组：可以理解为二维表中的一行，在数据库中经常被称为记录</li>
<li>属性：可以理解为二维表中的一列，在数据库中经常被称为字段</li>
<li>域：属性的取值范围，也就是数据库中某一列的取值限制</li>
<li>关键字：一组可以唯一标识元组的属性，数据库中常称为主键，由一个或多个列组成</li>
<li>关系模式：指对关系的描述。其格式为：关系名(属性1，属性2， … … ，属性N)，在数据库中成为表结构</li>
<li>码：码就是能唯一标识实体的属性，对应表中的列。</li>
<li>候选码： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li>
<li>主码：主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li>
<li>外码：外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li>
<li>主属性：候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）.显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li>
<li>非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li>
</ul>
<p>关系型数据库的优点：</p>
<ul>
<li>容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解</li>
<li>使用方便：通用的SQL语言使得操作关系型数据库非常方便</li>
<li>易于维护：数据库的ACID属性，大大减低了数据冗余和数据不一致的概率</li>
</ul>
<p>关系型数据库的瓶颈：</p>
<ul>
<li>海量数据的读写效率：对于网站的并发量高，往往达到每秒上万次的请求，对于传统关系型数据库来说，硬盘I&#x2F;o是一个很大的挑战。</li>
<li>高扩展性和可用性：在基于web的结构中，数据库是最难以横向拓展的，当一个应用系统的用户量和访问量与日俱增的时候，数据库没有办法像web Server那样简单的通过添加更多的硬件和服务节点来拓展性能和负载能力。</li>
</ul>
<h2 id="主键和外键有什么区别"><a href="#主键和外键有什么区别" class="headerlink" title="主键和外键有什么区别"></a>主键和外键有什么区别</h2><ul>
<li>主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li>
<li>外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li>
</ul>
<h2 id="非关系型数据库-NoSQL"><a href="#非关系型数据库-NoSQL" class="headerlink" title="非关系型数据库 NoSQL"></a>非关系型数据库 NoSQL</h2><p>主要指那些非关系型的、分布式的，且一般不保证ACID的数据存储系统。依据结构化方法以及应用场合的不同，主要分为以下几类：</p>
<ol>
<li>面向高性能并发读写的key-value数据库：key-value数据库的主要特点即使具有极高的并发读写性能，Redis,Tokyo Cabinet,Flare就是这类的代表</li>
<li>面向海量数据访问的面向文档数据库：这类数据库的特点是，可以在海量的数据中快速的查询数据，典型代表为MongoDB以及CouchDB</li>
<li>面向可扩展性的分布式数据库：这类数据库想解决的问题就是传统数据库存在可扩展性上的缺陷，这类数据库可以适应数据量的增加以及数据结构的变化</li>
</ol>
<p>缺点：但是由于Nosql约束少，所以也不能够像sql那样提供where字段属性的查询。因此适合存储较为简单的数据。有一些不能够持久化数据，所以需要和关系型数据库结合。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://blog.csdn.net/oChangWen/article/details/53423301">关系型数据库和非关系型数据库区别、oracle与mysql的区别</a></li>
<li><a href="https://blog.csdn.net/lzj3462144/article/details/70973368?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param">关系型数据库 VS 非关系型数据库</a></li>
</ul>
<h1 id="主键索引和唯一索引区别"><a href="#主键索引和唯一索引区别" class="headerlink" title="主键索引和唯一索引区别"></a>主键索引和唯一索引区别</h1><p>唯一索引的值可以为null吗<br>主键索引的值可以为null吗<br>一个表有几个主键<br>一个表可以有多个唯一索引吗</p>
<h1 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h1><h1 id="数据库事务的4个特征（ACID特性）"><a href="#数据库事务的4个特征（ACID特性）" class="headerlink" title="数据库事务的4个特征（ACID特性）"></a>数据库事务的4个特征（ACID特性）</h1><ul>
<li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>
<li>持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</li>
</ul>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>隔离级别越高，性能越低</p>
<ol>
<li>Serializable（串行化）：可避免脏读、不可重复读、虚读情况的发生；</li>
<li>Reapeatable read（可重复读）：可避免脏读、不可重复读的情况的发生；</li>
<li>Read Committed（读已提交）：可避免脏读的情况</li>
<li>Read uncommitted（读未提交）：最低级别，任何情况均无法保证；</li>
</ol>
<h1 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h1><ul>
<li><a href="https://www.nowcoder.com/discuss/468424?source_id=profile_create&channel=1011">面试题之数据库</a></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>无人机仿真</title>
    <url>/2021/01/19/droneSimulator/</url>
    <content><![CDATA[<h1 id="无人机仿真的几种方法"><a href="#无人机仿真的几种方法" class="headerlink" title="无人机仿真的几种方法"></a>无人机仿真的几种方法</h1><h2 id="在ros环境下无人机的仿真方式有以下几种"><a href="#在ros环境下无人机的仿真方式有以下几种" class="headerlink" title="在ros环境下无人机的仿真方式有以下几种"></a>在ros环境下无人机的仿真方式有以下几种</h2><ul>
<li><a href="https://github.com/tu-darmstadt-ros-pkg/hector_quadrotor">hector_quadrotor</a></li>
<li><a href="https://github.com/ethz-asl/rotors_simulator">rotors_simulator</a></li>
<li><a href="https://www.yuque.com/xtdrone/manual_cn">XTDrone</a>：基于<a href="https://docs.px4.io/master/zh/simulation">PX4</a>的无人机仿真<span id="more"></span></li>
</ul>
<h2 id="本教程环境"><a href="#本教程环境" class="headerlink" title="本教程环境"></a>本教程环境</h2><ul>
<li>系统：ubuntu16.04</li>
<li>ROS版本：kinetic</li>
</ul>
<h1 id="hector-quadrotor"><a href="#hector-quadrotor" class="headerlink" title="hector_quadrotor"></a><a href="https://github.com/tu-darmstadt-ros-pkg/hector_quadrotor">hector_quadrotor</a></h1><p><a href="http://wiki.ros.org/hector_quadrotor">hector_quadrotor wiki</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1-新建工作空间并初始化"><a href="#1-新建工作空间并初始化" class="headerlink" title="1. 新建工作空间并初始化"></a>1. 新建工作空间并初始化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p hector_quadrotor_catkin/src</span><br><span class="line">cd hector_quadrotor_catkin/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure>
<h3 id="2-克隆源代码"><a href="#2-克隆源代码" class="headerlink" title="2. 克隆源代码"></a>2. 克隆源代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/tu-darmstadt-ros-pkg/hector_quadrotor.git</span><br></pre></td></tr></table></figure>
<h3 id="3-初始化wstool，并更新所需库"><a href="#3-初始化wstool，并更新所需库" class="headerlink" title="3. 初始化wstool，并更新所需库"></a>3. 初始化wstool，并更新所需库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wstool init</span><br><span class="line">wstool merge tutorials.rosinstall</span><br><span class="line">wstool update</span><br></pre></td></tr></table></figure>
<h3 id="4-编译"><a href="#4-编译" class="headerlink" title="4. 编译"></a>4. 编译</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/hector_quadrotor_catkin/</span><br><span class="line">catkin build</span><br></pre></td></tr></table></figure>
<h3 id="5-环境变量"><a href="#5-环境变量" class="headerlink" title="5. 环境变量"></a>5. 环境变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ./devel/setup.bash</span><br></pre></td></tr></table></figure>
<p>也可以用下面的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;source ~/hector_quadrotor_catkin/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>编译成功后可以运行demo试一下，hector_quadrotor一共有两个demo，indoor和outdoor.</p>
<h3 id="indoor"><a href="#indoor" class="headerlink" title="indoor"></a>indoor</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">roslaunch hector_quadrotor_demo indoor_slam_gazebo.launch</span><br></pre></td></tr></table></figure>
<h3 id="outdoor"><a href="#outdoor" class="headerlink" title="outdoor"></a>outdoor</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">roslaunch hector_quadrotor_demo outdoor_flight_gazebo.launch</span><br></pre></td></tr></table></figure>

<h2 id="键盘操控"><a href="#键盘操控" class="headerlink" title="键盘操控"></a>键盘操控</h2><p>使用<code>teleop_twist_keyboard package</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ros-kinetic-teleop-twist-keyboard</span><br><span class="line">rosrun teleop_twist_keyboard teleop_twist_keyboard.py</span><br></pre></td></tr></table></figure>
<p><em>ps:需要先按<code>t</code>让飞机先飞起来才能控制</em></p>
<h1 id="rotors-simulator"><a href="#rotors-simulator" class="headerlink" title="rotors_simulator"></a><a href="https://github.com/ethz-asl/rotors_simulator">rotors_simulator</a></h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><h3 id="1-新建工作空间并初始化-1"><a href="#1-新建工作空间并初始化-1" class="headerlink" title="1. 新建工作空间并初始化"></a>1. 新建工作空间并初始化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p rotors_ws/src</span><br><span class="line">cd rotors_ws/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure>
<h3 id="2-克隆源代码-1"><a href="#2-克隆源代码-1" class="headerlink" title="2. 克隆源代码"></a>2. 克隆源代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/ethz-asl/rotors_simulator.git</span><br></pre></td></tr></table></figure>
<h3 id="3-初始化wstool，并更新所需库-1"><a href="#3-初始化wstool，并更新所需库-1" class="headerlink" title="3. 初始化wstool，并更新所需库"></a>3. 初始化wstool，并更新所需库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wstool init</span><br><span class="line">wget https://raw.githubusercontent.com/ethz-asl/rotors_simulator/master/rotors_hil.rosinstall</span><br><span class="line">wstool merge rotors_hil.rosinstall</span><br><span class="line">wstool update</span><br></pre></td></tr></table></figure>
<h3 id="4-编译-1"><a href="#4-编译-1" class="headerlink" title="4. 编译"></a>4. 编译</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/rotors_ws/</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<h3 id="5-环境变量-1"><a href="#5-环境变量-1" class="headerlink" title="5. 环境变量"></a>5. 环境变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ./devel/setup.bash</span><br></pre></td></tr></table></figure>
<p>也可以用下面的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;source ~/rotors_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">roslaunch rotors_gazebo mav_hovering_example.launch mav_name:=firefly world_name:=basic</span><br></pre></td></tr></table></figure>

<h2 id="功能开发"><a href="#功能开发" class="headerlink" title="功能开发"></a>功能开发</h2><p>更多功能的开发请看<a href="https://suzhilong.github.io/2021/01/20/rotorsSimulator/">无人机仿真：rotors_simulator的使用</a></p>
<h1 id="XTDrone"><a href="#XTDrone" class="headerlink" title="XTDrone"></a><a href="https://github.com/robin-shaun/XTDrone">XTDrone</a></h1><p>其实这是基于<a href="https://docs.px4.io/master/zh/simulation">PX4</a>和ROS的无人机仿真平台，不过有很多已经开发好的项目</p>
<h2 id="一、PX4的安装"><a href="#一、PX4的安装" class="headerlink" title="一、PX4的安装"></a>一、PX4的安装</h2><p>安装使用PX4可以直接看<a href="https://www.yuque.com/xtdrone/manual_cn">官方文档</a></p>
<p>也可以照着<a href="https://www.yuque.com/xtdrone/manual_cn/basic_config_1.11">XTDrone</a>的步骤（推荐）</p>
<h3 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install -y ninja-build exiftool python-argparse python-empy python-toml python-numpy python-yaml python-dev python-pip ninja-build protobuf-compiler libeigen3-dev genromfs xmlstarlet libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev</span><br><span class="line"></span><br><span class="line">pip2 install pandas jinja2 pyserial cerberus pyulog numpy toml pyquaternion</span><br><span class="line">pip3 install packaging numpy empy toml pyyaml jinja2</span><br><span class="line"></span><br><span class="line">//gazebo</span><br><span class="line">sudo apt install ros-kinetic-gazebo9-*</span><br></pre></td></tr></table></figure>
<h3 id="2-安装-mavros-以及相关的-geographiclib-dataset"><a href="#2-安装-mavros-以及相关的-geographiclib-dataset" class="headerlink" title="2. 安装 mavros 以及相关的 geographiclib dataset"></a>2. 安装 mavros 以及相关的 geographiclib dataset</h3><p><a href="http://wiki.ros.org/mavros">mavros</a> 是一个飞机固件与ros通信的包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install ros-kinetic-mavros ros-kinetic-mavros-extras</span><br><span class="line">//如果出现443拒绝连接的情况，可能是因为域名污染，在/etc/hosts中加入raw.githubusercontent.com指定ip就行</span><br><span class="line">wget https://raw.githubusercontent.com/mavlink/mavros/master/mavros/scripts/install_geographiclib_datasets.sh</span><br><span class="line">sudo chmod a+x ./install_geographiclib_datasets.sh</span><br><span class="line">sudo ./install_geographiclib_datasets.sh</span><br></pre></td></tr></table></figure>

<h3 id="3-下载编译px4-Firmware"><a href="#3-下载编译px4-Firmware" class="headerlink" title="3. 下载编译px4 Firmware"></a>3. 下载编译px4 Firmware</h3><h4 id="创建工作空间（已经有工作空间的跳过）"><a href="#创建工作空间（已经有工作空间的跳过）" class="headerlink" title="创建工作空间（已经有工作空间的跳过）"></a>创建工作空间（已经有工作空间的跳过）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/px4_ws/src</span><br><span class="line">cd ~/px4_ws/src/</span><br><span class="line">catkin_init_workspace</span><br><span class="line">cd ..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<h4 id="下载编译px4"><a href="#下载编译px4" class="headerlink" title="下载编译px4"></a>下载编译px4</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//一般将固件放在主目录下而不是ros的工作空间中</span><br><span class="line">git clone https://github.com/PX4/PX4-Autopilot.git</span><br><span class="line">mv PX4-Autopilot PX4_Firmware</span><br><span class="line">cd PX4_Firmware</span><br><span class="line">//可以根据需求改变版本号v1.x.x</span><br><span class="line">git checkout v1.11.2</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">//开始编译</span><br><span class="line">make px4_sitl_default gazebo</span><br></pre></td></tr></table></figure>

<h4 id="编译报错"><a href="#编译报错" class="headerlink" title="编译报错"></a>编译报错</h4><p>编译报错时，可能缺少了必要的依赖，可以在编译前：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/PX4_Firmware</span><br><span class="line">bash</span><br><span class="line">//只是进行ros下开发仿真的话，可以把ubuntu.sh里的INSTALL_NUTTX改为’false’，或是加上参数--no-nuttx</span><br><span class="line">bash ./Tools/setup/ubuntu.sh --no-nuttx</span><br></pre></td></tr></table></figure>
<p><strong>注意：ubuntu.sh可能安装失败，请务必重新运行ubuntu.sh脚本，直至成功</strong></p>
<h3 id="4-添加环境变量"><a href="#4-添加环境变量" class="headerlink" title="4. 添加环境变量"></a>4. 添加环境变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//添加工作空间source</span><br><span class="line">echo &quot;source ~/px4_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line">//添加px4路径</span><br><span class="line">echo &quot;source ~/PX4_Firmware/Tools/setup_gazebo.bash\</span><br><span class="line"> ~/PX4_Firmware/\</span><br><span class="line"> ~/PX4_Firmware/build/px4_sitl_default&quot;\</span><br><span class="line"> &gt;&gt; ~/.bashrc</span><br><span class="line">echo &quot;export ROS_PACKAGE_PATH=\$ROS_PACKAGE_PATH:~/PX4_Firmware&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">echo &quot;export ROS_PACKAGE_PATH=\$ROS_PACKAGE_PATH:~/PX4_Firmware/Tools/sitl_gazebo&quot; &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line">//source一下</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<h3 id="5-运行"><a href="#5-运行" class="headerlink" title="5. 运行"></a>5. 运行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/PX4_Firmware</span><br><span class="line">//此命令同时启动了mavros</span><br><span class="line">roslaunch px4 mavros_posix_sitl.launch</span><br></pre></td></tr></table></figure>

<h2 id="二、安装无人机的地面站控制软件QGC"><a href="#二、安装无人机的地面站控制软件QGC" class="headerlink" title="二、安装无人机的地面站控制软件QGC"></a>二、安装无人机的地面站控制软件QGC</h2><p><a href="https://dev.px4.cc/v1.8.2/zh/qgc/">QGroundControl</a> 是一个基于PX4自动驾驶仪配置和飞行的应用程序</p>
<p><a href="https://docs.qgroundcontrol.com/master/en/getting_started/download_and_install.html">官方安装指导教程</a></p>
<h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo usermod -a -G dialout $USER</span><br><span class="line">sudo apt-get remove modemmanager -y</span><br><span class="line">sudo apt install gstreamer1.0-plugins-bad gstreamer1.0-libav gstreamer1.0-gl -y</span><br></pre></td></tr></table></figure>
<h3 id="2-安装QGC"><a href="#2-安装QGC" class="headerlink" title="2. 安装QGC"></a>2. 安装QGC</h3><h4 id="1-下载"><a href="#1-下载" class="headerlink" title="1) 下载"></a>1) 下载</h4><p>前往<a href="https://github.com/mavlink/qgroundcontrol/releases">QCG发布网站</a>下载合适的版本的<code>QGroundControl.AppImage</code></p>
<p><strong>注意：</strong> ubuntu16.04只能使用4.0以前的版本，4.0（含）以后的版本至少需要18.04，<a href="https://docs.qgroundcontrol.com/master/en/getting_started/download_and_install.html">官方安装指导教程</a>中已经说明</p>
<h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2) 安装"></a>2) 安装</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x ./QGroundControl.AppImage</span><br><span class="line">./QGroundControl.AppImage  //或者双击就可以打开QGC</span><br></pre></td></tr></table></figure>
<h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3) 使用"></a>3) 使用</h4><p><code>roslaunch px4 mavros_posix_sitl.launch</code>之后打开QGC会显示<code>飞机已连接</code>，在里面中添加飞行任务，然后<code>上传</code>，再<code>滑动</code>就可以启动飞行任务。</p>
<p><strong>———————-PX4与ROS基础配置完成———————–</strong></p>
<p>各部分间的关系如下图所示：</p>
<p><img src="https://i.loli.net/2021/01/19/puTiaGwZLjW5QqH.png" alt="PX4架构"></p>
<h2 id="三、XTDrone部分"><a href="#三、XTDrone部分" class="headerlink" title="三、XTDrone部分"></a>三、XTDrone部分</h2><p>见<a href="https://www.yuque.com/xtdrone/manual_cn/basic_config_1.11">XTDrone使用文档</a></p>
<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul>
<li><a href="https://blog.csdn.net/wendox/article/details/52337171">玩转四旋翼无人机（仿真）</a></li>
<li><a href="https://blog.csdn.net/phenixlou/article/details/78518207">hector_quadrotor 的编译运行</a></li>
<li><a href="http://www.gkmm.tu-darmstadt.de/publications/files/meyer2012quadrotorsimulation.pdf">hector_quadrotor 的论文：Comprehensive Simulation of Quadrotor UAVs<br>using ROS and Gazebo</a></li>
<li><a href="https://www.guyuehome.com/7598">rotors无人机仿真</a></li>
<li><a href="https://www.guyuehome.com/16351">无人机ROS仿真包 rotors_simulator 编译教程</a></li>
<li><a href="https://www.guyuehome.com/21614">无人机ROS仿真包 rotors_simulator 使用教程</a></li>
<li><a href="https://www.guyuehome.com/7672">PX4无人机ROS下仿真开发</a></li>
<li><a href="https://www.guyuehome.com/7699">ROS下基于YOLO的px4无人机目标检测</a></li>
<li><a href="https://www.guyuehome.com/8983">基于px4的无人机自主导航</a></li>
<li><a href="https://docs.px4.io/master/en/dev_setup/dev_env_linux_ubuntu.html">px4文档</a></li>
<li><a href="https://github.com/robin-shaun/XTDrone">开源无人机项目：XTDrone</a></li>
</ul>
]]></content>
      <categories>
        <category>robot</category>
      </categories>
      <tags>
        <tag>Drone</tag>
      </tags>
  </entry>
  <entry>
    <title>imss</title>
    <url>/2019/08/02/imss/</url>
    <content><![CDATA[<h1 id="标题一级爱你"><a href="#标题一级爱你" class="headerlink" title="标题一级爱你"></a>标题一级爱你</h1><h2 id="标题二级爱你"><a href="#标题二级爱你" class="headerlink" title="标题二级爱你"></a>标题二级爱你</h2><h3 id="标题三级爱你"><a href="#标题三级爱你" class="headerlink" title="标题三级爱你"></a>标题三级爱你</h3><h4 id="标题四级爱你"><a href="#标题四级爱你" class="headerlink" title="标题四级爱你"></a>标题四级爱你</h4><h5 id="标题五级爱你"><a href="#标题五级爱你" class="headerlink" title="标题五级爱你"></a>标题五级爱你</h5><h6 id="标题六级爱你"><a href="#标题六级爱你" class="headerlink" title="标题六级爱你"></a>标题六级爱你</h6><h1 id="标题一级爱你-1"><a href="#标题一级爱你-1" class="headerlink" title="标题一级爱你"></a>标题一级爱你</h1><h2 id="标题二级爱你-1"><a href="#标题二级爱你-1" class="headerlink" title="标题二级爱你"></a>标题二级爱你</h2><p><strong>加粗字体爱你</strong></p>
<p><em>斜体字体爱你</em></p>
<p><em><strong>斜体与加粗爱你</strong></em></p>
<blockquote>
<p>这里添加引用文字爱你</p>
</blockquote>
<blockquote>
<p>带有多个段落的块引用爱你<br>爱你<br>带有多个段落的块引用爱你</p>
</blockquote>
<blockquote>
<p>嵌套引用1.</p>
<blockquote>
<p> 嵌套引用2.</p>
</blockquote>
</blockquote>
<blockquote>
<h4 id="标题四级"><a href="#标题四级" class="headerlink" title="标题四级"></a>标题四级</h4><ul>
<li>段落一</li>
<li>段落二.</li>
</ul>
<p> <em>斜体</em> 与 <strong>加粗</strong>.</p>
</blockquote>
<ul>
<li>条目一</li>
</ul>
<ul>
<li>条目二</li>
</ul>
<ul>
<li>条目三</li>
</ul>
<ul>
<li>条目四<ul>
<li>缩进一 前面4个空格</li>
<li>缩进二 前面4个空格</li>
<li>缩进三 或双Tab</li>
</ul>
</li>
</ul>
<ul>
<li>条目五</li>
</ul>
<p><a href="https://suzhilong.github.io/">我的主页-无备注</a><br><a href="https://suzhilong.github.io/" title="我的主页备注信息">我的主页-有备注</a></p>
<p>[我的主页-无备注][1]<br>[我的主页-无备注] [1]<br>[我的主页-有备注][a]<br>[我的主页-有备注][A]<br>[1]: <a href="https://suzhilong.github.io/">https://suzhilong.github.io/</a><br>[A]: <a href="https://suzhilong.github.io/">https://suzhilong.github.io/</a> “备注信息”<br>[A]: <a href="https://suzhilong.github.io/">https://suzhilong.github.io/</a> ‘备注信息’<br>[A]: <a href="https://suzhilong.github.io/">https://suzhilong.github.io/</a> (备注信息)<br>[A]: <a href="https://suzhilong.github.io/">https://suzhilong.github.io/</a> “备注信息”<br>[a]: <a href="https://suzhilong.github.io/">https://suzhilong.github.io/</a> ‘备注信息’<br>[a]: <a href="https://suzhilong.github.io/">https://suzhilong.github.io/</a> (备注信息)</p>
<table>
<thead>
<tr>
<th>标题</th>
<th align="center">内容</th>
<th align="right">备注</th>
</tr>
</thead>
<tbody><tr>
<td>标题1</td>
<td align="center">内容1</td>
<td align="right">备注1</td>
</tr>
<tr>
<td>标题2</td>
<td align="center">内容2</td>
<td align="right">备注2</td>
</tr>
</tbody></table>
<p><del>此段内容删除</del></p>
<p>这是一个简短的脚注，<a href="%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E8%84%9A%E6%B3%A8%E3%80%82">^1</a> 和一个较长的脚注。<a href="%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E8%BE%83%E9%95%BF%E7%9A%84%E8%84%9A%E6%B3%A8%E3%80%82">^bignote</a></p>
<pre><code>缩进段落以将其包含在脚注中。

`&#123; my code &#125;`

添加任意数量的段落。
</code></pre>
<p><code>反引号行内码</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码块</span><br></pre></td></tr></table></figure>
<pre><code>代码块
</code></pre>
<p><img src="http://shuju.taobao.ali.com/images/web/tsj_main_dirc_img.png" alt="图片标题"></p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
  </entry>
  <entry>
    <title>STL常用方法</title>
    <url>/2020/07/12/STL/</url>
    <content><![CDATA[<h1 id="常用STL库的使用方法"><a href="#常用STL库的使用方法" class="headerlink" title="常用STL库的使用方法"></a>常用STL库的使用方法</h1><p>记录了常用的STL使用方法</p>
<span id="more"></span>
<h2 id="vector：数组"><a href="#vector：数组" class="headerlink" title="vector：数组"></a>vector：数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;  </span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; a(10);//初始化10个默认为0的数  </span><br><span class="line">vector&lt;int&gt; a(10,1);//初始化10个默认为1的数  </span><br><span class="line">vector&lt;int&gt; a;  </span><br><span class="line"></span><br><span class="line">//初始化二维数组  </span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; 2dVec(m ,vector&lt;int&gt;(n)); //m*n的二维vector，注意两个 &quot;&gt; &quot;之间要有空格</span><br><span class="line">2dVec.push_back(&#123;1, 2, 3&#125;);//可以这样加vector  </span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; 2dVec(m ,vector&lt;int&gt;(n,0)); //m*n的二维vector，所有元素初始化为0  </span><br><span class="line">a.push_back()  </span><br><span class="line">a[0]  </span><br><span class="line">a.front() //首元素  </span><br><span class="line">a.back() //尾元素  </span><br><span class="line">a.size()  </span><br><span class="line">a.pop_back()//删除不输出  </span><br><span class="line">it = a.begin()+1  </span><br><span class="line">a.erase(it)  </span><br><span class="line">it2 = a.begin()+3  </span><br><span class="line">a.erase(it,it2)//删除[it1,it2)  </span><br><span class="line">a.clear()  </span><br><span class="line">a.empty()  </span><br><span class="line">a.insert(it,-1)  </span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator itDele;</span><br><span class="line">it = find(a.begin(), a.end(), 3);//查找3</span><br><span class="line">if(it!=a.end())//如果找到了</span><br><span class="line"></span><br><span class="line">//pair  make_pair</span><br><span class="line">vector&lt;pair&lt;int ,int&gt; &gt; vp;</span><br><span class="line">vp.push_back(&#123;1, 0&#125;);</span><br><span class="line">vp.push_back(make_pair(0, 1));</span><br><span class="line">vector&lt;pair&lt;int, int&gt; &gt; vp2 = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">vp2.push_back(make_pair&lt;int, int&gt;(5, 6));</span><br></pre></td></tr></table></figure>

<h2 id="list：数组"><a href="#list：数组" class="headerlink" title="list：数组"></a>list：数组</h2><p>Lists将元素按顺序储存在链表中. 与向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;list&gt;</span><br><span class="line">pop_back() 删除最后一个元素 </span><br><span class="line">pop_front() 删除第一个元素 </span><br><span class="line">push_back() 在list的末尾添加一个元素 </span><br><span class="line">push_front() 在list的头部添加一个元素 </span><br><span class="line">back() 返回最后一个元素 </span><br><span class="line">front() 返回第一个元素 </span><br><span class="line">begin() 返回指向第一个元素的迭代器 </span><br><span class="line">end() 返回末尾的迭代器 </span><br><span class="line">size() 返回list中的元素个数 </span><br><span class="line">clear() 删除所有元素 </span><br><span class="line">empty() 如果list是空的则返回true</span><br><span class="line">a.sort() 给list排序</span><br><span class="line">erase() 删除一个元素 </span><br><span class="line">assign() 给list赋值 </span><br><span class="line">get_allocator() 返回list的配置器 </span><br><span class="line">insert() 插入一个元素到list中 </span><br><span class="line">max_size() 返回list能容纳的最大元素数量 </span><br><span class="line">merge() 合并两个list </span><br><span class="line">rbegin() 返回指向第一个元素的逆向迭代器 </span><br><span class="line">remove() 从list删除元素 </span><br><span class="line">remove_if() 按指定条件删除元素 </span><br><span class="line">rend() 指向list末尾的逆向迭代器 </span><br><span class="line">resize() 改变list的大小 </span><br><span class="line">reverse() 把list的元素倒转 </span><br><span class="line">splice() 合并两个list </span><br><span class="line">swap() 交换两个list </span><br><span class="line">unique() 删除list中重复的元素</span><br></pre></td></tr></table></figure>

<h2 id="stack：栈"><a href="#stack：栈" class="headerlink" title="stack：栈"></a>stack：栈</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stack&gt;</span><br><span class="line"></span><br><span class="line">stack&lt;int&gt; a;</span><br><span class="line">a.push()</span><br><span class="line">a.top()</span><br><span class="line">a.pop()</span><br><span class="line">a.empty()</span><br><span class="line">a.size()</span><br></pre></td></tr></table></figure>

<h2 id="queue：队列"><a href="#queue：队列" class="headerlink" title="queue：队列"></a>queue：队列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt; a;</span><br><span class="line">a.push()</span><br><span class="line">a.front()</span><br><span class="line">a.back()</span><br><span class="line">a.pop()</span><br><span class="line">a.empty()</span><br><span class="line">a.size()</span><br></pre></td></tr></table></figure>

<h2 id="priority-queue：堆"><a href="#priority-queue：堆" class="headerlink" title="priority_queue：堆"></a>priority_queue：堆</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">//priority_queue&lt;type,container,function&gt;</span><br><span class="line">//小根堆，a&gt;b</span><br><span class="line">priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; </span><br><span class="line">//大根堆，a&lt;b</span><br><span class="line">priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; q;</span><br><span class="line">//默认是大根堆</span><br><span class="line">priority_queue &lt;int&gt; q ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//自定义堆的比较方式</span><br><span class="line">//方法1，用类</span><br><span class="line">class cmp</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    bool operator()(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b)&#123;</span><br><span class="line">        return a.second &gt; b.second; //a&gt;b = greater&lt;int&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//方法2，用struct</span><br><span class="line">struct cmp</span><br><span class="line">&#123;</span><br><span class="line">    bool operator()(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b)&#123;</span><br><span class="line">        return a.second &gt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;int, int&gt;,vector&lt;pair&lt;int,int&gt; &gt;, cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">//注意！没有front和back</span><br><span class="line">q.push()</span><br><span class="line">q.pop()</span><br><span class="line">q.top()</span><br><span class="line">q.empty()</span><br><span class="line">q.size()</span><br></pre></td></tr></table></figure>

<h2 id="map-x2F-unordered-map"><a href="#map-x2F-unordered-map" class="headerlink" title="map&#x2F;unordered_map"></a>map&#x2F;unordered_map</h2><p>哈希表的实现：STL中，<code>map/set</code> 对应的数据结构是红黑树。红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 O(logN)。而 <code>unordered_map/unordered_set</code> 对应 哈希表，哈希表的特点就是查找效率高，时间复杂度为常数级别 O(1)， 而额外空间复杂度则要高出许多而且无序。所以对于需要高效率查询的情况，使用 <code>unordered_map</code> 容器。而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用 <code>map</code> 容器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">std:map&lt;int,int&gt; mapA;</span><br><span class="line">//插入</span><br><span class="line">mapA.insert(std::pair&lt;int,int&gt;(0,1));</span><br><span class="line">mapA.insert(map&lt;int,int&gt;::value_type (0,1));</span><br><span class="line">mapA[0] = 1;</span><br><span class="line">mapA.at(0)</span><br><span class="line">mapA.size()</span><br><span class="line">map&lt;int, int&gt;::iterator iter;//迭代器</span><br><span class="line">mapA.erase(key/iter)</span><br><span class="line">mapA.clear()</span><br><span class="line">mapA.empty()</span><br><span class="line">mapA.count() //由于map不包含重复的key，因此m.count(key)取值为0，或者1，表示是否包含。</span><br><span class="line">mapA.find(key)//返回迭代器，判断是否存在。</span><br><span class="line">mapA.find(key) != mapA.end() //为真说明存在</span><br><span class="line"></span><br><span class="line">#include &lt;unordered_map&gt; //和map差不多</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/06/15/2eMDTN3HXOPt9oK.png" alt="map的用法"></p>
<h3 id="map的注意事项："><a href="#map的注意事项：" class="headerlink" title="map的注意事项："></a>map的注意事项：</h3><ul>
<li>在map中，由key查找value时，首先要判断map中是否包含key。</li>
<li>如果不检查，直接返回map[key]，可能会出现意想不到的行为。如果map包含key，没有问题，如果map不包含key，使用下标有一个危险的副作用，会在map中插入一个key的元素，value取默认值，返回value。也就是说，map[key]不可能返回null。</li>
</ul>
<p>比如：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;string, int&gt; mapA;</span><br><span class="line">cout &lt;&lt; mapA.size() &lt;&lt; endl; //这时为0</span><br><span class="line">int a = mapA[&quot;aa&quot;] //本来是空map，但是调用mapA[&quot;aa&quot;]之后，会自动插入mapA[&quot;aa&quot;]=0，返回0</span><br><span class="line">cout &lt;&lt; mapA.size() &lt;&lt; endl; //这使为1</span><br></pre></td></tr></table></figure>

<h2 id="set-x2F-multiset-x2F-unordered-set"><a href="#set-x2F-multiset-x2F-unordered-set" class="headerlink" title="set&#x2F;multiset&#x2F;unordered_set"></a>set&#x2F;multiset&#x2F;unordered_set</h2><p>set和multiset的区别：</p>
<ul>
<li>set不可以有重复的元素</li>
<li>multiset可以有重复的元素</li>
</ul>
<p>和map&#x2F;unordered_map一样，也是set&#x2F;multiset使用红黑树实现，unordered_set使用哈希表实现。unordered_set和unordered_map内部实现的公共接口大致相同。</p>
<ol>
<li>set是按照一定的次序存储元素的容器，set遍历后有序，默认按照小于排序</li>
<li>set中只放value，但是底层存放的是&lt;value, value&gt;的键值对。每个value必须是惟一的</li>
<li>set允许插入和删除，不允许修改</li>
<li>set按照内部比较对象（类型比较）所指示的特定严格弱排序准则进行排序</li>
<li>set在底层用二叉搜索树（红黑树）实现</li>
<li>set中查找、插入、删除元素的复杂度为O(logn)，unordered_set为O(1)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line"></span><br><span class="line">unordered_set&lt;int&gt; us;</span><br><span class="line">us.insert(2);//插入</span><br><span class="line">unordered_set&lt;int&gt; us1(us);//us1=us</span><br><span class="line">unordered_set&lt;int&gt; us2(us1.begin(),us1.end());</span><br><span class="line"></span><br><span class="line">us.erase(6); //删除键值为6的元素</span><br><span class="line">set&lt;int&gt;::iterator it;  </span><br><span class="line">it = us.find(6); //查找键值为6的元素</span><br><span class="line">int n = us.count(6);//也能判断一个数是否在集合中。n=0不在，n=在</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; s = &#123;3,8,12,15&#125;</span><br><span class="line">s.lower_bound(8); //表示查找 &gt;= 8 的元素中最小的一个(8)，并返回指向该元素的迭代器</span><br><span class="line">s.upper_bound(8); //表示查找 &gt;8 的元素中最小的一个(12)，并返回指向该元素的迭代器</span><br><span class="line"></span><br><span class="line">s.lower_bound(9); //12</span><br><span class="line">s.upper_bound(9); //12</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">begin()         //返回指向第一个元素的迭代器</span><br><span class="line">clear()         //清除所有元素</span><br><span class="line">count()         //返回某个值元素的个数</span><br><span class="line">empty()         //如果集合为空，返回true</span><br><span class="line">end()           //返回指向最后一个元素的迭代器</span><br><span class="line">equal_range()   //返回集合中与给定值相等的上下限的两个迭代器</span><br><span class="line">erase()         //删除集合中的元素</span><br><span class="line">find()          //返回一个指向被查找到元素的迭代器</span><br><span class="line">get_allocator() //返回集合的分配器</span><br><span class="line">insert()        //在集合中插入元素</span><br><span class="line">lower_bound()   //返回指向大于（或等于）某值的第一个元素的迭代器</span><br><span class="line">key_comp()      //返回一个用于元素间值比较的函数</span><br><span class="line">max_size()      //返回集合能容纳的元素的最大限值</span><br><span class="line">rbegin()        //返回指向集合中最后一个元素的反向迭代器</span><br><span class="line">rend()          //返回指向集合中第一个元素的反向迭代器</span><br><span class="line">size()          //集合中元素的数目</span><br><span class="line">swap()          //交换两个集合变量</span><br><span class="line">upper_bound()   //返回大于某个值元素的迭代器</span><br><span class="line">value_comp()    //返回一个用于比较元素间的值的函数</span><br></pre></td></tr></table></figure>

<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">string s;</span><br><span class="line">s.find()//在s当中查找第一个出现</span><br><span class="line">s.rfind()//在s当中查找最后一个出现</span><br><span class="line">int is = stoi(val) //把string val转换成int。stoi()会做范围检查，默认范围是在int的范围内的，如果超出范围的话则会runtime error</span><br><span class="line">int is = atoi(val.c_str()) //atoi()不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界</span><br><span class="line"></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">reverse(s.begin(),s.end()); //反转字符串</span><br><span class="line"></span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">//s1 s2需要c风格字符串char</span><br><span class="line">//如果是string，需要s1.c_str()</span><br><span class="line">strcmp(s1,s2) //相等返回0；s1-s2大于0，则返回1，小于0则返回-1</span><br><span class="line">strncmp(s1,s2,n) //比较前n个</span><br><span class="line">strcpy(s1,s2) //s2复制到s1,注意s2不要比s1长</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/06/15/gkiTrRs2O5WL9qU.png" alt="string和char的对比"></p>
<h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><p><img src="https://i.loli.net/2020/06/19/DtlTnEAUK7qQRFc.jpg" alt="ASCII表"></p>
<ol>
<li><strong>对应大小写字母之间相差32</strong></li>
<li>transform函数：直接处理<code>string</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s = &quot;aBc&quot;;</span><br><span class="line"></span><br><span class="line">transform(s.begin(), s.end(), s.begin(), ::tolower);//::toupper转大写</span><br></pre></td></tr></table></figure></li>
<li>toupper, tolower：处理<code>char</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cctype&gt;</span><br><span class="line"></span><br><span class="line">char s = &#x27;a&#x27;;</span><br><span class="line">char sl = tolower(s);</span><br><span class="line">char su = toupper(sl);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p><code>sort</code>并非只是普通的<strong>快速排序</strong>，除了对普通的快速排序进行优化，它还结合了<strong>插入排序</strong>和<strong>堆排序</strong>。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">//nums必须是线性容器</span><br><span class="line">//降序排序</span><br><span class="line">sort(nums.begin(),nums.end(),greater&lt;int&gt;());</span><br><span class="line">//升序（默认是升序）</span><br><span class="line">sort(nums.begin(),nums.end(),less&lt;int&gt;());</span><br><span class="line">sort(nums.begin(),nums.end());</span><br><span class="line"></span><br><span class="line">//自定义排序函数</span><br><span class="line">vector&lt;vecotr&lt;int&gt; &gt; nums2d;</span><br><span class="line">bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123;</span><br><span class="line">    //注意！这个函数要在类外面定义</span><br><span class="line">    return a[1] &gt; b[1];//按第二维降序</span><br><span class="line">&#125;</span><br><span class="line">sort(nums2d.begin(),nums2d.end(),cmp);</span><br><span class="line"></span><br><span class="line">//稳定排序</span><br><span class="line">stable_sort(nums.begin(),nums.end(),greater&lt;int&gt;());</span><br><span class="line">stable_sort(nums.begin(),nums.end(),less&lt;int&gt;());</span><br></pre></td></tr></table></figure>
<p>sort算法有个限制，利用sort算法只能对<strong>序列容器</strong>进行排序，就是线性的，如<strong>vector，list，deque</strong>。map也是一个集合容器，但它里面存储的元素是pair，不是线性存储的（前面提过，像红黑树），所以利用sort不能直接和map结合进行排序。</p>
<p>如果想对map进行排序，可以把map放到vector中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将map中的内容转存到vector中</span><br><span class="line">vector&lt;pair&lt;string, int&gt; &gt; vec(map.begin(), map.end());</span><br><span class="line"></span><br><span class="line">bool cmp(const pair&lt;string, int&gt;&amp; a, const pair&lt;string, int&gt;&amp; b) &#123;</span><br><span class="line">        return a.second &lt; b.second;</span><br><span class="line">&#125;</span><br><span class="line">//对线性的vector进行排序</span><br><span class="line">sort(vec.begin(), vec.end(), cmp);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>支持随机存取迭代器（连续存储空间）的<code>vector</code>，<code>deque</code> （双向存取的vector）可以使用sort；</li>
<li>支持随机存取迭代器（链式非连续存储空间）的<code>list</code>（双向链表）和<code>slist</code>（单向链表forward_list），不能使用STL的sort，但是类中有自定义的sort()成员函数；</li>
<li>关系型容器中基于红黑树的<code>set</code>，<code>multiset</code>，<code>map</code>，<code>multimap</code>，本身就有自动排序的功能，不需要sort函数。如果有特殊排序需求的话，可以放入vector中；</li>
<li><code>stack</code>，<code>queue</code>没有迭代器，入口出口固定，不能进行排序；</li>
<li>基于哈希表的<code>unordered_map</code>等都是为排序的，也不需要排序。</li>
</ol>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; nums = &#123;100,100,100,101&#125;;</span><br><span class="line">int num = count(nums.begin(),nums.end(),100);//统计100出现的次数</span><br></pre></td></tr></table></figure>

<h3 id="lower-bound、upper-bound、binary-search"><a href="#lower-bound、upper-bound、binary-search" class="headerlink" title="lower_bound、upper_bound、binary_search"></a>lower_bound、upper_bound、binary_search</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">lower_bound(起始地址，结束地址，要查找的数值) //返回的是数值 第一个 出现的位置。</span><br><span class="line">upper_bound(起始地址，结束地址，要查找的数值) //返回的是数值 最后一个 出现的位置。</span><br><span class="line">binary_search(起始地址，结束地址，要查找的数值)  //返回的是是否存在这么一个数，是一个bool值。</span><br></pre></td></tr></table></figure>

<h2 id="一些数学运算"><a href="#一些数学运算" class="headerlink" title="一些数学运算"></a>一些数学运算</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cmath&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/06/15/iLAdQTJq3j19CH5.png" alt="cmath"></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iterator&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/06/15/lqItjZGhRkmMwPf.png" alt="iter"></p>
<h2 id="cctype"><a href="#cctype" class="headerlink" title="cctype"></a>cctype</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cctype&gt;</span><br><span class="line"></span><br><span class="line">isalnum(c)//当c是字母或数字时为真</span><br><span class="line">isalpha(c)//当c是字母时为真</span><br><span class="line">isdigit(c)//当c是数字时为真</span><br><span class="line">islower(c)//当c是小写字母时为真</span><br><span class="line">isupper(c)//当c是大写字母时为真</span><br><span class="line">isspace(c)//当c是空白时为真（即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符）</span><br><span class="line">iscntrl(c)//当c是控制字符时为真</span><br><span class="line">isgraph(c)//当c不是空格但可打印时为真</span><br><span class="line">isprint(c)//当c是可打印字符时为真（即c是空格或c具有可视形式）</span><br><span class="line">ispunct(c)//当c是标点符号时为真</span><br><span class="line">isxdigit(c)//当c是十六进制数字时为真</span><br><span class="line">tolower(c)//如果c是大写字母，输出对应的小写字母，否则原样输出c</span><br><span class="line">toupper(c)//如果c是小写字母，输出对应的大写字母，否则原样输出c</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>光流鲁棒性评估</title>
    <url>/2022/11/27/optical_flow_evaluation/</url>
    <content><![CDATA[<ol>
<li>本篇文档对鲁棒性的定义：$$goodPoints&#x2F;allPoints$$ 其中</li>
<li>goodPoints：跟踪成功的特征点。即，向前-向后追踪回到开始帧，EPE 小于设定的阈值(单位: pixel)。</li>
<li>allPoints：所有特征点</li>
<li>使用全部特征点测试鲁棒性，$$Harris \gtrsim Tomasi &gt; Fast$$</li>
<li>使用我们的均匀化策略后的特征点测试鲁棒性，$$Fast &gt; Tomasi \approx Harris$$</li>
</ol>
<span id="more"></span>
<h1 id="光流评估指标"><a href="#光流评估指标" class="headerlink" title="光流评估指标"></a>光流评估指标</h1><h2 id="误差指标"><a href="#误差指标" class="headerlink" title="误差指标"></a>误差指标</h2><ul>
<li><p>EPE(Endpoint Error)：估计光流和 ground-truth 光流的欧氏距离<br>$$EPE &#x3D; \sqrt{(u_{est} - u_{gt})^2 + (v_{est} - v_{gt})^2}$$<br><img src="https://s2.loli.net/2022/11/27/gm1UaiBwIoZrnPc.png" alt="EPE.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;float&gt; EndPointError(const std::vector&lt;cv::Point2f&gt;&amp; prevPoints, const std::vector&lt;cv::Point2f&gt;&amp; nextPoints, std::vector&lt;uchar&gt; status)</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;float&gt; endPointError;</span><br><span class="line">    for (int i = 0; i &lt; prevPoints.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      const cv::Point2f prevP = prevPoints[i];</span><br><span class="line">      const cv::Point2f nextP = nextPoints[i];</span><br><span class="line">      float distance = 100.0;</span><br><span class="line">      if ((bool)status[i])</span><br><span class="line">      &#123;</span><br><span class="line">        const cv::Point2f diff = nextP - prevP;</span><br><span class="line">        distance = sqrt((float)diff.ddot(diff));</span><br><span class="line">      &#125;</span><br><span class="line">      endPointError.push_back(distance);</span><br><span class="line">    &#125;</span><br><span class="line">    return endPointError;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>AE(Angular Error)：光流向量之间的角度误差。计算角度误差时增加一维，使用的是三维向量 (u, v, 1)<br>$$\mathrm{AE}&#x3D;\arccos \left(\frac{\left(\mathrm{u}<em>{\mathrm{est}}, \mathrm{v}</em>{\text {est }}, 1\right)^{\mathrm{T}} *\left(\mathrm{u}<em>{\mathrm{gt}}, \mathrm{v}</em>{\mathrm{gt}}, 1\right)}{\left.\sqrt{1.0+\mathrm{u}<em>{\mathrm{est}} * \mathrm{u}</em>{\mathrm{est}}+\mathrm{v}<em>{\mathrm{est}} * \mathrm{v}</em>{\mathrm{est}}} \sqrt{1.0+\mathrm{u}<em>{\mathrm{gt}} * \mathrm{u}</em>{\mathrm{gt}}+\mathrm{v}<em>{\mathrm{gt}} * \mathrm{v}</em>{\mathrm{gt}}}\right)}\right)$$<br><img src="https://s2.loli.net/2022/11/27/Pb8hR4dVBoi7cJn.png" alt="AE.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;float&gt; AngularError(const std::vector&lt;cv::Point2f&gt;&amp; prevPoints, const std::vector&lt;cv::Point2f&gt;&amp; nextPoints, std::vector&lt;uchar&gt; status)</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;float&gt; angularErrs;</span><br><span class="line">    for (int i = 0; i &lt; prevPoints.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">      const cv::Point2f prevPoint2d = prevPoints[i];</span><br><span class="line">      const cv::Point2f nextPoint2d = nextPoints[i];</span><br><span class="line">      const cv::Point3f prevPoint3d(prevPoint2d.x, prevPoint2d.y, 1);</span><br><span class="line">      const cv::Point3f nextPoint3d(nextPoint2d.x, nextPoint2d.y, 1);</span><br><span class="line">      double angularErr = 100.0;</span><br><span class="line">      if ((bool)status[i])</span><br><span class="line">      &#123;</span><br><span class="line">        double vecDocVec = prevPoint3d.ddot(nextPoint3d);</span><br><span class="line">        double vecNormProvecNorm = norm(prevPoint3d) * norm(nextPoint3d);</span><br><span class="line">        double mid = vecDocVec / vecNormProvecNorm;</span><br><span class="line">        double AE = acos(mid);</span><br><span class="line">        angularErr = acos((double)(prevPoint3d.ddot(nextPoint3d) / norm(prevPoint3d) * norm(nextPoint3d)));</span><br><span class="line">      &#125;</span><br><span class="line">      angularErrs.push_back(angularErr);</span><br><span class="line">    &#125;</span><br><span class="line">    return angularErrs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="统计指标"><a href="#统计指标" class="headerlink" title="统计指标"></a>统计指标</h2><ul>
<li>AEE：平均点误差</li>
<li>AAE：平均角误差</li>
</ul>
<h1 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h1><h2 id="MPI-Sintel"><a href="#MPI-Sintel" class="headerlink" title="MPI Sintel"></a><a href="http://sintel.is.tue.mpg.de/">MPI Sintel</a></h2><p>从人工生成的动画 sintel 中得到光流 ground truth，每一个版本都包含 1041 个可用来训练的图片对，提供的 ground truth 十分密集，大幅度、小幅度的运动都包含。 </p>
<p>sintel 数据集包括两种版本： </p>
<ul>
<li>sintel final：包括运动模糊和一些环境氛围特效，如雾等</li>
<li>sintel clean：没有 final 的特效</li>
</ul>
<h2 id="Crowd-Flow"><a href="#Crowd-Flow" class="headerlink" title="Crowd-Flow"></a><a href="https://github.com/tsenst/CrowdFlow">Crowd-Flow</a></h2><ul>
<li>序列包含 371 到 1451 个独立运动的个体</li>
<li>数据集由 10 个长度范围的序列组成，在 300 至 450 帧之间，所有序列均以 25hz 的帧速率和高清分辨率呈现</li>
<li>与此前光流数据集相比，该数据集除了提高了分辨率和帧的数量之外，还以连续序列而不是单帧对进行组织，允许评估时间一致性，例如以轨迹的形式</li>
</ul>
<h2 id="KITTI"><a href="#KITTI" class="headerlink" title="KITTI"></a><a href="https://www.cvlibs.net/datasets/kitti/index.php">KITTI</a></h2><p>只有一种特殊的动作类型（类似行车记录仪），并且位移很大，视频使用一个摄像头，ground-truth 由 3D 激光雷达得出，远距离的物体，如天空没法被捕捉，导致该数据集光流 ground-truth 比较稀疏。</p>
<ul>
<li>KITTI 2012：194 组图片</li>
<li>KITTI 2015：200 组图片</li>
</ul>
<h2 id="Flying-Chairs"><a href="#Flying-Chairs" class="headerlink" title="Flying Chairs"></a><a href="https://lmb.informatik.uni-freiburg.de/resources/datasets/FlyingChairs.en.html">Flying Chairs</a></h2><p>软件渲染生成的虚拟数据，包含了 22872 对图像。</p>
<h2 id="SceneFlow"><a href="#SceneFlow" class="headerlink" title="SceneFlow"></a><a href="https://lmb.informatik.uni-freiburg.de/resources/datasets/SceneFlowDatasets.en.html">SceneFlow</a></h2><p>利用软件渲染生成的虚拟立体数据集，包含 35454 个训练图像（有 ground truth），所有的图片分辨率都是 960x540。<br>主要包含三个子集：</p>
<ul>
<li>FlyingThings3D</li>
<li>Driving</li>
<li>Monkaa</li>
</ul>
<h2 id="Middlebury"><a href="#Middlebury" class="headerlink" title="Middlebury"></a><a href="http://vision.middlebury.edu/flow/eval">Middlebury</a></h2><ul>
<li>评估使用 1.1 中的 4 个指标</li>
<li>gray 和 color 都有</li>
<li>位移很小，通常小于10个像素</li>
<li>12 个场景的图片流，每个场景图片只有 10 张</li>
<li>针对的是全图片的光流，ground-truth 只有 1 帧的。需要把跑出来的光流结果保存成指定的数据格式(.flo)，上传到指定地址</li>
</ul>
<h2 id="数据集生成工具"><a href="#数据集生成工具" class="headerlink" title="数据集生成工具"></a>数据集生成工具</h2><ul>
<li><a href="https://microsoft.github.io/AirSim/">AirSim</a>：能够生成无人机视角和公路驾驶视角的两类数据</li>
<li><a href="http://carla.org/">Carla</a>：高仿真的自动驾驶场景</li>
</ul>
<h1 id="不依赖数据集评估方案"><a href="#不依赖数据集评估方案" class="headerlink" title="不依赖数据集评估方案"></a>不依赖数据集评估方案</h1><h2 id="forward-backward"><a href="#forward-backward" class="headerlink" title="forward-backward"></a>forward-backward</h2><p>使用基于奇偶数的 forward-backward：如有 5 幅图像。前向时为 0-2-4，后向时为 4-3-1-0，连起来为 0-2-4-3-1-0。<br>最后使用欧氏距离计算出 0 帧与最后的 0 帧图像之间，特征点位置的漂移 e，即 final drift。设定一个阈值 threshold，计算小于 thresh 的特征点的百分比，为鲁棒性；e 的直方图用于表示稳定性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float OpticalFlowRubost(std::vector&lt;float&gt; endpointErr, float thresh)</span><br><span class="line">&#123;</span><br><span class="line">    int goodPoint = 0;</span><br><span class="line">    int totalPoint = endpointErr.size();</span><br><span class="line">    for (size_t i = 0; i &lt; totalPoint; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      if (endpointErr[i] &lt; thresh)</span><br><span class="line">      &#123;</span><br><span class="line">        goodPoint++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (float)goodPoint / (float)totalPoint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref."></a>Ref.</h1><ul>
<li><a href="https://blog.csdn.net/catpico/article/details/122890919">optical flow光流估计的评价指标_wrotcat的博客-CSDN博客</a></li>
<li><a href="https://sourceforge.net/p/emgucv/opencv_contrib/ci/4ec320efe1a04604eee4c024c7b9d9d37ddab80a/tree/modules/optflow/samples/optical_flow_evaluation.cpp#l1">Emgu CV &#x2F; OpenCV Contrib Git clone &#x2F; [4ec320] &#x2F;modules&#x2F;optflow&#x2F;samples&#x2F;optical_flow_evaluation.cpp</a></li>
<li><a href="https://www.docin.com/p-1461046820.html">图像序列光流计算评估理论及方法研究</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/548858539">最全自动驾驶数据集分享系列四｜光流数据集</a></li>
<li><a href="https://opendatalab.com/">Datasets-OpenDataLab</a></li>
<li><a href="https://github.com/liruoteng/OpticalFlowToolkit">OPTICAL FLOW TOOLKIT</a></li>
<li><a href="https://blog.csdn.net/qxqxqzzz/article/details/100989893">optical flow数据集KITTI 2012 2015 sintel crowd flow_城俊BLOG的博客-CSDN博客</a></li>
<li>论文：Evaluation of Endoscopic Image Enhancement for Feature Tracking: A New Validation Framework</li>
<li><a href="https://blog.csdn.net/u010141025/article/details/15810713">特征点检测和追踪评价:A New Validation Framework</a></li>
</ul>
]]></content>
      <categories>
        <category>robot</category>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>Computer vision</tag>
      </tags>
  </entry>
  <entry>
    <title>RCAR2021 wiki</title>
    <url>/2021/03/30/rcar_wiki/</url>
    <content><![CDATA[<h1 id="How-to-register-and-make-payment"><a href="#How-to-register-and-make-payment" class="headerlink" title="How to register and make payment"></a>How to register and make payment</h1><p>Contents:</p>
<ul>
<li>How to register</li>
<li>How to payment</li>
<li>Confirm whether the payment is successful</li>
</ul>
<span id="more"></span>
<h2 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h2><ol>
<li>Visit <a href="https://www.softconf.com/l/rcar2021/">IEEE-RCAR2021</a></li>
<li>Register<ul>
<li>Finish the registration procedure<img src="https://i.loli.net/2021/03/30/OyKmUotCzkVuNgq.png" alt="normal regist"></li>
<li>Authors can start to register by login to softconf site<img src="https://i.loli.net/2021/03/30/cTQhvPwzYCZrK2g.png" alt="Authors register"></li>
</ul>
</li>
<li>Fill in your profile in below text-boxes(<strong>* is mandatory</strong>). Then click <code>Continue</code> to next <code>Payment</code> step<br> <img src="https://i.loli.net/2021/03/30/hT2eAmZJgl51qtd.png" alt="fill in"></li>
</ol>
<h2 id="Payment"><a href="#Payment" class="headerlink" title="Payment"></a>Payment</h2><ol>
<li><p>Choose item you need to pay for, then click <code>Checkout</code> button.<br> <strong>Note:</strong> if your paper has more than 6 pages, you also need to pay for the extra pages<br> <img src="https://i.loli.net/2021/03/30/YgQjZ4rOdAtyW85.png" alt="payment"></p>
</li>
<li><p>Checkout your bill: Here a Payment information will be shown, and a transaction ID will be generated.<br> Click <code>Pay</code>, you will receive a notification mail about this transaction.<br> <img src="https://i.loli.net/2021/03/30/MNUk6WBxc8SJeIy.png" alt="checkout"></p>
</li>
<li><p>Using your PayPal account to pay.</p>
</li>
</ol>
<h2 id="Confirm"><a href="#Confirm" class="headerlink" title="Confirm"></a>Confirm</h2><ol>
<li><p>Login with your passcode<br> <img src="https://i.loli.net/2021/03/30/yMruJBQaosdGp5P.png" alt="login"></p>
</li>
<li><p>Click <code>Processed payment archive</code><br> <img src="https://i.loli.net/2021/03/30/1feyA9R2k7vhxOT.png" alt="archive"></p>
</li>
<li><p>Check table list<br> <img src="https://i.loli.net/2021/03/30/9NsvaHkoSL6MBEW.png" alt="list"></p>
</li>
</ol>
<p>We are looking forward to see you at IEEE RCAR 2021!</p>
<p>Regards,</p>
<p>The IEEE RCAR 2021 committee.</p>
]]></content>
      <categories>
        <category>robot</category>
      </categories>
      <tags>
        <tag>wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>基于rotors_simulator和ROS的无人机仿真</title>
    <url>/2021/01/20/rotorsSimulator/</url>
    <content><![CDATA[<p><a href="https://github.com/suzhilong/uav_tracking">uav_tracking项目代码</a></p>
<h1 id="安装-rotors-simulator"><a href="#安装-rotors-simulator" class="headerlink" title="安装 rotors_simulator"></a>安装 <a href="(https://github.com/ethz-asl/rotors_simulator)">rotors_simulator</a></h1><h2 id="1-新建工作空间并初始化（有工作空间的跳过此步骤）"><a href="#1-新建工作空间并初始化（有工作空间的跳过此步骤）" class="headerlink" title="1. 新建工作空间并初始化（有工作空间的跳过此步骤）"></a>1. 新建工作空间并初始化（有工作空间的跳过此步骤）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/rotors_ws/src</span><br><span class="line">cd ~/rotors_ws/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure>
<h2 id="2-克隆源代码"><a href="#2-克隆源代码" class="headerlink" title="2. 克隆源代码"></a>2. 克隆源代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/rotors_ws/src</span><br><span class="line">git clone https://github.com/ethz-asl/rotors_simulator.git</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="3-初始化wstool，并更新所需库"><a href="#3-初始化wstool，并更新所需库" class="headerlink" title="3. 初始化wstool，并更新所需库"></a>3. 初始化wstool，并更新所需库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wstool init</span><br><span class="line">wget https://raw.githubusercontent.com/ethz-asl/rotors_simulator/master/rotors_hil.rosinstall</span><br><span class="line">wstool merge rotors_hil.rosinstall</span><br><span class="line">wstool update</span><br></pre></td></tr></table></figure>
<h2 id="4-编译"><a href="#4-编译" class="headerlink" title="4. 编译"></a>4. 编译</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/rotors_ws/</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<h2 id="5-环境变量"><a href="#5-环境变量" class="headerlink" title="5. 环境变量"></a>5. 环境变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ./devel/setup.bash</span><br></pre></td></tr></table></figure>
<p>也可以用下面的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;source ~/rotors_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="6-测试"><a href="#6-测试" class="headerlink" title="6. 测试"></a>6. 测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">roslaunch rotors_gazebo mav_hovering_example.launch mav_name:=firefly world_name:=basic</span><br></pre></td></tr></table></figure>
<p>如果安装成功，就能启动<code>gazebo</code>，看到飞机</p>
<h1 id="切换环境和飞机模型"><a href="#切换环境和飞机模型" class="headerlink" title="切换环境和飞机模型"></a>切换环境和飞机模型</h1><p>可以在启动时指定参数切换飞机和场景，也可以修改<code>launch</code>文件。</p>
<p>下面以修改<code>mav_hovering_example_with_vi_sensor.launch</code>为例，<code>mav_hovering_example_with_vi_sensor.launch</code>文件位于<code>~/rotors_ws/src/rotors_simulator/rotors_gazebo/launch/</code>路径下：</p>
<p><code>mav_hovering_example_with_vi_sensor.launch文件</code>：<br><img src="https://i.loli.net/2021/01/20/aTE2lOB9qC6zjAw.png" alt="launch文件"></p>
<h2 id="修改launch文件中的mav-name切换飞机"><a href="#修改launch文件中的mav-name切换飞机" class="headerlink" title="修改launch文件中的mav_name切换飞机"></a>修改<code>launch</code>文件中的<code>mav_name</code>切换飞机</h2><ol>
<li><p>打开<code>launch</code>文件</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gedit ~/rotors_ws/src/rotors_simulator/rotors_gazebo/launch/mav_hovering_example_with_vi_sensor.launch</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三行参数<code>firefly</code>可以改为<code>~/rotors_ws/src/rotors_simulator/rotors_description/urdf</code>路径中的任意一个飞机名，如<code>iris</code>，<code>ardrone</code>等。</p>
</li>
</ol>
<h2 id="修改launch文件中的world-name切换场景"><a href="#修改launch文件中的world-name切换场景" class="headerlink" title="修改launch文件中的world_name切换场景"></a>修改<code>launch</code>文件中的<code>world_name</code>切换场景</h2><ol>
<li>打开<code>launch</code>文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gedit ~/rotors_ws/src/rotors_simulator/rotors_gazebo/launch/mav_hovering_example_with_vi_sensor.launch</span><br></pre></td></tr></table></figure></li>
<li>第四行参数<code>outdoor</code>可以改为<code>~/rotors_ws/src/rotors_simulator/rotors_gazebo/worlds/</code>路径中的任意一个文件名，如<code>outdoor</code>，<code>plane</code>等。</li>
</ol>
<p><code>~/rotors_ws/src/rotors_simulator/rotors_gazebo/worlds/</code>路径下的文件如下图<br><img src="https://i.loli.net/2021/01/20/QJHVIyC8GUeKwtZ.png" alt="worlds"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>修改完之后运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">roslaunch rotors_gazebo mav_hovering_example_with_vi_sensor.launch</span><br></pre></td></tr></table></figure>
<p>即可查看修改效果</p>
<p><em>ps. 如果修改的是其他<code>launch</code>文件，则运行对应的文件查看。</em></p>
<h1 id="创建直接的-ROS-package-来控制飞机"><a href="#创建直接的-ROS-package-来控制飞机" class="headerlink" title="创建直接的 ROS package 来控制飞机"></a>创建直接的 ROS package 来控制飞机</h1><h2 id="1-新建-ROS-package"><a href="#1-新建-ROS-package" class="headerlink" title="1. 新建 ROS package"></a>1. 新建 ROS package</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/rotors_ws/src</span><br><span class="line">catkin_create_pkg [PACKAGE_NAME] std_msgs rospy roscpp</span><br></pre></td></tr></table></figure>
<p>如：新建跟踪 package: <code>catkin_create_pkg uav_tracking std_msgs rospy roscpp</code></p>
<h2 id="2-修改-uav-tracking-CMakeLists-txt-添加依赖"><a href="#2-修改-uav-tracking-CMakeLists-txt-添加依赖" class="headerlink" title="2. 修改 uav_tracking/CMakeLists.txt 添加依赖"></a>2. 修改 <code>uav_tracking/CMakeLists.txt</code> 添加依赖</h2><p>修改前</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>修改后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line"></span><br><span class="line">  sensor_msgs</span><br><span class="line">  geometry_msgs</span><br><span class="line">  mav_msgs</span><br><span class="line">  gazebo_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>sensor_msgs,添加对ROS官方sensor_msgs消息的依赖,在包的程序中可以使用sensor_msgs&#x2F;xxx类型的消息;</li>
<li>geometry_msgs,添加对ROS官方geometry_msgs消息的依赖,在包的程序中可以使用geometry_msgs&#x2F;xxx类型的消息;</li>
<li>mav_msgs,添加对mav_msgs消息的依赖,在包的程序中可以使用mav_msgs&#x2F;xxx类型的消息,该消息的定义在UAV\src\mav_comm包中定义;</li>
<li>gazebo_msgs添加对ROS官方gazebo_msgs消息的依赖,在包的程序中可以使用gazebo_msgs&#x2F;xxx类型的消息,主要用于从Gazebo中获取消息.</li>
</ul>
<h2 id="3-修改-uav-tracking-package-xml"><a href="#3-修改-uav-tracking-package-xml" class="headerlink" title="3. 修改 uav_tracking/package.xml"></a>3. 修改 <code>uav_tracking/package.xml</code></h2><p>在 <code>&lt;exec_depend&gt;std_msg&lt;/exec_depend&gt;</code> 后添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;depend&gt;gazebo_msgs&lt;/depend&gt;</span><br><span class="line">&lt;depend&gt;gazebo_plugins&lt;/depend&gt;</span><br><span class="line">&lt;depend&gt;geometry_msgs&lt;/depend&gt;</span><br><span class="line">&lt;depend&gt;joy&lt;/depend&gt;</span><br><span class="line">&lt;depend&gt;mav_msgs&lt;/depend&gt;</span><br><span class="line">&lt;depend&gt;rotors_gazebo_plugins&lt;/depend&gt;</span><br><span class="line">&lt;depend&gt;sensor_msgs&lt;/depend&gt;</span><br><span class="line">&lt;depend&gt;xacro&lt;/depend&gt;</span><br></pre></td></tr></table></figure>

<p>添加后：<br><img src="https://i.loli.net/2021/01/20/PFDWncqtCIsiaJw.png" alt="package.xml"></p>
<h2 id="4-新建测试-cpp-文件"><a href="#4-新建测试-cpp-文件" class="headerlink" title="4. 新建测试 cpp 文件"></a>4. 新建测试 cpp 文件</h2><p>在<code>uav_tracking/src/</code>中新建<code>control_test.cpp</code>文件并写入下面代码，用于控制飞机：</p>
<details>
  <summary>点击查看代码</summary>
  <pre><code>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;ros/ros.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;geometry_msgs/PointStamped.h&gt;</span><br><span class="line">#include &lt;std_srvs/Empty.h&gt;</span><br><span class="line">#include &lt;Eigen/Core&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;mav_msgs/conversions.h&gt;</span><br><span class="line">#include &lt;mav_msgs/default_topics.h&gt;</span><br><span class="line">#include &lt;trajectory_msgs/MultiDOFJointTrajectory.h&gt;</span><br><span class="line"></span><br><span class="line">ros::Publisher trajectory_pub;</span><br><span class="line">geometry_msgs::PointStamped current_position;</span><br><span class="line"></span><br><span class="line">float linear_smoothing_navigation_step = 2;</span><br><span class="line">bool flag_gps_initialized_OK = false;</span><br><span class="line">bool flag_take_off_OK = false;</span><br><span class="line">int flag_tasks_OK = 0;</span><br><span class="line">Eigen::Vector3d home;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Description: </span><br><span class="line">    updateUavPosition(const geometry_msgs::PointStamped&amp; msg)</span><br><span class="line">    gps数据更新的回调函数.</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">    msg 位置信息</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">    无</span><br><span class="line">*/</span><br><span class="line">void updateUavPosition(const geometry_msgs::PointStamped&amp; msg)</span><br><span class="line">&#123;</span><br><span class="line">    if (!flag_gps_initialized_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        flag_gps_initialized_OK= true;</span><br><span class="line">        home[0] = msg.point.x;</span><br><span class="line">        home[1] = msg.point.y;</span><br><span class="line">        home[2] = msg.point.z;</span><br><span class="line">    &#125;</span><br><span class="line">    current_position = msg;</span><br><span class="line">    // std::cout&lt;&lt;&quot;UAV current position is: &quot;&lt;&lt;msg.point.x&lt;&lt; msg.point.y&lt;&lt; msg.point.z&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Description: </span><br><span class="line">    getDistanceToTarget(const Eigen::Vector3d&amp; target)</span><br><span class="line">    获取当前位置到指定位置位置的距离.</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">    target 需要飞达的位置点</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">    double 当前位置到达目标点的位置</span><br><span class="line">*/</span><br><span class="line">double getDistanceToTarget(const Eigen::Vector3d&amp; target)</span><br><span class="line">&#123;</span><br><span class="line">    double temp = 0;</span><br><span class="line">    temp += pow((target[0] - current_position.point.x), 2);</span><br><span class="line">    temp += pow((target[1] - current_position.point.y), 2);</span><br><span class="line">    temp += pow((target[2] - current_position.point.z), 2);</span><br><span class="line">    temp = sqrt(temp);</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Description: </span><br><span class="line">    reachTargetPosition(const Eigen::Vector3d&amp; target, float max_error)</span><br><span class="line">    判定是否到达指定的目标点.</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">    target 需要飞达的位置点</span><br><span class="line">    max_error 允许的位置误差阈值,当前位置和目标位置小于该阈值时,判定无人机到达目标点</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">    bool 到达目标点时返回 true</span><br><span class="line">         未到达目标点时返回 false</span><br><span class="line">*/</span><br><span class="line">bool reachTargetPosition(const Eigen::Vector3d&amp; target, float max_error)</span><br><span class="line">&#123;</span><br><span class="line">    double temp = getDistanceToTarget(target);</span><br><span class="line"></span><br><span class="line">    if (temp &lt; max_error)</span><br><span class="line">        return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Description: </span><br><span class="line">    linearSmoothingNavigationTask(const Eigen::Vector3d&amp; target)</span><br><span class="line">    控制无人机从当前位置飞向指定位置.</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">    target 需要飞达的位置点</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">    bool 起飞结束后返回 true</span><br><span class="line">         起飞过程中返回 false</span><br><span class="line">*/</span><br><span class="line">bool linearSmoothingNavigationTask(const Eigen::Vector3d&amp; target)</span><br><span class="line">&#123;</span><br><span class="line">    trajectory_msgs::MultiDOFJointTrajectory trajectory_msg;</span><br><span class="line">    trajectory_msg.header.stamp = ros::Time::now();</span><br><span class="line"></span><br><span class="line">    if (reachTargetPosition(target,0.2))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    double dist = getDistanceToTarget(target);</span><br><span class="line">    Eigen::Vector3d next_step;</span><br><span class="line"></span><br><span class="line">    if(dist&lt;linear_smoothing_navigation_step)</span><br><span class="line">    &#123;</span><br><span class="line">        next_step = target;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        next_step[0] = current_position.point.x+(target[0]-current_position.point.x)/dist*linear_smoothing_navigation_step;</span><br><span class="line">        next_step[1] = current_position.point.y+(target[1]-current_position.point.y)/dist*linear_smoothing_navigation_step;</span><br><span class="line">        next_step[2] = current_position.point.z+(target[2]-current_position.point.z)/dist*linear_smoothing_navigation_step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double desired_yaw = 0.0; </span><br><span class="line"></span><br><span class="line">    mav_msgs::msgMultiDofJointTrajectoryFromPositionYaw(next_step, desired_yaw, &amp;trajectory_msg);</span><br><span class="line">    trajectory_pub.publish(trajectory_msg);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Description: </span><br><span class="line">    takeOffTask(float height)</span><br><span class="line">    起飞函数,调用后无人机从起始位置起飞指定高度.</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">    height 指定的起飞高度</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">    bool 起飞结束后返回 true</span><br><span class="line">         起飞过程中返回 false</span><br><span class="line">*/</span><br><span class="line">bool takeOffTask(float height)</span><br><span class="line">&#123;</span><br><span class="line">    trajectory_msgs::MultiDOFJointTrajectory trajectory_msg;</span><br><span class="line">    trajectory_msg.header.stamp = ros::Time::now();</span><br><span class="line"></span><br><span class="line">    static Eigen::Vector3d desired_position(current_position.point.x, current_position.point.y, height);</span><br><span class="line">    double desired_yaw = 0.0;</span><br><span class="line"></span><br><span class="line">    if (reachTargetPosition(desired_position,0.2))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    mav_msgs::msgMultiDofJointTrajectoryFromPositionYaw(desired_position, desired_yaw, &amp;trajectory_msg);</span><br><span class="line">    trajectory_pub.publish(trajectory_msg);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Description: </span><br><span class="line">    gohome()</span><br><span class="line">    反航函数,调用后无人机先沿着当前高度飞到反航点正上方,然后降落.</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">    无</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">    无</span><br><span class="line">*/</span><br><span class="line">void gohome()</span><br><span class="line">&#123;</span><br><span class="line">    static Eigen::Vector3d temp(home[0], home[1], current_position.point.z);</span><br><span class="line">    static bool flag_temp = false;</span><br><span class="line"></span><br><span class="line">    if (!flag_temp)</span><br><span class="line">    &#123;</span><br><span class="line">        flag_temp = linearSmoothingNavigationTask(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        linearSmoothingNavigationTask(home);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    ros::init(argc, argv, &quot;UAV_Controler&quot;);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    // Create a private node handle for accessing node parameters.</span><br><span class="line">    ros::NodeHandle nh_private(&quot;~&quot;);</span><br><span class="line"></span><br><span class="line">    std::string uav_name = &quot;&quot;;  </span><br><span class="line">    ros::param::get(&quot;~mav_name&quot;,uav_name);</span><br><span class="line"></span><br><span class="line">    // 订阅话题</span><br><span class="line">    // /odometry_sensor1/position   无人机位置信息(包含噪声)</span><br><span class="line">    ros::Subscriber position_sub = nh.subscribe(std::string(&quot;/&quot;+uav_name+&quot;/odometry_sensor1/position&quot;).c_str(), 10, &amp;updateUavPosition);</span><br><span class="line"></span><br><span class="line">    trajectory_pub = nh.advertise&lt;trajectory_msgs::MultiDOFJointTrajectory&gt;(mav_msgs::default_topics::COMMAND_TRAJECTORY, 10);</span><br><span class="line"></span><br><span class="line">    // 等待5s,让Gazebo可以成功启动.</span><br><span class="line">    ros::Duration(5.0).sleep();</span><br><span class="line"></span><br><span class="line">    // 创建控制Gazebo自动运行的服务,这里自动运行是指让Gazebo自动Play</span><br><span class="line">    std_srvs::Empty srv;</span><br><span class="line">    bool unpaused = ros::service::call(&quot;/gazebo/unpause_physics&quot;, srv); </span><br><span class="line"></span><br><span class="line">    // 尝试让Gazebo自动运行</span><br><span class="line">    int i=0;</span><br><span class="line">    while (i &lt;= 10 &amp;&amp; !unpaused) &#123;</span><br><span class="line">        ROS_INFO(&quot;Wait for 1 second before trying to unpause Gazebo again.&quot;);</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">        unpaused = ros::service::call(&quot;/gazebo/unpause_physics&quot;, srv);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断Gazebo有没有自动运行,没有成功Play则退出</span><br><span class="line">    if (!unpaused) &#123;</span><br><span class="line">        ROS_FATAL(&quot;Could not wake up Gazebo.&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ROS_INFO(&quot;Unpaused the Gazebo simulation.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Eigen::Vector3d&gt; path;</span><br><span class="line">    path.push_back(Eigen::Vector3d(5.f,5.f,5.f));</span><br><span class="line">    path.push_back(Eigen::Vector3d(-5.f,5.f,5.f));</span><br><span class="line">    path.push_back(Eigen::Vector3d(-5.f,-5.f,5.f));</span><br><span class="line">    path.push_back(Eigen::Vector3d(5.f,-5.f,5.f));</span><br><span class="line">    path.push_back(Eigen::Vector3d(5.f,5.f,5.f));</span><br><span class="line">    std::cout &lt;&lt; path.size() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    ros::Rate loop_rate(10);</span><br><span class="line">    while (ros::ok())</span><br><span class="line">    &#123; </span><br><span class="line">        if(flag_gps_initialized_OK &amp;&amp; !flag_take_off_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            // ROS_INFO(&quot;UAV take off task is running...&quot;);</span><br><span class="line">            flag_take_off_OK = takeOffTask(3);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(flag_take_off_OK &amp;&amp; flag_tasks_OK&lt;path.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(flag_tasks_OK&lt;path.size())</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                bool temp = linearSmoothingNavigationTask(path[flag_tasks_OK]);</span><br><span class="line">                if (temp)</span><br><span class="line">                    flag_tasks_OK ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(flag_tasks_OK &gt;= path.size())</span><br><span class="line">        &#123;</span><br><span class="line">            gohome();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ros::spinOnce();</span><br><span class="line">        loop_rate.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  </code></pre></p>
</details>

<h2 id="5-创建launch文件夹并新建control-test-launch文件"><a href="#5-创建launch文件夹并新建control-test-launch文件" class="headerlink" title="5. 创建launch文件夹并新建control_test.launch文件"></a>5. 创建<code>launch</code>文件夹并新建<code>control_test.launch</code>文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/rotors_ws/src/uav_tracking/</span><br><span class="line">mkdir launch &amp;&amp; cd launch</span><br><span class="line">touch control_test.launch</span><br><span class="line">gedit control_test.launch</span><br></pre></td></tr></table></figure>
<p>在<code>control_test.launch</code>中写入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">    &lt;arg name=&quot;mav_name&quot; default=&quot;firefly&quot;/&gt;</span><br><span class="line">    &lt;arg name=&quot;world_name&quot; default=&quot;basic&quot;/&gt;</span><br><span class="line">    &lt;arg name=&quot;enable_logging&quot; default=&quot;false&quot; /&gt;</span><br><span class="line">    &lt;arg name=&quot;enable_ground_truth&quot; default=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;arg name=&quot;log_file&quot; default=&quot;$(arg mav_name)&quot; /&gt;</span><br><span class="line">    &lt;arg name=&quot;debug&quot; default=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;arg name=&quot;gui&quot; default=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;arg name=&quot;paused&quot; default=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;!-- The following line causes gzmsg and gzerr messages to be printed to the console</span><br><span class="line">        (even when Gazebo is started through roslaunch) --&gt;</span><br><span class="line">    &lt;arg name=&quot;verbose&quot; default=&quot;false&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--Run Gazebo--&gt;</span><br><span class="line">    &lt;env name=&quot;GAZEBO_MODEL_PATH&quot; value=&quot;$&#123;GAZEBO_MODEL_PATH&#125;:$(find rotors_gazebo)/models&quot;/&gt;</span><br><span class="line">    &lt;env name=&quot;GAZEBO_RESOURCE_PATH&quot; value=&quot;$&#123;GAZEBO_RESOURCE_PATH&#125;:$(find rotors_gazebo)/models&quot;/&gt;</span><br><span class="line">    &lt;include file=&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;&gt;</span><br><span class="line">        &lt;arg name=&quot;world_name&quot; value=&quot;$(find rotors_gazebo)/worlds/$(arg world_name).world&quot; /&gt;</span><br><span class="line">        &lt;arg name=&quot;debug&quot; value=&quot;$(arg debug)&quot; /&gt;</span><br><span class="line">        &lt;arg name=&quot;paused&quot; value=&quot;$(arg paused)&quot; /&gt;</span><br><span class="line">        &lt;arg name=&quot;gui&quot; value=&quot;$(arg gui)&quot; /&gt;</span><br><span class="line">        &lt;arg name=&quot;verbose&quot; value=&quot;$(arg verbose)&quot;/&gt;</span><br><span class="line">    &lt;/include&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--Run UAV model and control node--&gt;</span><br><span class="line">    &lt;group ns=&quot;$(arg mav_name)&quot;&gt;</span><br><span class="line">        &lt;include file=&quot;$(find rotors_gazebo)/launch/spawn_mav.launch&quot;&gt;</span><br><span class="line">        &lt;arg name=&quot;mav_name&quot; value=&quot;$(arg mav_name)&quot; /&gt;</span><br><span class="line">        &lt;arg name=&quot;model&quot; value=&quot;$(find rotors_description)/urdf/mav_generic_odometry_sensor.gazebo&quot; /&gt;</span><br><span class="line">        &lt;arg name=&quot;enable_logging&quot; value=&quot;$(arg enable_logging)&quot; /&gt;</span><br><span class="line">        &lt;arg name=&quot;enable_ground_truth&quot; value=&quot;$(arg enable_ground_truth)&quot; /&gt;</span><br><span class="line">        &lt;arg name=&quot;log_file&quot; value=&quot;$(arg log_file)&quot;/&gt;</span><br><span class="line">        &lt;/include&gt;</span><br><span class="line"></span><br><span class="line">        &lt;node name=&quot;lee_position_controller_node&quot; pkg=&quot;rotors_control&quot; type=&quot;lee_position_controller_node&quot; output=&quot;screen&quot;&gt;</span><br><span class="line">        &lt;rosparam command=&quot;load&quot; file=&quot;$(find rotors_gazebo)/resource/lee_controller_$(arg mav_name).yaml&quot; /&gt;</span><br><span class="line">        &lt;rosparam command=&quot;load&quot; file=&quot;$(find rotors_gazebo)/resource/$(arg mav_name).yaml&quot; /&gt;</span><br><span class="line">        &lt;remap from=&quot;odometry&quot; to=&quot;odometry_sensor1/odometry&quot; /&gt;</span><br><span class="line">        &lt;/node&gt;</span><br><span class="line"></span><br><span class="line">        &lt;node name=&quot;robot_state_publisher&quot; pkg=&quot;robot_state_publisher&quot; type=&quot;robot_state_publisher&quot; /&gt;</span><br><span class="line">        &lt;node name=&quot;joint_state_publisher&quot; pkg=&quot;joint_state_publisher&quot; type=&quot;joint_state_publisher&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--name属性用来定义节点运行的名称。pkg定义节点所在的功能包名称，type定义节点的可执行文件名称，这两个属性等同于在终端中使用rosrun命令执行节点时的输入参数--&gt;</span><br><span class="line">        &lt;node </span><br><span class="line">            name=&quot;control_test&quot; pkg=&quot;uav_tracking&quot; type=&quot;control_test&quot; output=&quot;screen&quot;&gt;</span><br><span class="line">            &lt;param name=&quot;mav_name&quot; type=&quot;string&quot; value=&quot;$(arg mav_name)&quot;/&gt;</span><br><span class="line">         &lt;/node&gt;  </span><br><span class="line">    &lt;/group&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure>

<h2 id="6-在-uav-tracking-CMakeLists-txt-添加编译"><a href="#6-在-uav-tracking-CMakeLists-txt-添加编译" class="headerlink" title="6. 在 uav_tracking/CMakeLists.txt 添加编译"></a>6. 在 <code>uav_tracking/CMakeLists.txt</code> 添加编译</h2><p>在<code>uav_tracking/CMakeLists.txt</code>文件最下方添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_executable(control_test src/control_test.cpp)</span><br><span class="line">target_link_libraries(control_test $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="7-编译"><a href="#7-编译" class="headerlink" title="7. 编译"></a>7. 编译</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/rotors_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>

<h2 id="8-运行"><a href="#8-运行" class="headerlink" title="8. 运行"></a>8. 运行</h2><p>重启终端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/rotors_ws/devel/setup.bash</span><br><span class="line">roslaunch uav_tracking control_test.launch</span><br></pre></td></tr></table></figure>

<p>如果启动成功，就可以看到程序自动启动仿真，无人机根据<code>control_test.cpp</code>的代码开始自己运动</p>
<h1 id="tracking-包的使用"><a href="#tracking-包的使用" class="headerlink" title="tracking 包的使用"></a>tracking 包的使用</h1><p><a href="https://suzhilong.github.io/2021/01/21/rotorsTracking/">基于ROS的无人机跟踪：tracking package</a></p>
<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul>
<li><a href="https://github.com/ethz-asl/rotors_simulator">rotors_simulator项目</a></li>
<li><a href="https://github.com/suzhilong/uav_tracking">uav_tracking包</a></li>
<li><a href="http://wiki.ros.org/rotors_simulator">rotors_simulator ROS wiki</a></li>
<li><a href="https://www.guyuehome.com/7598">rotors无人机仿真</a></li>
<li><a href="https://www.guyuehome.com/16351">无人机ROS仿真包 rotors_simulator 编译教程</a></li>
<li><a href="https://www.guyuehome.com/21614">无人机ROS仿真包 rotors_simulator 使用教程</a></li>
</ul>
]]></content>
      <categories>
        <category>robot</category>
      </categories>
      <tags>
        <tag>Drone</tag>
      </tags>
  </entry>
  <entry>
    <title>使用NodeJs和VueJs搭建网站</title>
    <url>/2020/12/15/vue/</url>
    <content><![CDATA[<h1 id="一、工具"><a href="#一、工具" class="headerlink" title="一、工具"></a>一、工具</h1><h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><p>Vue是一套用于构建用户界面的渐进式框架。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p>
<p><a href="https://cn.vuejs.org/">Vue官方网站</a></p>
<h2 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h2><p>一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。</p>
<p><a href="https://element.eleme.cn/#/zh-CN/component/installation">ElementUI官网</a></p>
<p>可以直接去官网的<strong>组件</strong>中，选择想要的组件，复制代码直接使用。</p>
<h2 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h2><p>Node.js 是能够在服务器端运行JavaScript 的开放源代码、跨平台 JavaScript 运行环境。</p>
<p>安装：<code>sudo apt-get install nodejs</code></p>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>npm 是 Node.js 官方提供的包管理工具，他已经成了 Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。</p>
<span id="more"></span>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>sudo apt-get install nodejs</code></p>
<p><em>ps. 安装完后需要使用<code>npm config set registry https://registry.npm.taobao.org</code>切换成淘宝镜像，不然速度很慢。</em></p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><code>npm i -g n</code></p>
<p><code>n latest</code></p>
<h2 id="安装vue"><a href="#安装vue" class="headerlink" title="安装vue"></a>安装vue</h2><p><code>npm i -g @vue/cli</code></p>
<h2 id="服务端后台常驻进程"><a href="#服务端后台常驻进程" class="headerlink" title="服务端后台常驻进程"></a>服务端后台常驻进程</h2><p><code>npm i -g nodemon</code></p>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>一个数据库</p>
<p><a href="https://docs.mongodb.com/manual/installation/">官网安装步骤</a></p>
<p>或</p>
<p><code>sudo apt-get install mongodb-server</code></p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx是异步框架的网页服务器，也可以用作反向代理、负载平衡器和HTTP缓存。简单来说，就是通过服务器通过Nginx替你找到html文件。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p><code>sudo apt-get install nginx</code></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol>
<li><p>在线配置nginx：<a href="http://nginxedit.cn/">Go Nginx config</a></p>
</li>
<li><p>根据要求依次选择相应的</p>
<ul>
<li><strong>网站配置</strong>选项：Preset，域名等等</li>
<li><strong>全局配置</strong>选项：刚开始基本不用管</li>
</ul>
</li>
<li><p>下载&#x2F;复制config文件</p>
</li>
<li><p>把config文件复制到服务器的<code>/etc/nginx/sites-available/</code>文件夹中，再在<code>/etc/nginx/sites-enabled/</code>中创建一个软连接指向<code>/etc/nginx/sites-available/</code>中的config文件</p>
<p> 例如域名为<code>test.com</code>：<br> <code>cp sites-available/test.com.conf /etc/nginx/sites-available/</code></p>
<p> <code>cd /etc/nginx/sites-avaible</code></p>
<p> <code>sudo ln -s ../sites-available/test* /etc/nginx/sites-enabled/</code> </p>
</li>
<li><p>Change <a href="mailto:&#109;&#101;&#64;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d;">&#109;&#101;&#64;&#101;&#x78;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d;</a> to your email<br> <code>sudo certbot --non-interactive --redirect --agree-tos --nginx -d test.com -m me@example.com</code></p>
</li>
</ol>
<h1 id="二、搭建项目"><a href="#二、搭建项目" class="headerlink" title="二、搭建项目"></a>二、搭建项目</h1><p><a href="https://github.com/suzhilong/RCAR2021web_frontEnd">示例项目</a></p>
<h2 id="项目初始化及其框架"><a href="#项目初始化及其框架" class="headerlink" title="项目初始化及其框架"></a>项目初始化及其框架</h2><p>以示例项目为例：</p>
<ul>
<li><code>admin</code>是管理员界面项目，可以用<code>vue create admin</code>来创建，里面包含<code>public</code>和<code>src</code>文件夹，<code>src</code>文件夹就是源代码所在文件夹</li>
<li><code>desktop</code>是pc桌面界面项目，可以用<code>vue create desktop</code>来创建</li>
<li><code>web</code>是移动端界面项目，可以用<code>vue create web</code>来创建</li>
<li><code>server</code>是nodejs组成的服务端项目，包括给后台和前端提供的接口。<ul>
<li>使用<code>mkdir server</code>创建文件夹后<code>cd server</code>，使用<code>npm init -y</code>初始化一个node项目（会生成一个<code>package.json</code>文件）</li>
<li>再在文件夹里新建一个<code>index.js</code>作为服务端入口文件</li>
<li>在<code>package.json</code>的<code>scripts</code>中，插入一行<code>&quot;serve&quot;: &quot;nodemon index.js&quot;,</code>。这样就可以在server中使用<code>npm run serve</code>来运行服务器项目</li>
</ul>
</li>
</ul>
<p>初始化完以后就可以cd进各个文件夹使用<code>npm run serve</code>本地运行，查看每个项目的效果。</p>
<p><em>ps: 如果提示错误，可以先使用<code>npm i</code>安装依赖</em></p>
<h2 id="安装elementUI和路由"><a href="#安装elementUI和路由" class="headerlink" title="安装elementUI和路由"></a>安装elementUI和路由</h2><p>在<code>admin</code>和<code>desktop</code>中，使用<code>vue add element</code>安装ElementUI，<code>vue add router</code>安装路由。</p>
<h2 id="vue项目文件说明"><a href="#vue项目文件说明" class="headerlink" title="vue项目文件说明"></a>vue项目文件说明</h2><p>以<code>admin</code>为例：</p>
<ul>
<li><code>public</code>可以先不管</li>
<li><code>src</code>是项目源代码<ul>
<li><code>components</code>是组件文件夹</li>
<li><code>views</code>存放的主要是总体页面的代码，<code>views</code>中新建.vue文件后，需要再<code>../router.js</code>中增加路由</li>
</ul>
</li>
</ul>
<h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><h3 id="服务器系统设置"><a href="#服务器系统设置" class="headerlink" title="服务器系统设置"></a>服务器系统设置</h3><h4 id="Install-Packages"><a href="#Install-Packages" class="headerlink" title="Install Packages"></a>Install Packages</h4><ol>
<li><p>Install Nodejs </p>
<p> <code>sudo apt-get install nodejs</code></p>
</li>
<li><p>Install npm</p>
<p> <code>sudo apt-get install npm</code></p>
</li>
<li><p>Config Taobao registry</p>
<p> <code>npm config set registry https://registry.npm.taobao.org</code></p>
</li>
<li><p>Update Nodejs</p>
<p> <code>npm i -g n</code></p>
<p> <code>n latest</code></p>
<p> Reload cmd shell</p>
</li>
<li><p>Install pm2</p>
<p> <code>npm i -g pm2</code></p>
</li>
<li><p>Install Mongodb</p>
<p> <code>sudo apt-get install mongodb-server</code></p>
</li>
<li><p>Install Nginx</p>
<p> <code>sudo apt-get install nginx</code></p>
</li>
<li><p>Install certbot</p>
<p> <code>sudo apt install -y nginx certbot python-certbot-nginx</code></p>
</li>
</ol>
<h4 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd desktop</span><br><span class="line">npm i</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure>
<p><code>npm run build</code>可以编译成静态html文件，直接打开</p>
<p>把<code>npm run build</code>改为<code>npm run server</code>可以在本地测试网站效果</p>
<p><strong>注意</strong>：<code>build</code>之前需要把对应文件夹里的<code>vue.config.js</code>（如：<code>desktop/vue.config.js</code>）中的<code>publicPath</code>的<code>/</code>改为<code>./</code>。<code>outputDir:</code>可以改为你想要编译到的目的路径</p>
<p>以示例项目为例，build 后在<code>desktop</code>中生产的<code>dist</code>文件夹就是静态html文件目录，点击<code>dist/index.html</code>就可以打开网站，把生成的<code>dist</code>文件夹里的文件放到服务器的对应文件夹就可以访问了。</p>
<h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ul>
<li><a href="https://www.bilibili.com/video/BV1A4411Y7fi">学习视频</a></li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程笔记</title>
    <url>/2020/10/15/%E5%90%8E%E7%AB%AF/</url>
    <content><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h2><p><strong>大端</strong>：高位存在低地址，低位存在高地址。</p>
<p><strong>小端</strong>：高位存在高地址，低位存在低地址。</p>
<p>大小端和CPU有关。</p>
<p>现代PC大多采用小段，所以<strong>小端字节序</strong>又被成为<strong>主机字节序</strong>。而<strong>大端字节序</strong>又被成为<strong>网络字节序</strong>。</p>
<span id="more"></span>

<h2 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h2><p>TCP: recv, send</p>
<p>UDP: recvfrom, sendto(也可以面向连接)</p>
<p>通用: recvmsg, sendmsg</p>
<h2 id="网络I-x2F-O"><a href="#网络I-x2F-O" class="headerlink" title="网络I&#x2F;O"></a>网络I&#x2F;O</h2><ul>
<li>管道：<code>ini pipi(int fd[2]);</code></li>
<li>双向管道：<code>ini socketpair(int domain, int type, int protocol, int fd[2]);</code> </li>
<li>分散读：<code>readv</code>、集中写：<code>writev</code></li>
<li>两个文件描述符之间传递数据：<code>sendfile</code></li>
<li>进程间通信共享内存：申请<code>mmap</code>, 释放<code>munmap</code></li>
<li>两个文件描述符之间移动数据：<code>splice</code></li>
<li>两个管道文件描述符间复制数据：<code>tee</code></li>
<li>文件描述符的各种控制：<code>fcntl</code></li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul>
<li><code>syslog</code></li>
<li><code>rsyslogd</code></li>
</ul>
<h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><ul>
<li><code>getuid</code>, <code>geteuid</code>, <code>getgid</code>, <code>getegid</code>, <code>getpgid</code>, <code>getsid</code></li>
<li><code>setuid</code>, <code>seteuid</code>, <code>setgid</code>, <code>setegid</code>, <code>setpgid</code>, <code>setsid</code></li>
</ul>
<h2 id="服务器框架"><a href="#服务器框架" class="headerlink" title="服务器框架"></a>服务器框架</h2><h3 id="TCP客户端与服务器工作流程"><a href="#TCP客户端与服务器工作流程" class="headerlink" title="TCP客户端与服务器工作流程"></a>TCP客户端与服务器工作流程</h3><p><img src="https://i.loli.net/2020/10/13/5sLG28gmfFzpJD4.png" alt="TCP客户端与服务器工作流程"></p>
<h3 id="I-x2F-O模型"><a href="#I-x2F-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h3><ul>
<li>同步<ul>
<li>阻塞I&#x2F;O</li>
<li>I&#x2F;O复用</li>
<li>信号驱动I&#x2F;O</li>
</ul>
</li>
<li>异步</li>
</ul>
<h4 id="I-x2F-O复用"><a href="#I-x2F-O复用" class="headerlink" title="I&#x2F;O复用"></a>I&#x2F;O复用</h4><ul>
<li><p>select，监听文件描述符。O(n)的无差别轮询，最大连接数1024。</p>
</li>
<li><p>poll，轮询文件描述符。也是O(n)的无差别轮询，但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p>
</li>
<li><p>epoll。可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I&#x2F;O事件通知我们。复杂度降低到了O(1)。</p>
<ul>
<li><strong>LT</strong>模式，<strong>ET</strong>模式</li>
<li><code>epoll_create</code></li>
<li><code>epoll_ctl</code></li>
<li><code>epoll_wait</code></li>
</ul>
</li>
</ul>
<p>ref. </p>
<ul>
<li><a href="https://www.cnblogs.com/aspirant/p/9166944.html">select、poll、epoll之间的区别</a></li>
<li><a href="https://www.cnblogs.com/anker/p/3265058.html">select、poll、epoll之间的区别总结</a></li>
</ul>
<h3 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h3><ul>
<li>Reactor</li>
<li>Proactor</li>
</ul>
<h3 id="并发模式"><a href="#并发模式" class="headerlink" title="并发模式"></a>并发模式</h3><ul>
<li>半同步&#x2F;半异步 (变体)&#x3D;&gt; 半同步&#x2F;半反应堆</li>
<li>领导者&#x2F;追随者</li>
</ul>
<h3 id="池"><a href="#池" class="headerlink" title="池"></a>池</h3><ul>
<li>内存池</li>
<li>进程池</li>
<li>线程池</li>
<li>连接池</li>
</ul>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><ul>
<li><code>kill</code></li>
<li><code>SIG_IGN</code></li>
<li><code>SIG_DFL</code></li>
<li><code>SIGHUP</code>, <code>SIGPIPE</code>, <code>SIGGURG</code></li>
</ul>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="Linux定时方法"><a href="#Linux定时方法" class="headerlink" title="Linux定时方法"></a>Linux定时方法</h3><ol>
<li>socket方法<ul>
<li><code>SO_RCVTIMEO</code></li>
<li><code>SO_SNDTIMEO</code></li>
</ul>
</li>
<li><code>SIGALRM</code></li>
<li>I&#x2F;O复用系统调用的超时参数</li>
</ol>
<h3 id="高性能定时器"><a href="#高性能定时器" class="headerlink" title="高性能定时器"></a>高性能定时器</h3><ol>
<li>时间轮</li>
<li>时间堆</li>
</ol>
<h2 id="I-x2F-O框架库-Libevent"><a href="#I-x2F-O框架库-Libevent" class="headerlink" title="I&#x2F;O框架库 Libevent"></a>I&#x2F;O框架库 Libevent</h2><h3 id="Linux服务器必须处理的3件事"><a href="#Linux服务器必须处理的3件事" class="headerlink" title="Linux服务器必须处理的3件事"></a>Linux服务器必须处理的3件事</h3><ol>
<li>I&#x2F;O 时间</li>
<li>信号</li>
<li>定时器</li>
</ol>
<h3 id="基于Reactor的框架库"><a href="#基于Reactor的框架库" class="headerlink" title="基于Reactor的框架库"></a>基于Reactor的框架库</h3><ol>
<li>句柄</li>
<li>事件多路分发器</li>
<li>事件处理器和具体事件处理器</li>
<li>Reactor<ul>
<li>handle_event</li>
<li>register_handler</li>
<li>remove_handler</li>
</ul>
</li>
</ol>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><ul>
<li><code>fork</code></li>
<li><code>exec</code> 系列</li>
<li>僵尸进程<ul>
<li><code>wait</code></li>
<li><code>waitpid</code></li>
</ul>
</li>
</ul>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><ul>
<li>管道 (pipe)</li>
<li>信号量 (Semaphore): P, V.<ul>
<li><code>semget</code></li>
<li><code>semop</code></li>
<li><code>semctl</code></li>
<li><code>IPC_PRIVATE</code></li>
</ul>
</li>
<li>共享内存<ul>
<li><code>shmget</code></li>
<li><code>shmat</code></li>
<li><code>shmdt</code></li>
<li><code>shmctl</code></li>
</ul>
</li>
<li>消息队列<ul>
<li><code>msgget</code></li>
<li><code>msgsnd</code></li>
<li><code>msgrcv</code></li>
<li><code>msgctl</code></li>
</ul>
</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ol>
<li>LinuxThreads</li>
<li>NPTL</li>
</ol>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li>pthread_creatr</li>
<li>pthread_exit</li>
<li>pthread_join</li>
<li>pthread_cancel</li>
</ul>
<h3 id="线程间同步"><a href="#线程间同步" class="headerlink" title="线程间同步"></a>线程间同步</h3><ul>
<li>POSIX信号量: <code>sem_xxx</code></li>
<li>互斥量: <code>pthread_mutex_xxx</code></li>
<li>条件变量: <code>pthread_cond_xxx</code></li>
<li>线程同步机制类: <code>locker.h</code></li>
<li>进程和线程: <code>pthread_atfork</code></li>
<li>线程和信号: <code>pthread_sigmask</code></li>
</ul>
<h2 id="进程池和线程池"><a href="#进程池和线程池" class="headerlink" title="进程池和线程池"></a>进程池和线程池</h2><ul>
<li>随机算法、Round Robin、工作队列</li>
<li>半同步&#x2F;半异步进程池实现</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li>游双. Linux高性能服务器编程. 机械工业出版社</li>
<li>徐晓鑫. 后台开发：核心技术与应用实践. 机械工业出版社</li>
</ul>
]]></content>
      <categories>
        <category>back-end</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>笔试输入输出总结</title>
    <url>/2020/07/11/cin_cout/</url>
    <content><![CDATA[<h1 id="常见输入"><a href="#常见输入" class="headerlink" title="常见输入"></a>常见输入</h1><p>常见机试输入</p>
<span id="more"></span>
<h2 id="输入一个数字再加上空格间隔的数组，并且给了数组元素个数n"><a href="#输入一个数字再加上空格间隔的数组，并且给了数组元素个数n" class="headerlink" title="输入一个数字再加上空格间隔的数组，并且给了数组元素个数n"></a>输入一个数字再加上空格间隔的数组，并且给了数组元素个数n</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">vector&lt;int&gt; input(n);</span><br><span class="line">for(int i = 0; i &lt; n; i++)</span><br><span class="line">    cin &gt;&gt; input[i];</span><br></pre></td></tr></table></figure>
<h2 id="输入一个数字再加上空格间隔的数组，但是没有给数组元素个数n"><a href="#输入一个数字再加上空格间隔的数组，但是没有给数组元素个数n" class="headerlink" title="输入一个数字再加上空格间隔的数组，但是没有给数组元素个数n"></a>输入一个数字再加上空格间隔的数组，但是没有给数组元素个数n</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a;</span><br><span class="line">vector&lt;int&gt; input;</span><br><span class="line">while(cin &gt;&gt; a)&#123;</span><br><span class="line">    input.push_back(a);</span><br><span class="line">    if(cin.get() == &#x27;\n&#x27;)</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="给你输入的数据组数t，和很多组数据。这些数据有换行，但是数组元素个数都没有给"><a href="#给你输入的数据组数t，和很多组数据。这些数据有换行，但是数组元素个数都没有给" class="headerlink" title="给你输入的数据组数t，和很多组数据。这些数据有换行，但是数组元素个数都没有给"></a>给你输入的数据组数t，和很多组数据。这些数据有换行，但是数组元素个数都没有给</h2><p>比如：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3            //有3组数据</span><br><span class="line">1 2 3 4 5    //第一组数据A</span><br><span class="line">2 4 5 3 6    //第一组数据B</span><br><span class="line">3 4 6        //第二组数据A</span><br><span class="line">2 2 5        //第二组数据B</span><br><span class="line">1            //第三组数据A</span><br><span class="line">0            //第三组数据B</span><br></pre></td></tr></table></figure>
<p>因为没有给每行数据的个数，所以一行数据输入完成时需要识别<strong>换行符</strong>。<br>输入方法：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int t, a;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">vector&lt;int&gt; A, B;</span><br><span class="line">for(int i = 0; i &lt; 2*t; i++)&#123;</span><br><span class="line">    while(cin &gt;&gt; a)&#123;</span><br><span class="line">        A.push_back(a);</span><br><span class="line">        if (cin.get() == &#x27;\n&#x27;) </span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    while(cin &gt;&gt; a)&#123;</span><br><span class="line">        B.push_back(a);</span><br><span class="line">        if (cin.get() == &#x27;\n&#x27;) </span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不存在空格的字符数组"><a href="#不存在空格的字符数组" class="headerlink" title="不存在空格的字符数组"></a>不存在空格的字符数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br></pre></td></tr></table></figure>

<h2 id="输入带有空格的字符数组"><a href="#输入带有空格的字符数组" class="headerlink" title="输入带有空格的字符数组"></a>输入带有空格的字符数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">getline(cin, s);</span><br></pre></td></tr></table></figure>

<h2 id="输入多个整数"><a href="#输入多个整数" class="headerlink" title="输入多个整数"></a>输入多个整数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a,b,c,d;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br></pre></td></tr></table></figure>

<h1 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h1><h2 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h2><ul>
<li><code>getline(istream&amp; is, string&amp; str);</code> 把is传到str中</li>
<li><code>getline(istream&amp; is, string&amp; str, char delim);</code> delim是截断字符，可以用来分割字符串<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sstream&gt;</span><br><span class="line"></span><br><span class="line">string s = &quot;alice,20,800,sz&quot;;</span><br><span class="line"></span><br><span class="line">istringstream is(s);</span><br><span class="line">string str;</span><br><span class="line">std::getline(is, str); //str: alice,20,800,sz</span><br><span class="line">std::getline(is, str, &#x27;,&#x27;); //str: alice</span><br></pre></td></tr></table></figure></li>
</ul>
<p>输入：<code>[1,1,1,1,2,1,1],[5,2,5,4,5,1,6]</code>。要求提取出数字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    string sw, sh;</span><br><span class="line">    getline(cin, sw, &#x27;]&#x27;);</span><br><span class="line">    getline(cin, sh, &#x27;]&#x27;);</span><br><span class="line"></span><br><span class="line">    istringstream isw(sw.substr(1)), ish(sh.substr(2));</span><br><span class="line">    </span><br><span class="line">    string tmp;</span><br><span class="line">    vector&lt;int&gt; width, height;</span><br><span class="line">    while (getline(isw, tmp, &#x27;,&#x27;))</span><br><span class="line">        width.push_back(stoi(tmp));</span><br><span class="line">    while (getline(ish, tmp, &#x27;,&#x27;))</span><br><span class="line">        height.push_back(stoi(tmp));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="输出精度控制"><a href="#输出精度控制" class="headerlink" title="输出精度控制"></a>输出精度控制</h1><p>如：输出保留2位小数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double d = 1.666666;</span><br><span class="line">//c++</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">cout &lt;&lt; setprecision(3) &lt;&lt; d &lt;&lt; endl; //1.67</span><br><span class="line">//c</span><br><span class="line">printf(&quot;%.2f\n&quot;, d); //1.67</span><br></pre></td></tr></table></figure>

<h1 id="OJ练习"><a href="#OJ练习" class="headerlink" title="OJ练习"></a>OJ练习</h1><p><a href="https://ac.nowcoder.com/acm/contest/320#question">牛客</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>基于ROS的无人机跟踪：tracking package</title>
    <url>/2021/01/21/rotorsTracking/</url>
    <content><![CDATA[<ul>
<li>无人机仿真：<a href="https://suzhilong.github.io/2021/01/20/rotorsSimulator/">rotors_simulator</a></li>
<li><a href="https://github.com/suzhilong/uav_tracking">uav_tracking项目代码</a></li>
</ul>
<h1 id="下载编译"><a href="#下载编译" class="headerlink" title="下载编译"></a>下载编译</h1><h2 id="克隆-package"><a href="#克隆-package" class="headerlink" title="克隆 package"></a>克隆 package</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/rotors_ws/src/</span><br><span class="line">git clone https://github.com/suzhilong/uav_tracking.git</span><br></pre></td></tr></table></figure>

<h2 id="复制-world文件："><a href="#复制-world文件：" class="headerlink" title="复制.world文件："></a>复制<code>.world</code>文件：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp ~/rotors_ws/src/uav_tracking/worlds/tracking_scen.world ~/rotors_ws/src/rotors_simulator/rotors_gazebo/worlds/</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/rotors_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<p>然后<strong>重启终端</strong></p>
<span id="more"></span>

<h1 id="tracking-包的使用"><a href="#tracking-包的使用" class="headerlink" title="tracking 包的使用"></a>tracking 包的使用</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/rotors_ws</span><br><span class="line">source ./devel/setup.bash</span><br></pre></td></tr></table></figure>

<h2 id="录制-ros-bag"><a href="#录制-ros-bag" class="headerlink" title="录制 ros bag"></a>录制 ros bag</h2><p>录制需要的话题，就可以避免每次仿真都打开<code>gazebo</code>：</p>
<h3 id="运行-launch-文件"><a href="#运行-launch-文件" class="headerlink" title="运行 launch 文件"></a>运行 launch 文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">roslaunch uav_tracking video_record.launch</span><br></pre></td></tr></table></figure>

<h3 id="录制话题"><a href="#录制话题" class="headerlink" title="录制话题"></a>录制话题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rosbag record -o [BAGNAME] /topic1/xxx /topic2/xxx</span><br></pre></td></tr></table></figure>

<p>话题可以使用<code>rostopic list</code>查看。例如我要录制相机采集的视频：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rosbag record -o video /firefly/vi_sensor/left/image_raw</span><br></pre></td></tr></table></figure>
<p>按 <code>ctrl + c</code> 结束录制</p>
<h3 id="rosbag-回放"><a href="#rosbag-回放" class="headerlink" title="rosbag 回放"></a>rosbag 回放</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rosbag play -l [bagNAME]</span><br></pre></td></tr></table></figure>

<h2 id="rosbag-转-MP4"><a href="#rosbag-转-MP4" class="headerlink" title="rosbag 转 MP4"></a>rosbag 转 MP4</h2><h3 id="1-bag2img-launch"><a href="#1-bag2img-launch" class="headerlink" title="1. bag2img.launch"></a>1. <a href="https://github.com/suzhilong/uav_tracking/blob/main/launch/bag2img.launch">bag2img.launch</a></h3><p>在<code>uav_tracking/launch</code>目录下新建<a href="https://github.com/suzhilong/uav_tracking/blob/main/launch/bag2img.launch">bag2img.launch</a>，写入下面内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">  &lt;node pkg=&quot;rosbag&quot; type=&quot;play&quot; name=&quot;rosbag&quot; args=&quot;-d 2 [BAGPATH]/xx.bag&quot;/&gt;</span><br><span class="line">  &lt;node name=&quot;extract&quot; pkg=&quot;image_view&quot; type=&quot;extract_images&quot; respawn=&quot;false&quot; output=&quot;screen&quot; cwd=&quot;ROS_HOME&quot;&gt;</span><br><span class="line">&lt;remap from=&quot;image&quot; to=&quot;/[your_topic]&quot;/&gt;</span><br><span class="line">  &lt;/node&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>[BAGPATH]&#x2F;xx.bag需要替换成自己的bag路径</li>
<li><code>remap</code>中的<code>/[your_topic]</code>需要替换为自己图片的话题</li>
</ul>
<h3 id="2-运行launch文件"><a href="#2-运行launch文件" class="headerlink" title="2. 运行launch文件"></a>2. 运行launch文件</h3><p><code>source</code> 后运行这个launch文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/rotors_ws/devel/setup.bash</span><br><span class="line">roslaunch bag2img.launch</span><br></pre></td></tr></table></figure>
<p>成功后会在<code>~/.ros</code>文件夹中生成命名格式为<code>framexxxx.jpg</code>（如<code>frame0000.jpg</code>）的图片</p>
<h3 id="3-移动图片"><a href="#3-移动图片" class="headerlink" title="3. 移动图片"></a>3. 移动图片</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir ~/rotors_ws/imgs</span><br><span class="line">mv ~/.ros/frame*.jpg ~/rotors_ws/imgs/</span><br></pre></td></tr></table></figure>

<h3 id="4-图片序列转MP4"><a href="#4-图片序列转MP4" class="headerlink" title="4. 图片序列转MP4"></a>4. 图片序列转MP4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -r 10  -s 752*480 -i frame%04d.jpg uav_record.mp4</span><br></pre></td></tr></table></figure>
<p><em>ps: -r 后是帧率，-s后是分辨率，-i后是图片名，最后是输出视频名</em></p>
<h2 id="tracking"><a href="#tracking" class="headerlink" title="tracking"></a>tracking</h2><h3 id="OpenCV-contrib-安装"><a href="#OpenCV-contrib-安装" class="headerlink" title="OpenCV_contrib 安装"></a>OpenCV_contrib 安装</h3><ol>
<li>安装<a href="https://opencv.org/">OpenCV</a> （已经安装好的使用命令<code>pkg-config opencv --modversion</code>查看安装的OpenCV版本）</li>
<li>下载对应的 <a href="https://github.com/opencv/opencv_contrib">OpenCV_contrib</a>（点击<code>tag</code>找到所需版本）</li>
<li>将解压后的<code>OpenCV_contrib</code>文件夹移到<code>opencv</code>根目录下</li>
<li>安装依赖 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line">sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</span><br></pre></td></tr></table></figure></li>
<li>进入 <code>opencv/build</code> （如果没有<code>build</code>，就新建一个<code>build</code>文件夹） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake -D CMAKE_INSTALL_PREFIX=/usr/local -D CMAKE_BUILD_TYPE=Release -D OPENCV_EXTRA_MODULES_PATH=../opencv_contrib-3.4.0/modules ..</span><br></pre></td></tr></table></figure>
 <strong>注意：参数 OPENCV_EXTRA_MODULES_PATH 中的opencv_contrib-3.4.0 就是 opencv_contrib 解压后移动到 opencv 目录下名字</strong></li>
<li>编译安装 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make -j8</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="img-tracking-cpp"><a href="#img-tracking-cpp" class="headerlink" title="img_tracking.cpp"></a><a href="https://github.com/suzhilong/uav_tracking/blob/main/src/img_tracking.cpp">img_tracking.cpp</a></h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li><p>先<code>roslaunch</code> uav 的仿真 或 <code>rosbag play</code>录制好的bag文件</p>
</li>
<li><ul>
<li>可以进入<code>~/rotors_ws/devel/lib/usv_tracking/</code>后使用<code>./img_tracking</code>运行视频目标跟踪程序</li>
<li>也可以<code>source ~/rotors_ws/devel/setup.bash</code>后直接使用<code>rosrun uav_tracking img_tracking</code>执行视频目标跟踪程序</li>
</ul>
</li>
</ol>
<h4 id="跟踪目标边框初始化"><a href="#跟踪目标边框初始化" class="headerlink" title="跟踪目标边框初始化"></a>跟踪目标边框初始化</h4><p>在<code>img_tracking.cpp</code>中，有两种方法初始化目标在第一帧的位置和大小：</p>
<ol>
<li><p>初始化检测框的坐标和大小</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boundingBox.x = 350;</span><br><span class="line">boundingBox.y = 200;</span><br><span class="line">boundingBox.width = 100;</span><br><span class="line">boundingBox.height = 80;</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动框选：<code>1.</code> 中的代码注释掉，使用下面代码：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boundingBox = selectROI(curFrame, false);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="test-tracking-cpp"><a href="#test-tracking-cpp" class="headerlink" title="test_tracking.cpp"></a><a href="https://github.com/suzhilong/uav_tracking/blob/main/src/test_tracking.cpp">test_tracking.cpp</a></h3><p>这个文件是用来测试仿真uav录制视频的跟踪的。</p>
<h4 id="修改跟踪目标文件"><a href="#修改跟踪目标文件" class="headerlink" title="修改跟踪目标文件"></a>修改跟踪目标文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VideoCapture video(&quot;[video_path]/[video_name].mp4&quot;);</span><br></pre></td></tr></table></figure>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure>
<p>新开一个终端，并且source一下，然后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rosrun uav_tracking test_tracking</span><br></pre></td></tr></table></figure>
<p>接着就会出现视频的第一帧，用鼠标框选出跟踪的目标，按回车就可以看到开始跟踪了。</p>
<p><img src="https://i.loli.net/2021/01/30/Ulr3SC7Rjd8Pq4u.gif" alt="tracking480.gif"></p>
<h3 id="uav-tracking-cpp"><a href="#uav-tracking-cpp" class="headerlink" title="uav_tracking.cpp"></a><a href="https://github.com/suzhilong/uav_tracking/blob/main/src/uav_tracking.cpp">uav_tracking.cpp</a></h3><h4 id="打开-gazebo"><a href="#打开-gazebo" class="headerlink" title="打开 gazebo"></a>打开 gazebo</h4><p>随便打开一个有 <code>rotors</code> 的 <code>gazebo</code> 世界，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">roslaunch uav_tracking video_record.launch</span><br></pre></td></tr></table></figure>
<h4 id="加载-turtlebot-到-gazebo"><a href="#加载-turtlebot-到-gazebo" class="headerlink" title="加载 turtlebot 到 gazebo"></a>加载 turtlebot 到 gazebo</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">roslaunch uav_tracking add_turtlebot.launch</span><br></pre></td></tr></table></figure>
<h4 id="使用跟踪"><a href="#使用跟踪" class="headerlink" title="使用跟踪"></a>使用跟踪</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rosrun uav_tracking uav_tracking</span><br></pre></td></tr></table></figure>

<p>然后选中turtlebot</p>
<h4 id="键盘控制turtlebot移动"><a href="#键盘控制turtlebot移动" class="headerlink" title="键盘控制turtlebot移动"></a>键盘控制turtlebot移动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">roslaunch turtlebot_teleop keyboard_teleop.launch</span><br></pre></td></tr></table></figure>

<p>就可以看到无人机跟随turtlebot运动了。</p>
<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul>
<li><a href="https://www.guyuehome.com/4748">为了实现高效的人体跟踪，我测试了这些开源CV算法</a></li>
<li><a href="https://www.guyuehome.com/17372">(Python)从零开始,简单快速学机器仿人视觉Opencv—运用五：物体运动跟踪</a></li>
<li><a href="https://www.guyuehome.com/18855">ROS实现无人机目标跟踪&#x2F;物体跟随&#x2F;循迹</a></li>
<li><a href="https://www.guyuehome.com/18055">基于ROS搭建简易软件框架实现ROV水下目标跟踪（十四完结）–目标跟踪模块</a></li>
<li><a href="https://github.com/aws-robotics/aws-robomaker-racetrack-world#aws-robomaker-racetrack-world-ros-package">赛道环境ROS包</a></li>
<li><a href="https://github.com/leggedrobotics/darknet_ros">YOLO_ROS包</a></li>
<li><a href="https://blog.csdn.net/LuohenYJ/article/details/89029816">使用OpenCV实现单目标跟踪</a></li>
<li><a href="https://blog.csdn.net/qq_35781447/article/details/103277509">linux下安装Opencv 和opencv-contrib</a></li>
<li><a href="https://learnopencv.com/object-tracking-using-opencv-cpp-python/">Object Tracking using OpenCV</a></li>
<li><a href="https://blog.csdn.net/qq_42589654/article/details/104246083">ROS基础知识学习笔记（1）—数据类型</a></li>
<li><a href="http://www.voidcn.com/article/p-nexaivrm-uc.html">std_msgs::UInt8MultiArray发布数组</a></li>
<li><a href="http://blog.leanote.com/post/610167078@qq.com/ROS-%E5%9B%BE%E5%83%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%BA%94%E7%94%A8">ROS 图像相关的命令与应用</a></li>
<li><a href="https://www.jianshu.com/p/9a5a0433f5e4">ROS的相机节点</a></li>
<li><a href="https://blog.csdn.net/weixin_40830684/article/details/94054564?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">rosbag转mp4文件</a></li>
</ul>
]]></content>
      <categories>
        <category>robot</category>
      </categories>
      <tags>
        <tag>Drone</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode每日一题 - 2020年八月</title>
    <url>/2020/08/01/LeetcodeDaily_Aug/</url>
    <content><![CDATA[<h1 id="8月3日-415-字符串相加（简单）"><a href="#8月3日-415-字符串相加（简单）" class="headerlink" title="8月3日 415. 字符串相加（简单）"></a>8月3日 <a href="https://leetcode-cn.com/problemset/all/">415. 字符串相加（简单）</a></h1><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p>
<p>注意：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num1 和num2 的长度都小于 5100.</span><br><span class="line">num1 和num2 都只包含数字 0-9.</span><br><span class="line">num1 和num2 都不包含任何前导零。</span><br><span class="line">你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</span><br></pre></td></tr></table></figure>
<p>题解：<br>两个数字位数不同时，在指针当前下标处于负数的时候返回 0，等价于对位数较短的数字进行了补零操作，这样就可以除去两个数字位数不同情况的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string addStrings(string num1, string num2)&#123;</span><br><span class="line">    int i = num1.length() - 1, j = num2.length() - 1, add = 0;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    while (i &gt;= 0 || j &gt;= 0 || carry != 0) &#123;</span><br><span class="line">        int x = i &gt;= 0 ? num1[i] - &#x27;0&#x27; : 0;</span><br><span class="line">        int y = j &gt;= 0 ? num2[j] - &#x27;0&#x27; : 0;</span><br><span class="line">        int result = x + y + carry;</span><br><span class="line">        res.push_back(&#x27;0&#x27; + result % 10);</span><br><span class="line">        carry = result / 10;</span><br><span class="line">        i -= 1;</span><br><span class="line">        j -= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算完以后的答案需要翻转过来</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(max{n1,n2})<br>空间复杂度：O(1)</p>
<h1 id="8月4日-207-课程表（中等）"><a href="#8月4日-207-课程表（中等）" class="headerlink" title="8月4日 207. 课程表（中等）"></a>8月4日 <a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表（中等）</a></h1><p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p>
<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。</span><br><span class="line">你可以假定输入的先决条件中没有重复的边。</span><br><span class="line">1 &lt;= numCourses &lt;= 10^5</span><br></pre></td></tr></table></figure>

<p>题解：  </p>
<ol>
<li>有向图的dfs遍历。<br><code>visited[i]</code>表示第i和节点的状态，0表示没有被访问过，1表示正在被访问，2表示访问结束的节点。<code>circle</code>表示有向图有环。使用dfs遍历有向图：</li>
</ol>
<ul>
<li>当正在访问的节点（visited[i]&#x3D;1）又被访问时，说明有向图存在环，返回false。</li>
<li>全部节点访问完毕，返回true<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void dfs(int u, vector&lt;vector&lt;int&gt; &gt; &amp;graph, vector&lt;int&gt; &amp;visited)&#123;</span><br><span class="line">    visited[u] = 1;//正在访问该节点</span><br><span class="line">    for(int v:graph[u])&#123;</span><br><span class="line">        if(visited[v]==0)&#123;</span><br><span class="line">            dfs(v, graph, visited);</span><br><span class="line">            if(circle)</span><br><span class="line">                return;</span><br><span class="line">        &#125;else if(visited[v]==1)&#123;</span><br><span class="line">            circle = true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123;</span><br><span class="line">    if(prerequisites.empty())</span><br><span class="line">        return true;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graph(numCourses);</span><br><span class="line">    for (auto course : prerequisites)</span><br><span class="line">    &#123;//build graph</span><br><span class="line">        graph[course[1]].push_back(course[0]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; visited(numCourses);</span><br><span class="line">    for (int i = 0; i &lt; numCourses &amp;&amp; !circle; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visited[i])</span><br><span class="line">            dfs(i, graph, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    return !circle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(m+n)。m是有向图的边，n是有向图的节点。<br>空间复杂度：O(m+n)</li>
</ul>
<ol start="2">
<li>bfs入度为0的点<br>拓扑排序中，起点都是入度为0的点。把所有入度为0的节点放入队列，依次访问队列中的节点。访问的时候把所有从该节点出去的边都删掉，即该节点出发连接的边的入度都减1。再把入度减到0的点加入队列。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123;</span><br><span class="line">    if(prerequisites.empty())</span><br><span class="line">        return true;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graph(numCourses);</span><br><span class="line">    vector&lt;int&gt; inDegree(numCourses, 0);</span><br><span class="line">    for (auto course : prerequisites)</span><br><span class="line">    &#123;//build graph</span><br><span class="line">        graph[course[1]].push_back(course[0]);</span><br><span class="line">        inDegree[course[0]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    for (int i = 0; i &lt; numCourses;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(inDegree[i]==0)</span><br><span class="line">            que.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int visited = 0;</span><br><span class="line">    while (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        visited++;</span><br><span class="line">        int u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int v:graph[u])&#123;</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            if(inDegree[v]==0)</span><br><span class="line">                que.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return visited == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(m+n)。m是有向图的边，n是有向图的节点。<br>空间复杂度：O(m+n)</li>
</ol>
<h1 id="真题"><a href="#真题" class="headerlink" title="真题"></a>真题</h1><h2 id="模版匹配"><a href="#模版匹配" class="headerlink" title="模版匹配"></a>模版匹配</h2><p>前面给一个词做模版，看后面的多个词是否能和前面的模版匹配。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：pattern = &quot;noon&quot;, str = &quot;big star star big&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：pattern = &quot;noon&quot;, str = &quot;big star star not&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool testMatch(string pattern, string str) &#123;</span><br><span class="line">    map&lt;string,char&gt; wordMap;</span><br><span class="line">    char used[128] = &#123;0&#125;;</span><br><span class="line">    string word;</span><br><span class="line">    int pos = 0;</span><br><span class="line">    str.push_back(&#x27; &#x27;);</span><br><span class="line">    for (int i = 0; i &lt; str.size();i++)&#123;</span><br><span class="line">        if(str[i]==&#x27; &#x27;)&#123;</span><br><span class="line">            if(pos==pattern.size())</span><br><span class="line">                return false;</span><br><span class="line">            if(wordMap.find(word)==wordMap.end())&#123;</span><br><span class="line">                if(used[pattern[pos]])</span><br><span class="line">                    return false;</span><br><span class="line">                wordMap[word] = pattern[pos];</span><br><span class="line">                used[pattern[pos]] = 1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(wordMap[word]!=pattern[pos])</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">            word = &quot;&quot;;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            word += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(pos!=pattern.size())</span><br><span class="line">        return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找到最小的排列组合数"><a href="#找到最小的排列组合数" class="headerlink" title="找到最小的排列组合数"></a>找到最小的排列组合数</h2><p>找到比原数字位数排列组合后，比原数字大的，最小的数。没有就输出-1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//80%  比如 2231就不对了</span><br><span class="line">int findGreaterNum(int N) &#123;</span><br><span class="line">    string s = to_string(N);</span><br><span class="line">    for (int i = s.size() - 1; i &gt; 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        if (s[i] &gt; s[i - 1])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(s[i], s[i - 1]);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = atoi(s.c_str());</span><br><span class="line">    if (res == N)</span><br><span class="line">        cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">    else </span><br><span class="line">        cout &lt;&lt; res;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1477-找两个和为目标值且不重叠的子数组"><a href="#1477-找两个和为目标值且不重叠的子数组" class="headerlink" title="1477. 找两个和为目标值且不重叠的子数组"></a><a href="https://leetcode-cn.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/">1477. 找两个和为目标值且不重叠的子数组</a></h2><p>给你一个整数数组 arr 和一个整数值 target。</p>
<p>请你在 arr 中找两个互不重叠的子数组 且它们的和都等于 target。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。</p>
<p>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。</p>
<p>题解：<br><code>dp[i]</code>表示i后面和等T的最小子数组长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int minSumOfLengths(vector&lt;int&gt;&amp; arr, int target)&#123;</span><br><span class="line">    int sum = 0, r = arr.size() - 1, res = 200000; </span><br><span class="line">    vector&lt;int&gt; dp(arr.size() + 1, 200000);//后面子数组的最小长度</span><br><span class="line">    for (int l = r; l &gt;= 0; --l) &#123; //l,r是滑动区间的左右坐标</span><br><span class="line">        sum += arr[l];</span><br><span class="line">        while (sum &gt; target)</span><br><span class="line">            sum -= arr[r--];</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            int curLen = r - l + 1; //子数组长度</span><br><span class="line">            res = min(res, curLen + dp[r + 1]); //子数组长度 + r后面子数组的最小长度</span><br><span class="line">            dp[l] = min(dp[l + 1], curLen); //更新l后面子数组的最小长度</span><br><span class="line">        &#125;else</span><br><span class="line">            dp[l] = dp[l + 1]; //更新子数组的最小长度</span><br><span class="line">    &#125;</span><br><span class="line">    return res == 200000 ? -1 : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16进制和10进制的互转"><a href="#16进制和10进制的互转" class="headerlink" title="16进制和10进制的互转"></a>16进制和10进制的互转</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string convert_10_to_16(int num)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; ivec;</span><br><span class="line">    int Num = num;</span><br><span class="line">    while (num != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ivec.push_back(num % 16);</span><br><span class="line">        num = num / 16;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    vector&lt;int&gt;::size_type sz = ivec.size();</span><br><span class="line">    vector&lt;string&gt; ivec2;</span><br><span class="line">    int m = 0;</span><br><span class="line">    string s;</span><br><span class="line">    for (vector&lt;int&gt;::size_type index = 0; index != sz; ++index)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ivec[sz - 1 - index] &gt; 9)</span><br><span class="line">        &#123;   </span><br><span class="line">            m = ivec[sz - 1 - index] + 55;</span><br><span class="line">            s = m+&#x27;0&#x27;-&#x27;0&#x27;;</span><br><span class="line">            ivec2.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            s = ivec[sz - 1 - index] + &#x27;0&#x27;;</span><br><span class="line">            ivec2.push_back(s);</span><br><span class="line"> </span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    for (auto item : ivec2)</span><br><span class="line">        res += item;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double convert_16_to_10(string str)</span><br><span class="line">&#123;</span><br><span class="line">    double sum = 0, times;</span><br><span class="line">    double m;</span><br><span class="line">    string::size_type sz = str.size();</span><br><span class="line">    for (string::size_type index = 0; index != sz; ++index)</span><br><span class="line">    &#123;</span><br><span class="line">        str[index] = tolower(str[index]);</span><br><span class="line">        if (str[index] &gt;= &#x27;a&#x27; &amp;&amp; str[index] &lt;= &#x27;f&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            m = str[index] - &#x27;a&#x27; + 10;</span><br><span class="line">            times = pow(16, (sz - 1 - index));</span><br><span class="line">            sum += m * times;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        else if (isdigit(str[index]))</span><br><span class="line">        &#123;</span><br><span class="line">            m= str[index] - 48;</span><br><span class="line">            times = pow(16, (sz - 1 - index));</span><br><span class="line">            sum += m * times;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8月10日-696-计数二进制子串"><a href="#8月10日-696-计数二进制子串" class="headerlink" title="8月10日 696. 计数二进制子串"></a>8月10日 <a href="https://leetcode-cn.com/problems/count-binary-substrings/">696. 计数二进制子串</a></h1><p>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</p>
<p>重复出现的子串要计算它们出现的次数。</p>
<p>示例 1 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;00110011&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。</span><br><span class="line"></span><br><span class="line">请注意，一些重复出现的子串要计算它们出现的次数。</span><br><span class="line"></span><br><span class="line">另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。</span><br></pre></td></tr></table></figure>
<p>示例 2 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;10101&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.length 在1到50,000之间。</span><br><span class="line">s 只包含“0”或“1”字符。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>把每个相同的字符分组，比如“00111011” 就可以分为subs&#x3D;{2,3,1,2}，表示2个0，3个1，1个0，2个1。每一对相邻的能有min{subs[i],subs[i+1]}个字串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int countBinarySubstrings(string s) &#123;</span><br><span class="line">    vector&lt;int&gt; subs;</span><br><span class="line">    </span><br><span class="line">    int i = 0;</span><br><span class="line">    while(i&lt;s.size())&#123;</span><br><span class="line">        int mark = i;</span><br><span class="line">        char cur = s[i];</span><br><span class="line">        while(i&lt;s.size() &amp;&amp; s[i]==cur)</span><br><span class="line">            i++;</span><br><span class="line">        subs.push_back(i-mark);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int res = 0;</span><br><span class="line">    for(int i = 0;i&lt;subs.size()-1;i++)&#123;</span><br><span class="line">        res += min(subs[i],subs[i+1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
</li>
<li><p>优化。空间复杂度优化到O(1)。也只用到subs的上一个状态量，所以可以不用保存整个subs数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（代码略）</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="8月11日-130-被围绕的区域（中等）"><a href="#8月11日-130-被围绕的区域（中等）" class="headerlink" title="8月11日 130. 被围绕的区域（中等）"></a>8月11日 <a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域（中等）</a></h1><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p>
<p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br><span class="line">运行你的函数后，矩阵变为：</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p>解释:<br>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。<br>题解：<br>dfs。也可以用bfs，但是需要自己用队列实现，还是递归方便一点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;char&gt; &gt;&amp; board,vector&lt;int&gt; &amp; s,vector&lt;vector&lt;bool&gt; &gt; &amp;marked)&#123;</span><br><span class="line">    int x=s[0],y=s[1];</span><br><span class="line">    if(board[x][y]==&#x27;X&#x27; || marked[x][y])</span><br><span class="line">        return;</span><br><span class="line">    marked[x][y] = true;</span><br><span class="line">    for(auto d:dirs)&#123;</span><br><span class="line">        int next_i = x+d[0], next_j = y+d[1];</span><br><span class="line">        vector&lt;int&gt; tmp = &#123;next_i,next_j&#125;;</span><br><span class="line">        if((next_i &gt; 0 &amp;&amp; next_i &lt; board.size())</span><br><span class="line">        &amp;&amp; (next_j &gt; 0 &amp;&amp; next_j &lt; board[0].size()))</span><br><span class="line">            dfs(board,tmp,marked);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</span><br><span class="line">    if(board.empty())</span><br><span class="line">        return;</span><br><span class="line">    int m = board.size(),n = board[0].size();</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; marked(m,vector&lt;bool&gt;(n, false));</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; side;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        if(board[0][i]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;0,i&#125;);</span><br><span class="line">            //marked[0][i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(board[m-1][i]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;m-1,i&#125;);</span><br><span class="line">            //marked[m-1][i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;m-1;i++)&#123;</span><br><span class="line">        if(board[i][0]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;i,0&#125;);</span><br><span class="line">            //marked[i][0] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(board[i][n-1]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;i,n-1&#125;);</span><br><span class="line">            //marked[i][n-1] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(auto s:side)&#123;</span><br><span class="line">        dfs(board,s,marked);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            if(!marked[i][j] &amp;&amp; board[i][j]==&#x27;O&#x27;)</span><br><span class="line">                board[i][j] = &#x27;X&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m<em>n)<br>空间复杂度：O(m</em>n)</p>
<h1 id="8月12日-133-克隆图（中等）"><a href="#8月12日-133-克隆图（中等）" class="headerlink" title="8月12日 133. 克隆图（中等）"></a>8月12日 <a href="https://leetcode-cn.com/problems/clone-graph/">133. 克隆图（中等）</a></h1><p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p>
<p>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>bfs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Node* cloneGraph(Node* node) &#123;</span><br><span class="line">    if (node == nullptr) &#123;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line"></span><br><span class="line">    // 将题目给定的节点添加到队列</span><br><span class="line">    queue&lt;Node*&gt; que;</span><br><span class="line">    que.push(node);</span><br><span class="line">    // 克隆第一个节点并存储到哈希表中</span><br><span class="line">    visited[node] = new Node(node-&gt;val);</span><br><span class="line"></span><br><span class="line">    // 广度优先搜索</span><br><span class="line">    while (!que.empty()) &#123;</span><br><span class="line">        // 取出队列的头节点</span><br><span class="line">        auto curNode = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        // 遍历该节点的邻居</span><br><span class="line">        for (auto&amp; neighbor: curNode-&gt;neighbors) &#123;</span><br><span class="line">            if (visited.find(neighbor) == visited.end()) &#123;</span><br><span class="line">                // 如果没有被访问过，就克隆并存储在哈希表中</span><br><span class="line">                visited[neighbor] = new Node(neighbor-&gt;val);</span><br><span class="line">                // 将邻居节点加入队列中</span><br><span class="line">                que.push(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新当前节点的邻居列表</span><br><span class="line">            visited[curNode]-&gt;neighbors.emplace_back(visited[neighbor]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return visited[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
</li>
<li><p>dfs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line"></span><br><span class="line">Node* cloneGraph(Node* node) &#123;</span><br><span class="line">    if (node == nullptr) &#123;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(visited.find(node) != visited.end())</span><br><span class="line">        return visited[node];</span><br><span class="line"></span><br><span class="line">    Node *cloneNode = new Node(node-&gt;val);</span><br><span class="line">    visited[node] = cloneNode;</span><br><span class="line"></span><br><span class="line">    for(auto &amp;neighbor:node-&gt;neighbors)&#123;</span><br><span class="line">        cloneNode-&gt;neighbors.push_back(cloneGraph(neighbor));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return visited[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
</li>
</ol>
<h1 id="8月13日-43-字符串相乘（中等）"><a href="#8月13日-43-字符串相乘（中等）" class="headerlink" title="8月13日 43. 字符串相乘（中等）"></a>8月13日 <a href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘（中等）</a></h1><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num1 和 num2 的长度小于110。</span><br><span class="line">num1 和 num2 只包含数字 0-9。</span><br><span class="line">num1 和 num2 均不以零开头，除非是数字 0 本身。</span><br><span class="line">不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</span><br></pre></td></tr></table></figure>
<p>题解：<br>大数相乘问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string multiply(string num1, string num2)&#123;</span><br><span class="line">    int m = num1.size(), n = num2.size();</span><br><span class="line">    vector&lt;long long&gt; num(m + n - 1, 0);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m;i++)&#123;//前面是高位，后面是低位</span><br><span class="line">        int a = num1[i] - &#x27;0&#x27;;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int b = num2[j] - &#x27;0&#x27;;</span><br><span class="line">            num[i + j] += a * b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int carry = 0;</span><br><span class="line">    for (int i = num.size() - 1; i &gt;= 0;i--)&#123;//前面是高位，后面是低位</span><br><span class="line">        int cur = num[i] + carry;</span><br><span class="line">        num[i] = cur % 10;</span><br><span class="line">        carry = cur / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    while(carry!=0)&#123;</span><br><span class="line">        int cur = carry % 10;</span><br><span class="line">        carry /= 10;</span><br><span class="line">        num.insert(num.begin(), cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    for (auto a : num)</span><br><span class="line">    &#123;</span><br><span class="line">        res += to_string(a);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m*n)<br>空间复杂度：O(m+n)</p>
<h1 id="8月19日-647-回文子串（中等）"><a href="#8月19日-647-回文子串（中等）" class="headerlink" title="8月19日 647. 回文子串（中等）"></a>8月19日 <a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串（中等）</a></h1><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure>
<p>题解：<br>枚举每一个字串，再判断是不是回文。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isPalindrome(string str)&#123;</span><br><span class="line">    int L = 0, R = str.size() - 1;</span><br><span class="line">    while(L&lt;R)&#123;</span><br><span class="line">        if(str[L]!=str[R])</span><br><span class="line">            break;</span><br><span class="line">        L++;</span><br><span class="line">        R--;</span><br><span class="line">    &#125;</span><br><span class="line">    return L&gt;=R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int countSubstrings(string s) &#123;</span><br><span class="line">    int n = s.size();</span><br><span class="line">    if(n==0) return 0;</span><br><span class="line">    int res = n;</span><br><span class="line">    for(int m=2;m&lt;=n;m++)&#123;</span><br><span class="line">        for(int i=0;i&lt;=n-m;i++)&#123;</span><br><span class="line">            string cur_str = s.substr(i,m);</span><br><span class="line">            if(isPalindrome(cur_str))</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p>
<h1 id="8月20日-529-扫雷游戏（中等）"><a href="#8月20日-529-扫雷游戏（中等）" class="headerlink" title="8月20日 529. 扫雷游戏（中等）"></a>8月20日 <a href="https://leetcode-cn.com/problems/minesweeper/">529. 扫雷游戏（中等）</a></h1><p>让我们一起来玩扫雷游戏！</p>
<p>给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，’E’ 代表一个未挖出的空方块，’B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’X’ 则表示一个已挖出的地雷。</p>
<p>现在给出在所有未挖出的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p>
<p>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’。<br>如果一个没有相邻地雷的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的未挖出方块都应该被递归地揭露。<br>如果一个至少与一个地雷相邻的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。<br>如果在此次点击中，若无更多方块可被揭露，则返回面板。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[&#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;],</span><br><span class="line"> [&#x27;E&#x27;, &#x27;E&#x27;, &#x27;M&#x27;, &#x27;E&#x27;, &#x27;E&#x27;],</span><br><span class="line"> [&#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;],</span><br><span class="line"> [&#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;]]</span><br><span class="line"></span><br><span class="line">Click : [3,0]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">[[&#x27;B&#x27;, &#x27;1&#x27;, &#x27;E&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;M&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[&#x27;B&#x27;, &#x27;1&#x27;, &#x27;E&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;M&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]]</span><br><span class="line"></span><br><span class="line">Click : [1,2]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">[[&#x27;B&#x27;, &#x27;1&#x27;, &#x27;E&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;X&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;B&#x27;],</span><br><span class="line"> [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]]</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>dfs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;,&#123;-1,1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;char&gt; &gt; &amp;res, int row, int col, vector&lt;vector&lt;bool&gt; &gt; &amp;hasVisited)&#123;</span><br><span class="line">    if(hasVisited[row][col])</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    //处理当前格子</span><br><span class="line">    int boom = 0;</span><br><span class="line">    for(auto d:dirs)&#123;</span><br><span class="line">        int next_i=row+d[0];</span><br><span class="line">        int next_j=col+d[1];</span><br><span class="line">        if(next_i &lt; 0 || next_i &gt;= res.size() || next_j &lt; 0 || next_j &gt;= res[0].size())</span><br><span class="line">            continue;</span><br><span class="line">        if(res[next_i][next_j]==&#x27;M&#x27;)</span><br><span class="line">            boom++;</span><br><span class="line">    &#125;</span><br><span class="line">    hasVisited[row][col] = true;</span><br><span class="line">    if(boom==0)</span><br><span class="line">        res[row][col] = &#x27;B&#x27;;</span><br><span class="line">    else&#123;</span><br><span class="line">        res[row][col] = to_string(boom)[0];</span><br><span class="line">        // res[cur_i][cur_j] = boom + &#x27;0&#x27;;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //处理下一个格子</span><br><span class="line">    for(auto d:dirs)&#123;</span><br><span class="line">        int next_i=row+d[0];</span><br><span class="line">        int next_j=col+d[1];</span><br><span class="line">        if(next_i &lt; 0 || next_i &gt;= res.size() || next_j &lt; 0 || next_j &gt;= res[0].size())</span><br><span class="line">            continue;</span><br><span class="line">        dfs(res,next_i,next_j,hasVisited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;char&gt;&gt; updateBoard(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;int&gt;&amp; click) &#123;</span><br><span class="line">    if(board.empty())</span><br><span class="line">        return board;</span><br><span class="line">    int row = click[0],col=click[1];</span><br><span class="line">    vector&lt;vector&lt;char&gt; &gt; res = board;</span><br><span class="line">    if(board[row][col]==&#x27;M&#x27;)&#123;</span><br><span class="line">        res[row][col] = &#x27;X&#x27;;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; hasVisited(board.size(), vector&lt;bool&gt;(board[0].size(),false));</span><br><span class="line">    dfs(res,row,col,hasVisited);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p>
</li>
<li><p>bfs。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;,&#123;-1,1&#125;&#125;;</span><br><span class="line">void bfs(vector&lt;vector&lt;char&gt; &gt; &amp;res, int row, int col, vector&lt;vector&lt;bool&gt; &gt; &amp;hasVisited)&#123;</span><br><span class="line">    queue&lt;vector&lt;int&gt; &gt; que;</span><br><span class="line">    que.push(&#123;row,col&#125;);</span><br><span class="line">    hasVisited[row][col] = true;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int sizeq = que.size();</span><br><span class="line">        while(sizeq--&gt;0)&#123;</span><br><span class="line">            int cur_i = que.front()[0];</span><br><span class="line">            int cur_j = que.front()[1];</span><br><span class="line">            que.pop();</span><br><span class="line">            </span><br><span class="line">            int boom = 0;</span><br><span class="line">            for(auto d:dirs)&#123;</span><br><span class="line">                int next_i=cur_i+d[0];</span><br><span class="line">                int next_j=cur_j+d[1];</span><br><span class="line">                if(next_i &lt; 0 || next_i &gt;= res.size() || next_j &lt; 0 || next_j &gt;= res[0].size())</span><br><span class="line">                    continue;</span><br><span class="line">                if(res[next_i][next_j]==&#x27;M&#x27;)</span><br><span class="line">                    boom++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(boom==0)&#123;</span><br><span class="line">                //处理当前格子</span><br><span class="line">                res[cur_i][cur_j] = &#x27;B&#x27;;</span><br><span class="line">                //下一个格子</span><br><span class="line">                for(auto d:dirs)&#123;</span><br><span class="line">                    int next_i=cur_i+d[0];</span><br><span class="line">                    int next_j=cur_j+d[1];</span><br><span class="line">                    if(next_i &lt; 0 || next_i &gt;= res.size() || next_j &lt; 0 || next_j &gt;= res[0].size()</span><br><span class="line">                    || hasVisited[next_i][next_j])</span><br><span class="line">                        continue;</span><br><span class="line">                    if(res[next_i][next_j]==&#x27;E&#x27;)&#123;</span><br><span class="line">                        que.push(&#123;next_i,next_j&#125;);</span><br><span class="line">                        hasVisited[next_i][next_j] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                res[cur_i][cur_j] = to_string(boom)[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;char&gt; &gt; updateBoard(vector&lt;vector&lt;char&gt; &gt;&amp; board, vector&lt;int&gt;&amp; click) &#123;</span><br><span class="line">    if(board.empty())</span><br><span class="line">        return board;</span><br><span class="line">    int row = click[0],col=click[1];</span><br><span class="line">    vector&lt;vector&lt;char&gt; &gt; res = board;</span><br><span class="line">    if(board[row][col]==&#x27;M&#x27;)&#123;</span><br><span class="line">        res[row][col] = &#x27;X&#x27;;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; hasVisited(board.size(), vector&lt;bool&gt;(board[0].size(),false));</span><br><span class="line">    bfs(res,row,col,hasVisited);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p>
</li>
</ol>
<h1 id="元素平衡"><a href="#元素平衡" class="headerlink" title="元素平衡"></a>元素平衡</h1><p>A，B，C，D四个数，每次可以任意减少2个单位然后增加1各单位，问当四个数相等时，最大和为多少。</p>
<p>题解：<br>笔试真题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;long&gt; nums(4);</span><br><span class="line">    cin &gt;&gt; nums[0] &gt;&gt; nums[1] &gt;&gt; nums[2] &gt;&gt; nums[3];</span><br><span class="line">    </span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">    long long sumn = nums[0] + nums[1] + nums[2] + nums[3];</span><br><span class="line">    long maxn = sumn / 4;</span><br><span class="line">    while(maxn&gt;0)&#123;</span><br><span class="line">        int sumL = 0, sumR = 0, idx = 0;</span><br><span class="line">        while(idx&lt;4 &amp;&amp; nums[idx]&lt;maxn)&#123;</span><br><span class="line">            sumL += (maxn - nums[idx]);</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        while(idx&lt;4 &amp;&amp; nums[idx]==maxn)</span><br><span class="line">            idx++;</span><br><span class="line">        while(idx&lt;4 &amp;&amp; nums[idx]&gt;maxn)&#123;</span><br><span class="line">            sumR += (nums[idx] - maxn);</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sumL*2 &lt;= sumR)&#123;</span><br><span class="line">            cout &lt;&lt; maxn * 4 &lt;&lt; endl;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        maxn--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Leetcode daily</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2020/06/10/network/</url>
    <content><![CDATA[<h1 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h1><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</p>
<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>计算机网络体系结构是指计算机网络层次结构模型，它是各层的协议以及层次之间的端口的集合。在计算机网络中实现通信必须依靠网络通信协议，目前广泛采用的是国际标准化组织（ISO）1997年提出的开放系统互联（Open System Interconnection，OSI）参考模型，习惯上称为ISO&#x2F;OSI参考模型。</p>
<span id="more"></span>
<h2 id="不同的网络体系结构"><a href="#不同的网络体系结构" class="headerlink" title="不同的网络体系结构"></a>不同的网络体系结构</h2><h3 id="OSI七层协议体系结构"><a href="#OSI七层协议体系结构" class="headerlink" title="OSI七层协议体系结构"></a>OSI七层协议体系结构</h3><p>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。</p>
<p>OSI七层协议模型主要包括是：</p>
<ul>
<li>应用层（Application）</li>
<li>表示层（Presentation）</li>
<li>会话层（Session）</li>
<li>运输层（Transport）</li>
<li>网络层（Network）</li>
<li>数据链路层（Data Link）</li>
<li>物理层（Physical）</li>
</ul>
<h3 id="TCP-x2F-IP四层体系结构"><a href="#TCP-x2F-IP四层体系结构" class="headerlink" title="TCP&#x2F;IP四层体系结构"></a>TCP&#x2F;IP四层体系结构</h3><p>TCP&#x2F;IP 是一个四层体系结构，主要包括：</p>
<ul>
<li>应用层</li>
<li>运输层</li>
<li>网际层（用网际层这个名字是强调这一层是为了解决不同网络的互连问题）</li>
<li>网络接口层</li>
</ul>
<p>不过从实质上讲，TCP&#x2F;IP 只有最上面的三层，因为最下面的网络接口层并没有什么具体内容，因此在学习计算机网络的原理时往往采用折中的办法，即综合 OSI 和 TCP&#x2F;IP 的优点，采用一种只有五层协议的体系结构。</p>
<h3 id="五层协议的体系结构"><a href="#五层协议的体系结构" class="headerlink" title="五层协议的体系结构"></a>五层协议的体系结构</h3><p>五层协议的体系结构主要包括：</p>
<ul>
<li>应用层</li>
<li>运输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<p><img src="https://i.loli.net/2020/06/09/wvthjWo3nSCx2NP.png" alt="不同体系结构对比"></p>
<p><em>ps. 五层协议的体系结构只是为了介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构。</em></p>
<h2 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h2><p><img src="https://i.loli.net/2020/06/09/Heb6Y83xwKsiodr.png" alt="TCP/IP四层协议表示方法举例"></p>
<h2 id="具有五层协议的体系结构"><a href="#具有五层协议的体系结构" class="headerlink" title="具有五层协议的体系结构"></a>具有五层协议的体系结构</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层（application-layer）的任务是通过<strong>应用进程间</strong>的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。</p>
<h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>运输层（transport layer）的主要任务就是负责向<strong>两台主机进程之间</strong>的通信提供<strong>通用的数据传输</strong>服务。应用进程利用该服务传送应用层报文。</p>
<p>运输层主要使用一下两种协议</p>
<ul>
<li>TCP-传输控制协议：提供面向连接的，可靠的数据传输服务</li>
<li>UDP-用户数据协议：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）</li>
</ul>
<h4 id="每一个应用层（TCP-x2F-IP参考模型的最高层）协议一般都会使用到两个传输层协议之一"><a href="#每一个应用层（TCP-x2F-IP参考模型的最高层）协议一般都会使用到两个传输层协议之一" class="headerlink" title="每一个应用层（TCP&#x2F;IP参考模型的最高层）协议一般都会使用到两个传输层协议之一"></a>每一个应用层（TCP&#x2F;IP参考模型的最高层）协议一般都会使用到两个传输层协议之一</h4><p><em>ps. 以下协议是应用层协议：</em></p>
<p>运行在TCP协议上的协议：</p>
<ul>
<li>HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。端口号：80</li>
<li>HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。端口号：443</li>
<li>FTP（File Transfer Protocol，文件传输协议），用于文件传输。端口号：21</li>
<li>POP3（Post Office Protocol, version 3，邮局协议），收邮件用。</li>
<li>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。</li>
<li>TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。端口号：23</li>
<li>SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。</li>
</ul>
<p>运行在UDP协议上的协议：</p>
<ul>
<li>BOOTP（Boot Protocol，启动协议），应用于无盘设备。</li>
<li>NTP（Network Time Protocol，网络时间协议），用于网络同步。</li>
<li>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</li>
</ul>
<p>运行在TCP和UDP协议上：</p>
<ul>
<li>DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。</li>
</ul>
<h3 id="网络层（网际层）"><a href="#网络层（网际层）" class="headerlink" title="网络层（网际层）"></a>网络层（网际层）</h3><p>网络层负责为分组交换网上的不同<strong>主机</strong>提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</p>
<p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>在物理层上所传送的数据单位是比特。</p>
<h3 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h3><p><img src="https://i.loli.net/2020/06/09/bgk9DNdcfawv5Fe.png" alt="数据在各层之间的传递过程"></p>
<h2 id="TCP的三次握手四次挥手"><a href="#TCP的三次握手四次挥手" class="headerlink" title="TCP的三次握手四次挥手"></a>TCP的三次握手四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://i.loli.net/2020/06/10/RQOy2WUYzfbxtmv.png" alt="三次握手"></p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://i.loli.net/2020/06/10/lD6isBec9Oh2zWo.jpg" alt="四次挥手"></p>
<p>MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<ul>
<li><strong>CLOSED</strong>：表示初始状态。</li>
<li><strong>LISTEN</strong>：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。</li>
<li><strong>SYN_SENT</strong>：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</li>
<li><strong>SYN_RCVD</strong>: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</li>
<li><strong>ESTABLISHED</strong>：表示连接已经建立。</li>
<li><strong>FIN_WAIT_1</strong>: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。</li>
<li><strong>FIN_WAIT_2</strong>：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。</li>
<li><strong>TIME_WAIT</strong>: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</li>
<li><strong>CLOSING</strong>: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</li>
<li><strong>CLOSE_WAIT</strong>: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。</li>
<li><strong>LAST_ACK</strong>: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。</li>
</ul>
<h3 id="半关闭状态"><a href="#半关闭状态" class="headerlink" title="半关闭状态"></a>半关闭状态</h3><p><img src="https://i.loli.net/2020/10/13/WLNRMogAhJYStbO.png" alt="半关闭状态"></p>
<h3 id="为什么TCP连接的时候是3次，不是2次"><a href="#为什么TCP连接的时候是3次，不是2次" class="headerlink" title="为什么TCP连接的时候是3次，不是2次"></a>为什么TCP连接的时候是3次，不是2次</h3><p>因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。</p>
<p>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。</p>
<h3 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h3><p>因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文（所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次）。</p>
<h3 id="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"><a href="#为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？" class="headerlink" title="为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"></a>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h3><p>这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p>
<h2 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h2 id="TCP和UDP对比"><a href="#TCP和UDP对比" class="headerlink" title="TCP和UDP对比"></a>TCP和UDP对比</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">UPD</th>
<th align="center">TCP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否连接</td>
<td align="center">无连接</td>
<td align="center">面向连接（3次握手）</td>
</tr>
<tr>
<td align="center">是否可靠</td>
<td align="center">尽最大努力交付，不保证可靠。不使用流量控制和拥塞控制</td>
<td align="center">使用流量控制和拥塞控制。可靠服务：无差错、不丢失、不重复、按序到达</td>
</tr>
<tr>
<td align="center">传输方式</td>
<td align="center">面向报文</td>
<td align="center">面向字节流</td>
</tr>
<tr>
<td align="center">连接对象个数</td>
<td align="center">一对一，多对多，多对一，一对多</td>
<td align="center">一对一</td>
</tr>
<tr>
<td align="center">首部开销</td>
<td align="center">8字节</td>
<td align="center">首部最小20字节，最大60字节</td>
</tr>
</tbody></table>
<h2 id="TCP怎么保证可靠"><a href="#TCP怎么保证可靠" class="headerlink" title="TCP怎么保证可靠"></a>TCP怎么保证可靠</h2><ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li>校验和：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li>流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li>拥塞控制：当网络拥塞时，减少数据的发送。</li>
<li>ARQ协议：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li>超时重传：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h2 id="拥塞控制和流量控制"><a href="#拥塞控制和流量控制" class="headerlink" title="拥塞控制和流量控制"></a>拥塞控制和流量控制</h2><p>都是保证TCP可靠的方法。</p>
<ul>
<li>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况</li>
<li>流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的</li>
</ul>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><ul>
<li>慢开始：从小到大逐渐增大发送窗口，每个传输轮次后将 cwnd 大小加倍。</li>
<li>拥塞避免：用慢开始门限（ssthresh）的阈值来控制 cwnd 的增长<ul>
<li>cwnd &lt; ssthresh , 使用慢开始算法</li>
<li>cwnd &#x3D; ssthresh , 使用慢开始算法或拥塞避免算法（线性增长，一般是加1）都可以</li>
<li>cwnd &gt; ssthresh , 使用拥塞避免算法。只要发现网络中出现拥塞就<strong>乘法减小</strong>ssthresh并从cwnd&#x3D;1开始重新执行慢开始算法。</li>
</ul>
</li>
<li>快重传：允许发送方再连续收到 3 个重复的确认后就可以开始执行乘法减小过程而不必再等待所设置的重传计时器到时。</li>
<li>快恢复：是与快重传算法配合使用的一个算法。快恢复算法后与原来不同的一点是当发现网络出现拥塞并执行了乘法减小过程后，并不是设置cwnd&#x3D;1并重新开始执行慢开始算法，而是让 cwnd &#x3D;乘法减小后的ssthresh并开始执行拥塞避免算法。</li>
</ul>
<p><img src="https://i.loli.net/2020/09/25/ZoESaLNlwbrugkv.png" alt="拥塞控制"></p>
<p><em>ps. ssthresh的设置：TCP&#x2F;IP 中规定无论是在慢开始阶段还是在拥塞避免阶段，只要发现网络中出现拥塞（没有按时收到确认），就要把ssthresh设置为此时发送窗口的一半大小（不能小于2）</em></p>
<ul>
<li><a href="https://blog.csdn.net/qq_41431406/article/details/97926927">TCP的拥塞控制（详解）</a></li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><ul>
<li>RTT算法</li>
<li>滑动窗口<ul>
<li>发送窗口</li>
<li>接受窗口</li>
</ul>
</li>
</ul>
<h2 id="使UPD可靠的方法"><a href="#使UPD可靠的方法" class="headerlink" title="使UPD可靠的方法"></a>使UPD可靠的方法</h2><ul>
<li>超时重传（定时器）</li>
<li>有序接受 （添加包序号）</li>
<li>应答确认 （Seq&#x2F;Ack应答机制）</li>
<li>滑动窗口流量控制等机制 （滑动窗口协议）</li>
</ul>
<p>已有协议：</p>
<ul>
<li>可靠用户数据报协议（RUDP）：RUDP使用类似于TCP的重发机制和拥塞控制算法</li>
<li>实时协议（RTP）：有效负载识别，序列编号，时间戳和投递监听</li>
<li>基于UDP的数据传输协议（UDT）：序列号、滑动窗口</li>
</ul>
<h2 id="为什么会发生-TCP-粘包、拆包"><a href="#为什么会发生-TCP-粘包、拆包" class="headerlink" title="为什么会发生 TCP 粘包、拆包"></a>为什么会发生 TCP 粘包、拆包</h2><p>粘包问题是由TCP是“字节流”协议，没有消息边界所引起的。</p>
<ol>
<li>应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。</li>
<li>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。</li>
<li>进行 MSS （最大报文长度）大小的 TCP 分段，当 <code>TCP报文长度 - TCP头部长度 &gt; MSS</code> 的时候将发生拆包。</li>
<li>接收方法不及时读取套接字缓冲区数据，这将发生粘包。</li>
</ol>
<h2 id="如何处理粘包、拆包？"><a href="#如何处理粘包、拆包？" class="headerlink" title="如何处理粘包、拆包？"></a>如何处理粘包、拆包？</h2><p>解决粘包的方法就是由应用层进行分包处理，本质上就是由应用层来维护消息和消息的边界。</p>
<ol>
<li>使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。</li>
<li>设置定长消息，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。</li>
<li>设置消息边界，服务端从网络流中按消息编辑分离出消息内容，一般使用‘\n’。</li>
<li>更为复杂的协议。</li>
</ol>
<h2 id="简述Socket通信基本步骤"><a href="#简述Socket通信基本步骤" class="headerlink" title="简述Socket通信基本步骤"></a>简述Socket通信基本步骤</h2><p>具体分成两个部分：</p>
<ol>
<li>服务端<ul>
<li>socket(创建socket) </li>
<li>bind(绑定socket和端口号) </li>
<li>listen(监听该端口号)</li>
<li>accept(等待并接受客户端连接请求)</li>
<li>read,write(读取数据和返回数据) </li>
<li>close(关闭socket)</li>
</ul>
</li>
<li>客户端<ul>
<li>socket(创建socket) </li>
<li>connect(连接指定的端口) </li>
<li>read,write(读取数据和返回数据) </li>
<li>close(关闭socket)</li>
</ul>
</li>
</ol>
<h2 id="GET、POST的区别"><a href="#GET、POST的区别" class="headerlink" title="GET、POST的区别"></a>GET、POST的区别</h2><ul>
<li>作用<br>GET 用于获取资源，而 POST 用于传输数据。</li>
<li>参数<br>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。</li>
<li>安全<br>GET 方法是安全的，而 POST 却不是。安全就是说请求方法不会改变服务器状态，也就是说它只是可读的。因为 POST 的目的是传送数据，这个数据可能是用户上传的表单，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。所以，从这个方面来讲，POST是不安全的。</li>
<li>幂等<br>GET方法都是幂等的，但 POST 方法不是。幂等就是说，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。所以，幂等方法不应该具有副作用。</li>
</ul>
<h2 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h2><ol>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ol>
<p>HTTPS是运行在SSL&#x2F;TLS之上的HTTP协议，SSL&#x2F;TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p>
<h2 id="SSL四次握手"><a href="#SSL四次握手" class="headerlink" title="SSL四次握手"></a>SSL四次握手</h2><p><img src="https://i.loli.net/2020/10/14/Ax72pejscZGi5T4.png" alt="SSL四次握手"></p>
<ol>
<li>客户端请求建立SSL链接，并向服务端发送一个<strong>随机数–Client random</strong>和<strong>客户端支持的加密方法</strong>，比如RSA公钥加密，此时是明文传输。</li>
<li>服务端回复一种客户端<strong>支持的加密方法</strong>、<strong>一个随机数–Server random</strong>、授信的服务器<strong>证书</strong>和<strong>非对称加密的公钥</strong>。</li>
<li>客户端收到服务端的回复后利用服务端的公钥，加上新的<strong>随机数–Premaster secret</strong> 通过服务端下发的公钥及加密方法进行加密，发送给服务器。</li>
<li>服务端收到客户端的回复，利用已知的加解密方式进行解密，同时利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key – session key。</li>
</ol>
<h2 id="什么是对称加密与非对称加密"><a href="#什么是对称加密与非对称加密" class="headerlink" title="什么是对称加密与非对称加密"></a>什么是对称加密与非对称加密</h2><ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等。这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li>
</ul>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul>
<li><a href="https://juejin.im/entry/58d7635e5c497d0057fae036">详细解析HTTP 与HTTPS 的区别</a></li>
</ul>
<h2 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h2><ol>
<li>首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；</li>
<li>客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；</li>
<li>消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；</li>
<li>发送给服务端，此时只有服务端（RSA私钥）能解密。</li>
<li>解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。</li>
</ol>
<h2 id="HTTP长连接，短连接是什么？"><a href="#HTTP长连接，短连接是什么？" class="headerlink" title="HTTP长连接，短连接是什么？"></a>HTTP长连接，短连接是什么？</h2><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
<p>在HTTP&#x2F;1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：<code>Connection:keep-alive</code></p>
<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<h2 id="HTTP版本对比"><a href="#HTTP版本对比" class="headerlink" title="HTTP版本对比"></a>HTTP版本对比</h2><h3 id="HTTP1-0版本的特性："><a href="#HTTP1-0版本的特性：" class="headerlink" title="HTTP1.0版本的特性："></a>HTTP1.0版本的特性：</h3><ul>
<li>1.0的HTTP版本，是一种无状态、无连接的应用层协议。</li>
<li>HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</li>
</ul>
<h3 id="HTTP1-1版本新特性"><a href="#HTTP1-1版本新特性" class="headerlink" title="HTTP1.1版本新特性"></a>HTTP1.1版本新特性</h3><ul>
<li>默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</li>
<li>管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应</li>
<li>断点续传原理</li>
</ul>
<h3 id="HTTP2-0版本的特性"><a href="#HTTP2-0版本的特性" class="headerlink" title="HTTP2.0版本的特性"></a>HTTP2.0版本的特性</h3><ul>
<li>二进制分帧（采用二进制格式的编码将其封装）</li>
<li>首部压缩（设置了专门的首部压缩设计的HPACK算法。）</li>
<li>流量控制（设置了接收某个数据流的多少字节一些流量控制）</li>
<li>多路复用（可以在共享TCP链接的基础上同时发送请求和响应）</li>
<li>请求优先级（可以通过优化这些帧的交错和传输顺序进一步优化性能）</li>
<li>服务器推送（就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资 源无需客户端明确的请求。（重大更新））</li>
</ul>
<h3 id="HTTP1-1-和-HTTP2-0-的区别"><a href="#HTTP1-1-和-HTTP2-0-的区别" class="headerlink" title="HTTP1.1 和 HTTP2.0 的区别"></a>HTTP1.1 和 HTTP2.0 的区别</h3><ul>
<li><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li>
<li><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li>
<li><strong>header压缩</strong>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li>
<li><strong>服务端推送</strong>（server push），同SPDY一样，HTTP2.0也具有server push功能。</li>
</ul>
<p>ref. <a href="https://juejin.im/entry/5981c5df518825359a2b9476">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></p>
<h2 id="输入URL到显示网页的过程"><a href="#输入URL到显示网页的过程" class="headerlink" title="输入URL到显示网页的过程"></a>输入URL到显示网页的过程</h2><ol>
<li>DNS解析：简单地说就是找到URL对应的IP地址。</li>
<li>TCP连接：浏览器与目标服务器建立TCP连接<ul>
<li>HTTP协议建立在TCP协议之上，HTTP请求前，需先进行TCP连接，形成客户端到服务器的稳定的通道。俗称TCP的三次握手。</li>
<li>TCP连接完成后，HTTP请求开始，请求有多种方式，常见的有GET，POST等。</li>
</ul>
</li>
<li>发送HTTP请求<ul>
<li>HTTP请求包含请求头，也可能包含请求体两部分，请求头中包含我们希望对请求文件的操作的信息，请求体中包含传递给后台的参数。</li>
</ul>
</li>
<li>服务器处理请求并返回HTTP报文<ul>
<li>服务器收到HTTP请求后，后台开始工作，如负载平衡，跨域等，这里就是后端的工作了。</li>
<li>文件处理完毕，生成响应数据包，响应也包含两部分，响应头和相应体，响应体就是我们所请求的文件。</li>
<li>经过网络传输，文件被下载到本地客户端，客户端开始加载。</li>
</ul>
</li>
<li>浏览器解析渲染HTML页面<ul>
<li>客户端浏览器加载了HTML文件后，由上到下解析HTML为DOM树（DOM Tree）。</li>
<li>遇到CSS文件，CSS中的url发起HTTP请求。</li>
<li>这是第二次HTTP请求，由于HTTP1.1协议增加了Connection: keep-alive声明，故TCP连接不会关闭，可以复用。</li>
<li>HTTP连接是无状态连接，客户端与服务器端需要重新发起请求–响应。在请求CSS的过程中，解析器继续解析HTML，然后到了script标签。</li>
<li>由于script可能会改变DOM结构，故解析器停止生成DOM树，解析器被js阻塞，等待js文件发起HTTP请求，然后加载。这是第三次HTTP请求。js执行完成后解析器继续解析。</li>
<li>由于CSS文件可能会影响js文件的执行结果，因此需等CSS文件加载完成后再执行。</li>
<li>浏览器收到CSS文件后，开始解析CSS文件为CSSOM树（CSS Rule Tree）。</li>
<li>CSSOM树生成后，DOM Tree与CSS Rule Tree结合生成渲染树（Render Tree）。</li>
<li>Render Tree会被CSS文件阻塞，渲染树生成后，先布局，绘制渲染树中节点的属性(位置，宽度，大小等)，然后渲染，页面就会呈现信息。</li>
<li>继续边解析边渲染，遇到了另一个js文件，js文件执行后改变了DOM树，渲染树从被改变的dom开始再次渲染。</li>
<li>继续向下渲染，碰到一个img标签，浏览器发起HTTP请求，不会等待img加载完成，继续向下渲染，之后再重新渲染此部分。</li>
<li>DOM树遇到HTML结束标签，停止解析，进而渲染结束。</li>
</ul>
</li>
<li>连接结束</li>
</ol>
<p>涉及到的协议：IP(网络)、OSPF(路由)、ARP(本地MAC解析)</p>
<h2 id="ARP，RARP-和-ICMP"><a href="#ARP，RARP-和-ICMP" class="headerlink" title="ARP，RARP 和 ICMP"></a>ARP，RARP 和 ICMP</h2><ul>
<li>ARP协议：属于ipv4协议簇，工作在数据链路层。其功能是把网络层32位的IP转换成数据链路层48位的MAC地址，在这个过程中有一个很重要的表——<strong>ARP缓存表</strong>，<ul>
<li>ARP缓存表中缓存了IP地址和MAC地址的映射关系。如果没有缓存的情况，ARP会广播某一个IP的信息，收到这个广播的设备会回应一个包，表示我是不是这个IP地址。如果是，广播该IP地址的设备会记录对应设备的MAC地址。</li>
</ul>
</li>
<li>RARP协议:(reverse arp，反向arp协议)，和ARP协议做相反的工作，它将48位的MAC地址转换为32位的IP地址。</li>
<li>ICMP协议:（Internet Control Message Protocol，网络控制消息协议），它的功能是报告无法传送的数据包的错误，并帮助对这些错误进行疑难解答。</li>
</ul>
<h2 id="DNS-Domain-Name-System-域名系统-域名解析过程"><a href="#DNS-Domain-Name-System-域名系统-域名解析过程" class="headerlink" title="DNS(Domain Name System, 域名系统) 域名解析过程"></a>DNS(Domain Name System, 域名系统) 域名解析过程</h2><p>域名格式：三级域名.二级域名.顶级域名(<a href="http://www.baidu.com/">www.baidu.com</a>)<br><img src="https://i.loli.net/2020/08/13/CwRs32gdhp1xfYv.png" alt="域名"></p>
<p>域名服务器：保存域名到IP地址映射的服务器。<br><img src="https://i.loli.net/2020/08/13/ij4qSdQV8bUFnPy.png" alt="域名服务器"></p>
<ul>
<li>递归查询：主机向本地域名服务器的查询一般都是采用<strong>递归查询</strong>。指的是，当主机所询问的本地域名服务器不知道被查询的域名IP地址时，<strong>本地域名服务器</strong>就以DNS客户的身份，向其他根域名服务器继续查询，而不是让主机自己进行下一步查询，</li>
<li>迭代查询：本地域名服务器向根域名服务器查询通常采用<strong>迭代查询</strong>。指的是，当根域名服务器没有保存本地域名服务器所查询的域名IP地址时，就告诉本地域名服务器下一步应当找哪一个域名服务器查询，而不是根域名服务器以客户身份查询。</li>
</ul>
<p><img src="https://i.loli.net/2020/08/13/eNUzQE9g8YIP3H4.png" alt="DNS查询"></p>
<p>找域名服务器查询之前，会先找缓存中有没有：</p>
<ol>
<li>浏览器缓存：当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）</li>
<li>系统缓存：当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP</li>
<li>路由器缓存：当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查</li>
</ol>
<p>当以上三个缓存中都没有，才会向DNS服务器查询。</p>
<h2 id="NAT-Network-Address-Translation-网络地址转换-协议"><a href="#NAT-Network-Address-Translation-网络地址转换-协议" class="headerlink" title="NAT(Network Address Translation, 网络地址转换)协议"></a>NAT(Network Address Translation, 网络地址转换)协议</h2><p>用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。</p>
<h2 id="cookie和session对于HTTP有什么用？"><a href="#cookie和session对于HTTP有什么用？" class="headerlink" title="cookie和session对于HTTP有什么用？"></a>cookie和session对于HTTP有什么用？</h2><p>HTTP协议本身是无法判断用户身份。所以需要cookie或者session</p>
<h2 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h2><p>cookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信息。客户端向服务器发起请求，就提取浏览器中的用户信息由http发送给服务器</p>
<h2 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h2><p>session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给session。</p>
<p>服务器默认为客户浏览器的cookie中设置 sessionid，这个sessionid就和cookie对应，浏览器在向服务器请求过程中传输的cookie 包含 sessionid ，服务器根据传输cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</p>
<h2 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h2><ul>
<li>cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高</li>
<li>单个cookie保存的数据不能超过4K，session无此限制</li>
<li>session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li>谢希仁. 计算机网络（第7版）. 电子工业出版社</li>
<li><a href="https://blog.csdn.net/ThinkWon/article/details/104903925">重学TCP&#x2F;IP协议和三次握手四次挥手</a></li>
<li><a href="https://blog.csdn.net/ls5718/article/details/52141571?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task">TCP&#x2F;UDP区别以及UDP如何实现可靠传输</a></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/08/18/os/</url>
    <content><![CDATA[<h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><h2 id="ubuntu开机的时候系统做了什么"><a href="#ubuntu开机的时候系统做了什么" class="headerlink" title="ubuntu开机的时候系统做了什么"></a>ubuntu开机的时候系统做了什么</h2><ul>
<li>加载BIOS<br>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做”硬件自检”。硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。</li>
<li>读取MBR<br>计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。</li>
<li>Bootloader<br>在这种情况下，计算机读取”主引导记录”前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统。<br>Boot Loader 就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核做好一切准备。<br>Boot Loader有若干种，其中Grub、Lilo和spfdisk是常见的Loader。Linux环境中，目前最流行的启动管理器是Grub。</li>
<li>加载内核<br>内核的加载，内核加载后，接开始操作系统初始化，根据进程的优先级启动进程。</li>
</ul>
<p>ref. <a href="https://blog.csdn.net/u013830021/article/details/72840669">ubuntu启动过程</a></p>
<h2 id="内核态（管态）和用户态（目态）"><a href="#内核态（管态）和用户态（目态）" class="headerlink" title="内核态（管态）和用户态（目态）"></a>内核态（管态）和用户态（目态）</h2><p>用户态（User Mode）：处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的。</p>
<p>内核态（Kernel Mode）：处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。</p>
<p>三种会导致用户态到内核态切换的情况：</p>
<ol>
<li>系统调用：应用程序主动向操作系统发出的服务请求</li>
<li>异常：非法指令或者其他原因导致当前指令执行失败。(如：内存出错)后的处理请求</li>
<li>外围设备的中断：来自硬件设备的处理请求</li>
</ol>
<p><img src="https://i.loli.net/2020/08/17/HfIPMVh8gSzKe5O.png" alt="中断，异常，系统调用的比较"></p>
<p><a href="https://www.cnblogs.com/gizing/p/10925286.html">用户态和内核态的区别</a></p>
<h2 id="什么的系统调用"><a href="#什么的系统调用" class="headerlink" title="什么的系统调用"></a>什么的系统调用</h2><p><strong>用户态</strong>调用操作系统提供的<strong>内核态</strong>级别的子功能。</p>
<p>系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><p><img src="https://i.loli.net/2020/08/18/zvqBnlW8fGQrgHK.png" alt="计算机系统存储层次"></p>
<h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><ul>
<li>最先匹配(First-fit)</li>
<li>最佳匹配(Best-fit)</li>
<li>最差匹配(Worst-fit)</li>
</ul>
<h3 id="伙伴算法-Buddy-system"><a href="#伙伴算法-Buddy-system" class="headerlink" title="伙伴算法(Buddy system)"></a>伙伴算法(Buddy system)</h3><p>Buddy（伙伴的定义）：<br>这里给出伙伴的概念，满足以下三个条件的称为伙伴：</p>
<ol>
<li>两个块大小相同；</li>
<li>两个块地址连续；</li>
<li>两个块必须是同一个大块中分离出来的；</li>
</ol>
<ul>
<li>伙伴算法分配内存:<br>若申请的内存大小为n则将n向上取整为2的幂设次数为s,则需要分配s大小的内存块,定位大相应数组：<ol>
<li>如果该数组有剩余内存块,则分配出去；</li>
<li>若没有剩余内存块就沿数组向上查找,然后再将该内存块分割出来s并将剩余的内存块放入相应大小的数组中。</li>
</ol>
</li>
</ul>
<p>例如分配5大小的内存块：定位到大小为8的链表中。若该链表中之中没有空余元素,则定位到16的链表中,16中有剩余元素,则取出该元素,并分割出大小为8的内存块供用户使用,然后将剩余的8连接到大小为8的数组中。</p>
<ul>
<li>伙伴算法的内存合并:<br>当用户用完内存后会归还,然后根据该内存块实际大小(向上取整为2的幂)归入链表中,在归入之前,<ol>
<li>我们还要检测他的伙伴内存块是否空闲,</li>
<li>如果空闲就合并在一起,合并后转到1,继续执行.</li>
<li>若果不是空闲的就直接归入链表中.</li>
</ol>
</li>
</ul>
<p>一般来说,伙伴算法实现中会用位图记录内存块是否被使用,用于伙伴内存的合并。</p>
<p>伙伴算法的特点:</p>
<ul>
<li>伙伴算法会浪费大量的内存，(如果需要大小为9的内存块必须分配大小为16的内存块)</li>
<li>优点也是明显的，分配和合并算法都很简单易行。</li>
</ul>
<p><img src="https://i.loli.net/2020/08/18/xpFWL6JzBkbtm8n.png" alt="伙伴系统的分配"></p>
<p><img src="https://i.loli.net/2020/08/18/8OasIUVAMXqhNHe.png" alt="伙伴系统的回收合并"></p>
<p><em>ps. 对于小块内存的分配和回收,伙伴算法效果不好，一般采用slab算法,或者叫做slab机制</em></p>
<h2 id="什么是内存碎片，怎么解决"><a href="#什么是内存碎片，怎么解决" class="headerlink" title="什么是内存碎片，怎么解决"></a>什么是内存碎片，怎么解决</h2><p>空闲的内存不但是能被利用</p>
<ul>
<li>外部碎片：分配单元之间的未被使用内存</li>
<li>内部碎片：<ul>
<li>分配单元内部的未被使用内存 </li>
<li>取决于分配单元大小是否要取整</li>
</ul>
</li>
</ul>
<p>解决：使用<strong>非连续内存分配</strong>：段、页、段页式</p>
<h2 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h2><h3 id="段式存储管理系统"><a href="#段式存储管理系统" class="headerlink" title="段式存储管理系统"></a>段式存储管理系统</h3><p>进程的段地址空间由多个段组成</p>
<ul>
<li>主代码段</li>
<li>子模块代码段</li>
<li>公用库代码段</li>
<li>堆栈段(stack)</li>
<li>堆数据(heap)</li>
<li>初始化数据段</li>
<li>符号表等</li>
</ul>
<p><img src="https://i.loli.net/2020/08/18/pmko41dCPxjAh7X.png" alt="段访问的硬件实现"></p>
<h3 id="页式存储管理系统"><a href="#页式存储管理系统" class="headerlink" title="页式存储管理系统"></a>页式存储管理系统</h3><p>分页就是说，将磁盘或者硬盘分为大小固定的数据块，叫做页，然后内存也分为同样大小的块，叫做页框。当进程执行的时候，会将磁盘的页载入内存的某些页框中，并且正在执行的进程如果发生缺页中断也会发生这个过程。页和页框都是由两个部分组成的，一个是页号或者页框号，一个是偏移量。分页一般是有硬件来完成的，每个页都对应一个页框，它们的对应关系存放在一个叫做页表的数据结构中，页号作为这个页表的索引，页框号作为页表的值。操作系统负责维护这个页表。</p>
<h4 id="帧（物理页面）"><a href="#帧（物理页面）" class="headerlink" title="帧（物理页面）"></a>帧（物理页面）</h4><p>把物理地址空间划分为大小相同的基本分配单位，大小为2的n次方，如512, 4096, 8192。</p>
<p>内存物理地址的表示：二元组 (f, o) </p>
<ul>
<li>f：帧号 (F 位, 共有2^F个帧) </li>
<li>o：帧内偏移 (S 位, 每帧有2^S字节) </li>
<li>物理地址 &#x3D;  f * 2^S + o</li>
</ul>
<p><img src="https://i.loli.net/2020/08/18/PJlxGQvrIZ82RAC.png" alt="帧到物理地址的转换"></p>
<h4 id="页（逻辑页面）"><a href="#页（逻辑页面）" class="headerlink" title="页（逻辑页面）"></a>页（逻辑页面）</h4><p>把逻辑地址空间也划分为相同大小的基本分配单位，帧和页的大小必须是相同的。</p>
<ul>
<li>页内偏移 &#x3D; 帧内偏移</li>
<li>通常：页号大小 ≠ 帧号大小</li>
</ul>
<p>进程逻辑地址的表示：二元组 (p, o)</p>
<ul>
<li>p：页号 (P 位, 2P 个页)</li>
<li>o：页内偏移 (S 位, 每页有2S 字节) </li>
<li>虚拟地址 &#x3D; p * 2S + o</li>
</ul>
<p><img src="https://i.loli.net/2020/08/18/3PGJVqbRfWTBwXO.png" alt="页到帧的映射"></p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p><img src="https://i.loli.net/2020/08/18/mbcz3MByi8nV5UQ.png" alt="页表"></p>
<p>页表项的组成：</p>
<ul>
<li>帧号 f</li>
<li>页表项标志<ul>
<li>存在位</li>
<li>引用位</li>
<li>修改位</li>
</ul>
</li>
</ul>
<h4 id="快表（TLB）"><a href="#快表（TLB）" class="headerlink" title="快表（TLB）"></a>快表（TLB）</h4><p>缓存近期访问的页表项。TLB 使用关联存储(associative memory)实现，具备快速访问性能。</p>
<ul>
<li>如果TLB命中，物理页号可以很快被获取</li>
<li>如果TLB未命中，对应的表项被更新到TLB中</li>
</ul>
<p><img src="https://i.loli.net/2020/08/18/gfuIHvNdwM6Pb3R.png" alt="快表"></p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p><img src="https://i.loli.net/2020/08/18/cFJD3ZoraAMPEfd.png" alt="多级页表"></p>
<p><img src="https://i.loli.net/2020/08/18/79GCmsaUNcoPbW3.png" alt="二级页表示例"></p>
<h3 id="分页和分段有什区别？"><a href="#分页和分段有什区别？" class="headerlink" title="分页和分段有什区别？"></a>分页和分段有什区别？</h3><ul>
<li>分页对程序员是透明的，但是分段需要程序员显式划分每个段。</li>
<li>分页的地址空间是一维地址空间，分段是二维的。</li>
<li>页的大小不可变，段的大小可以动态改变。</li>
<li>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>
</ul>
<p><img src="https://i.loli.net/2020/08/18/lqM8dCZ3ti9vR7B.png" alt="分页和分段有什区别"></p>
<h3 id="段页式存储管理系统"><a href="#段页式存储管理系统" class="headerlink" title="段页式存储管理系统"></a>段页式存储管理系统</h3><p>在段式存储管理基础上，给每个段加一级页表</p>
<p><img src="https://i.loli.net/2020/08/18/OxEH6koDQ4Y3MzU.png" alt="段页式"></p>
<p>段页式存储管理中的内存共享：<br><img src="https://i.loli.net/2020/08/18/6ECwKXGhANcmr9Q.png" alt="段页式存储管理中的内存共享"></p>
<h2 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h2><p>虚拟存储就是说，让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。虚拟内存使用部分加载的技术，让一个进程或者资源的某些页面加载进内存，从而能够加载更多的进程，甚至能加载比内存大的进程，这样看起来好像内存变大了，这部分内存其实包含了磁盘或者硬盘，并且就叫做虚拟内存。</p>
<p><img src="https://i.loli.net/2020/08/17/NrkonUwiHXluMte.png" alt="地址生成过程"></p>
<p><img src="https://i.loli.net/2020/08/17/tcJQk3Gf7hAaIPx.png" alt="地址检查"></p>
<h3 id="虚拟页式存储管理"><a href="#虚拟页式存储管理" class="headerlink" title="虚拟页式存储管理"></a>虚拟页式存储管理</h3><p>在页式存储管理的基础上，增加请求调页和页面置换。</p>
<ul>
<li>当用户程序要装载到内存运行时，只装入部分页面，就启动程序运行</li>
<li>进程在运行中发现有需要的代码或数据不在内存时，则向系统发出缺页异常请求</li>
<li>操作系统在处理缺页异常时，将外存中相应的页面调入内存，使得进程能继续运行</li>
</ul>
<p><img src="https://i.loli.net/2020/08/18/uReoCxG91ZXEDn7.png" alt="虚拟页式存储中地址转换"></p>
<h3 id="虚拟段式存储管理"><a href="#虚拟段式存储管理" class="headerlink" title="虚拟段式存储管理"></a>虚拟段式存储管理</h3><p>在段式存储管理的基础上，以分段为单位进行换入换出。</p>
<h3 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h3><p><img src="https://i.loli.net/2020/08/18/7cR4ansgeVQNuCM.png" alt="缺页异常"></p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>当出现缺页异常，需调入新页面而内存已满时，置换算法选择被置换的物理页面</p>
<h4 id="局部置换"><a href="#局部置换" class="headerlink" title="局部置换"></a>局部置换</h4><p>置换页面的选择范围仅限于当前进程占用的物理页面内</p>
<ul>
<li>最优置换算法<br>选择的被换出的页面是<strong>未来最长时间内不再被访问的页面</strong>，通常可以保证获得最低的缺页率。这是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</li>
<li>先进先出<br>选择换出的页面是最先进入的页面。该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。</li>
<li>最近最久未使用(Least Recently Used, LRU)<br>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。<br>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</li>
<li>时钟算法(Clock)<br>页面装入内存时，访问位初始化为0。访问页面（读&#x2F;写)时，置访问位置为1。缺页时，从指针当前位置顺序检查环形链表：<ul>
<li>访问位为0，则置换该页</li>
<li>访问位为1，则访问位置0，并指针移动到下一个页面，直到找到可置换的页面</li>
</ul>
</li>
<li>最不常用算法(Least Frequently Used, LFU)<br>缺页时，置换访问次数最少的页面。每个页面设置一个访问计数，访问页面时，访问计数加1，缺页时，置换计数最小的页面。</li>
</ul>
<h4 id="全局置换"><a href="#全局置换" class="headerlink" title="全局置换"></a>全局置换</h4><p>置换页面的选择范围是所有可换出的物理页面。</p>
<ul>
<li>工作集置换算法：换出不在工作集中的页面。当前时刻前τ个内存访问的页引用是工作集，τ被称为窗口大小。</li>
<li>缺页率算法：通过调节常驻集大小，使每个进程的缺页率保持在一个合理的范围内。</li>
</ul>
<h4 id="Belady现象"><a href="#Belady现象" class="headerlink" title="Belady现象"></a>Belady现象</h4><p>采用FIFO等算法时，可能出现分配的物理页面数增加，缺页次数反而升高的异常现象</p>
<ul>
<li>FIFO算法的置换特征与进程访问内存的动态特征矛盾</li>
<li>被它置换出去的页面并不一定是进程近期不会访问的</li>
</ul>
<p><strong>LRU算法没有Belady现象</strong></p>
<h4 id="抖动-thrashing"><a href="#抖动-thrashing" class="headerlink" title="抖动(thrashing)"></a>抖动(thrashing)</h4><p>进程物理页面太少，不能包含工作集，造成大量缺页，频繁置换，进程运行速度变慢。</p>
<p>原因：随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升。</p>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>Linux 下创建新进程的系统调用是<code>fork</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t fork(void);</span><br><span class="line"></span><br><span class="line">//处理僵尸进程</span><br><span class="line">pid_t waitpid(pid_t pid, int* stat_loc, int options);</span><br></pre></td></tr></table></figure>

<h3 id="进程有哪几种状态-他们的转换方式"><a href="#进程有哪几种状态-他们的转换方式" class="headerlink" title="进程有哪几种状态?他们的转换方式"></a>进程有哪几种状态?他们的转换方式</h3><ul>
<li>创建状态(new)：进程正在被创建，尚未到就绪状态。</li>
<li>就绪状态(ready)：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li>
<li>运行状态(running)：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li>
<li>阻塞状态(waiting)：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li>
<li>结束状态(terminated)：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>
</ul>
<p><img src="https://i.loli.net/2020/07/26/qWaBZCesYmz5GQT.jpg" alt="系统状态转换图"></p>
<h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><ol>
<li>管道&#x2F;匿名管道(Pipes)：速度慢，容量有限，只用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li>
<li>命名管道(Names Pipes&#x2F;FIFO)：任何进程间都能通讯，但速度慢，严格遵循先进先出(first in first out)。</li>
<li>消息队列(Message Queuing)：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。</li>
<li>信号量(Semaphores)：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。不能传递复杂消息，只能用来同步。</li>
<li>共享内存(Shared memory)：能够很容易控制容量，速度快，但需要依靠某种同步操作，如互斥锁和信号量等。比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。</li>
<li>套接字(Sockets)：此方法主要用于在客户端和服务器之间通过网络进行通信，也可以用于同一主机上的socket通信。</li>
<li>信号(Signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
</ol>
<p><a href="https://www.cnblogs.com/zgq0/p/8780893.html">进程间的五种通信方式介绍</a></p>
<h3 id="进程控制块（process-control-block，PCB）"><a href="#进程控制块（process-control-block，PCB）" class="headerlink" title="进程控制块（process control block，PCB）"></a>进程控制块（process control block，PCB）</h3><p>PCB 是进程存在的唯一标识，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。</p>
<h4 id="进程描述信息："><a href="#进程描述信息：" class="headerlink" title="进程描述信息："></a>进程描述信息：</h4><ul>
<li>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</li>
<li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</li>
</ul>
<h4 id="进程控制和管理信息："><a href="#进程控制和管理信息：" class="headerlink" title="进程控制和管理信息："></a>进程控制和管理信息：</h4><ul>
<li>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</li>
<li>进程优先级：进程抢占 CPU 时的优先级；</li>
</ul>
<h4 id="资源分配清单："><a href="#资源分配清单：" class="headerlink" title="资源分配清单："></a>资源分配清单：</h4><ul>
<li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I&#x2F;O 设备信息。</li>
</ul>
<h4 id="CPU-相关信息："><a href="#CPU-相关信息：" class="headerlink" title="CPU 相关信息："></a>CPU 相关信息：</h4><ul>
<li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。</li>
</ul>
<h4 id="每个-PCB-是如何组织的呢？"><a href="#每个-PCB-是如何组织的呢？" class="headerlink" title="每个 PCB 是如何组织的呢？"></a>每个 PCB 是如何组织的呢？</h4><p>通常是通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。比如：</p>
<ul>
<li>将所有处于就绪状态的进程链在一起，称为就绪队列；</li>
<li>把所有因等待某事件而处于等待状态的进程链在一起就组成各种阻塞队列；</li>
<li>另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。</li>
</ul>
<h3 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h3><ul>
<li><strong>先到先服务</strong>(FCFS)调度算法：从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先</strong>(SJF)的调度算法：从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转</strong>调度算法：时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>多级反馈队列</strong>调度算法：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级</strong>调度：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
<h3 id="孤儿进程，僵尸进程，守护进程"><a href="#孤儿进程，僵尸进程，守护进程" class="headerlink" title="孤儿进程，僵尸进程，守护进程"></a>孤儿进程，僵尸进程，守护进程</h3><p>孤儿进程：父进程退出后子进程还在运行。这些子进程就叫做孤儿进程。孤儿进程被init进程收养。</p>
<p>僵尸进程：子进程结束后，内核不会立即释放该进程的进程表表项，以满足父进程后续对该子进程的信息查询。子进程退出之后，父进程读取其退出状态（调用waitpid获取子进程状态信息）之前，就是僵尸进程。</p>
<p>守护进程：在后台运行不受终端控制的进程。如输入，输出，网络服务等。</p>
<h4 id="创建守护进程"><a href="#创建守护进程" class="headerlink" title="创建守护进程"></a>创建守护进程</h4><ol>
<li>创建子进程，父进程退出</li>
<li>在子进程中创建新的会话（脱离控制终端）：使用系统函数setsid()来创建。</li>
<li>改变当前目录为根目录</li>
<li>重设文件权限掩码，关闭文件描述符</li>
</ol>
<h4 id="处理孤儿进程，僵尸进程"><a href="#处理孤儿进程，僵尸进程" class="headerlink" title="处理孤儿进程，僵尸进程"></a>处理孤儿进程，僵尸进程</h4><p>孤儿进程没有什么危害，所以并不需要怎么处理。</p>
<p>如果父进程一直不调用wait&#x2F;waitpid处理以及退出的子进程，子进程就会一直在系统里占用资源。</p>
<p>僵尸进程的处理方式为：当一个进程结束时，它会给父进程发送一个<code>SIGCHLD</code>信号，我们在父进程中捕获<code>SIGCHLD</code>信号，并在信号处理函数中调用<code>waitpid</code>函数来处理退出的子进程。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>Linux 系统中，线程的基础API都定义在 <code>pthread.h</code> 中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;pthead.h&gt;</span><br><span class="line">int pthread_create(pthread_t* thread, const pthread_attr_r* attr,</span><br><span class="line">                   void* (*start_routine)(void*), void* arg);</span><br><span class="line"></span><br><span class="line">void pthread_exit(void* retval);</span><br></pre></td></tr></table></figure>

<h3 id="线程间的同步的方式"><a href="#线程间的同步的方式" class="headerlink" title="线程间的同步的方式"></a>线程间的同步的方式</h3><ol>
<li>锁机制<ul>
<li>互斥锁：互斥锁提供了以排他方式防止数据结构被并发修改的方法</li>
<li>读写锁：读写锁允许多个线程同时读共享数据，而对写操作是互斥的</li>
<li>条件变量：条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用</li>
<li>自旋锁</li>
</ul>
</li>
<li>信号量(Semphares)：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li>
<li>信号机制(Signal)：类似进程间的信号处理</li>
</ol>
<p>互斥锁与信号量的区别：</p>
<ul>
<li>互斥锁用户线程互斥，信号量用于线程同步。</li>
<li>互斥锁仅用于线程，信号量还可以用于进程。</li>
</ul>
<h3 id="线程安全怎么实现"><a href="#线程安全怎么实现" class="headerlink" title="线程安全怎么实现"></a>线程安全怎么实现</h3><p><strong>线程安全定义</strong>：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。</p>
<p>线程安全的实现方式：</p>
<ol>
<li>互斥同步：指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用。常见的互斥实现方式有：临界区(critical selection)，互斥量(mutex)和信号量(semaphore)。互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种实现方式也叫阻塞同步。从处理问题的方式上来说，互斥同步属于一种悲观的并发策略。</li>
<li>非阻塞同步：随着硬件指令集的发展，我们有了另外的一个选择：基于冲突检测的乐观并发策略。也就是先进行操作，如果没有其它线程使用共享数据，那就操作成功；如果有，那就再采取补偿措施。这种方式不需要把线程挂起，因此称为：非阻塞同步(Non-Blocking Synchronization)。</li>
<li>无同步方案：<ul>
<li>可重入代码</li>
<li>线程本地存储：如果一段代码中所需要的数据都完全包含在同一个线程中，如果能保证这一点，那就不会因为跟其它线程争抢修改资源而导致数据不一致，也就没有线程风险，是线程安全的。</li>
</ul>
</li>
</ol>
<p>ref.</p>
<ul>
<li><a href="https://www.cnblogs.com/nevermorewang/p/9614092.html">线程安全的实现方式</a></li>
</ul>
<h2 id="进程和线程的差别"><a href="#进程和线程的差别" class="headerlink" title="进程和线程的差别"></a>进程和线程的差别</h2><p>线程是指进程内的一个执行单元，也是进程内的可调度实体。线程与进程的区别：</p>
<ul>
<li>调度：线程作为CPU调度的基本单位，进程作为拥有资源的基本单位；</li>
<li>拥有资源：进程是拥有资源的一个独立单元，进程拥有一个完整的资源平台；线程只独享必不可少的资源，如寄存器和栈，不拥有系统资源但可以访问隶属于进程的资源</li>
<li>并发性：不仅进程之间可以并发执行，同一个进程的多个线程也可以并发执行；</li>
<li>线程的状态：线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li>
<li>系统开销：在创建或撤销进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤销线程时的开销；</li>
</ul>
<h2 id="进程上下文切换，线程上下文切换，中断上下文切换"><a href="#进程上下文切换，线程上下文切换，中断上下文切换" class="headerlink" title="进程上下文切换，线程上下文切换，中断上下文切换"></a>进程上下文切换，线程上下文切换，中断上下文切换</h2><h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>进程上下文包括计算机系统中与执行该进程有关的各种<strong>寄存器</strong>（例如<strong>通用寄存器</strong>，<strong>程序计数器PC</strong>，<strong>程序状态字寄存器PS</strong>等）的值，程序段在经过编译过后形成的<strong>机器指令代码集</strong>，数据集及<strong>各种堆栈值</strong>PCB结构。</p>
<p>当切换进程时，需要保存当前进程的所有状态，即当前进程的<strong>进程上下文</strong>，以便再次执行该进程时，能够恢复切换时的状态，继续执行。</p>
<h3 id="发生进程上下文切换有哪些场景？"><a href="#发生进程上下文切换有哪些场景？" class="headerlink" title="发生进程上下文切换有哪些场景？"></a>发生进程上下文切换有哪些场景？</h3><p>在进程状态发生改变时，且进程基本都属于进程上下文切换的场景：</p>
<ul>
<li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；</li>
<li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；</li>
<li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；</li>
<li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；</li>
<li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；</li>
</ul>
<h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>线程上下文：当进程只有一个线程时，可以认为进程就等于线程；当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的；另外，线程也有自己的私有数据，比如<strong>栈和寄存器</strong>等，这些在上下文切换时也是需要保存的。</p>
<p>线程的上下文切换：</p>
<ul>
<li>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；</li>
<li>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；</li>
</ul>
<h3 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h3><p>中断上下文：中断时需要保存的参数和进程环境。</p>
<h3 id="线程有自己的堆，栈吗"><a href="#线程有自己的堆，栈吗" class="headerlink" title="线程有自己的堆，栈吗"></a>线程有自己的堆，栈吗</h3><p>与线程“绑定”的是栈，用于存储自动变量。每一个线程建立的时候，都会新建一个默认栈与之配合。堆则是通常与进程相关，用于存储全局性的变量，进程建立的时候，会建立默认堆。于是，每一个线程都有自己的栈，然后访问共同的堆。当然，你可以通过OsApi建立其他堆栈。</p>
<ul>
<li>堆：是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。</li>
<li>栈：是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是　thread safe的。操作系统在切换线程的时候会自动的切换栈，就是切换　ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放。</li>
</ul>
<h2 id="并发，同步，异步，互斥，阻塞，非阻塞"><a href="#并发，同步，异步，互斥，阻塞，非阻塞" class="headerlink" title="并发，同步，异步，互斥，阻塞，非阻塞"></a>并发，同步，异步，互斥，阻塞，非阻塞</h2><p>并发：多个程序同时运行即并发。并发可分为<strong>同步</strong>和<strong>互斥</strong>。</p>
<h3 id="同步，互斥"><a href="#同步，互斥" class="headerlink" title="同步，互斥"></a>同步，互斥</h3><p>互斥：同一时间只能有一个访问者访问资源，无序的</p>
<p>同步：必须按照某种顺序运行。在互斥的基础上通过其他机制实现资源的有序访问。</p>
<p>同步时一种更复杂的互斥，互斥是一种特殊的同步。</p>
<h3 id="同步，异步"><a href="#同步，异步" class="headerlink" title="同步，异步"></a>同步，异步</h3><p>同步：顺序执行，需要等待、协调运作。</p>
<p>异步：彼此独立，在等待某事件的过程中继续做自己的事，不需要等待。</p>
<ul>
<li>线程是实现异步的一个方式</li>
<li>异步 不等于 多线程。异步是最终目的，多线程只是实现异步的一种手段</li>
</ul>
<h3 id="阻塞，非阻塞"><a href="#阻塞，非阻塞" class="headerlink" title="阻塞，非阻塞"></a>阻塞，非阻塞</h3><p>经常访问数据时，根据IO操作的就绪状态不同采取的不同处理方式。比如读取文件内容，阻塞方式下主程序会等到函数读取完再继续，非阻塞方式下主程序不等待文件读取完就继续往下执行。</p>
<p>一般可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞</p>
<h3 id="同步阻塞，同步非阻塞，异步阻塞，异步非阻塞"><a href="#同步阻塞，同步非阻塞，异步阻塞，异步非阻塞" class="headerlink" title="同步阻塞，同步非阻塞，异步阻塞，异步非阻塞"></a>同步阻塞，同步非阻塞，异步阻塞，异步非阻塞</h3><p>以发送方发出请求要接收方读取文件内容为例。</p>
<ul>
<li>同步阻塞：发送方发出请求后一直等待（同步）。接受方开始读取，如果不能马上读到就一直等待，直到读取后响应发送方，等待期间不能做其他操作（阻塞）。</li>
<li>同步非阻塞：发送方发出请求后一直等待（同步）。接受方开始读取，如果不能马上读到就立即返回继续做其他事情（非阻塞），并未响应发送方。直到IO完成才响应。</li>
<li>异步阻塞：发送方发出请求后不等待响应，继续其他工作（异步）。接受方开始读取，如果不能马上读到就一直等待，直到读取后响应发送方，等待期间不能做其他操作（阻塞）。</li>
<li>异步非阻塞：发送方发出请求后不等待响应，继续其他工作（异步）。接受方开始读取，如果不能马上读到就立即返回继续做其他事情（非阻塞），并未响应发送方。直到IO完成才响应。（效率最高）</li>
</ul>
<p><em>ps. 发送方等待就是同步，不等待就是异步；接收方等待就是阻塞，不等待就是非阻塞。</em></p>
<p>总结：</p>
<ul>
<li>同步异步是两个线程之间的关系，两个线程之间要么是同步的，要么是异步的。</li>
<li>阻塞与非阻塞是对同一个线程来说。某个时刻，线程处于阻塞或非阻塞</li>
</ul>
<h2 id="多进程、多线程的优缺点"><a href="#多进程、多线程的优缺点" class="headerlink" title="多进程、多线程的优缺点"></a>多进程、多线程的优缺点</h2><ul>
<li>多进程更鲁棒，一个进程死了不影响其他进程，子进程死了不影响主进程。多线程比较脆弱，一个线程崩溃可能会影响整个程序。</li>
<li>进程性能大于线程，但是创建进程花销大于线程。</li>
<li>进程通讯需要跨越进程边界，不适合大量数据传送，更适合小数据活着密集数据。线程可以共享内存和变量，适合大量数据的传送。</li>
<li>多进程逻辑空控制比多线程复杂</li>
<li>多线程虽然逻辑控制比较简单，但是需要复杂的同步和加锁控制等机制</li>
<li>可以通过增加CPU数量来增加进程的数量，但是不能通过增加CPU来增加线程的数量，线程的数量由进程的空间资源和线程本身栈大小确定。</li>
</ul>
<h2 id="为什么要使用线程？与进程相比有哪些好处"><a href="#为什么要使用线程？与进程相比有哪些好处" class="headerlink" title="为什么要使用线程？与进程相比有哪些好处"></a>为什么要使用线程？与进程相比有哪些好处</h2><ol>
<li>资源<br>和进程相比，它是一种非常”节俭”的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。</li>
<li>切换效率<br>运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。（但是进程性能大于线程）</li>
<li>通信<br>线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。</li>
<li>使多CPU系统更加有效。<br>操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。(CPU设计保证）</li>
<li>改善程序结构。<br>一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。（代码易维护）</li>
</ol>
<h2 id="什么时候用进程，什么时候用线程"><a href="#什么时候用进程，什么时候用线程" class="headerlink" title="什么时候用进程，什么时候用线程"></a>什么时候用进程，什么时候用线程</h2><p>进程用来“做大事”，线程用来“各自做小事”：</p>
<ul>
<li>创建和销毁较频繁，用线程</li>
<li>需要大量数据传送，用线程</li>
<li>并行操作，用线程</li>
<li><strong>总结</strong>：安全稳定用进程，快速频繁用线程</li>
</ul>
<h2 id="Linux查看-x2F-杀死-x2F-重启进程"><a href="#Linux查看-x2F-杀死-x2F-重启进程" class="headerlink" title="Linux查看&#x2F;杀死&#x2F;重启进程"></a>Linux查看&#x2F;杀死&#x2F;重启进程</h2><ul>
<li>查看：<code>ps -aux</code> 或 <code>ps -ef</code></li>
<li>杀死：<code>kill -PID</code> 或强制杀死<code>kill -KILL PID</code></li>
<li>重启：<code>kill -HUP PID</code></li>
</ul>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="https://www.nowcoder.com/discuss/450511?type=all&order=time&pos=&page=1&channel=666&source_id=search_all">进程、线程基础知识全家桶</a></p>
<h2 id="有哪些锁？"><a href="#有哪些锁？" class="headerlink" title="有哪些锁？"></a>有哪些锁？</h2><ul>
<li>互斥锁：同一时间只能有一个线程获得互斥锁，其他线程阻塞进入休眠态</li>
<li>读写锁：同一时间可以有多个线程获得读锁，适用于读操作频繁的场景</li>
<li>自旋锁：同一时间只能有一个线程获得自旋锁，其他线程会一直等待锁并且不会进入休眠态，如果不加限制，某个线程申请已经锁定的自旋锁，就会导致其他线程卡死，所以自旋锁适用于锁拥有者保持锁时间很短的场景</li>
</ul>
<p><a href="https://www.nowcoder.com/questionTerminal/554355eea5aa44d697a3a4bc99795207">C++有哪些锁</a></p>
<h2 id="什么是可重入和不可重入函数？"><a href="#什么是可重入和不可重入函数？" class="headerlink" title="什么是可重入和不可重入函数？"></a>什么是可重入和不可重入函数？</h2><ul>
<li>可重入函数可以由多个任务并发使用，而不必担心数据错误。<br>可重入函数可以在任意时刻被中断，稍后继续运行，不会丢失数据，可重入函数要么使用本地变量，要么使用全局变量时保护自己的数据。</li>
<li>不可重入函数不能由多个任务共享，除非能确保函数的互斥。</li>
</ul>
<p>特点：</p>
<ul>
<li>可重入函数  <ul>
<li>不可连续的调用持有静态数据；</li>
<li>不返回指向静态数据的指针，所有数据都是由函数的调用者提供；</li>
<li>使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据；</li>
<li>如果必须访问全局变量，记住利用互斥信号量来保护全局变量；</li>
<li>绝不调用任何不可重入函数。</li>
</ul>
</li>
<li>不可重入函数  <ul>
<li>函数中使用了静态变量，无论是全局静态变量还是局部静态变量；</li>
<li>函数返回静态变量；</li>
<li>函数中调用了不可重入函数；</li>
<li>函数体内使用了静态的数据结构；</li>
<li>函数体内调用了malloc()或者free()函数；</li>
<li>函数体内调用了其他标准I&#x2F;O函数；</li>
</ul>
</li>
</ul>
<p>总之，如果一个函数在重入条件下使用了未受保护的共享资源，那么就是不可重入的。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>死锁</strong>是指两个或多个进程在执行的过程中，因为竞争资源而造成互相等待的现象，若无外力作用，它们都无法推进下去。</p>
<h3 id="死锁的处理方法"><a href="#死锁的处理方法" class="headerlink" title="死锁的处理方法"></a>死锁的处理方法</h3><ul>
<li>预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。</li>
<li>避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。</li>
<li>检测死锁：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。</li>
<li>解除死锁：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来。</li>
</ul>
<h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><ol>
<li>因为系统资源不足。</li>
<li>进程运行推进的顺序不合适。</li>
<li>资源分配不当等。</li>
</ol>
<h3 id="死锁的4个必要条件"><a href="#死锁的4个必要条件" class="headerlink" title="死锁的4个必要条件"></a>死锁的4个必要条件</h3><ol>
<li>互斥：一个资源每次只能被一个进程使用。</li>
<li>请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h3 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h3><p>我们可以通过破坏产生死锁的四个必要条件来预防死锁，但是<strong>资源互斥</strong>是固有特性无法改变的。</p>
<ol>
<li>破坏“请求与保持”条件<ul>
<li>静态分配，每个进程在开始执行时就申请他所需要的全部资源。</li>
<li>动态分配，每个进程在申请所需要的资源时他本身不占用系统资源。</li>
</ul>
</li>
<li>破坏“不可剥夺”条件<br>一个进程不可获得其所需要的全部资源便处于等待状态，等待期间他占用的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。</li>
<li>破坏“循环等待”条件<br>采用资源有序分配的基本思想。将系统中的资源顺序进行编号，将紧缺的、稀少的资源采用较大的编号，申请资源时必须按照编号的顺序执行，一个进程只有较小编号的进程才能申请较大编号的进程。</li>
</ol>
<h3 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h3><ul>
<li>有序资源分配法：源按某种规则系统中的所有资源统一编号，申请时必须以上升的次序。</li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95">银行家算法</a></li>
</ul>
<h3 id="ref-1"><a href="#ref-1" class="headerlink" title="ref."></a>ref.</h3><ul>
<li><a href="https://blog.csdn.net/wljliujuan/article/details/79614019?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">死锁</a></li>
</ul>
<h2 id="进程占用率过高怎么排查"><a href="#进程占用率过高怎么排查" class="headerlink" title="进程占用率过高怎么排查"></a>进程占用率过高怎么排查</h2><ul>
<li>jstack：适用于java进程，可以取到所以线程的堆栈dump；</li>
<li>pstack：适用于所有linux进程，是对gdb的功能封装。<br>此命令可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID。</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>文件描述符是打开文件的标识，操作系统在打开文件表中维护的打开文件状态和信息。</p>
<ul>
<li>文件指针</li>
<li>文件打开计数</li>
<li>文件的磁盘位置</li>
<li>访问权限</li>
</ul>
<h2 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h2><p>Linux文件系统里面有文件和目录，组成一个树状的结构，树的每一个叶子节点表示文件或者空目录。每个文件基本上都由两部分组成：</p>
<ul>
<li>inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；</li>
<li>block：记录文件的内容，文件太大时，会占用多个 block。</li>
</ul>
<p>除此之外还包括：</p>
<ul>
<li>superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li>
<li>block bitmap：记录 block 是否被使用的位图。</li>
</ul>
<p>当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。</p>
<p><a href="https://www.cnblogs.com/huxiao-tee/p/4657851.html">从内核文件系统看文件读写过程</a></p>
<h2 id="什么是-inode"><a href="#什么是-inode" class="headerlink" title="什么是 inode"></a>什么是 inode</h2><p>理解inode，要从文件储存说起。</p>
<p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</p>
<p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p>
<p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p>
<p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p>
<h2 id="Linux-文件系统通过-i-节点把文件的逻辑结构和物理结构转换的工作过程"><a href="#Linux-文件系统通过-i-节点把文件的逻辑结构和物理结构转换的工作过程" class="headerlink" title="Linux 文件系统通过 i 节点把文件的逻辑结构和物理结构转换的工作过程"></a>Linux 文件系统通过 i 节点把文件的逻辑结构和物理结构转换的工作过程</h2><p>Linux 通过 inode 节点表将文件的逻辑结构和物理结构进行转换。</p>
<p>inode 节点是一个 64 字节长的表，表中包含了文件的相关信息，其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息。在 inode 节点表中最重要的内容是磁盘地址表。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。<br>Linux 文件系统通过把 inode 节点和文件名进行连接，当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的 inode 节点号，通过该 inode 节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构。</p>
<h2 id="硬链接和软链接有什么区别"><a href="#硬链接和软链接有什么区别" class="headerlink" title="硬链接和软链接有什么区别"></a>硬链接和软链接有什么区别</h2><ul>
<li><p>硬链接：由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1。<br>不足：</p>
<ul>
<li>不可以在不同文件系统的文件间建立链接；</li>
<li>只有超级用户才可以为目录创建硬链接。</li>
</ul>
</li>
<li><p>软链接：软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。<br>不足：</p>
<ul>
<li>因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。</li>
</ul>
</li>
<li><p>实际场景下，基本是使用软链接。总结区别如下：</p>
<ul>
<li>硬链接不可以跨分区，软件链可以跨分区。</li>
<li>硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点。</li>
<li>删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/09/03/5HGam2yJM8VLACu.jpg" alt="软硬链接的区别"></p>
<h2 id="文件的分配"><a href="#文件的分配" class="headerlink" title="文件的分配"></a>文件的分配</h2><ul>
<li>连续分配</li>
<li>链式分配</li>
<li>索引分配</li>
</ul>
<h2 id="操作系统读写文件的过程"><a href="#操作系统读写文件的过程" class="headerlink" title="操作系统读写文件的过程"></a>操作系统读写文件的过程</h2><p><a href="https://github.com/justtreee/blog/issues/18">从Linux文件系统看文件读写过程</a><br><a href="https://www.cnblogs.com/huxiao-tee/p/4657851.html">从内核文件系统看文件读写过程</a></p>
<h1 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><h2 id="三种I-x2F-O操作"><a href="#三种I-x2F-O操作" class="headerlink" title="三种I&#x2F;O操作"></a>三种I&#x2F;O操作</h2><ul>
<li>阻塞I&#x2F;O：读写数据时，进程将进入等待状态</li>
<li>非阻塞I&#x2F;O：立即从read或write系统调用返回，返回值为成功传输字节数</li>
<li>异步I&#x2F;O：使用指针标记好用户缓冲区，立即返回；稍后内核再处理并通知用户</li>
</ul>
<h2 id="I-x2F-O请求生存周期"><a href="#I-x2F-O请求生存周期" class="headerlink" title="I&#x2F;O请求生存周期"></a>I&#x2F;O请求生存周期</h2><p><img src="https://i.loli.net/2020/08/18/ytkB6C9Nzed8MlH.png" alt="I/O请求生存周期"></p>
<h2 id="CPU与设备控制器的数据传输"><a href="#CPU与设备控制器的数据传输" class="headerlink" title="CPU与设备控制器的数据传输"></a>CPU与设备控制器的数据传输</h2><h3 id="程序控制I-x2F-O-PIO-Programmed-I-x2F-O"><a href="#程序控制I-x2F-O-PIO-Programmed-I-x2F-O" class="headerlink" title="程序控制I&#x2F;O(PIO, Programmed I&#x2F;O)"></a>程序控制I&#x2F;O(PIO, Programmed I&#x2F;O)</h3><p>通过CPU的in&#x2F;out或者load&#x2F;store传输所有数据。</p>
<p><img src="https://i.loli.net/2020/08/18/pKiDgIs43dXkS25.png" alt="直接IO读取磁盘步骤"></p>
<h3 id="直接内存访问-DMA"><a href="#直接内存访问-DMA" class="headerlink" title="直接内存访问(DMA)"></a>直接内存访问(DMA)</h3><p>设备控制器可直接访问系统总线，控制器直接与内存互相传输数据。</p>
<h2 id="I-x2F-O设备如何通知操作系统"><a href="#I-x2F-O设备如何通知操作系统" class="headerlink" title="I&#x2F;O设备如何通知操作系统"></a>I&#x2F;O设备如何通知操作系统</h2><ul>
<li>CPU主动轮询：I&#x2F;O 设备在特定的状态寄存器中放置状态和错误信息，操作系统定期检测状态寄存器。</li>
<li>设备中断：CPU在I&#x2F;O之前设置任务参数；CPU发出I&#x2F;O请求后，继续执行其他任务；I&#x2F;O设备处理I&#x2F;O请求；I&#x2F;O设备处理完成时，触发CPU中断请求；CPU接收中断，分发到相应中断处理例程。<br><img src="https://i.loli.net/2020/08/18/39Buzsox264Z7GN.png" alt="设备中断处理流程"></li>
</ul>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><ul>
<li>先来先服务(FIFO)<ul>
<li>按照磁盘请求的顺序进行调度。</li>
<li>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</li>
</ul>
</li>
<li>最短寻道时间优先(SSTF)<ul>
<li>优先调度与当前磁头所在磁道距离最近的磁道。</li>
<li>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。一般来说，两端的磁道请求更容易出现饥饿现象。</li>
</ul>
</li>
<li>电梯算法(SCAN扫描算法)<ul>
<li>电梯算法就是说读写磁头总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li>
<li>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了最短寻道时间优先的饥饿问题。</li>
</ul>
</li>
<li>循环扫描算法(C-SCAN)<ul>
<li>限制了仅在一个方向上扫描</li>
<li>当最后一个磁道也被访问过了后，磁臂返回到磁盘的另外一端再次进行</li>
</ul>
</li>
<li>C-LOOK算法<ul>
<li>磁臂先到达该方向上最后一个请求处，然后立即反转，而不是先到最后点路径上的所有请求</li>
</ul>
</li>
<li>N步扫描(N-step-SCAN)算法<ul>
<li>磁头粘着(Arm Stickiness)现象：SSTF、SCAN及CSCAN等算法中，可能出现磁头停留在某处不动的情况</li>
<li>N步扫描算法将磁盘请求队列分成长度为N的子队列，按FIFO算法依次处理所有子队列，扫描算法处理每个队列</li>
</ul>
</li>
<li>双队列扫描(FSCAN)算法<ul>
<li>FSCAN算法是N步扫描算法的简化，FSCAN只将磁盘请求队列分成两个子队列</li>
<li>把磁盘I&#x2F;O请求分成两个队列，交替使用扫描算法处理一个队列，新生成的磁盘I&#x2F;O请求放入另一队列中，所有的新请求都将被推迟到下一次扫描时处理。</li>
</ul>
</li>
</ul>
<h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><ul>
<li>单缓存<br><img src="https://i.loli.net/2020/08/18/qrHuvCbRY7TkeXP.png" alt="单缓存"></li>
<li>双缓存<br><img src="https://i.loli.net/2020/08/18/p8TtFbZy4HimRBQ.png" alt="双缓存"></li>
</ul>
<h1 id="ref-2"><a href="#ref-2" class="headerlink" title="ref"></a>ref</h1><ul>
<li><a href="http://os.cs.tsinghua.edu.cn/oscourse/OS2019spring">清华大学操作系统课程</a></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode每日一题 - 2020年七月</title>
    <url>/2020/07/01/LeetcodeDaily_July/</url>
    <content><![CDATA[<h1 id="7月1日-718-最长重复子数组（中等）"><a href="#7月1日-718-最长重复子数组（中等）" class="headerlink" title="7月1日 718. 最长重复子数组（中等）"></a>7月1日 <a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组（中等）</a></h1><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">A: [1,2,3,2,1]</span><br><span class="line">B: [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">长度最长的公共子数组是 [3, 2, 1] 。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>滑动窗口。主串从第一个开始，滑动匹配串直到与主串的当前元素相等，再看后面一共有几个元素相等。分别以 A 为主串和 B 为主串匹配一次取最大。比如A &#x3D; {0,0,0,0,0,0,1,0,0,0}, B &#x3D; {0,0,0,0,0,0,0,1,0,0}，以 A 为主串会得到6。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int findCore(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B)&#123;</span><br><span class="line">    int maxLen = 0;</span><br><span class="line">    for (int i = 0; i &lt; A.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int j = 0;</span><br><span class="line"></span><br><span class="line">        while (j &lt; B.size())</span><br><span class="line">        &#123;</span><br><span class="line">            while(j&lt;B.size() &amp;&amp; B[j]!=A[i])//判断边界的一定要在前面</span><br><span class="line">                j++;</span><br><span class="line">            if(j==B.size())</span><br><span class="line">                break;</span><br><span class="line">            int cur = i;</span><br><span class="line">            while(cur&lt;A.size() &amp;&amp; j&lt;B.size() &amp;&amp; A[cur]==B[j])&#123;</span><br><span class="line">                cur++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = max(maxLen, cur - i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;</span><br><span class="line">    if(A.empty() || B.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int a = findCore(A, B);</span><br><span class="line">    int b = findCore(B, A);</span><br><span class="line">    return max(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O((m+n) * min{n,m})。m、n为数组的长度。<br>空间复杂度：O(1)</p>
</li>
<li><p>二维dp。dp[i][j]表示A[0:i) 和 B[0:i)最长公共字串长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;</span><br><span class="line">    if(A.empty() || B.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int a = A.size(), b = B.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(a + 1, vector&lt;int&gt;(b + 1, 0));</span><br><span class="line">    int maxLen = 0;</span><br><span class="line">    for (int i = 1; i &lt;= a; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= b;j++)&#123;</span><br><span class="line">            if(A[i - 1] == B[j - 1])</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">            maxLen = max(maxLen, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p>
</li>
<li><p>一维dp。<br>因为只用到了上一行的dp，所以可以只用一维dp来做，但是j的更新就需要从后往前，因为更新当前的值需要上一行的前面的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;</span><br><span class="line">    if(A.empty() || B.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int a = A.size(), b = B.size();</span><br><span class="line">    vector&lt;int&gt; dp(b + 1, 0);</span><br><span class="line">    int maxLen = 0;</span><br><span class="line">    for (int i = 1; i &lt;= a; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = b; j &gt; 0;j--)&#123;</span><br><span class="line">            if(A[i - 1] == B[j - 1])</span><br><span class="line">                dp[j] = dp[j - 1] + 1;</span><br><span class="line">            else</span><br><span class="line">                dp[j] = 0;</span><br><span class="line">            maxLen = max(maxLen, dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(m)</p>
</li>
</ol>
<h1 id="7月2日-378-有序矩阵中第K小的元素（中等）"><a href="#7月2日-378-有序矩阵中第K小的元素（中等）" class="headerlink" title="7月2日 378. 有序矩阵中第K小的元素（中等）"></a>7月2日 <a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第K小的元素（中等）</a></h1><p>给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。<br>请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">   [ 1,  5,  9],</span><br><span class="line">   [10, 11, 13],</span><br><span class="line">   [12, 13, 15]</span><br><span class="line">],</span><br><span class="line">k = 8,</span><br><span class="line"></span><br><span class="line">返回 13。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>把二维拉成一维，然后排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123;</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    for(int i=0;i&lt;matrix.size();i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;matrix[0].size();j++)&#123;</span><br><span class="line">            vec.push_back(matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(vec.begin(),vec.end());</span><br><span class="line">    return vec[k-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2 * log(n^2))<br>空间复杂度：O(n^2)</p>
</li>
<li><p>类似与归并排序。到第k个就结束。本代码每次都遍历每一行的首位元素，找到最小值弹出。（其实可以用一个小根堆来求最小值，可以减少时间复杂度为O(k * logn)）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int kthSmallest(vector&lt;vector&lt;int&gt; &gt;&amp; matrix, int k) &#123;</span><br><span class="line">    int n = matrix.size();</span><br><span class="line">    for (int i = 0; i &lt; k;i++)&#123;</span><br><span class="line">        int min = 0;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            while (matrix[min].empty())</span><br><span class="line">                min++;</span><br><span class="line">            if (matrix[j].empty())</span><br><span class="line">                continue;</span><br><span class="line">            min = matrix[min][0] &lt;= matrix[j][0] ? min : j;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i==k-1)</span><br><span class="line">            return matrix[min][0];</span><br><span class="line">        matrix[min].erase(matrix[min].begin(), matrix[min].begin() + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(k * n)<br>空间复杂度：O(1)</p>
</li>
</ol>
<h1 id="7月3日-108-将有序数组转换为二叉搜索树（简单）"><a href="#7月3日-108-将有序数组转换为二叉搜索树（简单）" class="headerlink" title="7月3日 108. 将有序数组转换为二叉搜索树（简单）"></a>7月3日 <a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树（简单）</a></h1><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>
<p>题解：<br>递归。中序遍历，总是选择中间位置左边的数字作为根节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeNode *buildTree(vector&lt;int&gt;&amp; nums, int left, int right)&#123;</span><br><span class="line">    if (left &gt; right) &#123;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    // 总是选择中间位置左边的数字作为根节点</span><br><span class="line">    int mid = (left + right) / 2;</span><br><span class="line"></span><br><span class="line">    TreeNode* root = new TreeNode(nums[mid]);</span><br><span class="line">    root-&gt;left = buildTree(nums, left, mid - 1);</span><br><span class="line">    root-&gt;right = buildTree(nums, mid + 1, right);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int L = 0, R = nums.size()-1;</span><br><span class="line">    TreeNode *res = buildTree(nums, L, R);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(logn)</p>
<h1 id="7月4日-32-最长有效括号（困难）"><a href="#7月4日-32-最长有效括号（困难）" class="headerlink" title="7月4日 32. 最长有效括号（困难）"></a>7月4日 <a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号（困难）</a></h1><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></figure>
<p>示例3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;()(())&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释，都是有效的。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>栈。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int longestValidParentheses(string s) &#123;</span><br><span class="line">    stack&lt;int&gt; st1;</span><br><span class="line">    st1.push(-1);</span><br><span class="line">    int longest = 0;</span><br><span class="line">    for (int i = 0; i &lt; s.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]==&#x27;(&#x27;)</span><br><span class="line">            st1.push(i);</span><br><span class="line">        else&#123;</span><br><span class="line">            st1.pop();</span><br><span class="line">            if(st1.empty())</span><br><span class="line">                st1.push(i);</span><br><span class="line">            else</span><br><span class="line">                longest = max(longest, i - st1.top());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
</li>
<li><p>dp。</p>
</li>
</ol>
<ul>
<li>s[i]&#x3D;‘)’ 且 s[i−1]&#x3D;‘(’，也就是字符串形如 “……()”“……()”，我们可以推出：<code>dp[i]=dp[i-2]+2</code></li>
<li>s[i]&#x3D;‘)’ 且 s[i−1]&#x3D;‘)’，也就是字符串形如 “……))”“……))”，我们可以推出：如果s[i−dp[i−1]−1]&#x3D;‘(’，那么：<code>dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2</code>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（代码略）</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="7月5日-44-通配符匹配（困难）"><a href="#7月5日-44-通配符匹配（困难）" class="headerlink" title="7月5日 44. 通配符匹配（困难）"></a>7月5日 <a href="https://leetcode-cn.com/problems/wildcard-matching/">44. 通配符匹配（困难）</a></h1><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>
<ol>
<li>‘?’ 可以匹配任何单个字符。</li>
<li>‘*’ 可以匹配任意字符串（包括空字符串）。</li>
</ol>
<p>两个字符串完全匹配才算匹配成功。</p>
<p>说明:</p>
<ol>
<li>s 可能为空，且只包含从 a-z 的小写字母。</li>
<li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</li>
</ol>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &#x27;*&#x27; 可以匹配任意字符串。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;cb&quot;</span><br><span class="line">p = &quot;?a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &#x27;?&#x27; 可以匹配 &#x27;c&#x27;, 但第二个 &#x27;a&#x27; 无法匹配 &#x27;b&#x27;。</span><br></pre></td></tr></table></figure>
<p>示例 4:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;adceb&quot;</span><br><span class="line">p = &quot;*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 第一个 &#x27;*&#x27; 可以匹配空字符串, 第二个 &#x27;*&#x27; 可以匹配字符串 &quot;dce&quot;.</span><br></pre></td></tr></table></figure>
<p>示例 5:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;acdcb&quot;</span><br><span class="line">p = &quot;a*c?b&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>递归。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool matchCore(string s, string p, int idxS, int idxP)&#123;</span><br><span class="line">    if(idxS == s.size() &amp;&amp; idxP == p.size())</span><br><span class="line">        return true;</span><br><span class="line">    if(idxS &gt;= s.size())&#123;</span><br><span class="line">        if(p[idxP] != &#x27;*&#x27;)</span><br><span class="line">            return false;</span><br><span class="line">        else</span><br><span class="line">            return matchCore(s, p, idxS, idxP + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(p[idxP]==&#x27;*&#x27;)&#123;</span><br><span class="line">        if(idxP==p.size()-1)</span><br><span class="line">            return true;</span><br><span class="line">        while(p[idxP]==&#x27;*&#x27;)//匹配连续的&#x27;*&#x27;</span><br><span class="line">            idxP++;</span><br><span class="line">        return matchCore(s, p, idxS + 1, idxP - 1) || matchCore(s, p, idxS, idxP);</span><br><span class="line">    &#125;</span><br><span class="line">    if(p[idxP]==&#x27;?&#x27; || s[idxS]==p[idxP])</span><br><span class="line">        return matchCore(s, p, idxS + 1, idxP + 1);</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isMatch(string s, string p) &#123;</span><br><span class="line">    return matchCore(s, p, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(2^k)。k是‘*’串的个数。超时，941 &#x2F; 1809 个通过测试用例。<br>空间复杂度：O(2^k)，递归调用需要用到栈</p>
</li>
<li><p>dp。<br><code>dp[i][j]</code>表示字符串s的前i个字符p的前j个字符是否能匹配。</p>
</li>
</ol>
<ul>
<li>注意：s和p下标是从 0 开始的。</li>
<li>当<code>s[i-1]==p[j-1]</code>或<code>p[j-1]==&#39;?&#39;</code>时：<code>dp[i][j] = dp[i - 1][j - 1]</code>。</li>
<li>当<code>p[j-1]==&#39;*&#39;</code>时：如果使用’*‘，则<code>dp[i][j] = dp[i-1][j]</code>；如果不使用’*‘，则<code>dp[i][j] = dp[i][j-1]</code>。</li>
<li>初始状态：<code>dp[0][0] = true</code>；<code>dp[i][0] = false</code>；如果直到<code>p[i]</code>前面都是”*“，<code>dp[0][0～i] = true</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isMatch(string s, string p) &#123;</span><br><span class="line">    int m = s.size(), n = p.size();</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; dp(m + 1, vector&lt;bool&gt;(n + 1, false));</span><br><span class="line"></span><br><span class="line">    dp[0][0] = true;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if (p[i - 1] == &#x27;*&#x27;)</span><br><span class="line">            dp[0][i] = true;</span><br><span class="line">        else</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n;j++)&#123;</span><br><span class="line">            if(p[j-1]==&#x27;?&#x27; || p[j-1]==s[i-1])</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">            else if(p[j-1]==&#x27;*&#x27;)</span><br><span class="line">                dp[i][j] = dp[i][j - 1] || dp[i - 1][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(mn)<br>空间复杂度：O(mn)</li>
</ul>
<p><em>ps. 以后碰到这种题，直接用dp，递归基本都是时间复杂度比较高的。</em></p>
<h1 id="7月6日-63-不同路径-II（中等）"><a href="#7月6日-63-不同路径-II（中等）" class="headerlink" title="7月6日 63. 不同路径 II（中等）"></a>7月6日 <a href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II（中等）</a></h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>二维dp。<br><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></li>
</ol>
<p>注意初始化：</p>
<ul>
<li>当obstacleGrid[i][j]&#x3D;&#x3D;1时dp[i][j] &#x3D; 0；</li>
<li>第一行和第一列，obstacleGrid[0][j]&#x3D;&#x3D;1和obstacleGrid[i][0]&#x3D;&#x3D;1之前初始化为1。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt; &gt;&amp; obstacleGrid) &#123;</span><br><span class="line">    int m = obstacleGrid.size(), n = obstacleGrid[0].size();</span><br><span class="line">    if(m==0 || obstacleGrid[0][0]==1)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(m,vector&lt;int&gt;(n,0));</span><br><span class="line"></span><br><span class="line">    dp[0][0] = 1;</span><br><span class="line">    for (int i = 1; i &lt; m; i++)&#123;</span><br><span class="line">        if(obstacleGrid[i][0]==1)</span><br><span class="line">            break;</span><br><span class="line">        dp[i][0] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int j = 1; j &lt; n;j++)&#123;</span><br><span class="line">        if(obstacleGrid[0][j]==1)</span><br><span class="line">            break;</span><br><span class="line">        dp[0][j] = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt; n;j++)&#123;</span><br><span class="line">            if(obstacleGrid[i][j]==1)</span><br><span class="line">                continue;</span><br><span class="line">            dp[i][j] = dp[i-1][j] + dp[i][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m-1][n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>一维dp。<br>因为只会用到上一行j之后（含j）的数据，所以可以优化为只用一维dp。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt; &gt;&amp; obstacleGrid) &#123;</span><br><span class="line">    int m = obstacleGrid.size(), n = obstacleGrid[0].size();</span><br><span class="line">    if(m==0 || obstacleGrid[0][0]==1)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; dp(n+1,0);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    for (int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">        if(obstacleGrid[0][i]==1)</span><br><span class="line">            break;</span><br><span class="line">        dp[i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(dp[0]==1 &amp;&amp; obstacleGrid[i][0]==0)</span><br><span class="line">            dp[0] = 1;</span><br><span class="line">        else</span><br><span class="line">            dp[0] = 0;</span><br><span class="line">        for (int j = 1; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(obstacleGrid[i][j]==1)</span><br><span class="line">                dp[j] = 0;</span><br><span class="line">            else</span><br><span class="line">                dp[j] = dp[j] + dp[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="7月7日-112-路径总和（简单）"><a href="#7月7日-112-路径总和（简单）" class="headerlink" title="7月7日 112. 路径总和（简单）"></a>7月7日 <a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和（简单）</a></h1><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p><strong>说明</strong>: 叶子节点是指没有子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">              5</span><br><span class="line">             / \</span><br><span class="line">            4   8</span><br><span class="line">           /   / \</span><br><span class="line">          11  13  4</span><br><span class="line">         /  \      \</span><br><span class="line">        7    2      1</span><br><span class="line">返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>dfs（递归）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool hasPathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return false;</span><br><span class="line">    if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr)&#123;</span><br><span class="line">        return root-&gt;val==sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int curVal = root-&gt;val;</span><br><span class="line">    return hasPathSum(root-&gt;left,sum-curVal) || hasPathSum(root-&gt;right,sum-curVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(h)。h为树的高度，最坏情况下h &#x3D; n。</p>
</li>
<li><p>bfs。队列实现。时空复杂度都是O(n)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（代码略）</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="7月8日-程序员面试金典-面试题-16-11-跳水板（简单）"><a href="#7月8日-程序员面试金典-面试题-16-11-跳水板（简单）" class="headerlink" title="7月8日 程序员面试金典 面试题 16.11. 跳水板（简单）"></a>7月8日 <a href="https://leetcode-cn.com/problems/diving-board-lcci/">程序员面试金典 面试题 16.11. 跳水板（简单）</a></h1><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。<br>返回的长度需要从小到大排列。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">shorter = 1</span><br><span class="line">longer = 2</span><br><span class="line">k = 3</span><br><span class="line">输出： &#123;3,4,5,6&#125;</span><br></pre></td></tr></table></figure>
<p>题解：<br>shorter的使用次数分别为0-k。<br>注意返回需要从小到大。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; divingBoard(int shorter, int longer, int k) &#123;</span><br><span class="line">    if(k==0)</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    if (shorter == longer) &#123;</span><br><span class="line">        return &#123;shorter * k&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for(int i=0;i&lt;=k;i++)&#123;</span><br><span class="line">        res.push_back(shorter*(k-i)+longer*i);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(k)<br>空间复杂度：O(k)</p>
<h1 id="7月9日-程序员面试金典-面试题-17-13-恢复空格（中等）"><a href="#7月9日-程序员面试金典-面试题-17-13-恢复空格（中等）" class="headerlink" title="7月9日 程序员面试金典 面试题 17.13. 恢复空格（中等）"></a><a href="https://leetcode-cn.com/problems/re-space-lcci/">7月9日 程序员面试金典 面试题 17.13. 恢复空格（中等）</a></h1><p>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子”I reset the computer. It still didn’t boot!”已经变成了”iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</p>
<p><strong>注意</strong>：本题相对原题稍作改动，只需返回未识别的字符数</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">dictionary = [&quot;looked&quot;,&quot;just&quot;,&quot;like&quot;,&quot;her&quot;,&quot;brother&quot;]</span><br><span class="line">sentence = &quot;jesslookedjustliketimherbrother&quot;</span><br><span class="line">输出： 7</span><br><span class="line">解释： 断句后为&quot;jess looked just like tim her brother&quot;，共7个未识别字符。</span><br></pre></td></tr></table></figure>
<p>题解：<br>dp。<br><code>dp[i]</code> 表示第 <code>i</code> 个之前字母（含i）之前未识别的最少字符数。</p>
<ul>
<li>当s[i-d:d)与字典中某一字符串匹配时： dp[i] &#x3D; min(dp[i - d],dp[i])。需要枚举每一个字典中的字符串。</li>
<li>当与所有不重合时： dp[i] &#x3D; dp[i -1] + 1， 把 s[i-1] 当作一个未识别字符。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int respace(vector&lt;string&gt;&amp; dictionary, string sentence) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(sentence.size() + 1,sentence.size());</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    for (int i = 1; i &lt;= sentence.size(); i++) &#123;</span><br><span class="line">        for (string dict : dictionary) &#123;</span><br><span class="line">            int d = dict.size();</span><br><span class="line">            if (i &gt;= d &amp;&amp; sentence.substr(i - d, d) == dict)</span><br><span class="line">                dp[i] = min(dp[i - d], dp[i]);</span><br><span class="line">            else dp[i] = min(dp[i - 1] + 1,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[sentence.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n*k)。n 为字符串 s 的长度，k为字典的长度。<br>空间复杂度：O(n)</li>
</ul>
<h1 id="7月10日-309-最佳买卖股票时机含冷冻期（中等）"><a href="#7月10日-309-最佳买卖股票时机含冷冻期（中等）" class="headerlink" title="7月10日 309. 最佳买卖股票时机含冷冻期（中等）"></a>7月10日 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi-4/">309. 最佳买卖股票时机含冷冻期（中等）</a></h1><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure>
<p>题解：<br>dp。<br>dp[i] 表示第 i 天结束之后的累计最大收益。<br>一共有三个状态：A观望，B持股，C冷却</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">状态转移图：A-(观望)-&gt;A,</span><br><span class="line">        A-(买入｜-price)-&gt;B,</span><br><span class="line">        B-(观望)-&gt;B,</span><br><span class="line">        B-(卖出|+price)-&gt;C,</span><br><span class="line">        C-(冷却)-&gt;A</span><br></pre></td></tr></table></figure>
<ul>
<li>持有：用dp[i][0]表示</li>
<li>冷却：用dp[i][1]表示</li>
<li>观望：用dp[i][2]表示</li>
</ul>
<p>根据状态转移图可以写出dp[i][j]的状态转移方程：</p>
<ul>
<li>dp[i][0] &#x3D; max(dp[i - 1][2] - prices[i], dp[i - 1][0]);</li>
<li>dp[i][1] &#x3D; dp[i - 1][0] + prices[i];</li>
<li>dp[i][2] &#x3D; max(dp[i - 1][1], dp[i - 1][2]);<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if(prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(prices.size(), vector&lt;int&gt;(3));</span><br><span class="line">    dp[0][0] = -prices[0];</span><br><span class="line">    for (int i = 1; i &lt; prices.size();i++)&#123;</span><br><span class="line">        dp[i][0] = max(dp[i - 1][2] - prices[i], dp[i - 1][0]);</span><br><span class="line">        dp[i][1] = dp[i - 1][0] + prices[i];</span><br><span class="line">        dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]);</span><br><span class="line">    &#125;</span><br><span class="line">    return max(dp[prices.size() - 1][1], dp[prices.size() - 1][2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n)<br>空间复杂度：O(n)</li>
</ul>
<h1 id="7月11日-315-计算右侧小于当前元素的个数（困难）"><a href="#7月11日-315-计算右侧小于当前元素的个数（困难）" class="headerlink" title="7月11日 315. 计算右侧小于当前元素的个数（困难）"></a>7月11日 <a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数（困难）</a></h1><p>给定一个整数数组 nums，按要求返回一个新数组 *counts。数组 *counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [5,2,6,1]</span><br><span class="line">输出: [2,1,1,0] </span><br><span class="line">解释:</span><br><span class="line">5 的右侧有 2 个更小的元素 (2 和 1).</span><br><span class="line">2 的右侧仅有 1 个更小的元素 (1).</span><br><span class="line">6 的右侧有 1 个更小的元素 (1).</span><br><span class="line">1 的右侧有 0 个更小的元素.</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<ol>
<li>暴力。O(n^2)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;int&gt; res(nums.size());</span><br><span class="line">    for(int i = 0;i&lt;nums.size();i++)&#123;</span><br><span class="line">        int greater = 0;</span><br><span class="line">        for(int j=i+1;j&lt;nums.size();j++)&#123;</span><br><span class="line">            if(nums[j]&lt;nums[i])</span><br><span class="line">                greater++;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = greater;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>从后往前，维护一个升序数组。插入的序号就是比它小数字的个数。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int insertNums(vector&lt;int&gt; &amp;sorted, int num)&#123;</span><br><span class="line">    if(sorted.size()==1)&#123;</span><br><span class="line">        if(num&gt;sorted[0])&#123;</span><br><span class="line">            sorted.push_back(num);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            sorted.insert(sorted.begin(),num);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int l = 0, r = sorted.size()-1;</span><br><span class="line">    int mid = (l + r) / 2;</span><br><span class="line">    while (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        if(sorted[mid]&lt;num)</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        else</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        mid = (l+r)/2;</span><br><span class="line">    &#125;</span><br><span class="line">    sorted.insert(sorted.begin()+l, num);</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    if(nums.empty())</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    vector&lt;int&gt; sorted;</span><br><span class="line">    vector&lt;int&gt; res(nums.size());</span><br><span class="line">    sorted.push_back(nums[nums.size()-1]);</span><br><span class="line">    for(int i=nums.size()-2;i&gt;=0;i--)&#123;</span><br><span class="line">        int idx = insertNums(sorted, nums[i]);</span><br><span class="line">        res[i] = idx;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(nlogn)。每次插入二分查找需要O(logn)的复杂度。<br>空间复杂度：O(n)</li>
</ol>
<h1 id="真题"><a href="#真题" class="headerlink" title="真题"></a>真题</h1><p>给定两个长度为n，值不重复的数列 A &amp; B ，将 A 这个数列进行入栈出栈操作，请问能否得到 B。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">A = [0,1,2,3,4]</span><br><span class="line">B = [2,1,0,4,3]</span><br><span class="line"></span><br><span class="line">输出： Y</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">A = [0]</span><br><span class="line">B = [1]</span><br><span class="line"></span><br><span class="line">输出： N</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool canGetB(vector&lt;int&gt; A, vector&lt;int&gt; B)&#123;</span><br><span class="line">    stack&lt;int&gt; st;</span><br><span class="line">    int idxA = 0, idxB = 0;</span><br><span class="line">    for (; idxB &lt; B.size(); idxB++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(idxA&lt;A.size() &amp;&amp; !st.empty() &amp;&amp; st.top()==B[idxB])&#123;</span><br><span class="line">            st.pop();</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        while (idxA&lt;A.size() &amp;&amp; A[idxA]!=B[idxB])</span><br><span class="line">        &#123;</span><br><span class="line">            st.push(A[idxA]);</span><br><span class="line">            idxA++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(idxA&lt;A.size())&#123;</span><br><span class="line">            idxA++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!st.empty() &amp;&amp; idxB&lt;B.size())&#123;</span><br><span class="line">        if(B[idxB]==st.top())&#123;</span><br><span class="line">            idxB++;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(idxA &lt; A.size() || idxB &lt; B.size())</span><br><span class="line">        return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h1 id="7月12日-174-地下城游戏（困难）"><a href="#7月12日-174-地下城游戏（困难）" class="headerlink" title="7月12日 174. 地下城游戏（困难）"></a>7月12日 <a href="https://leetcode-cn.com/problems/dungeon-game/">174. 地下城游戏（困难）</a></h1><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p>
<p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-2(K)  -3    3</span><br><span class="line">-5	  -10    1</span><br><span class="line">10	   30   -5(P)</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ul>
<li>骑士的健康点数没有上限。</li>
<li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li>
</ul>
<p>题解：<br>反向dp。<br>因为正向dp需要维护两个重要变量：当 前HP 和 最大伤害。没办法做到<strong>无后效性</strong>。<br><code>dp[i][j]</code> 表示从坐标 <code>(i,j)</code> 到终点所需的最小初始值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int calculateMinimumHP(vector&lt;vector&lt;int&gt; &gt;&amp; dungeon) &#123;</span><br><span class="line">    if(dungeon.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int M = dungeon.size(), N = dungeon[0].size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(M+1, vector&lt;int&gt;(N+1, INT_MAX));</span><br><span class="line">    dp[M][N - 1] = dp[M - 1][N] = 1;</span><br><span class="line">    for (int i = M - 1; i &gt;= 0;i--)&#123;</span><br><span class="line">        for (int j = N - 1; j &gt;= 0;j--)&#123;</span><br><span class="line">            int minn = min(dp[i + 1][j], dp[i][j + 1]);</span><br><span class="line">            dp[i][j] = max(minn - dungeon[i][j], 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[0][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(MN)<br>空间复杂度：O(MN)</p>
<h1 id="7月13日-350-两个数组的交集-II（简单）"><a href="#7月13日-350-两个数组的交集-II（简单）" class="headerlink" title="7月13日 350. 两个数组的交集 II（简单）"></a>7月13日 <a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II（简单）</a></h1><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2,2]</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[4,9]</span><br></pre></td></tr></table></figure>
<p>题解：   </p>
<ol>
<li><p>双指针。但是需要先排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">    sort(nums1.begin(),nums1.end());</span><br><span class="line">    sort(nums2.begin(),nums2.end());</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    int idx1=0,idx2=0;</span><br><span class="line">    while(idx1&lt;nums1.size() &amp;&amp; idx2&lt;nums2.size())&#123;</span><br><span class="line">        if(nums1[idx1]==nums2[idx2])&#123;</span><br><span class="line">            res.push_back(nums1[idx1]);</span><br><span class="line">            idx1++;</span><br><span class="line">            idx2++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(nums1[idx1]&lt;nums2[idx2])</span><br><span class="line">                idx1++;</span><br><span class="line">            else</span><br><span class="line">                idx2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mlogm<em>nlogn)。 排序需要 O(nlogn</em>mlogm)。<br>空间复杂度：O(min{m,n})。</p>
</li>
<li><p>哈希表。遍历其中一个数组，存入哈希表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">    if(nums2.size()&lt;nums1.size())</span><br><span class="line">        return intersect(nums2, nums1);</span><br><span class="line">    unordered_map&lt;int,int&gt; numMap;</span><br><span class="line">    for (int n : nums1)</span><br><span class="line">        numMap[n]++;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for (int n : nums2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(numMap.count(n))&#123;</span><br><span class="line">            res.push_back(n);</span><br><span class="line">            numMap[n]--;</span><br><span class="line">            if(numMap[n]==0)</span><br><span class="line">                numMap.erase(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m+n)。<br>空间复杂度：O(min{m,n})。</p>
</li>
</ol>
<h1 id="7月14日-120-三角形最小路径和（中等）"><a href="#7月14日-120-三角形最小路径和（中等）" class="headerlink" title="7月14日 120. 三角形最小路径和（中等）"></a>7月14日 <a href="https://leetcode-cn.com/problems/triangle/">120. 三角形最小路径和（中等）</a></h1><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p>
<p>例如，给定三角形：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</p>
<p><strong>说明</strong>：<br>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<p>题解：</p>
<ol>
<li>普通dp。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int minimumTotal(vector&lt;vector&lt;int&gt; &gt;&amp; triangle) &#123;</span><br><span class="line">    if(triangle.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int n = triangle.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(n,vector&lt;int&gt;(n));</span><br><span class="line">    dp[0][0] = triangle[0][0];</span><br><span class="line">    for (int i = 1; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][0] = dp[i - 1][0] + triangle[i][0];</span><br><span class="line">        for (int j = 1; j &lt; i;j++)&#123;</span><br><span class="line">            dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][i] = dp[i - 1][i - 1] + triangle[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    return *min_element(dp[n - 1].begin(), dp[n - 1].end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n^2)。<br>空间复杂度：O(n^2)。</li>
</ol>
<h1 id="7月15日-96-不同的二叉搜索树（中等）"><a href="#7月15日-96-不同的二叉搜索树（中等）" class="headerlink" title="7月15日 96. 不同的二叉搜索树（中等）"></a>7月15日 <a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树（中等）</a></h1><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<ol>
<li>dp。<br>设需要求 n 个节点。以一个节点为根节点，左子树的数量加右子树的数量就是以这个节点为根节点的数量。遍历不同的根节点（0~n）累加。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int numTrees(int n) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(n + 1, 0);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    dp[1] = 1;</span><br><span class="line"></span><br><span class="line">    for (int i = 2; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= i; ++j) &#123;</span><br><span class="line">            dp[i] += dp[j - 1] * dp[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>数学。<br>数学上被称为卡塔兰数。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nt numTrees(int n) &#123;</span><br><span class="line">    long long C = 1;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        C = C * 2 * (2 * i + 1) / (i + 2);</span><br><span class="line">    &#125;</span><br><span class="line">    return (int)C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="7月16日-785-判断二分图（中等）"><a href="#7月16日-785-判断二分图（中等）" class="headerlink" title="7月16日 785. 判断二分图（中等）"></a>7月16日 <a href="https://leetcode-cn.com/problems/is-graph-bipartite/">785. 判断二分图（中等）</a></h1><p>给定一个无向图graph，当这个图为二分图时返回true。</p>
<p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p>
<p>graph将会以邻接表方式给出，<code>graph[i]</code>表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： <code>graph[i]</code> 中不存在i，并且<code>graph[i]</code>中没有重复的值。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">输出: true</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">输出: false</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">我们不能将节点分割成两个独立的子集。</span><br></pre></td></tr></table></figure>
<p>题解：<br>bfs或者dfs，把经过的点分别标上交替的记号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（代码待补全）</span><br></pre></td></tr></table></figure>

<h1 id="7月17日-35-搜索插入位置（简单）"><a href="#7月17日-35-搜索插入位置（简单）" class="headerlink" title="7月17日 35. 搜索插入位置（简单）"></a>7月17日 <a href="">35. 搜索插入位置（简单）</a></h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p>示例 4:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
<p>题解：<br>二分查找。可以用O(n)的复杂度顺序遍历。但是一看到排好序，就想到了二分查找。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    if(nums.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int L=0,R=nums.size()-1;</span><br><span class="line">    int mid;</span><br><span class="line">    while(L&lt;=R)&#123;</span><br><span class="line">        mid = (L+R)/2;</span><br><span class="line">        if(nums[mid]&gt;target)</span><br><span class="line">            R = mid - 1;</span><br><span class="line">        else if(nums[mid]&lt;target)</span><br><span class="line">            L = mid + 1;</span><br><span class="line">        else</span><br><span class="line">            return mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(logn)。<br>空间复杂度：O(1)。</p>
<h1 id="7月18日-97-交错字符串（困难）"><a href="#7月18日-97-交错字符串（困难）" class="headerlink" title="7月18日 97. 交错字符串（困难）"></a>7月18日 <a href="https://leetcode-cn.com/problems/interleaving-string/">97. 交错字符串（困难）</a></h1><p>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<ol>
<li>双指针递归。（超时）99 &#x2F; 101 个通过测试用例<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isInterleaveCore(string s1,string s2,string s3,int idx1,int idx2,int idx3)&#123;</span><br><span class="line">    if(idx1==s1.size())</span><br><span class="line">        return s2.substr(idx2,s2.size()-idx2+1)==s3.substr(idx3,s3.size()-idx3+1);</span><br><span class="line">    if(idx2==s2.size())</span><br><span class="line">        return s1.substr(idx1,s1.size()-idx1+1)==s3.substr(idx3,s3.size()-idx3+1);</span><br><span class="line">    if(s1[idx1]==s3[idx3])&#123;</span><br><span class="line">        if(s2[idx2]==s3[idx3])</span><br><span class="line">            return isInterleaveCore(s1,s2,s3,idx1+1,idx2,idx3+1) || isInterleaveCore(s1,s2,s3,idx1,idx2+1,idx3+1);</span><br><span class="line">        else</span><br><span class="line">            return isInterleaveCore(s1,s2,s3,idx1+1,idx2,idx3+1);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if(s2[idx2]==s3[idx3])</span><br><span class="line">            return isInterleaveCore(s1,s2,s3,idx1,idx2+1,idx3+1);</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isInterleave(string s1, string s2, string s3) &#123;</span><br><span class="line">    if(s3.size() != s1.size()+s2.size())</span><br><span class="line">        return false;</span><br><span class="line">    return isInterleaveCore(s1,s2,s3,0,0,0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>二维dp。<br>dp[i][j] 表示字符串 s3[0:i+j] 能否由 s1[0:i] 和 s2[0:j] 组成。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isInterleave(string s1, string s2, string s3) &#123;</span><br><span class="line">    if(s3.size() != s1.size()+s2.size())</span><br><span class="line">        return false;</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; dp(s1.size()+1,vector&lt;bool&gt;(s2.size()+1,false));</span><br><span class="line"></span><br><span class="line">    dp[0][0] = true;</span><br><span class="line">    for(int i=1;i&lt;=s1.size();i++)&#123;</span><br><span class="line">        if(s1[i-1]==s3[i-1])</span><br><span class="line">            dp[i][0] = true;</span><br><span class="line">        else</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=s2.size();i++)&#123;</span><br><span class="line">        if(s2[i-1]==s3[i-1])</span><br><span class="line">            dp[0][i] = true;</span><br><span class="line">        else</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=s1.size();i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=s2.size();j++)&#123;</span><br><span class="line">            dp[i][j] = (s1[i-1]==s3[i+j-1] &amp;&amp; dp[i-1][j]) || (s2[j-1]==s3[i+j-1] &amp;&amp; dp[i][j-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s1.size()][s2.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(mn)。m 为s1的长度，n 为s2的长度。<br>空间复杂度：O(mn)。</li>
</ol>
<p>ref. <a href="https://leetcode-cn.com/problems/interleaving-string/solution/lei-si-lu-jing-wen-ti-zhao-zhun-zhuang-tai-fang-ch/">leetcode题解</a></p>
<ol start="3">
<li>一维dp。<br>因为dp在计算时只用到了上一行，所以可以优化为只用一维数组。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码略</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="7月19日-312-戳气球（困难）"><a href="#7月19日-312-戳气球（困难）" class="headerlink" title="7月19日 312. 戳气球（困难）"></a>7月19日 <a href="https://leetcode-cn.com/problems/burst-balloons/">312. 戳气球（困难）</a></h1><p>有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p>
<p>现在要求你戳破所有的气球。如果你戳破气球 i ，就可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的 <code>left</code> 和 <code>right</code> 代表和 <code>i</code> 相邻的两个气球的序号。注意当你戳破了气球 <code>i</code> 后，气球 <code>left</code> 和气球 <code>right</code> 就变成了相邻的气球。</p>
<p>求所能获得硬币的最大数量。</p>
<p>说明:</p>
<ul>
<li>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; 1，但注意它们不是真实存在的所以并不能被戳破。</li>
<li>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</li>
</ul>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,1,5,8]</span><br><span class="line">输出: 167 </span><br><span class="line">解释: nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span><br><span class="line">     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</span><br></pre></td></tr></table></figure>
<p>题解：<br>dp。<br><code>dp[i][j]</code>表示<code>(i:j)</code>开区间内所能得到的最大值。外层循环要倒序，因为子问题<code>dp[k][j]</code>要在父问题<code>dp[i][j]</code>（i&lt;&#x3D;k&lt;&#x3D;j）之前。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxCoins(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(n + 2, vector&lt;int&gt;(n + 2, 0));</span><br><span class="line">    nums.insert(nums.begin(), 1);</span><br><span class="line">    nums.push_back(1);</span><br><span class="line">    for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        for (int j = i + 2; j &lt;= n + 1; j++) &#123;</span><br><span class="line">            for (int k = i + 1; k &lt; j; k++) &#123;</span><br><span class="line">                dp[i][j] = max(</span><br><span class="line">                        dp[i][j],</span><br><span class="line">                        (dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[0][n + 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^3)。<br>空间复杂度：O(n^2)。</p>
<h1 id="7月20日-167-两数之和-II-输入有序数组（简单）"><a href="#7月20日-167-两数之和-II-输入有序数组（简单）" class="headerlink" title="7月20日 167. 两数之和 II - 输入有序数组（简单）"></a>7月20日 <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组（简单）</a></h1><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<p>说明:</p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<ol>
<li><p>哈希表。<br>哈希表保存每个元素，再遍历一次即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">    unordered_map&lt;int, int&gt; numMap;</span><br><span class="line">    for (int i = 0; i &lt; numbers.size();i++)</span><br><span class="line">        numMap[numbers[i]] = i;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; numbers.size();i++)&#123;</span><br><span class="line">        auto it = numMap.find(target - numbers[i]);</span><br><span class="line">        if (it != numMap.end())</span><br><span class="line">            return &#123;i + 1, it-&gt;second+1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)。<br>空间复杂度：O(n)。</p>
</li>
<li><p>二分查找。时间复杂度：O(nlogn)。空间复杂度：O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码略</span><br></pre></td></tr></table></figure>
</li>
<li><p>双指针。<br>初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">    int L = 0, R = numbers.size() - 1;</span><br><span class="line">    while (L &lt; R) &#123;</span><br><span class="line">        int sum = numbers[L] + numbers[R];</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            return &#123;L + 1, R + 1&#125;;</span><br><span class="line">        &#125; else if (sum &lt; target) &#123;</span><br><span class="line">            ++L;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            --R;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;-1, -1&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)。<br>空间复杂度：O(1)。</p>
</li>
</ol>
<h1 id="7月21日-95-不同的二叉搜索树-II（中等）"><a href="#7月21日-95-不同的二叉搜索树-II（中等）" class="headerlink" title="7月21日 95. 不同的二叉搜索树 II（中等）"></a>7月21日 <a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II（中等）</a></h1><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>
<p><strong>提示</strong>：0 &lt;&#x3D; n &lt;&#x3D; 8</p>
<p>题解：<br>递归。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;TreeNode*&gt; generateSubTree(int L, int R)&#123;</span><br><span class="line">    if(L&gt;R)</span><br><span class="line">        return &#123;nullptr&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;TreeNode*&gt; Trees;</span><br><span class="line">    for(int i=L;i&lt;=R;i++)&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; leftTree = generateSubTree(L,i-1);</span><br><span class="line">        vector&lt;TreeNode*&gt; rightTree = generateSubTree(i+1,R);</span><br><span class="line"></span><br><span class="line">        for(auto lTree:leftTree)&#123;</span><br><span class="line">            for(auto rTree:rightTree)&#123;</span><br><span class="line">                TreeNode* root = new TreeNode(i);</span><br><span class="line">                root-&gt;left = lTree;</span><br><span class="line">                root-&gt;right = rTree;</span><br><span class="line">                Trees.push_back(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Trees;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;TreeNode*&gt; generateTrees(int n) &#123;</span><br><span class="line">    if(n==0)</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    return generateSubTree(1,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7月22日-剑指-Offer-11-旋转数组的最小数字（简单）"><a href="#7月22日-剑指-Offer-11-旋转数组的最小数字（简单）" class="headerlink" title="7月22日 剑指 Offer 11. 旋转数组的最小数字（简单）"></a>7月22日 <a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字（简单）</a></h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>暴力。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int minArray(vector&lt;int&gt;&amp; numbers) &#123;</span><br><span class="line">    if(numbers.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    for(int i=1;i&lt;numbers.size();i++)&#123;</span><br><span class="line">        if(numbers[i]&lt;numbers[i-1])</span><br><span class="line">            return numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return numbers[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
</li>
<li><p>二分。<br>注意：当<code>numbers[mid]==numbers[R]</code>时，由于重复元素的存在，我们并不能确定<code>numbers[mid]</code>究竟在最小值的左侧还是右侧，因此我们不能忽略某一部分的元素。但是由于它们的值相同，所以可以忽略二分查找区间的右端点<code>numbers[R]</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int minArray(vector&lt;int&gt;&amp; numbers) &#123;</span><br><span class="line">    if(numbers.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int L=0,R=numbers.size()-1;</span><br><span class="line">    while(L&lt;R)&#123;</span><br><span class="line">        int mid = (L+R)/2;</span><br><span class="line">        if(numbers[mid]&lt;numbers[R])</span><br><span class="line">            R=mid;</span><br><span class="line">        else if(numbers[mid]&gt;numbers[R])</span><br><span class="line">            L=mid+1;</span><br><span class="line">        else&#123;</span><br><span class="line">            R--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return numbers[R];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>
</li>
</ol>
<h1 id="7月23日-64-最小路径和（中等）"><a href="#7月23日-64-最小路径和（中等）" class="headerlink" title="7月23日 64. 最小路径和（中等）"></a>7月23日 <a href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和（中等）</a></h1><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明</strong>：每次只能向下或者向右移动一步。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<ol>
<li><p>二维dp。<br><code>dp[i][j]</code>表示走到第i行第j列格子时的最小值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    if(grid.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int m = grid.size(),n=grid[0].size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(m+1,vector&lt;int&gt;(n+1,INT_MAX));</span><br><span class="line">    dp[1][1] = grid[0][0];</span><br><span class="line">    for(int i = 1;i&lt;=m;i++)&#123;</span><br><span class="line">        for(int j = 1;j&lt;=n;j++)&#123;</span><br><span class="line">            if(i==1&amp;&amp;j==1)</span><br><span class="line">                continue;</span><br><span class="line">            dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p>
</li>
<li><p>一维dp。<br>因为只用到了上一行的dp，所以二维dp可以优化为一维。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    if(grid.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int m = grid.size(),n=grid[0].size();</span><br><span class="line">    vector&lt;int&gt; dp(n,0);</span><br><span class="line">    </span><br><span class="line">    dp[0] = grid[0][0];</span><br><span class="line">    for(int i = 1;i&lt;n;i++)</span><br><span class="line">        dp[i] = grid[0][i]+dp[i-1];</span><br><span class="line">    </span><br><span class="line">    for(int i = 1;i&lt;m;i++)&#123;</span><br><span class="line">        for(int j = 0;j&lt;n;j++)&#123;</span><br><span class="line">            if(j==0)</span><br><span class="line">                dp[j] = dp[j]+grid[i][0];</span><br><span class="line">            else</span><br><span class="line">                dp[j] = min(dp[j-1],dp[j])+grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(n)</p>
</li>
</ol>
<h1 id="7月24日-1025-除数博弈（简单）"><a href="#7月24日-1025-除数博弈（简单）" class="headerlink" title="7月24日 1025. 除数博弈（简单）"></a>7月24日 <a href="https://leetcode-cn.com/problems/divisor-game/">1025. 除数博弈（简单）</a></h1><p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</p>
<p>最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：</p>
<p>选出任一 x，满足 0 &lt; x &lt; N 且 N % x &#x3D;&#x3D; 0 。<br>用 N - x 替换黑板上的数字 N 。<br>如果玩家无法执行这些操作，就会输掉游戏。</p>
<p>只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：true</span><br><span class="line">解释：爱丽丝选择 1，鲍勃无法进行操作。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：false</span><br><span class="line">解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<ol>
<li><p>dp。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool divisorGame(int N) &#123;</span><br><span class="line">    vector&lt;bool&gt; dp(N+1,false);</span><br><span class="line">    dp[1] = false;</span><br><span class="line">    dp[2]= true;</span><br><span class="line">    int n=N;</span><br><span class="line">    for(int i=3;i&lt;=N;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;i;j++)&#123;</span><br><span class="line">            if(i % j == 0 &amp;&amp; !dp[i - j])&#123;</span><br><span class="line">                dp[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(N^2)<br>空间复杂度：O(N)</p>
</li>
<li><p>归纳法。N 为奇数的时候 Alice（先手）必败，N 为偶数的时候 Alice 必胜。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool divisorGame(int N) &#123;</span><br><span class="line">    return N % 2 == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(1)<br>空间复杂度：O(1)</p>
</li>
</ol>
<h1 id="7月25日-410-分割数组的最大值（困难）"><a href="#7月25日-410-分割数组的最大值（困难）" class="headerlink" title="7月25日 410. 分割数组的最大值（困难）"></a>7月25日 <a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值（困难）</a></h1><p>给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。</p>
<p><strong>注意</strong>:<br>数组长度 n 满足以下条件:</p>
<ul>
<li>1 ≤ n ≤ 1000</li>
<li>1 ≤ m ≤ min(50, n)</li>
</ul>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums = [7,2,5,10,8]</span><br><span class="line">m = 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">一共有四种方法将nums分割为2个子数组。</span><br><span class="line">其中最好的方式是将其分为[7,2,5] 和 [10,8]，</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<ol>
<li>dp。<code>dp[i][j]</code>表示前i个数被分成j段的答案。<code>dp[i][j]</code>的状态转移方程为：<ul>
<li><code>dp[i][j] = min(max(dp[k][j-1],subSum(k+1,i)))</code></li>
</ul>
</li>
</ol>
<p>其中<code>min</code>里需要枚举k&#x3D;[0,i)，subSum(k+1,i)表示nums[k+1]到nums[i]的和。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int splitArray(vector&lt;int&gt;&amp; nums, int m) &#123;</span><br><span class="line">    vector&lt;vector&lt;long long&gt; &gt; dp(nums.size() + 1, vector&lt;long long&gt;(m + 1, LLONG_MAX));</span><br><span class="line"></span><br><span class="line">    vector&lt;long long&gt; preSum(nums.size() + 1, 0);</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= nums.size();i++)</span><br><span class="line">        preSum[i] = preSum[i - 1] + nums[i-1];</span><br><span class="line"></span><br><span class="line">    dp[0][0] = 0;</span><br><span class="line">    for (int i = 1; i &lt;= nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= min(m, i); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int k = 0; k &lt; i; k++)</span><br><span class="line">                dp[i][j] = min(dp[i][j], max(dp[k][j - 1], preSum[i] - preSum[k]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (int)dp[nums.size()][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m * n^2)<br>空间复杂度：O(mn)</p>
<h1 id="7月26日-329-矩阵中的最长递增路径（困难）"><a href="#7月26日-329-矩阵中的最长递增路径（困难）" class="headerlink" title="7月26日 329. 矩阵中的最长递增路径（困难）"></a>7月26日 <a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径（困难）</a></h1><p>给定一个整数矩阵，找出最长递增路径的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = </span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure>
<p>题解：<br>有记忆的dfs。<br>普通dfs会超时，所以加了二位矩阵来记录已经得到的最长序列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">int dfs(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int i, int j, vector&lt;vector&lt;int&gt; &gt; &amp;memo)&#123;</span><br><span class="line">    if(memo[i][j]!=0)</span><br><span class="line">        return memo[i][j];</span><br><span class="line">    memo[i][j] = 1;</span><br><span class="line">    for(auto d:dirs)&#123;</span><br><span class="line">        if (i + d[0] &gt;= 0 &amp;&amp; i + d[0] &lt; matrix.size() </span><br><span class="line">            &amp;&amp; j + d[1] &gt;= 0 &amp;&amp; j + d[1] &lt; matrix[0].size() </span><br><span class="line">            &amp;&amp; matrix[i + d[0]][j + d[1]] &gt; matrix[i][j])</span><br><span class="line">            memo[i][j] = max(memo[i][j], dfs(matrix, i + d[0], j + d[1], memo) + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return memo[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int longestIncreasingPath(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123;</span><br><span class="line">    if(matrix.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int m = matrix.size(), n = matrix[0].size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; memo(m, vector&lt;int&gt;(n, 0));</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            res = max(res, dfs(matrix, i, j, memo));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p>
<h1 id="7月27日-392-判断子序列（简单）"><a href="#7月27日-392-判断子序列（简单）" class="headerlink" title="7月27日 392. 判断子序列（简单）"></a>7月27日 <a href="https://leetcode-cn.com/problems/is-subsequence/">392. 判断子序列（简单）</a></h1><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~&#x3D; 500,000），而 s 是个短字符串（长度 &lt;&#x3D;100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">返回 true.</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &quot;axc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">返回 false.</span><br></pre></td></tr></table></figure>

<p>后续挑战：<br>如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<p>题解：<br>双指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isSubsequence(string s, string t) &#123;</span><br><span class="line">    if(t.empty())&#123;</span><br><span class="line">        if(s.empty())</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int idxS=0,idxT=0;</span><br><span class="line">    while(idxS&lt;s.size() &amp;&amp; idxT&lt;t.size())&#123;</span><br><span class="line">        if(s[idxS]==t[idxT])</span><br><span class="line">            idxS++;</span><br><span class="line">        idxT++;</span><br><span class="line">    &#125;</span><br><span class="line">    return idxS==s.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m+n)<br>空间复杂度：O(1)</p>
<h1 id="7月28日-104-二叉树的最大深度（简单）"><a href="#7月28日-104-二叉树的最大深度（简单）" class="headerlink" title="7月28日 104. 二叉树的最大深度（简单）"></a>7月28日 <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度（简单）</a></h1><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明</strong>: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br><code>给定二叉树 [3,9,20,null,null,15,7]，     3    / \   9  20     /  \    15   7 返回它的最大深度 3 。</code></p>
<p>题解：</p>
<ol>
<li><p>层序遍历（BFS）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxDepth(TreeNode* root)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return 0;</span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">    que.push(root);</span><br><span class="line">    int hight = 0;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        hight++;</span><br><span class="line">        int n = que.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *curNode = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            if(curNode-&gt;left!=nullptr)</span><br><span class="line">                que.push(curNode-&gt;left);</span><br><span class="line">            if(curNode-&gt;right!=nullptr)</span><br><span class="line">                que.push(curNode-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return hight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
</li>
<li><p>递归。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxDepth(TreeNode* root)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return 0;</span><br><span class="line">    return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(hight)</p>
</li>
</ol>
<h1 id="7月29日-LCP-13-寻宝（困难）"><a href="#7月29日-LCP-13-寻宝（困难）" class="headerlink" title="7月29日 LCP 13. 寻宝（困难）"></a>7月29日 <a href="https://leetcode-cn.com/problems/xun-bao/">LCP 13. 寻宝（困难）</a></h1><p>我们得到了一副藏宝图，藏宝图显示，在一个迷宫中存在着未被世人发现的宝藏。</p>
<p>迷宫是一个二维矩阵，用一个字符串数组表示。它标识了唯一的入口（用 ‘S’ 表示），和唯一的宝藏地点（用 ‘T’ 表示）。但是，宝藏被一些隐蔽的机关保护了起来。在地图上有若干个机关点（用 ‘M’ 表示），只有所有机关均被触发，才可以拿到宝藏。</p>
<p>要保持机关的触发，需要把一个重石放在上面。迷宫中有若干个石堆（用 ‘O’ 表示），每个石堆都有无限个足够触发机关的重石。但是由于石头太重，我们一次只能搬一个石头到指定地点。</p>
<p>迷宫中同样有一些墙壁（用 ‘#’ 表示），我们不能走入墙壁。剩余的都是可随意通行的点（用 ‘.’ 表示）。石堆、机关、起点和终点（无论是否能拿到宝藏）也是可以通行的。</p>
<p>我们每步可以选择向上&#x2F;向下&#x2F;向左&#x2F;向右移动一格，并且不能移出迷宫。搬起石头和放下石头不算步数。那么，从起点开始，我们最少需要多少步才能最后拿到宝藏呢？如果无法拿到宝藏，返回 -1 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： [&quot;S#O&quot;, &quot;M..&quot;, &quot;M.T&quot;]</span><br><span class="line"></span><br><span class="line">输出：16</span><br><span class="line"></span><br><span class="line">解释：最优路线为： S-&gt;O, cost = 4, 去搬石头 O-&gt;第二行的M, cost = 3, M机关触发 第二行的M-&gt;O, cost = 3, 我们需要继续回去 O 搬石头。 O-&gt;第三行的M, cost = 4, 此时所有机关均触发 第三行的M-&gt;T, cost = 2，去T点拿宝藏。 总步数为16。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： [&quot;S#O&quot;, &quot;M.#&quot;, &quot;M.T&quot;]</span><br><span class="line"></span><br><span class="line">输出：-1</span><br><span class="line"></span><br><span class="line">解释：我们无法搬到石头触发机关</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： [&quot;S#O&quot;, &quot;M.T&quot;, &quot;M..&quot;]</span><br><span class="line"></span><br><span class="line">输出：17</span><br><span class="line"></span><br><span class="line">解释：注意终点也是可以通行的。</span><br></pre></td></tr></table></figure>
<p>限制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 &lt;= maze.length &lt;= 100</span><br><span class="line">1 &lt;= maze[i].length &lt;= 100</span><br><span class="line">maze[i].length == maze[j].length</span><br><span class="line">S 和 T 有且只有一个</span><br><span class="line">0 &lt;= M的数量 &lt;= 16</span><br><span class="line">0 &lt;= O的数量 &lt;= 40，题目保证当迷宫中存在 M 时，一定存在至少一个 O 。</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int dx[4] = &#123;1, -1, 0, 0&#125;;</span><br><span class="line">int dy[4] = &#123;0, 0, 1, -1&#125;;</span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">bool inBound(int x, int y) &#123;</span><br><span class="line">    return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; bfs(int x, int y, vector&lt;string&gt;&amp; maze) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ret(n, vector&lt;int&gt;(m, -1));</span><br><span class="line">    ret[x][y] = 0;</span><br><span class="line">    queue&lt;pair&lt;int, int&gt;&gt; Q;</span><br><span class="line">    Q.push(&#123;x, y&#125;);</span><br><span class="line">    while (!Q.empty()) &#123;</span><br><span class="line">        auto p = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        int x = p.first, y = p.second;</span><br><span class="line">        for (int k = 0; k &lt; 4; k++) &#123;</span><br><span class="line">            int nx = x + dx[k], ny = y + dy[k];</span><br><span class="line">            if (inBound(nx, ny) &amp;&amp; maze[nx][ny] != &#x27;#&#x27; &amp;&amp; ret[nx][ny] == -1) &#123;</span><br><span class="line">                ret[nx][ny] = ret[x][y] + 1;</span><br><span class="line">                Q.push(&#123;nx, ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int minimalSteps(vector&lt;string&gt;&amp; maze) &#123;</span><br><span class="line">    n = maze.size(), m = maze[0].size();</span><br><span class="line">    // 机关 &amp; 石头</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; buttons, stones;</span><br><span class="line">    // 起点 &amp; 终点</span><br><span class="line">    int sx, sy, tx, ty;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">            if (maze[i][j] == &#x27;M&#x27;) &#123;</span><br><span class="line">                buttons.push_back(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (maze[i][j] == &#x27;O&#x27;) &#123;</span><br><span class="line">                stones.push_back(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (maze[i][j] == &#x27;S&#x27;) &#123;</span><br><span class="line">                sx = i, sy = j;</span><br><span class="line">            &#125;</span><br><span class="line">            if (maze[i][j] == &#x27;T&#x27;) &#123;</span><br><span class="line">                tx = i, ty = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int nb = buttons.size();</span><br><span class="line">    int ns = stones.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; start_dist = bfs(sx, sy, maze);</span><br><span class="line"></span><br><span class="line">    // 边界情况：没有机关</span><br><span class="line">    if (nb == 0) &#123;</span><br><span class="line">        return start_dist[tx][ty];</span><br><span class="line">    &#125;</span><br><span class="line">    // 从某个机关到其他机关 / 起点与终点的最短距离。</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dist(nb, vector&lt;int&gt;(nb + 2, -1));</span><br><span class="line">    // 中间结果</span><br><span class="line">    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dd(nb);</span><br><span class="line">    for (int i = 0; i &lt; nb; i++) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; d = bfs(buttons[i].first, buttons[i].second, maze);</span><br><span class="line">        dd[i] = d;</span><br><span class="line">        // 从某个点到终点不需要拿石头</span><br><span class="line">        dist[i][nb + 1] = d[tx][ty];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nb; i++) &#123;</span><br><span class="line">        int tmp = -1;</span><br><span class="line">        for (int k = 0; k &lt; ns; k++) &#123;</span><br><span class="line">            int mid_x = stones[k].first, mid_y = stones[k].second;</span><br><span class="line">            if (dd[i][mid_x][mid_y] != -1 &amp;&amp; start_dist[mid_x][mid_y] != -1) &#123;</span><br><span class="line">                if (tmp == -1 || tmp &gt; dd[i][mid_x][mid_y] + start_dist[mid_x][mid_y]) &#123;</span><br><span class="line">                    tmp = dd[i][mid_x][mid_y] + start_dist[mid_x][mid_y];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dist[i][nb] = tmp;</span><br><span class="line">        for (int j = i + 1; j &lt; nb; j++) &#123;</span><br><span class="line">            int mn = -1;</span><br><span class="line">            for (int k = 0; k &lt; ns; k++) &#123;</span><br><span class="line">                int mid_x = stones[k].first, mid_y = stones[k].second;</span><br><span class="line">                if (dd[i][mid_x][mid_y] != -1 &amp;&amp; dd[j][mid_x][mid_y] != -1) &#123;</span><br><span class="line">                    if (mn == -1 || mn &gt; dd[i][mid_x][mid_y] + dd[j][mid_x][mid_y]) &#123;</span><br><span class="line">                        mn = dd[i][mid_x][mid_y] + dd[j][mid_x][mid_y];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dist[i][j] = mn;</span><br><span class="line">            dist[j][i] = mn;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 无法达成的情形</span><br><span class="line">    for (int i = 0; i &lt; nb; i++) &#123;</span><br><span class="line">        if (dist[i][nb] == -1 || dist[i][nb + 1] == -1) return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // dp 数组， -1 代表没有遍历到</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp(1 &lt;&lt; nb, vector&lt;int&gt;(nb, -1));</span><br><span class="line">    for (int i = 0; i &lt; nb; i++) &#123;</span><br><span class="line">        dp[1 &lt;&lt; i][i] = dist[i][nb];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 由于更新的状态都比未更新的大，所以直接从小到大遍历即可</span><br><span class="line">    for (int mask = 1; mask &lt; (1 &lt;&lt; nb); mask++) &#123;</span><br><span class="line">        for (int i = 0; i &lt; nb; i++) &#123;</span><br><span class="line">            // 当前 dp 是合法的</span><br><span class="line">            if (mask &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">                for (int j = 0; j &lt; nb; j++) &#123;</span><br><span class="line">                    // j 不在 mask 里</span><br><span class="line">                    if (!(mask &amp; (1 &lt;&lt; j))) &#123;</span><br><span class="line">                        int next = mask | (1 &lt;&lt; j);</span><br><span class="line">                        if (dp[next][j] == -1 || dp[next][j] &gt; dp[mask][i] + dist[i][j]) &#123;</span><br><span class="line">                            dp[next][j] = dp[mask][i] + dist[i][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ret = -1;</span><br><span class="line">    int final_mask = (1 &lt;&lt; nb) - 1;</span><br><span class="line">    for (int i = 0; i &lt; nb; i++) &#123;</span><br><span class="line">        if (ret == -1 || ret &gt; dp[final_mask][i] + dist[i][nb + 1]) &#123;</span><br><span class="line">            ret = dp[final_mask][i] + dist[i][nb + 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7月30日-343-整数拆分（中等）"><a href="#7月30日-343-整数拆分（中等）" class="headerlink" title="7月30日 343. 整数拆分（中等）"></a>7月30日 <a href="https://leetcode-cn.com/problems/integer-break/">343. 整数拆分（中等）</a></h1><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>: 你可以假设 n 不小于 2 且不大于 58。</p>
<p>题解：</p>
<ol>
<li>dp。<br><code>dp[i]</code>表示数字i分解后能达到的最大积。可以分为两种情况：</li>
</ol>
<ul>
<li>1）i分解为j和i-j两个数；</li>
<li>2）i分解为j和i-j后，i-j还可以再分解，其最大积为<code>dp[i-j]</code>。</li>
<li>枚举1~i-1每一个点，看哪个点分解后的积最大<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int integerBreak(int n) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(n+1,0);</span><br><span class="line">    for (int i = 2; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n^2)<br>空间复杂度：O(n)</li>
</ul>
<h1 id="7月31日-程序员面试金典-面试题-08-03-魔术索引（简单）"><a href="#7月31日-程序员面试金典-面试题-08-03-魔术索引（简单）" class="headerlink" title="7月31日 程序员面试金典 面试题 08.03. 魔术索引（简单）"></a>7月31日 <a href="https://leetcode-cn.com/problems/magic-index-lcci/">程序员面试金典 面试题 08.03. 魔术索引（简单）</a></h1><p>魔术索引。 在数组<code>A[0…n-1]</code>中，有所谓的魔术索引，满足条件<code>A[i] = i</code>。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。</p>
<p>示例1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0, 2, 3, 4, 5]</span><br><span class="line">输出：0</span><br><span class="line">说明: 0下标的元素为0</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1, 1, 1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示</strong>: nums长度在[1, 1000000]之间</p>
<p>题解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int findMagicIndex(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">        if(nums[i]==i)</span><br><span class="line">            return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Leetcode daily</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode每日一题 - 2020年六月</title>
    <url>/2020/06/01/LeetcodeDaily_June/</url>
    <content><![CDATA[<h1 id="6月1日-1431-拥有最多糖果的孩子（简单）"><a href="#6月1日-1431-拥有最多糖果的孩子（简单）" class="headerlink" title="6月1日 1431. 拥有最多糖果的孩子（简单）"></a>6月1日 <a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/">1431. 拥有最多糖果的孩子（简单）</a></h1><p>给你一个数组 <code>candies</code> 和一个整数 <code>extraCandies</code> ，其中 <code>candies[i]</code> 代表第 <code>i</code> 个孩子拥有的糖果数目。<br>对每一个孩子，检查是否存在一种方案，将额外的 <code>extraCandies</code> 个糖果分配给孩子们之后，此孩子有 <strong>最多</strong> 的糖果。注意，允许有多个孩子同时拥有 <strong>最多</strong> 的糖果数目。<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candies = [4,2,1,1,2], extraCandies = 1</span><br><span class="line">输出：[true,false,false,false,false] </span><br><span class="line">解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 &lt;= candies.length &lt;= 100</span><br><span class="line">1 &lt;= candies[i] &lt;= 100</span><br><span class="line">1 &lt;= extraCandies &lt;= 50</span><br></pre></td></tr></table></figure>
<p>题解：<br>如果采用暴力法，在每个孩子的糖果数上加上extraCandies再与其他孩子比，时间复杂度为O(n2)。<br>可以先找出最大值<code>most</code>，遍历时与<code>most-extraCandies</code>比较，此时只需O(n)。<br>找数组中的最大值可以自己实现，也可以使用STL实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int getMostCandies(vector&lt;int&gt;&amp; candies)&#123;</span><br><span class="line">    int most = 0;</span><br><span class="line">    for(int n:candies)&#123;</span><br><span class="line">        if(n&gt;most)</span><br><span class="line">            most = n;</span><br><span class="line">    &#125;</span><br><span class="line">    return most;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;bool&gt; kidsWithCandies(vector&lt;int&gt;&amp; candies, int extraCandies) &#123;</span><br><span class="line">    int most = getMostCandies(candies);</span><br><span class="line">    vector&lt;bool&gt; isMostCandies(candies.size());</span><br><span class="line">    for(int i=0;i&lt;candies.size();i++)&#123;</span><br><span class="line">        if(most-candies[i]&gt;extraCandies)</span><br><span class="line">            isMostCandies[i] = false;</span><br><span class="line">        else</span><br><span class="line">            isMostCandies[i] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    return isMostCandies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6月2日-剑指Offer面试题64-求1-2-…-n"><a href="#6月2日-剑指Offer面试题64-求1-2-…-n" class="headerlink" title="6月2日 剑指Offer面试题64. 求1+2+…+n"></a>6月2日 <a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指Offer面试题64. 求1+2+…+n</a></h1><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。<br><code>1 &lt;= n &lt;= 10000</code><br>题解：<br>通常实现递归的时候我们都会利用条件判断语句来决定递归的出口，但由于题目的限制我们不能使用条件判断语句，所以我们使用<code>逻辑运算符的短路性质</code>：<br>以逻辑运算符 &amp;&amp; 为例，对于 A &amp;&amp; B 这个表达式，如果 A 表达式返回 False ，那么 A &amp;&amp; B 已经确定为 False ，此时不会去执行表达式 B。同理，对于逻辑运算符 ||， 对于 A || B 这个表达式，如果 A 表达式返回 True ，那么 A || B 已经确定为 True ，此时不会去执行表达式 B。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sumNums(int n) &#123;</span><br><span class="line">    n &amp;&amp; (n += sumNums(n-1));</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6月3日-837-新21点（中等）"><a href="#6月3日-837-新21点（中等）" class="headerlink" title="6月3日 837. 新21点（中等）"></a>6月3日 <a href="https://leetcode-cn.com/problems/new-21-game/">837. 新21点（中等）</a></h1><p>爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：<br>爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。<br>当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：N = 21, K = 17, W = 10</span><br><span class="line">输出：0.73278</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 &lt;= K &lt;= N &lt;= 10000</span><br><span class="line">1 &lt;= W &lt;= 10000</span><br></pre></td></tr></table></figure>
<p>题解：<br><code>dp[x]</code>为她已经获得的分数为x时，能获胜的概率。  </p>
<ul>
<li><code>dp[x] = (dp[x+1]+dp[x+2]+dp[x+3]...+dp[x+W])/W</code>  </li>
<li><code>dp[x-1] = (dp[x]+dp[x+1]+dp[x+2]...+dp[x-1+W])/W</code></li>
<li><code>dp[x-1]-dp[x] = (dp[x]-dp[x-1+W])/W</code></li>
</ul>
<p>最后公式为：</p>
<ul>
<li><code>dp[x] = x &lt;= N ? 1 : 0</code>&amp;emsp;&amp;emsp;K &lt;&#x3D; x &lt; K+W</li>
<li><code>dp[K-1] = (dp[K]+dp[K+1]+dp[K+2]...+dp[K-1+W])/W</code></li>
<li><code>dp[x-1] = dp[x] + (dp[x]-dp[x+W])/W</code>&amp;emsp;&amp;emsp;0 &lt;&#x3D; x &lt; K-1</li>
</ul>
<p>如果不求<code>dp[x]</code>与<code>dp[x-1]</code>的状态转移方程，可以用概率和的状态转移方程代替：</p>
<ul>
<li><code>sumOfW[x] = sumOfW[x+1] - dp[x+W] + dp[x]</code></li>
</ul>
<p>因为抽取点数机会都是均等的，她能抽取的面值在[1,W]之间，所以将概率之和平均一下就是dp[x]的概率。<br>她可能达到的最大牌面是K-1+W，而一开始她的牌面是0，所以我们用一个长度为K+W的dp数组来保存她在所有面值下的胜率。<br>dp[0]就是最开始爱丽丝还没有抽牌时的胜率。</p>
<p>使用dp状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double new21Game(int N, int K, int W) &#123;</span><br><span class="line">    if(K==0)</span><br><span class="line">        return 1.0;</span><br><span class="line">    vector&lt;double&gt; dp(K + W);</span><br><span class="line">    double sumOfW = 0;</span><br><span class="line">    for (int i = K; i &lt; K + W;i++)&#123;</span><br><span class="line">        dp[i] = i &lt;= N ? 1.0 : 0.0;</span><br><span class="line">        sumOfW += dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[K - 1] = sumOfW / W;</span><br><span class="line">    for (int i = K - 2; i &gt;= 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = dp[i + 1] + (dp[i + 1] - dp[i +1 + W]) / W;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用概率和状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double new21Game(int N, int K, int W) &#123;</span><br><span class="line">    vector&lt;double&gt; dp(K + W + 1);</span><br><span class="line">    double sumOfW = 0;</span><br><span class="line">    for (int i = K; i &lt; K + W;i++)&#123;</span><br><span class="line">        //不能抽牌时，超过N为0，不超过N为1</span><br><span class="line">        dp[i] = i &lt;= N ? 1 : 0;</span><br><span class="line">        sumOfW += dp[i];//为了方便求sum(dp[x+1]...dp[x+W])</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = K - 1; i &gt;= 0;i--)&#123;</span><br><span class="line">        //使用分析中的公式</span><br><span class="line">        dp[i] = sumOfW / W;</span><br><span class="line">        sumOfW = sumOfW - dp[i + W] + dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="6月4日-238-除自身以外数组的乘积（中等）"><a href="#6月4日-238-除自身以外数组的乘积（中等）" class="headerlink" title="6月4日 238. 除自身以外数组的乘积（中等）"></a>6月4日 <a href="https://leetcode-cn.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积（中等）</a></h1><p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。<br>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong> 题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。<br><strong>说明:</strong> 请不要使用除法（数组中有0时失效），且在 O(n) 时间复杂度内完成此题。</p>
<p>题解：</p>
<ul>
<li>时间复杂度O(N)，空间复杂度O(N)的方法：<br>利用左侧所有数字的乘积和右侧所有数字的乘积相乘得到：通过两次遍历（从前向后，从后向前）得到两个乘积表：<br><code>productOfLeft(n)</code>和<code>productOfRight(n)</code><br><code>productOfLeft(i) = productOfLeft[i-1] * nums[i-1]</code>表示<code>nums[i]</code>左边所有数的乘积，其中<code>productOfLeft(0)=1</code>；<br><code>productOfRight(i) = productOfRight[i+1] * nums[i+1]</code>表示<code>nums[i]</code>右边所有数的乘积，其中<code>productOfLeft(n-1)=1</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; productOfLeft(n,0), productOfRight(n,0), output(n,0);</span><br><span class="line">    </span><br><span class="line">    productOfLeft[0] = 1;</span><br><span class="line">    for(int i=1;i&lt;n;i++)</span><br><span class="line">        productOfLeft[i] = productOfLeft[i-1] * nums[i-1];</span><br><span class="line">    </span><br><span class="line">    productOfRight[n-1] = 1;</span><br><span class="line">    for(int i = n-2;i&gt;=0;i--)</span><br><span class="line">        productOfRight[i] = productOfRight[i+1] * nums[i+1];</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i&lt;n;i++)</span><br><span class="line">        output[i] = productOfLeft[i] * productOfRight[i];</span><br><span class="line"></span><br><span class="line">    return output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>时间复杂度O(N)，空间复杂度O(1)的方法，这是对上面方法的优化：<br>1）把<code>productOfLeft(n)</code>存放都<code>output(n)</code>中（输出数组不算占用空间）<br>2）用一个<code>int</code>来代替<code>productOfRight(n)</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; output(n,0);</span><br><span class="line">    </span><br><span class="line">    output[0] = 1;</span><br><span class="line">    for(int i=1;i&lt;n;i++)</span><br><span class="line">        output[i] = output[i-1] * nums[i-1];</span><br><span class="line">    </span><br><span class="line">    int productOfRight = 1;</span><br><span class="line">    for(int i = n-1;i&gt;=0;i--)&#123;</span><br><span class="line">        output[i] = output[i] * productOfRight;</span><br><span class="line">        productOfRight *= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="6月5日-剑指Offer面试题29-顺时针打印矩阵（简单）"><a href="#6月5日-剑指Offer面试题29-顺时针打印矩阵（简单）" class="headerlink" title="6月5日 剑指Offer面试题29. 顺时针打印矩阵（简单）"></a>6月5日 <a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指Offer面试题29. 顺时针打印矩阵（简单）</a></h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>
<p>题解：<br>顺时针访问矩阵共有4个遍历方向，依次循环直到全部访问：1）从左到右；2）从上到下；3）从右到左；4）从下到上。<br>关键是方向改变的判定条件。</p>
<p>可以设置一个hasVisited[row][col]数组来不标记访问过的元素。这需要这样的话空间复杂度为O(row*col)。</p>
<p>也可以使用4个int分别表示上下左右的访问边界，每次变换方向，就把该行&#x2F;列的边界向里面缩一行。</p>
<p>第二种方法的代码：<br>时间复杂度O(row*col)：其中 row 和 col 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。<br>空间复杂度：O(1)。除了输出数组以外，只需要4个int来表示边界。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    if(matrix.empty())</span><br><span class="line">        return result;</span><br><span class="line">    int upWall = 0,downWall = matrix.size()-1,leftWall = 0,rightWall = matrix[0].size()-1;</span><br><span class="line">    //1 L To R; 2 Up To D; 3R To L; 4 D To Up</span><br><span class="line">    int dir = 1;</span><br><span class="line">    int row = 0, col = 0;</span><br><span class="line">    while(upWall&lt;=downWall &amp;&amp; leftWall&lt;=rightWall)&#123;</span><br><span class="line">        result.push_back(matrix[row][col]);</span><br><span class="line">        if(dir==1)&#123;//从左到右</span><br><span class="line">            if(col!=rightWall)</span><br><span class="line">                col++;</span><br><span class="line">            else&#123;</span><br><span class="line">                row++;</span><br><span class="line">                upWall++;</span><br><span class="line">                dir = 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(dir==2)&#123;//从上到下</span><br><span class="line">            if(row!=downWall)</span><br><span class="line">                row++;</span><br><span class="line">            else&#123;</span><br><span class="line">                col--;</span><br><span class="line">                rightWall--;</span><br><span class="line">                dir = 3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(dir==3)&#123;//从右到左</span><br><span class="line">            if(col!=leftWall)</span><br><span class="line">                col--;</span><br><span class="line">            else&#123;</span><br><span class="line">                row--;</span><br><span class="line">                downWall--;</span><br><span class="line">                dir = 4;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;//从下到上</span><br><span class="line">            if(row!=upWall)</span><br><span class="line">                row--;</span><br><span class="line">            else&#123;</span><br><span class="line">                col++;</span><br><span class="line">                leftWall++;</span><br><span class="line">                dir = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6月6日-128-最长连续序列（困难）"><a href="#6月6日-128-最长连续序列（困难）" class="headerlink" title="6月6日 128. 最长连续序列（困难）"></a>6月6日 <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列（困难）</a></h1><p>给定一个未排序的整数数组，找出最长连续序列的长度。<br>要求算法的时间复杂度为 O(n)。<br>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [100, 4, 200, 1, 3, 2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<ol>
<li>暴力枚举。最外层枚举每一个元素O(n)；每个数要找它的前一个和后一个连续数O(n)；在数组中定位一个元素，暴力法O(n)，map、set这些红黑树实现的O（lgn），哈希表O(1)。所以纯暴力法时间复杂度O(n3)，最优也是用哈希表的O(n2)。</li>
<li>排序。时间复杂度为O(n*lgn)。虽然不满足要求，但是提交能过。<br>排序后用双指针，遍历一遍O(n)。（去重可以用stl库的unique函数，这里直接设置一个重复计数器eqNums，最后减掉重复数即可）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    if(nums.size()==0)</span><br><span class="line">        return 0;</span><br><span class="line">    sort(nums.begin(),nums.end());</span><br><span class="line">    int idxL = 0, idxR = 0, maxSub = 1, eqNums = 0;</span><br><span class="line">    for(int i = 1;i&lt;nums.size();i++)&#123;</span><br><span class="line">        if(nums[i]==nums[i-1])&#123;</span><br><span class="line">            idxR++;</span><br><span class="line">            eqNums++;</span><br><span class="line">        &#125;else if(nums[i]==nums[i-1]+1)&#123;</span><br><span class="line">            idxR++;</span><br><span class="line">            maxSub = max(maxSub,idxR-idxL+1-eqNums);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            maxSub = max(maxSub,idxR-idxL+1-eqNums);</span><br><span class="line">            idxL = i;</span><br><span class="line">            idxR = i;</span><br><span class="line">            eqNums = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxSub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用哈希表(unordered_set)一遍遍历O(n)。在进入while循环，以当前数字为首增加currentSub时，先在哈希表中寻找前一位数字是否存在。只有前一位不存在，才开始以当前数字为首扩充子序列。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    unordered_set&lt;int&gt; num_set;</span><br><span class="line">    for (const int&amp; num : nums) &#123;</span><br><span class="line">        num_set.insert(num);</span><br><span class="line">    &#125;</span><br><span class="line">    int maxSub = 0;</span><br><span class="line">    for (const int&amp; num : num_set) &#123;</span><br><span class="line">        if (!num_set.count(num - 1)) &#123;</span><br><span class="line">            int currentNum = num;</span><br><span class="line">            int currentSub = 1;</span><br><span class="line"></span><br><span class="line">            while (num_set.count(currentNum + 1)) &#123;</span><br><span class="line">                currentNum += 1;</span><br><span class="line">                currentSub += 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxSub = max(maxSub, currentSub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxSub;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>并查集<a href="https://www.bilibili.com/video/av68236186/">(视频讲解)</a><br><a href="https://zhuanlan.zhihu.com/p/93647900">什么是并查集</a><br><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/cbing-cha-ji-xie-fa-dai-ma-ji-duan-by-leck/">代码：</a><br>初始化的时候先把数组里每个元素初始化为他的下一个数；<br>并的时候找他能到达的最远的数字就可以了。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;int,int&gt; a;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    return a.count(x)?a[x]=find(a[x]):x;</span><br><span class="line">&#125;</span><br><span class="line">int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    for(auto i:nums)</span><br><span class="line">        a[i]=i+1;</span><br><span class="line">    int maxSub=0;</span><br><span class="line">    for(auto i:nums)&#123;</span><br><span class="line">        int y=find(i+1);</span><br><span class="line">        maxSub=max(maxSub,y-i);</span><br><span class="line">    &#125;</span><br><span class="line">    return maxSub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="6月7日-126-单词接龙-II（困难）"><a href="#6月7日-126-单词接龙-II（困难）" class="headerlink" title="6月7日 126. 单词接龙 II（困难）"></a>6月7日 <a href="https://leetcode-cn.com/problems/word-ladder-ii/">126. 单词接龙 II（困难）</a></h1><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：<br>每次转换只能改变一个字母；转换过程中的中间单词必须是字典中的单词。<br><strong>说明:</strong><br>如果不存在这样的转换序列，返回一个空列表。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。<br>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">输出: []</span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<ol>
<li><p>回溯算法。先建图，然后找出所有路径，然后再从所有路径中找出最短路径。<br><strong>建图</strong>时间复杂度：建图需要外层枚举O(n)，里层遍历O(n)，两个单词之间的比较O(m)（m为单词的长度）。所以时间复杂度为O(n2*m)。<br>但是在回溯算法找路径时，时间会随字典中的单词数成指数增长。<br>下面代码能通过19&#x2F;39，最后超时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isConnection(string word1, string word2)&#123;</span><br><span class="line">    int diff = 0;</span><br><span class="line">    for (int i = 0; i &lt; word1.size() &amp;&amp; diff&lt;=1 ;i++)&#123;</span><br><span class="line">        if(word1[i]!=word2[i])</span><br><span class="line">            diff++;</span><br><span class="line">    &#125;</span><br><span class="line">    return diff == 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; buildGraphic(vector&lt;string&gt;&amp; wordList)&#123;</span><br><span class="line">    int N = wordList.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graphic(N);</span><br><span class="line">    for (int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        string curWord = wordList[i];</span><br><span class="line">        for (int j = 0; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            string nextWord = wordList[j];</span><br><span class="line">            if (isConnection(curWord,nextWord))</span><br><span class="line">                graphic[i].push_back(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(auto g:graphic)&#123;</span><br><span class="line">        for(int n:g)</span><br><span class="line">            cout &lt;&lt; n &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;build graphic done&quot; &lt;&lt; endl;</span><br><span class="line">    return graphic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backTracking(vector&lt;string&gt; &amp;wordList, vector&lt;vector&lt;int&gt; &gt; &amp;graphic, vector&lt;bool&gt; &amp;hasVisted, vector&lt;string&gt; &amp;preWord, vector&lt;vector&lt;string&gt; &gt; &amp;result, string endWord, int current)</span><br><span class="line">&#123;</span><br><span class="line">    if (wordList[current] == endWord)</span><br><span class="line">    &#123;</span><br><span class="line">        result.push_back(preWord);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int next : graphic[current])&#123;</span><br><span class="line">        if(hasVisted[next])</span><br><span class="line">            continue;</span><br><span class="line">        preWord.push_back(wordList[next]);</span><br><span class="line">        hasVisted[next] = true;</span><br><span class="line">        backTracking(wordList, graphic, hasVisted, preWord, result, endWord, next);</span><br><span class="line">        hasVisted[next] = false;</span><br><span class="line">        preWord.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;string&gt; &gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt; resultAll;</span><br><span class="line">    vector&lt;string&gt;::iterator it = find(wordList.begin(), wordList.end(), endWord);</span><br><span class="line">    if(it==wordList.end())//wordList中没有endWord</span><br><span class="line">        return resultAll;</span><br><span class="line">    wordList.push_back(beginWord);</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graphic = buildGraphic(wordList);</span><br><span class="line"></span><br><span class="line">    vector&lt;bool&gt; hasVisted(wordList.size(), false);</span><br><span class="line">    hasVisted[wordList.size() - 1] = true;//beginWord</span><br><span class="line">    vector&lt;string&gt; preWord;</span><br><span class="line">    preWord.push_back(beginWord);</span><br><span class="line">    backTracking(wordList, graphic, hasVisted, preWord, resultAll, endWord, wordList.size() - 1);</span><br><span class="line"></span><br><span class="line">    int less = wordList.size();</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt; result;</span><br><span class="line">    for (auto res : resultAll)//找长度最小值</span><br><span class="line">        less = res.size() &lt; less ? res.size() : less;</span><br><span class="line">    for(auto res : resultAll)&#123;//过滤长度最小的</span><br><span class="line">        if(res.size()==less)</span><br><span class="line">            result.push_back(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先通过<strong>BFS</strong>找到最短路径长度（方法可以看我的<a href="https://suzhilong.github.io/2020/05/25/algorithm/">算法总结：查找&#x2F;BFS 专题中的62题</a>），然后再在方法1回溯的时候加上路径长度条件。<br>虽然减少了一些分支，但是还是最坏情况的时间复杂度还是和1一样，与单词数成指数相关。<br>21&#x2F;39个通过，最后超时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isConnection(string word1, string word2)&#123;</span><br><span class="line">    int diff = 0;</span><br><span class="line">    for (int i = 0; i &lt; word1.size() &amp;&amp; diff&lt;=1 ;i++)&#123;</span><br><span class="line">        if(word1[i]!=word2[i])</span><br><span class="line">            diff++;</span><br><span class="line">    &#125;</span><br><span class="line">    return diff == 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; buildGraphic(vector&lt;string&gt;&amp; wordList)&#123;</span><br><span class="line">    int N = wordList.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graphic(N);</span><br><span class="line">    for (int i = 0; i &lt; N; i++)&#123;</span><br><span class="line">        string curWord = wordList[i];</span><br><span class="line">        for (int j = 0; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            string nextWord = wordList[j];</span><br><span class="line">            if (isConnection(curWord,nextWord))</span><br><span class="line">                graphic[i].push_back(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return graphic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getShortestPath(vector&lt;string&gt; &amp;wordList, vector&lt;vector&lt;int&gt; &gt; &amp;graphic, string endWord)&#123;</span><br><span class="line">    int N = graphic.size();</span><br><span class="line">    vector&lt;bool&gt; hasVisited(N, false);</span><br><span class="line">    hasVisited[N - 1] = true;</span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    que.push(N - 1);//beginWord</span><br><span class="line">    int shortestPath = 1;</span><br><span class="line">    while (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        shortestPath++;</span><br><span class="line">        int size = que.size();</span><br><span class="line">        while(size-- &gt; 0)&#123;</span><br><span class="line">            int current = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            for(int next : graphic[current])&#123;</span><br><span class="line">                if(wordList[next]==endWord)</span><br><span class="line">                    return shortestPath;</span><br><span class="line">                if(hasVisited[next])</span><br><span class="line">                    continue;</span><br><span class="line">                hasVisited[next] = true;</span><br><span class="line">                que.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backTracking(vector&lt;string&gt; &amp;wordList, vector&lt;vector&lt;int&gt; &gt; &amp;graphic, vector&lt;bool&gt; &amp;hasVisted, vector&lt;string&gt; &amp;preWord, vector&lt;vector&lt;string&gt; &gt; &amp;result, string endWord, int current, int curPath, int shortestPath)</span><br><span class="line">&#123;</span><br><span class="line">    if(curPath&gt;shortestPath)</span><br><span class="line">        return;</span><br><span class="line">    if (wordList[current] == endWord)</span><br><span class="line">    &#123;</span><br><span class="line">        result.push_back(preWord);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int next : graphic[current])&#123;</span><br><span class="line">        if(hasVisted[next])</span><br><span class="line">            continue;</span><br><span class="line">        preWord.push_back(wordList[next]);</span><br><span class="line">        hasVisted[next] = true;</span><br><span class="line">        backTracking(wordList, graphic, hasVisted, preWord, result, endWord, next, curPath+1, shortestPath);</span><br><span class="line">        hasVisted[next] = false;</span><br><span class="line">        preWord.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;string&gt; &gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt; result;</span><br><span class="line">    vector&lt;string&gt;::iterator it = find(wordList.begin(), wordList.end(), endWord);</span><br><span class="line">    if(it==wordList.end())//wordList中没有endWord</span><br><span class="line">        return result;</span><br><span class="line">    wordList.push_back(beginWord);</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graphic = buildGraphic(wordList);</span><br><span class="line"></span><br><span class="line">    int shortestPath = getShortestPath(wordList, graphic, endWord);</span><br><span class="line"></span><br><span class="line">    vector&lt;bool&gt; hasVisted(wordList.size(), false);</span><br><span class="line">    hasVisted[wordList.size() - 1] = true;//beginWord</span><br><span class="line">    vector&lt;string&gt; preWord;</span><br><span class="line">    preWord.push_back(beginWord);</span><br><span class="line">    backTracking(wordList, graphic, hasVisted, preWord, result, endWord, wordList.size() - 1, 1, shortestPath);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>反向BFS建图，从endWord开始向上BFS，同时记录每个结点的父结点。再从beginWord开始回溯。<br>（代码略）</p>
</li>
<li><p>双向BFS建图。<br>使用<code>unordered_map&lt;string, vector&lt;string&gt; &gt; graphic</code>来记录单词的子结点，<code>string</code>是wordList中的单词，<code>vector&lt;string&gt;</code>是可以与<code>string</code>连接的子结点（与这个<code>string</code>只有一个字母之差且存在与字典中的集合）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt; &gt; result;</span><br><span class="line"></span><br><span class="line">bool isConnection(string word1, string word2)&#123;</span><br><span class="line">    int diff = 0;</span><br><span class="line">    for (int i = 0; i &lt; word1.size() &amp;&amp; diff&lt;=1 ;i++)&#123;</span><br><span class="line">        if(word1[i]!=word2[i])</span><br><span class="line">            diff++;</span><br><span class="line">    &#125;</span><br><span class="line">    return diff == 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;string, vector&lt;string&gt; &gt; buildGraphic(vector&lt;string&gt;&amp; wordList, string beginWord, string endWord)&#123;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; graphic; //存储string能连接到的下一层结点</span><br><span class="line">    unordered_set&lt;string&gt; dict(wordList.begin(), wordList.end());</span><br><span class="line">    unordered_set&lt;string&gt; beginToEnd&#123;beginWord&#125;;</span><br><span class="line">    unordered_set&lt;string&gt; endToBegin&#123;endWord&#125;;</span><br><span class="line">    bool findShortest = false; //是否找到最短序列标志,</span><br><span class="line">    bool dirction = 0; //方向标志。0:begin to end   1:end to begin</span><br><span class="line">    while(!beginToEnd.empty())&#123;</span><br><span class="line">        unordered_set&lt;string&gt; nextLayer;</span><br><span class="line">        for (string s : beginToEnd) //把图里已经有的从list中删除</span><br><span class="line">            dict.erase(s);</span><br><span class="line">        for(string curStr:beginToEnd)&#123;//建立下一层连接</span><br><span class="line">            for(string nextStr:dict)&#123;</span><br><span class="line">                if(isConnection(curStr,nextStr))&#123;</span><br><span class="line">                    if(endToBegin.find(nextStr) != endToBegin.end())//双边遍历碰到了</span><br><span class="line">                        findShortest = true;</span><br><span class="line">                    else</span><br><span class="line">                        nextLayer.insert(nextStr);</span><br><span class="line">                    dirction ? graphic[nextStr].push_back(curStr) : graphic[curStr].push_back(nextStr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(findShortest)</span><br><span class="line">            break;</span><br><span class="line">        if(nextLayer.size()&lt;=endToBegin.size())</span><br><span class="line">            beginToEnd = nextLayer;</span><br><span class="line">        else&#123;</span><br><span class="line">            beginToEnd = endToBegin;</span><br><span class="line">            endToBegin = nextLayer;</span><br><span class="line">            dirction = !dirction;//end和begin反转，方向标志也要反转</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return graphic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backTracking(unordered_map&lt;string, vector&lt;string&gt; &gt; &amp;graphic, vector&lt;string&gt;&amp; preWords, string beginWord, string endWord)</span><br><span class="line">&#123;</span><br><span class="line">    if (beginWord == endWord)</span><br><span class="line">    &#123;</span><br><span class="line">        result.push_back(preWords);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(graphic.find(beginWord) == graphic.end())</span><br><span class="line">        return;</span><br><span class="line">    for(string str:graphic[beginWord])&#123;</span><br><span class="line">        preWords.push_back(str);</span><br><span class="line">        backTracking(graphic, preWords, str, endWord);</span><br><span class="line">        preWords.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;string&gt; &gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">    vector&lt;string&gt;::iterator it = find(wordList.begin(), wordList.end(), endWord);</span><br><span class="line">    if(it==wordList.end())//wordList中没有endWord</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt; &gt; graphic = buildGraphic(wordList, beginWord, endWord);</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; preWords = &#123;beginWord&#125;;</span><br><span class="line"></span><br><span class="line">    backTracking(graphic, preWords, beginWord, endWord);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<br>建图需要O(n^2)。建图时比较两个单词是否可以连接需要O(c)，c为单词的长度。普通BFS时间复杂度为O(n2)。<br>回溯需要O(2^m)，m为建好的图中的单词数。<br>普通BFS建图中单词数m&#x3D;n，双向BFS建图可以大大减少图中的单词数。</p>
</li>
</ol>
<h1 id="6月8日-990-等式方程的可满足性（中等）"><a href="#6月8日-990-等式方程的可满足性（中等）" class="headerlink" title="6月8日 990. 等式方程的可满足性（中等）"></a>6月8日 <a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">990. 等式方程的可满足性（中等）</a></h1><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：”a&#x3D;&#x3D;b” 或 “a!&#x3D;b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p>
<p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a==b&quot;,&quot;b!=a&quot;]</span><br><span class="line">输出：false</span><br><span class="line">解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出：[&quot;b==a&quot;,&quot;a==b&quot;]</span><br><span class="line">输入：true</span><br><span class="line">解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p>示例 5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 &lt;= equations.length &lt;= 500</span><br><span class="line">equations[i].length == 4</span><br><span class="line">equations[i][0] 和 equations[i][3] 是小写字母</span><br><span class="line">equations[i][1] 要么是 &#x27;=&#x27;，要么是 &#x27;!&#x27;</span><br><span class="line">equations[i][2] 是 &#x27;=&#x27;</span><br></pre></td></tr></table></figure>

<p>题解：<br>这题需要用到<strong>并查集</strong>，相关专题可以查看我的<a href="https://suzhilong.github.io/2020/05/25/algorithm/">博客</a>。<br>把相等的左右两边放到一个子集里面，然后看不相等的是否在同一个子集里。如果在同一个子集的两个字母不相等返回<code>false</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class UnionFind &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; parent;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    UnionFind() &#123;</span><br><span class="line">        parent.resize(26);</span><br><span class="line">        iota(parent.begin(), parent.end(), 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int find(int index) &#123;</span><br><span class="line">        if (index == parent[index]) &#123;</span><br><span class="line">            return index;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[index] = find(parent[index]);</span><br><span class="line">        return parent[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void unite(int index1, int index2) &#123;</span><br><span class="line">        parent[find(index1)] = find(index2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123;</span><br><span class="line">        UnionFind uf;</span><br><span class="line">        for (const string&amp; str: equations) &#123;</span><br><span class="line">            if (str[1] == &#x27;=&#x27;) &#123;</span><br><span class="line">                int index1 = str[0] - &#x27;a&#x27;;</span><br><span class="line">                int index2 = str[3] - &#x27;a&#x27;;</span><br><span class="line">                uf.unite(index1, index2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (const string&amp; str: equations) &#123;</span><br><span class="line">            if (str[1] == &#x27;!&#x27;) &#123;</span><br><span class="line">                int index1 = str[0] - &#x27;a&#x27;;</span><br><span class="line">                int index2 = str[3] - &#x27;a&#x27;;</span><br><span class="line">                if (uf.find(index1) == uf.find(index2)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="6月9日-剑指Offer面试题46-把数字翻译成字符串（中等）"><a href="#6月9日-剑指Offer面试题46-把数字翻译成字符串（中等）" class="headerlink" title="6月9日 剑指Offer面试题46. 把数字翻译成字符串（中等）"></a>6月9日 <a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指Offer面试题46. 把数字翻译成字符串（中等）</a></h1><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。<br>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 &lt;= num &lt; 2^31</span><br></pre></td></tr></table></figure>
<p>题解：<br>典型的动态规划题，同类型例题可以看我的<a href="https://suzhilong.github.io/2020/05/25/algorithm/">算法总结中的动态规划专题</a><br><code>dp[i]</code>表示第 i 位数字之前（含）的不同翻译种数，i&#x3D;[1,n]，dp[0]是为了递推方便初始化的，没有实际意义。<br>有两种情况：</p>
<ul>
<li><code>dp[i] = dp[i-1]</code>前2位中的第一位是为0，如求506的dp[3]时，前一位为0，所以dp[3] &#x3D; dp[2]；前面两位数字大于25，如535，其中35不能翻译为字母，所以dp[3]&#x3D;dp[2]</li>
<li><code>dp[i] = dp[i-1] + dp[i-2]</code>如516，dp[3]&#x3D;dp[2]+dp[1]：516的翻译方法等于5的翻译种数（尾巴添16），加上51的翻译方法种数（尾巴添6）。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int translateNum(int num)&#123;</span><br><span class="line">    string numStr = to_string(num);</span><br><span class="line">    int n = numStr.size();</span><br><span class="line">    vector&lt;int&gt; dp(n + 1);</span><br><span class="line">    dp[0] = 1, dp[1] = 1;//dp[i]表示第i数字之前（含）的不同翻译种数，i=[1,n]，dp[0]是为了递推方便初始化的，没有实际意义</span><br><span class="line">    for (int i = 2; i &lt;= n; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        string pre1num = numStr.substr(i - 2, 1);//看前面2位中的第一位是否为0</span><br><span class="line">        string pre2num = numStr.substr(i - 2, 2);</span><br><span class="line">        dp[i] = (stoi(pre2num) &gt; 25 || stoi(pre1num)==0) ? dp[i - 1] : dp[i - 1] + dp[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度O(n)<br>空间复杂度O(n)。因为只用到前面2个，所以可以优化为O(1)，只用dp[0],dp[1],dp[2]（代码略）。</li>
</ul>
<h1 id="6月10日-回文数（简单）"><a href="#6月10日-回文数（简单）" class="headerlink" title="6月10日 回文数（简单）"></a>6月10日 <a href="https://leetcode-cn.com/problems/palindrome-number/">回文数（简单）</a></h1><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<ol>
<li><p>将数字转换为字符串，设置双指针<code>idxL</code>和<code>idxR</code>，分别指向字符串的头和尾。两个指针边比较边向中间移动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isPalindrome(int x) &#123;</span><br><span class="line">    if(x&lt;0)</span><br><span class="line">        return false;</span><br><span class="line">    string numStr = to_string(x);</span><br><span class="line">    int idxL = 0, idxR = numStr.size() - 1;</span><br><span class="line">    while (idxR&gt;idxL)</span><br><span class="line">    &#123;</span><br><span class="line">        if(numStr[idxL]!=numStr[idxR])</span><br><span class="line">            return false;</span><br><span class="line">        else&#123;</span><br><span class="line">            idxL++;</span><br><span class="line">            idxR--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)<br>空间复杂度O(n)<br>n是数字的位数</p>
</li>
<li><p>不转换成字符串。当x位数为偶数时只用看后一半反转后与前一半是否相等；当x位数为奇数时，我们可以通过 revertedNum&#x2F;10 去除处于中位的数字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isPalindrome(int x) &#123;</span><br><span class="line">    if(x&lt;0 || (x % 10 == 0 &amp;&amp; x != 0))//末尾是0的也不可能是回文</span><br><span class="line">        return false;</span><br><span class="line">    int revertedNum = 0;</span><br><span class="line">    while(x &gt; revertedNum)&#123;//已经到一半了</span><br><span class="line">        revertedNum = revertedNum * 10 + x % 10;</span><br><span class="line">        x /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return x == revertedNum || x == revertedNum / 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="6月11日-739-每日温度（中等）"><a href="#6月11日-739-每日温度（中等）" class="headerlink" title="6月11日 739. 每日温度（中等）"></a>6月11日 <a href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度（中等）</a></h1><p>根据每日 <code>气温</code> 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<p>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<ol>
<li><p>纯暴力法（超时）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;</span><br><span class="line">    vector&lt;int&gt; res(T.size(),0);</span><br><span class="line">    for(int i=0;i&lt;T.size();i++)&#123;</span><br><span class="line">        for(int j=i+1;j&lt;T.size();j++)&#123;</span><br><span class="line">            if(T[j]&gt;T[i])&#123;</span><br><span class="line">                res[i] = j-i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n^2)。空间复杂度(1)。</p>
</li>
<li><p>温度数组加暴力。由于温度范围在<code>[30, 100]</code>之内，因此可以维护一个数组<code>tempFirstPos</code>记录每个温度第一次出现的下标。数组<code>tempFirstPos</code>中的元素初始化为<code>n</code>，因为数组的最大索引为<code>n-1</code>。在<strong>反向</strong>遍历温度列表的过程中更新 tempFirstPos 的值。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;</span><br><span class="line">    int n = T.size();</span><br><span class="line">    vector&lt;int&gt; res(n), tempFirstPos(101, n);</span><br><span class="line">    for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        int warmerIndex = n;//最大值为数组长度</span><br><span class="line">        for (int t = T[i] + 1; t &lt;= 100; t++) &#123;</span><br><span class="line">            warmerIndex = min(warmerIndex, tempFirstPos[t]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (warmerIndex != n) &#123;</span><br><span class="line">            res[i] = warmerIndex - i;</span><br><span class="line">        &#125;</span><br><span class="line">        tempFirstPos[T[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n*m)，n是数组长度，m是温度的范围。空间复杂度O(n)。</p>
</li>
<li><p>单调栈。维护一个单调递减的栈，栈中元素为温度值的索引。当前温度比栈顶索引温度低时，直接进栈；当前温度比栈顶索引温度高时，两个索引之间的差就是栈顶索引值所求结果。<br><a href="https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/">视频讲解</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;</span><br><span class="line">    int n = T.size();</span><br><span class="line">    vector&lt;int&gt; res(n,0);</span><br><span class="line">    stack&lt;int&gt; s;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        while (!s.empty() &amp;&amp; T[i] &gt; T[s.top()]) &#123;</span><br><span class="line">            int previousIndex = s.top();</span><br><span class="line">            res[previousIndex] = i - previousIndex;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)。空间复杂度O(n)。</p>
</li>
</ol>
<h1 id="6月12日-15-三数之和"><a href="#6月12日-15-三数之和" class="headerlink" title="6月12日 15. 三数之和"></a>6月12日 <a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h1><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p><strong>注意</strong>：答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>题解：  </p>
<ol>
<li><p>暴力（超时）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    set&lt;vector&lt;int&gt; &gt; resultSet;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">    if (n &lt; 3)</span><br><span class="line">        return result;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = i + 1; j &lt; n; j++)&#123;</span><br><span class="line">            for (int k = j + 1; k &lt; n; k++)&#123;</span><br><span class="line">                if(nums[i]+nums[j]+nums[k]==0)&#123;</span><br><span class="line">                    vector&lt;int&gt; tmp;</span><br><span class="line">                    tmp.push_back(nums[i]);</span><br><span class="line">                    tmp.push_back(nums[j]);</span><br><span class="line">                    tmp.push_back(nums[k]);</span><br><span class="line">                    sort(tmp.begin(), tmp.end());</span><br><span class="line">                    resultSet.insert(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(auto s:resultSet)&#123;</span><br><span class="line">        result.push_back(s);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>311 &#x2F; 313 个通过测试用例<br>时间复杂度O(n^3)，空间复杂度O(1)  </p>
</li>
<li><p>把最里面一层改为二分查找，需要先排序。还是超时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool biSearch(int resNum, int &amp;idx, vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">    int idxL = 0, idxR = nums.size()-1;</span><br><span class="line">    int mid = idxR / 2;</span><br><span class="line">    while(idxL &lt;= idxR)&#123;</span><br><span class="line">        if(resNum &gt; nums[mid])&#123;</span><br><span class="line">            idxL = mid + 1;</span><br><span class="line">        &#125;else if(resNum &lt; nums[mid])&#123;</span><br><span class="line">            idxR = mid - 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            idx = mid;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (idxL+idxR)/2;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">    unordered_set&lt;vector&lt;int&gt; &gt; resultSet;</span><br><span class="line">    </span><br><span class="line">    sort(nums.begin(),nums.end());</span><br><span class="line">    if (n &lt; 3 || nums[0] &gt; 0 || nums[n-1] &lt; 0)//全正或全负</span><br><span class="line">        return result;</span><br><span class="line">    if(nums[0] == 0 &amp;&amp; nums[n-1] == 0)&#123;//全是0</span><br><span class="line">        vector&lt;int&gt; tmp0 = &#123;0, 0, 0&#125;;</span><br><span class="line">        result.push_back(tmp0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">            if(j == i)</span><br><span class="line">                continue;</span><br><span class="line">            int resNum = 0 - nums[i] - nums[j];</span><br><span class="line">            int idx = -1;</span><br><span class="line">            if(biSearch(resNum,idx,nums) &amp;&amp; idx != i &amp;&amp; idx != j)&#123;</span><br><span class="line">                vector&lt;int&gt; tmp;</span><br><span class="line">                tmp.push_back(nums[i]);</span><br><span class="line">                tmp.push_back(nums[j]);</span><br><span class="line">                tmp.push_back(nums[idx]);</span><br><span class="line">                sort(tmp.begin(), tmp.end());</span><br><span class="line">                resultSet.insert(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(auto s:resultSet)&#123;</span><br><span class="line">        result.push_back(s);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>313 &#x2F; 313 个通过测试用例<br>时间复杂度O(N^2 * logn)，空间复杂度O(1)</p>
</li>
</ol>
<p>还可以在最里层用一个unordered_set&#x2F;map来查找。可以把时间复杂度降到O(n^2)。但是每次建立unordered_set都需要去掉nums[i] 和 nums[j] 的值，如果有重复，在查重的时候又要增加时间复杂度。</p>
<ol start="3">
<li>双指针。先排序O(nlong)。第一层循环O(n)，第二个数和第三个数是此消彼长的关系。所以<strong>左指针</strong>向右移动时，<strong>右指针</strong>也需要忘左缩进（因为随着第二个数的增加，第三个数必然会减小）。这样时间复杂度就从两层循环O(n^2)减少至只需要一层循环O(n)。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">    </span><br><span class="line">    if (n &lt; 3 || nums[0] &gt; 0 || nums[n-1] &lt; 0)//全正或全负</span><br><span class="line">        return result;</span><br><span class="line">    if(nums[0] == 0 &amp;&amp; nums[n-1] == 0)&#123;//全是0</span><br><span class="line">        vector&lt;int&gt; tmp0 = &#123;0, 0, 0&#125;;</span><br><span class="line">        result.push_back(tmp0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 第一个数循环</span><br><span class="line">    for (int first = 0; first &lt; n; ++first) &#123;</span><br><span class="line">        // 去重</span><br><span class="line">        if (first &gt; 0 &amp;&amp; nums[first] == nums[first - 1]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 第三个数对应的指针初始指向数组的最右端</span><br><span class="line">        int third = n - 1;</span><br><span class="line">        int target = -nums[first];</span><br><span class="line">        // 第二层循环</span><br><span class="line">        for (int second = first + 1; second &lt; n; ++second) &#123;</span><br><span class="line">            if (second &gt; first + 1 &amp;&amp; nums[second] == nums[second - 1]) &#123;// 去重</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 需要保证第二个数指针在第三个数指针的左侧</span><br><span class="line">            while (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;</span><br><span class="line">                --third;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果指针重合，随着第二个数的增加，就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span><br><span class="line">            if (second == third) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[second] + nums[third] == target) &#123;</span><br><span class="line">                result.push_back(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="6月13日-70-爬楼梯（简单）"><a href="#6月13日-70-爬楼梯（简单）" class="headerlink" title="6月13日 70. 爬楼梯（简单）"></a>6月13日 <a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯（简单）</a></h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意</strong>：给定 n 是一个正整数。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>
<p>题解：<br>和6月9日的题一样，典型的dp问题。可以看我的<a href="https://suzhilong.github.io/2020/05/25/algorithm/">算法总结</a>里的dp专题。</p>
<p>一维dp问题。<code>dp[i] = dp[i-1] + dp[i-2]</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int climbStairs(int n) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(n + 1);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    dp[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= n;i++)&#123;</span><br><span class="line">        dp[i] = dp[i - 1] + dp[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)<br>空间复杂度O(n)</p>
<p>空间优化：实际上，只用到了前两个<code>dp[i-1]</code>，<code>dp[i-2]</code>。所以可以只用到3个int，把空间优化为O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int climbStairs(int n) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(3);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    dp[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= n;i++)&#123;</span><br><span class="line">        dp[2] = dp[1] + dp[0];</span><br><span class="line">        dp[0] = dp[1];</span><br><span class="line">        dp[1] = dp[2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第28场双周赛-6-13"><a href="#第28场双周赛-6-13" class="headerlink" title="第28场双周赛 6.13"></a>第28场双周赛 6.13</h1><h2 id="5420-商品折扣后的最终价格（简单）"><a href="#5420-商品折扣后的最终价格（简单）" class="headerlink" title="5420. 商品折扣后的最终价格（简单）"></a><a href="https://leetcode-cn.com/problems/final-prices-with-a-special-discount-in-a-shop/">5420. 商品折扣后的最终价格（简单）</a></h2><p>给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。<br>商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j &gt; i 且 prices[j] &lt;&#x3D; prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。<br>请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [8,4,6,2,3]</span><br><span class="line">输出：[4,2,4,2,3]</span><br><span class="line">解释：</span><br><span class="line">商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。</span><br><span class="line">商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。</span><br><span class="line">商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。</span><br><span class="line">商品 3 和 4 都没有折扣。</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; finalPrices(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    vector&lt;int&gt; res = prices;</span><br><span class="line">    for (int i = 0; i &lt; prices.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = i + 1; j &lt; prices.size();j++)&#123;</span><br><span class="line">            if(prices[j]&lt;=prices[i])&#123;</span><br><span class="line">                res[i] = prices[i] - prices[j];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5423-找两个和为目标值且不重叠的子数组（中等）"><a href="#5423-找两个和为目标值且不重叠的子数组（中等）" class="headerlink" title="5423. 找两个和为目标值且不重叠的子数组（中等）"></a><a href="https://leetcode-cn.com/problems/subrectangle-queries/">5423. 找两个和为目标值且不重叠的子数组（中等）</a></h2><p>给你一个整数数组 arr 和一个整数值 target 。<br>请你在 arr 中找 两个互不重叠的子数组 且它们的和都等于 target 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。<br>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [3,2,2,4,3], target = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：只有两个子数组和为 3 （[3] 和 [3]）。它们的长度和为 2 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [7,3,4,7], target = 7</span><br><span class="line">输出：2</span><br><span class="line">解释：尽管我们有 3 个互不重叠的子数组和为 7 （[7], [3,4] 和 [7]），但我们会选择第一个和第三个子数组，因为它们的长度和 2 是最小值。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [4,3,2,6,2,3,4], target = 6</span><br><span class="line">输出：-1</span><br><span class="line">解释：我们只有一个和为 6 的子数组。</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<ol>
<li>最容易想到的办法就是遍历数组得到所有sum为target的子数组，再从子数组列表中找出不重合的最小的两个子数组。找子数组处理重合的时候要很仔细。（代码略）  </li>
<li>双指针（滑动窗口）。左右指针从右到左移动，同时用一个数组<code>len</code>记录后面的最小子数组。其中，<code>len[i]</code>表示<code>i</code>后面（含i）的最小子数组长度。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int minSumOfLengths(vector&lt;int&gt;&amp; arr, int target) &#123;</span><br><span class="line">    int sum = 0, r = arr.size() - 1, ans = 200000; </span><br><span class="line">    vector&lt;int&gt; len(arr.size() + 1, 200000);//后面子数组的最小长度</span><br><span class="line">    for (int l = r; l &gt;= 0; --l) &#123; //l,r是滑动区间的左右坐标</span><br><span class="line">        sum += arr[l];</span><br><span class="line">        while (sum &gt; target)</span><br><span class="line">            sum -= arr[r--];</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            int cur = r - l + 1; //子数组长度</span><br><span class="line">            ans = min(ans, cur + len[r + 1]); //子数组长度 + r后面子数组的最小长度</span><br><span class="line">            len[l] = min(len[l + 1], r - l + 1); //更新l后面子数组的最小长度</span><br><span class="line">        &#125;else</span><br><span class="line">            len[l] = len[l + 1]; //更新子数组的最小长度</span><br><span class="line">    &#125;</span><br><span class="line">    return ans == 200000 ? -1 : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5421-安排邮筒（困难）"><a href="#5421-安排邮筒（困难）" class="headerlink" title="5421. 安排邮筒（困难）"></a><a href="https://leetcode-cn.com/problems/allocate-mailboxes/">5421. 安排邮筒（困难）</a></h2><p>给你一个房屋数组houses 和一个整数 k ，其中 houses[i] 是第 i 栋房子在一条街上的位置，现需要在这条街上安排 k 个邮筒。<br>请你返回每栋房子与离它最近的邮筒之间的距离的 最小 总和。<br>答案保证在 32 位有符号整数范围以内。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：houses = [1,4,8,10,20], k = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：将邮筒分别安放在位置 3， 9 和 20 处。</span><br><span class="line">每个房子到最近邮筒的距离和为 |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：houses = [2,3,5,12,18], k = 2</span><br><span class="line">输出：9</span><br><span class="line">解释：将邮筒分别安放在位置 3 和 14 处。</span><br><span class="line">每个房子到最近邮筒距离和为 |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：houses = [7,4,6,1], k = 1</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：houses = [3,6,14,10], k = 4</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n == houses.length</span><br><span class="line">1 &lt;= n &lt;= 100</span><br><span class="line">1 &lt;= houses[i] &lt;= 10^4</span><br><span class="line">1 &lt;= k &lt;= n</span><br><span class="line">数组 houses 中的整数互不相同。</span><br></pre></td></tr></table></figure>

<h1 id="第193场周赛-6-14"><a href="#第193场周赛-6-14" class="headerlink" title="第193场周赛 6.14"></a>第193场周赛 6.14</h1><h2 id="5436-一维数组的动态和（简单）"><a href="#5436-一维数组的动态和（简单）" class="headerlink" title="5436. 一维数组的动态和（简单）"></a><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/">5436. 一维数组的动态和（简单）</a></h2><p>题目难度Easy<br>给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] &#x3D; sum(nums[0]…nums[i]) 。</p>
<p>请返回 nums 的动态和。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3,4]<br>输出：[1,3,6,10]<br>解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。<br>示例 2：</p>
<p>输入：nums &#x3D; [1,1,1,1,1]<br>输出：[1,2,3,4,5]<br>解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。<br>示例 3：</p>
<p>输入：nums &#x3D; [3,1,2,10,1]<br>输出：[3,4,6,16,17]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;int&gt; res(nums.size(),0);</span><br><span class="line">    res[0] = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">        res[i] = res[i - 1] + nums[i];</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5437-不同整数的最少数目（Medium）"><a href="#5437-不同整数的最少数目（Medium）" class="headerlink" title="5437. 不同整数的最少数目（Medium）"></a><a href="https://leetcode-cn.com/problems/least-number-of-unique-integers-after-k-removals/">5437. 不同整数的最少数目（Medium）</a></h2><p>给你一个整数数组 arr 和一个整数 k 。现需要从数组中恰好移除 k 个元素，请找出移除后数组中不同整数的最少数目。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [5,5,4], k = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：移除 1 个 4 ，数组中只剩下 5 一种整数。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [4,3,1,1,3,3,2], k = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：先移除 4、2 ，然后再移除两个 1 中的任意 1 个或者三个 3 中的任意 1 个，最后剩下 1 和 3 两种整数。</span><br></pre></td></tr></table></figure>
<p>题解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool cmpByValue(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123;//注意！这个函数要在类外面定义</span><br><span class="line">    return a[1] &gt; b[1];//value降序</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findLeastNumOfUniqueInts(vector&lt;int&gt;&amp; arr, int k) &#123;</span><br><span class="line">    map&lt;int, int&gt; numMap;</span><br><span class="line">    for(int n:arr)&#123;</span><br><span class="line">        if(numMap.count(n) == 0)</span><br><span class="line">            numMap.insert(pair&lt;int, int&gt;(n, 1));</span><br><span class="line">        else</span><br><span class="line">            numMap[n]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; numMapV;</span><br><span class="line">    for (auto m : numMap)</span><br><span class="line">        numMapV.push_back(&#123;m.first, m.second&#125;);</span><br><span class="line"></span><br><span class="line">    sort(numMapV.begin(), numMapV.end(), cmpByValue);</span><br><span class="line"></span><br><span class="line">    while (k &gt; 0 &amp;&amp; numMap.size() &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; minNum = numMapV.back();</span><br><span class="line">        if (minNum[1] &gt; k)</span><br><span class="line">            return numMap.size();</span><br><span class="line">        else if(minNum[1] == k)</span><br><span class="line">            return numMap.size() - 1;</span><br><span class="line">        else&#123;</span><br><span class="line">            k = k - minNum[1];</span><br><span class="line">            numMap.erase(minNum[0]);</span><br><span class="line">            numMapV.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return numMap.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5438-制作-m-束花所需的最少天数（Medium）"><a href="#5438-制作-m-束花所需的最少天数（Medium）" class="headerlink" title="5438. 制作 m 束花所需的最少天数（Medium）"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/">5438. 制作 m 束花所需的最少天数（Medium）</a></h2><p>给你一个整数数组 bloomDay，以及两个整数 m 和 k 。<br>现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花。<br>花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。<br>请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：bloomDay = [1,10,3,10,2], m = 3, k = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。</span><br><span class="line">现在需要制作 3 束花，每束只需要 1 朵。</span><br><span class="line">1 天后：[x, _, _, _, _]   // 只能制作 1 束花</span><br><span class="line">2 天后：[x, _, _, _, x]   // 只能制作 2 束花</span><br><span class="line">3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：bloomDay = [1,10,3,10,2], m = 3, k = 2</span><br><span class="line">输出：-1</span><br><span class="line">解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3</span><br><span class="line">输出：12</span><br><span class="line">解释：要制作 2 束花，每束需要 3 朵。</span><br><span class="line">花园在 7 天后和 12 天后的情况如下：</span><br><span class="line">7 天后：[x, x, x, x, _, x, x]</span><br><span class="line">可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。</span><br><span class="line">12 天后：[x, x, x, x, x, x, x]</span><br><span class="line">显然，我们可以用不同的方式制作两束花。</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：bloomDay = [1000000000,1000000000], m = 1, k = 1</span><br><span class="line">输出：1000000000</span><br><span class="line">解释：需要等 1000000000 天才能采到花来制作花束</span><br></pre></td></tr></table></figure>
<p>示例 5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>
<p>题解：<br>（待补充）</p>
<h2 id="5188-树节点的第-K-个祖先（困难）"><a href="#5188-树节点的第-K-个祖先（困难）" class="headerlink" title="5188. 树节点的第 K 个祖先（困难）"></a><a href="https://leetcode-cn.com/problems/kth-ancestor-of-a-tree-node/">5188. 树节点的第 K 个祖先（困难）</a></h2><p>给你一棵树，树上有 n 个节点，按从 0 到 n-1 编号。树以父节点数组的形式给出，其中 parent[i] 是节点 i 的父节点。树的根节点是编号为 0 的节点。<br>请你设计并实现 getKthAncestor(int node, int k) 函数，函数返回节点 node 的第 k 个祖先节点。如果不存在这样的祖先节点，返回 -1 。<br>树节点的第 k 个祖先节点是从该节点到根节点路径上的第 k 个节点。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;TreeAncestor&quot;,&quot;getKthAncestor&quot;,&quot;getKthAncestor&quot;,&quot;getKthAncestor&quot;]</span><br><span class="line">[[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,1,0,-1]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);</span><br><span class="line"></span><br><span class="line">treeAncestor.getKthAncestor(3, 1);  // 返回 1 ，它是 3 的父节点</span><br><span class="line">treeAncestor.getKthAncestor(5, 2);  // 返回 0 ，它是 5 的祖父节点</span><br><span class="line">treeAncestor.getKthAncestor(6, 3);  // 返回 -1 因为不存在满足要求的祖先节点</span><br></pre></td></tr></table></figure>
<p>题解：<br>（待补充）</p>
<h1 id="6月14日-1300-转变数组后最接近目标值的数组和（中等）"><a href="#6月14日-1300-转变数组后最接近目标值的数组和（中等）" class="headerlink" title="6月14日 1300. 转变数组后最接近目标值的数组和（中等）"></a>6月14日 <a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/">1300. 转变数组后最接近目标值的数组和（中等）</a></h1><p>给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。<br>如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。<br>请注意，答案不一定是 arr 中的数字。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [4,9,3], target = 10</span><br><span class="line">输出：3</span><br><span class="line">解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [2,3,5], target = 10</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [60864,25176,27249,21296,20204], target = 56803</span><br><span class="line">输出：11361</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 &lt;= arr.length &lt;= 10^4</span><br><span class="line">1 &lt;= arr[i], target &lt;= 10^5</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>其实就是从一个范围中找到一个数。这个范围的下界是0，因为<code>arr[i]</code>&gt;&#x3D;1，所以sum肯定是&gt;&#x3D;1的。上界是<code>arr</code>中的最大值<code>maxNum</code>，因为当<code>value &gt; maxNum</code>时，<code>arr</code>中的元素不会变，得到的sum是一样的。所以就是从<code>[0, maxNum]</code>中找到value。从排序的数组中查找，用<strong>二分查找</strong>来减少时间复杂度。初始条件 <code>l=0, r=maxNum, mid=(l+r)/2</code>， 判定条件是：当<code>sum(mid)-target &gt; 0</code>（value&#x3D;mid）时，值偏大，<code>r = mid - 1</code>；当<code>sum(mid)-target &lt; 0</code>时，值偏小，<code>l = mid + 1</code>；当<code>sum(mid)-target == 0</code>时mid为所寻找的值。循环条件为<code>l&lt;=r &amp;&amp; sumArr != target</code>。循环中需要用一个minAbs来保存最接近的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int getSum(vector&lt;int&gt; arr, int value)&#123;</span><br><span class="line">    int sumArr = 0;</span><br><span class="line">    for (int i = 0; i &lt; arr.size();i++)&#123;</span><br><span class="line">        if(arr[i]&lt;=value)</span><br><span class="line">            sumArr += arr[i];</span><br><span class="line">        else</span><br><span class="line">            sumArr += value;</span><br><span class="line">    &#125;</span><br><span class="line">    return sumArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findBestValue(vector&lt;int&gt;&amp; arr, int target) &#123;</span><br><span class="line">    int maxNum = 0, sumArr = 0;</span><br><span class="line">    for (int a : arr)&#123;</span><br><span class="line">        sumArr += a;</span><br><span class="line">        maxNum = max(maxNum, a);</span><br><span class="line">    &#125;</span><br><span class="line">    if(sumArr&lt;=target)</span><br><span class="line">        return maxNum;</span><br><span class="line"></span><br><span class="line">    int l = 0, r = maxNum, mid;</span><br><span class="line">    int minAbs = sumArr - target &gt; 0 ? sumArr - target : target - sumArr;</span><br><span class="line">    int value = maxNum;</span><br><span class="line">    int diff, abs;</span><br><span class="line">    while (l &lt;= r &amp;&amp; sumArr != target)&#123;</span><br><span class="line">        mid = (l + r) / 2;</span><br><span class="line">        sumArr = getSum(arr, mid);//看value==mid后的和</span><br><span class="line">        diff = sumArr - target;</span><br><span class="line">        if(diff==0)&#123;//找到其中一个</span><br><span class="line">            value = min(value, mid);</span><br><span class="line">        &#125;else if(diff&gt;0)&#123;</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;//diff&lt;0</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        abs = diff &gt; 0 ? diff : -diff;</span><br><span class="line">        if(abs&lt;minAbs || (abs==minAbs &amp;&amp; mid&lt;value))&#123;</span><br><span class="line">            value = mid;</span><br><span class="line">            minAbs = abs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(logc*n)，c为最大值maxNum，n为数组长度。<br>空间复杂度：O(1)</p>
</li>
<li><p>先排序，再从头遍历，当<code>arr[i] &gt; (target-preSum[i]) / (n-i)</code>时，就是不能再增大了，返回<strong>剩余的平均值</strong>。<code>preSum[i]</code>是 <code>arr[i]</code> 之前的所有数的和。注意小数部分的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int findBestValue(vector&lt;int&gt;&amp; arr, int target)&#123;</span><br><span class="line">    int maxNum = 0, sumArr = 0;</span><br><span class="line">    for (int a : arr)&#123;</span><br><span class="line">        sumArr += a;</span><br><span class="line">        maxNum = max(maxNum, a);</span><br><span class="line">    &#125;</span><br><span class="line">    if(sumArr&lt;=target)</span><br><span class="line">        return maxNum;</span><br><span class="line"></span><br><span class="line">    sort(arr.begin(), arr.end());</span><br><span class="line">    </span><br><span class="line">    int preSum = 0, n = arr.size();</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int x = (target - preSum) / (n - i);</span><br><span class="line">        if (x &lt; arr[i]) &#123;</span><br><span class="line">            double t = ((double)(target - preSum)) / (n - i);</span><br><span class="line">            if (t - x &gt; 0.5) &#123;</span><br><span class="line">                return x + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        preSum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return arr[n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：排序O(nlogn)，遍历O(n)，所以是O(nlogn)。<br>空间复杂度：O(1)</p>
</li>
</ol>
<h1 id="6月15日-14-最长公共前缀（简单）"><a href="#6月15日-14-最长公共前缀（简单）" class="headerlink" title="6月15日 14. 最长公共前缀（简单）"></a>6月15日 <a href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀（简单）</a></h1><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">所有输入只包含小写字母 a-z 。</span><br></pre></td></tr></table></figure>
<p>题解：<br>一位一位比较。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    bool stop = false;</span><br><span class="line">    for(int i = 0; !stop; i++)&#123;</span><br><span class="line">        char cur = strs[0][i];</span><br><span class="line">        for(string s:strs)&#123;</span><br><span class="line">            if(s.size()==i+1)//有一个str已经到最后一位了</span><br><span class="line">                stop = true;</span><br><span class="line">            if(s[i]==cur)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                return res;</span><br><span class="line">        &#125;</span><br><span class="line">        res += cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m*n)，m 是 strs 中最短字符串的长度，n是字符串列表的长度。<br>空间复杂度：O(1)</p>
<h1 id="6月16日-297-二叉树的序列化与反序列化（困难）"><a href="#6月16日-297-二叉树的序列化与反序列化（困难）" class="headerlink" title="6月16日 297. 二叉树的序列化与反序列化（困难）"></a>6月16日 <a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化（困难）</a></h1><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。<br>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>示例: <br><img src="https://i.loli.net/2020/06/16/DwJHZvu7SbTaBkC.png" alt="示例"></p>
<p><strong>提示</strong>: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p><strong>说明</strong>: 不要使用类的成员 &#x2F; 全局 &#x2F; 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p>
<p>树的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>按照示例<strong>层序遍历</strong>，即<strong>BFS</strong>。可以使用队列来序列化，也可以使用递归。  </p>
</li>
<li><p><strong>先序遍历</strong>，即<strong>DFS</strong>。使用栈来系列化，也可以使用递归。</p>
</li>
</ol>
<h1 id="6月17日-1014-最佳观光组合（中等）"><a href="#6月17日-1014-最佳观光组合（中等）" class="headerlink" title="6月17日 1014. 最佳观光组合（中等）"></a>6月17日 <a href="https://leetcode-cn.com/problems/best-sightseeing-pair/">1014. 最佳观光组合（中等）</a></h1><p>给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。<br>一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。<br>返回一对观光景点能取得的最高分。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[8,1,5,2,6]</span><br><span class="line">输出：11</span><br><span class="line">解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>暴力（超时）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">    int maxScore = 0;</span><br><span class="line">    for (int i = 0; i &lt; A.size();i++)&#123;</span><br><span class="line">        for (int j = i + 1; j &lt; A.size();j++)</span><br><span class="line">            maxScore = max(maxScore, A[i] + A[j] + i - j);</span><br><span class="line">    &#125;</span><br><span class="line">    return maxScore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p>
</li>
<li><p>把<code>A[i]+A[j]+i-j</code>分解为两部分：<code>A[i]+i</code> 和 <code>A[j]-j</code>。<code>dpPre[j] = max(dpPre[j-1],A[j-1]+j-1)</code>，表示索引<code>j</code>之前<code>A[i]+i</code>的最大值；<br><code>dp[i] = max(dp[i-1],dpPre[i-1]+A[i]-i)</code>。但是这需要O(n)的空间复杂度保存之前的最大值。因为dp只用到了之前的一个值，所以可以优化为只用两个 int 来保存前面的状态，遍历时同时更新<code>dpPre</code>和<code>dp</code>。<br>用一个<code>preMax</code>保存<code>j</code>前面<code>A[i]+i</code>的最大值，<code>maxScore</code>保存答案。同时更新两个量，一遍遍历即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">    int maxScore = 0, preMax = A[0] + 0;</span><br><span class="line">    for (int j = 1; j &lt; A.size();j++)&#123;</span><br><span class="line">        maxScore = max(maxScore, preMax + A[j] - j);//更新dp[j]</span><br><span class="line">        preMax = max(preMax, A[j] + j);//更新下一次j的dpPre[j-1]</span><br><span class="line">    &#125;</span><br><span class="line">    return maxScore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
</li>
</ol>
<h1 id="6月18日-1028-从先序遍历还原二叉树（困难）"><a href="#6月18日-1028-从先序遍历还原二叉树（困难）" class="headerlink" title="6月18日 1028. 从先序遍历还原二叉树（困难）"></a>6月18日 <a href="https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/">1028. 从先序遍历还原二叉树（困难）</a></h1><p>我们从二叉树的根节点 root 开始进行深度优先搜索。<br>在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。<br>如果节点只有一个子节点，那么保证该子节点为左子节点。<br>给出遍历输出 S，还原树并返回其根节点 root。</p>
<p>示例1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;1-2--3--4-5--6--7&quot;</span><br><span class="line">输出：[1,2,5,3,4,6,7]</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;1-2--3---4-5--6---7&quot;</span><br><span class="line">输出：[1,2,5,3,null,6,null,4,null,7]</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;1-401--349---90--88&quot;</span><br><span class="line">输出：[1,401,null,349,88,90]</span><br></pre></td></tr></table></figure>
<p>题解：<br>当前节点为T，上一个节点为S，只有两种情况：</p>
<ul>
<li>T 是 S 的左子节点；</li>
<li>T 是根节点到 S 这一条路径上（不包括 S，因为题目中规定了如果节点只有一个子节点，那么保证该子节点为左子节点）某一个节点的右子节点。</li>
</ul>
<p>所以，我们用一个栈保存<strong>根节点</strong>到当前节点的<strong>上一个节点</strong>的路径：</p>
<ol>
<li><strong>当前节点</strong>的深度刚好比<strong>栈的高度</strong>大1：<strong>当前节点</strong>正好是<strong>栈顶节点</strong>的<strong>左子节点</strong>；<em>ps. 深度是从0开始，所以当深度的值和栈高度相等时，就是深度刚好比栈的高度大1</em></li>
<li><strong>当前节点</strong>的深度小于等于<strong>栈的高度</strong>：<ul>
<li><strong>当前节点</strong>的深度刚和<strong>栈的高度</strong>相等：<strong>当前节点</strong>是<strong>栈顶节点右兄弟节点</strong>即<strong>栈顶节点父节点的右子节点</strong>；</li>
<li><strong>当前节点</strong>的深度小于<strong>栈的高度</strong>：<strong>当前节点</strong>是<strong>根节点</strong>到<strong>栈顶节点</strong>路径上某一个节点的<strong>右子节点</strong>。一直弹出栈顶节点直到满足情况<code>1</code>。</li>
<li>*ps. <strong>当前节点</strong>的深度刚和<strong>栈的高度</strong>相等 即 <code>level=path.size()-1</code>，也是需要弹出栈顶节点一次*<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeNode* recoverFromPreorder(string S) &#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; path;</span><br><span class="line">    int pos = 0;</span><br><span class="line">    while(pos&lt;S.size())&#123;</span><br><span class="line">        int level = 0;</span><br><span class="line">        while(S[pos]==&#x27;-&#x27;)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int value = 0;</span><br><span class="line">        while (pos &lt; S.size() &amp;&amp; isdigit(S[pos]))&#123;//取当前节点的值</span><br><span class="line">            value = value * 10 + (S[pos] - &#x27;0&#x27;);</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *node = new TreeNode(value);</span><br><span class="line">        if(level==path.size())&#123;//第1种情况</span><br><span class="line">            if(!path.empty())</span><br><span class="line">                path.top()-&gt;left = node;</span><br><span class="line">        &#125;else&#123;//第2种情况</span><br><span class="line">            while(level!=path.size())</span><br><span class="line">                path.pop();</span><br><span class="line">            path.top()-&gt;right = node;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    while(path.size()&gt;1)</span><br><span class="line">        path.pop();</span><br><span class="line">    return path.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n)。n为S的长度<br>空间复杂度：O(h)。h为树的高度</li>
</ul>
</li>
</ol>
<h1 id="6月19日-125-验证回文串（简单）"><a href="#6月19日-125-验证回文串（简单）" class="headerlink" title="6月19日 125. 验证回文串（简单）"></a>6月19日 <a href="https://leetcode-cn.com/problems/valid-palindrome/">125. 验证回文串（简单）</a></h1><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p><strong>说明</strong>：本题中，我们将空字符串定义为有效的回文串。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>题解：<br>用一前一后双指针依次往中间遍历，直到指针碰见。可以在开始时用<code>transform()</code>先把字符串全部转换为小写字母，也可以在比较时使用<code>toupper()/tolower()</code>转单个字母。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isPalindrome(string s) &#123;</span><br><span class="line">    // transform(s.begin(), s.end(), s.begin(), ::tolower);</span><br><span class="line">    if (s.size() == 0)</span><br><span class="line">        return true;</span><br><span class="line">    int idxL = 0, idxR = s.size() - 1;</span><br><span class="line">    while(idxL&lt;idxR)&#123;</span><br><span class="line">        while(!isalnum(s[idxL]) &amp;&amp; idxL&lt;idxR)</span><br><span class="line">            idxL++; </span><br><span class="line">        while(!isalnum(s[idxR]) &amp;&amp; idxL&lt;idxR)</span><br><span class="line">            idxR--;</span><br><span class="line">        if(tolower(s[idxL]) != tolower(s[idxR]))</span><br><span class="line">            return false;</span><br><span class="line">        else&#123;</span><br><span class="line">            idxL++;</span><br><span class="line">            idxR--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)。n为字符串s的长度<br>空间复杂度：O(1)</p>
<h1 id="6月20日-10-正则表达式匹配（困难）"><a href="#6月20日-10-正则表达式匹配（困难）" class="headerlink" title="6月20日 10. 正则表达式匹配（困难）"></a>6月20日 <a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配（困难）</a></h1><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;.&#x27; 匹配任意单个字符</span><br><span class="line">&#x27;*&#x27; 匹配零个或多个前面的那一个元素</span><br><span class="line">所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s 可能为空，且只包含从 a-z 的小写字母。</span><br><span class="line">p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</span><br></pre></td></tr></table></figure>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span><br></pre></td></tr></table></figure>
<p>示例 4:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#x27;*&#x27; 表示零个或多个，这里 &#x27;c&#x27; 为 0 个, &#x27;a&#x27; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure>
<p>示例 5:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>递归（超时）。需要用到有限状态机的思想。</p>
<ul>
<li>当p索引的下一个字符是’*’时：<ul>
<li>当前字符匹配：当作没有’*‘ || 转移状态，看s的下一位 ||’*‘匹配0个</li>
<li>当前字符不匹配：’*‘匹配0个，p索引向后移动两位</li>
</ul>
</li>
<li>当p索引的下一个字符不是’*‘时。如果当前字符匹配，则都向后移动一位。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool matchCore(string s, string p, int idxS, int idxP)&#123;</span><br><span class="line">    if(idxS==s.size() &amp;&amp; idxP==p.size())</span><br><span class="line">        return true;</span><br><span class="line">    if(idxS&lt;s.size() &amp;&amp; idxP==p.size())</span><br><span class="line">        return false;</span><br><span class="line">    </span><br><span class="line">    if(p[idxP+1]==&#x27;*&#x27;)&#123;//p索引的下一个字符是&#x27;*&#x27;</span><br><span class="line">        if(p[idxP]==s[idxS] || (p[idxP]==&#x27;.&#x27; &amp;&amp; idxS&lt;s.size())) //当前字符匹配</span><br><span class="line">            return matchCore(s, p, idxS + 1, idxP + 2)//当作没有*</span><br><span class="line">                || matchCore(s, p, idxS + 1, idxP) //</span><br><span class="line">                || matchCore(s, p, idxS, idxP + 2);//*匹配0个</span><br><span class="line">        else //当前字符不匹配</span><br><span class="line">            return matchCore(s, p, idxS, idxP + 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(s[idxS]==p[idxP] || (p[idxP]==&#x27;.&#x27; &amp;&amp; idxS&lt;s.size())) //p索引的下一个字符不是&#x27;*&#x27;</span><br><span class="line">        return matchCore(s, p, idxS + 1, idxP + 1);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isMatch(string s, string p)</span><br><span class="line">&#123;</span><br><span class="line">    return matchCore(s, p, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>dp。用 <code>dp[i][j]</code> 表示 <code>s</code> 的前 <code>i</code> 个字符与 <code>p</code> 中的前 <code>j</code> 个字符是否能够匹配。</p>
<ul>
<li>p[j]不是’*‘<ul>
<li><code>dp[i][j] = dp[i-1][j-1]</code> (s[i] &#x3D;&#x3D; p[j] 含p[j]&#x3D;&#x3D;’.’的情况)</li>
<li>false (s[i] !&#x3D; p[j])</li>
</ul>
</li>
<li>p[j]是’*‘<ul>
<li><code>dp[i][j] = dp[i-1][j](匹配s的该位字符) || dp[i][j-2](字母+星号不匹配任何字符)</code> (s[i] &#x3D;&#x3D; p[j-1] s[i] &#x3D;&#x3D; p[j] 含p[j-1]&#x3D;&#x3D;’.’的情况)</li>
<li><code>dp[i][j] = dp[i][j-2]</code> (s[i]!&#x3D;p[j-1])</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><em>ps. 需要特别注意字符串的索引是从0开始的，和dp的索引相差1</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isMatch(string s, string p)</span><br><span class="line">&#123;</span><br><span class="line">    int m = s.size(), n = p.size();</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; dp(m+1,vector&lt;bool&gt;(n+1));</span><br><span class="line"></span><br><span class="line">    //初始化很重要！！！</span><br><span class="line">    dp[0][0] = true;</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        if (p[i-1] == &#x27;*&#x27; &amp;&amp; dp[0][i - 2])&#123;</span><br><span class="line">            // p[0]不可能是&#x27;\*&#x27;，因为&#x27;\*&#x27;必须依附前面的字符。</span><br><span class="line">            // p = &quot;a*c*b*a&quot;这种情况，dp[0][2/4/6]都为true</span><br><span class="line">            dp[0][i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(p[j-1]!=&#x27;*&#x27;)&#123;</span><br><span class="line">                if(s[i-1]==p[j-1] || p[j-1]==&#x27;.&#x27;)</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">                else</span><br><span class="line">                    dp[i][j] = false;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(s[i-1]==p[j-2] || p[j-2]==&#x27;.&#x27;)&#123;</span><br><span class="line">                    dp[i][j] = (dp[i - 1][j] || dp[i][j - 2]);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - 2];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6月21日-124-二叉树中的最大路径和（困难）"><a href="#6月21日-124-二叉树中的最大路径和（困难）" class="headerlink" title="6月21日 124. 二叉树中的最大路径和（困难）"></a>6月21日 <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和（困难）</a></h1><p>给定一个非空二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [-10,9,20,null,null,15,7]</span><br><span class="line">       -10</span><br><span class="line">       / \</span><br><span class="line">      9  20</span><br><span class="line">        /  \</span><br><span class="line">       15   7</span><br><span class="line"></span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure>
<p>题解：<br>递归。<br>一个节点处于最大路径上时，可能有两种情况：</p>
<ul>
<li>他是最上层节点，不再父节点走。这时候需要求<code>lANDr</code>：当前节点和左右路径的最大值</li>
<li>他不是最上层，有父节点。这时候需要求<code>lORr</code>：当前节点往左子树<strong>还是</strong>子树和更大</li>
</ul>
<p>递归函数返回的是左&#x2F;右子树的最大路径和。同时更新一个保存全局最大路径和的<strong>引用</strong><code>maxSum</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int getMaxPathSum(TreeNode* root, int &amp;maxSum)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return 0;</span><br><span class="line">    int lPath = getMaxPathSum(root-&gt;left, maxSum);</span><br><span class="line">	int rPath = getMaxPathSum(root-&gt;right, maxSum);</span><br><span class="line">	int lANDr = root-&gt;val + max(0, lPath) + max(0, rPath);</span><br><span class="line">	int lORr = root-&gt;val + max(0, max(lPath, rPath));</span><br><span class="line">	maxSum = max(maxSum, max(lANDr, lORr));</span><br><span class="line">	return lORr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int maxPathSum(TreeNode* root) &#123;</span><br><span class="line">    int maxSum = INT_MIN;</span><br><span class="line">    getMaxPathSum(root, maxSum);</span><br><span class="line">    return maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，其中 n 是二叉树中的节点个数。对每个节点访问不超过 2 次。<br>空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用层数，最大层数等于二叉树的高度，最坏情况下，二叉树的高度等于二叉树中的节点个数。</p>
<h1 id="第194场周赛-6-21"><a href="#第194场周赛-6-21" class="headerlink" title="第194场周赛 6.21"></a>第194场周赛 6.21</h1><h2 id="5440-数组异或操作"><a href="#5440-数组异或操作" class="headerlink" title="5440. 数组异或操作"></a>5440. 数组异或操作</h2><p>题目难度Easy<br>给你两个整数，n 和 start 。</p>
<p>数组 nums 定义为：nums[i] &#x3D; start + 2*i（下标从 0 开始）且 n &#x3D;&#x3D; nums.length 。</p>
<p>请返回 nums 中所有元素按位异或（XOR）后得到的结果。</p>
<p>示例 1：</p>
<p>输入：n &#x3D; 5, start &#x3D; 0<br>输出：8<br>解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) &#x3D; 8 。<br>     “^” 为按位异或 XOR 运算符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int xorOperation(int n, int start) &#123;</span><br><span class="line">    vector&lt;int&gt; nums(n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">        nums[i] = start + 2 * i;</span><br><span class="line"></span><br><span class="line">    int res = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; n;i++)</span><br><span class="line">        res ^= nums[i];</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5441-保证文件名唯一（中等）"><a href="#5441-保证文件名唯一（中等）" class="headerlink" title="5441. 保证文件名唯一（中等）"></a>5441. 保证文件名唯一（中等）</h2><p>给你一个长度为 n 的字符串数组 names 。你将会在文件系统中创建 n 个文件夹：在第 i 分钟，新建名为 names[i] 的文件夹。</p>
<p>由于两个文件 不能 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 (k) 的形式为新文件夹的文件名添加后缀，其中 k 是能保证文件名唯一的 最小正整数 。</p>
<p>返回长度为 n 的字符串数组，其中 ans[i] 是创建第 i 个文件夹时系统分配给该文件夹的实际名称。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：names = [&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]</span><br><span class="line">输出：[&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]</span><br><span class="line">解释：文件系统将会这样创建文件名：</span><br><span class="line">&quot;pes&quot; --&gt; 之前未分配，仍为 &quot;pes&quot;</span><br><span class="line">&quot;fifa&quot; --&gt; 之前未分配，仍为 &quot;fifa&quot;</span><br><span class="line">&quot;gta&quot; --&gt; 之前未分配，仍为 &quot;gta&quot;</span><br><span class="line">&quot;pes(2019)&quot; --&gt; 之前未分配，仍为 &quot;pes(2019)&quot;</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：names = [&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece&quot;]</span><br><span class="line">输出：[&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece(4)&quot;]</span><br><span class="line">解释：当创建最后一个文件夹时，最小的正有效 k 为 4 ，文件名变为 &quot;onepiece(4)&quot;。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：names = [&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido&quot;,&quot;kaido(1)&quot;]</span><br><span class="line">输出：[&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido(2)&quot;,&quot;kaido(1)(1)&quot;]</span><br><span class="line">解释：注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; getFolderNames(vector&lt;string&gt;&amp; names) &#123;</span><br><span class="line">    unordered_map&lt;string, int&gt; fileMap;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    for (int i = 0; i &lt; names.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int tmp = fileMap[names[i]]; //如果该key不存在，会自动创建一个&#123;key,0&#125;的插入map，并返回0</span><br><span class="line">        if (tmp == 0)</span><br><span class="line">        &#123;//文件名不存在</span><br><span class="line">            res.push_back(names[i]);</span><br><span class="line">            fileMap[names[i]] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;//文件名已存在</span><br><span class="line">            while (fileMap.count(names[i]+&quot;(&quot;+to_string(tmp)+&quot;)&quot;))</span><br><span class="line">                tmp++;</span><br><span class="line">            res.push_back(names[i]+&quot;(&quot;+to_string(tmp)+&quot;)&quot;);</span><br><span class="line">            fileMap[names[i]] = tmp;</span><br><span class="line">            fileMap[names[i]+&quot;(&quot;+to_string(tmp)+&quot;)&quot;] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5442-避免洪水泛滥（中等）"><a href="#5442-避免洪水泛滥（中等）" class="headerlink" title="5442. 避免洪水泛滥（中等）"></a>5442. 避免洪水泛滥（中等）</h2><p>你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 n 个湖泊下雨的时候，如果第 n 个湖泊是空的，那么它就会装满水，否则这个湖泊会发生洪水。你的目标是避免任意一个湖泊发生洪水。</p>
<p>给你一个整数数组 rains ，其中：<br>rains[i] &gt; 0 表示第 i 天时，第rains[i]个湖泊会下雨。<br>rains[i] &#x3D;&#x3D; 0 表示第 i 天没有湖泊会下雨，你可以选择一个湖泊并抽干这个湖泊的水。</p>
<p>请返回一个数组 ans ，满足：<br>ans.length &#x3D;&#x3D; rains.length<br>如果 rains[i] &gt; 0 ，那么ans[i] &#x3D;&#x3D; -1 。<br>如果 rains[i] &#x3D;&#x3D; 0 ，ans[i] 是你第 i 天选择抽干的湖泊。<br>如果有多种可行解，请返回它们中的任意一个 。如果没办法阻止洪水，请返回一个空的数组。</p>
<p>请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生（详情请看示例 4）。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：rains = [1,2,3,4]</span><br><span class="line">输出：[-1,-1,-1,-1]</span><br><span class="line">解释：第一天后，装满水的湖泊包括 [1]</span><br><span class="line">第二天后，装满水的湖泊包括 [1,2]</span><br><span class="line">第三天后，装满水的湖泊包括 [1,2,3]</span><br><span class="line">第四天后，装满水的湖泊包括 [1,2,3,4]</span><br><span class="line">没有哪一天你可以抽干任何湖泊的水，也没有湖泊会发生洪水。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：rains = [1,2,0,0,2,1]</span><br><span class="line">输出：[-1,-1,2,1,-1,-1]</span><br><span class="line">解释：第一天后，装满水的湖泊包括 [1]</span><br><span class="line">第二天后，装满水的湖泊包括 [1,2]</span><br><span class="line">第三天后，我们抽干湖泊 2 。所以剩下装满水的湖泊包括 [1]</span><br><span class="line">第四天后，我们抽干湖泊 1 。所以暂时没有装满水的湖泊了。</span><br><span class="line">第五天后，装满水的湖泊包括 [2]。</span><br><span class="line">第六天后，装满水的湖泊包括 [1,2]。</span><br><span class="line">可以看出，这个方案下不会有洪水发生。同时， [-1,-1,1,2,-1,-1] 也是另一个可行的没有洪水的方案。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：rains = [1,2,0,1,2]</span><br><span class="line">输出：[]</span><br><span class="line">解释：第二天后，装满水的湖泊包括 [1,2]。我们可以在第三天抽干一个湖泊的水。</span><br><span class="line">但第三天后，湖泊 1 和 2 都会再次下雨，所以不管我们第三天抽干哪个湖泊的水，另一个湖泊都会发生洪水。</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：rains = [69,0,0,0,69]</span><br><span class="line">输出：[-1,69,1,1,-1]</span><br><span class="line">解释：任何形如 [-1,69,x,y,-1], [-1,x,69,y,-1] 或者 [-1,x,y,69,-1] 都是可行的解，其中 1 &lt;= x,y &lt;= 10^9</span><br></pre></td></tr></table></figure>
<p>示例 5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：rains = [10,20,20]</span><br><span class="line">输出：[]</span><br><span class="line">解释：由于湖泊 20 会连续下 2 天的雨，所以没有没有办法阻止洪水。</span><br></pre></td></tr></table></figure>
<p>题解：<br><code>lastRainDay</code>保存了湖号(key)到目前的最后一天下雨的日期。<br>set <code>s</code> 保存了前面未下雨的日期。</p>
<ul>
<li><p>碰到rains[i]&#x3D;&#x3D;0后（没下雨），把未下雨的天数先存到<code>s</code>里，继续往后。</p>
</li>
<li><p>如果下雨</p>
<ul>
<li>湖<code>lakeNum</code>未满，就更新<code>lastRainDay[lakeNum]=i</code>和<code>res[i]=-1</code></li>
<li>湖<code>lakeNum</code>满了，就从未下雨的日期set <code>s</code> 中取出 湖<code>lakeNum</code> 最后下雨日期<code>lastRainDay[lakeNum]</code> 之后<strong>最近的未下雨的日期</strong>，在<code>lastRainDay[lakeNum]</code>当天把<code>lakeNum</code>抽干。</li>
</ul>
</li>
</ul>
<p>简单来说，就是在碰到水满之后，把最前面没下雨的一天用来抽该湖上次下的雨。（当然，抽水的日期要在下雨日期之后）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; avoidFlood(vector&lt;int&gt;&amp; rains) &#123;</span><br><span class="line">    set&lt;int&gt; s;</span><br><span class="line">    vector&lt;int&gt; res(rains.size(), 1);</span><br><span class="line">    unordered_map&lt;int, int&gt; lastRainDay;//key是第i天下雨的湖号码，val是i</span><br><span class="line">    for (int i = 0; i &lt; rains.size(); i++) &#123;</span><br><span class="line">        int lakeNum = rains[i];//第i天下雨的湖号</span><br><span class="line">        //第i天没下雨</span><br><span class="line">        if (lakeNum == 0) &#123;</span><br><span class="line">            s.insert(i);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //第i天下雨了</span><br><span class="line">        res[i] = -1;</span><br><span class="line">        if (lastRainDay.find(lakeNum) == lastRainDay.end()) &#123;//湖里没水</span><br><span class="line">            lastRainDay[lakeNum] = i;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //湖里有水</span><br><span class="line">        auto lastDay = lastRainDay[lakeNum];</span><br><span class="line">        auto it = s.upper_bound(lastDay);</span><br><span class="line">        if (it == s.end()) &#123;</span><br><span class="line">            return vector&lt;int&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res[*it] = lakeNum;</span><br><span class="line">        lastRainDay[lakeNum] = i;</span><br><span class="line">        s.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6月22日-面试题-16-18-模式匹配（中等）"><a href="#6月22日-面试题-16-18-模式匹配（中等）" class="headerlink" title="6月22日 面试题 16.18. 模式匹配（中等）"></a>6月22日 <a href="https://leetcode-cn.com/problems/pattern-matching-lcci/">面试题 16.18. 模式匹配（中等）</a></h1><p>你有两个字符串，即pattern和value。 pattern字符串由字母”a”和”b”组成，用于描述字符串中的模式。例如，字符串”catcatgocatgo”匹配模式”aabab”（其中”cat”是”a”，”go”是”b”），该字符串也匹配像”a”、”ab”和”b”这样的模式。但需注意”a”和”b”不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： pattern = &quot;abba&quot;, value = &quot;dogcatcatdog&quot;</span><br><span class="line">输出： true</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： pattern = &quot;abba&quot;, value = &quot;dogcatcatfish&quot;</span><br><span class="line">输出： false</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： pattern = &quot;aaaa&quot;, value = &quot;dogcatcatdog&quot;</span><br><span class="line">输出： false</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： pattern = &quot;abba&quot;, value = &quot;dogdogdogdog&quot;</span><br><span class="line">输出： true</span><br><span class="line">解释： &quot;a&quot;=&quot;dogdog&quot;,b=&quot;&quot;，反之也符合规则</span><br></pre></td></tr></table></figure>
<p>题解：<br>枚举模式a和b的长度<code>lA</code> 和 <code>lB</code>，在看该长度下的substr是否满足条件。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool patternMatching(string pattern, string value) &#123;</span><br><span class="line">    if(pattern==&quot;&quot; &amp;&amp; value!=&quot;&quot;)</span><br><span class="line">        return false;</span><br><span class="line">    if (pattern.size() == 1 || (pattern==&quot;&quot; &amp;&amp; value==&quot;&quot;))</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    int cntA = 0, cntB = 0;</span><br><span class="line">    for(char c:pattern)&#123;//统计pattern里种类的数量</span><br><span class="line">        if(c==&#x27;a&#x27;)</span><br><span class="line">            cntA++;</span><br><span class="line">        if(c==&#x27;b&#x27;)</span><br><span class="line">            cntB++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(cntA==0 || cntB==0)&#123;//只有1个模式</span><br><span class="line">        if(value.size()%pattern.size()!=0)</span><br><span class="line">            return false;</span><br><span class="line">        int n = pattern.size();</span><br><span class="line">        int nSub = value.size() / pattern.size();</span><br><span class="line">        for (int i = 1; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int idx = i * nSub;</span><br><span class="line">            for (int j = 0; j &lt; nSub;j++)&#123;</span><br><span class="line">                if(value[j]!=value[idx+j])</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123; //2个模式</span><br><span class="line">        if(value.size()==0)</span><br><span class="line">            return false;</span><br><span class="line">        if(cntA==1 || cntB==1)</span><br><span class="line">            return true;</span><br><span class="line">        //枚举每个模式的字符串长度</span><br><span class="line">        for (int lA = 0; lA &lt;= value.size() / cntA; lA++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int lB = 0; lB &lt;= value.size() / cntB;lB++)&#123;</span><br><span class="line">                if(lA*cntA + lB*cntB != value.size())</span><br><span class="line">                    continue;</span><br><span class="line">                </span><br><span class="line">                map&lt;char, string&gt; pMap;</span><br><span class="line">                int idxA = 0, idxB = 0;</span><br><span class="line">                int a = 0, b = 0;</span><br><span class="line">                while (pattern[a++] != &#x27;a&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    idxA += lB;</span><br><span class="line">                &#125;</span><br><span class="line">                while(pattern[b++]!=&#x27;b&#x27;)</span><br><span class="line">                    idxB += lA;</span><br><span class="line">                </span><br><span class="line">                pMap[&#x27;a&#x27;] = value.substr(idxA, lA);</span><br><span class="line">                pMap[&#x27;b&#x27;] = value.substr(idxB, lB);</span><br><span class="line">                </span><br><span class="line">                //按模式的长度lA和lB验证是否匹配</span><br><span class="line">                int pos = 0;</span><br><span class="line">                for (int i = 0; i &lt; pattern.size(); i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    char cur = pattern[i];</span><br><span class="line">                    int l = cur == &#x27;a&#x27; ? lA : lB;</span><br><span class="line">                    if (pMap[cur] == value.substr(pos,l))&#123;</span><br><span class="line">                        pos += l;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(pos==value.size())</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6月23日-67-二进制求和（简单）"><a href="#6月23日-67-二进制求和（简单）" class="headerlink" title="6月23日 67. 二进制求和（简单）"></a>6月23日 <a href="https://leetcode-cn.com/problems/add-binary/">67. 二进制求和（简单）</a></h1><p>给你两个二进制字符串，返回它们的和（用二进制表示）。<br>输入为 非空 字符串且只包含数字 1 和 0。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">输出: &quot;100&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>数位法。和做大数乘法一样，处理每一位和进位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string addBinary(string a, string b) &#123;</span><br><span class="line">    int carry = 0;</span><br><span class="line">    int i = a.size() - 1, j = b.size() - 1;</span><br><span class="line">    string endDigital = &quot;&quot;;</span><br><span class="line">    while (i &gt;= 0 &amp;&amp; j &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        string curDigit = &quot;&quot;;</span><br><span class="line">        if(carry == 0)&#123;</span><br><span class="line">            if(a[i]==&#x27;1&#x27; &amp;&amp; b[j]==&#x27;1&#x27;)&#123;</span><br><span class="line">                curDigit = &quot;0&quot;;</span><br><span class="line">                carry = 1;</span><br><span class="line">            &#125;else if((a[i]==&#x27;1&#x27; &amp;&amp; b[j]==&#x27;0&#x27;) || (a[i]==&#x27;0&#x27; &amp;&amp; b[j]==&#x27;1&#x27;))&#123;</span><br><span class="line">                curDigit = &#x27;1&#x27;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                curDigit = &#x27;0&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(a[i]==&#x27;1&#x27; &amp;&amp; b[j]==&#x27;1&#x27;)&#123;</span><br><span class="line">                curDigit = &quot;1&quot;;</span><br><span class="line">            &#125;else if((a[i]==&#x27;1&#x27; &amp;&amp; b[j]==&#x27;0&#x27;) || (a[i]==&#x27;0&#x27; &amp;&amp; b[j]==&#x27;1&#x27;))&#123;</span><br><span class="line">                curDigit = &#x27;0&#x27;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                curDigit = &#x27;1&#x27;;</span><br><span class="line">                carry = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        endDigital = curDigit + endDigital;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(i&gt;=0)&#123;</span><br><span class="line">        if(carry==1)&#123;</span><br><span class="line">            if(a[i]==&#x27;0&#x27;)&#123;</span><br><span class="line">                endDigital = &#x27;1&#x27; + endDigital;</span><br><span class="line">                carry = 0;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                endDigital = &#x27;0&#x27; + endDigital;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            endDigital = a[i] + endDigital;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    while(j&gt;=0)&#123;</span><br><span class="line">        if(carry==1)&#123;</span><br><span class="line">            if(b[j]==&#x27;0&#x27;)&#123;</span><br><span class="line">                endDigital = &#x27;1&#x27; + endDigital;</span><br><span class="line">                carry = 0;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                endDigital = &#x27;0&#x27; + endDigital;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            endDigital = b[j] + endDigital;</span><br><span class="line">        &#125;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    if(carry == 1)&#123;</span><br><span class="line">        endDigital = &quot;1&quot; + endDigital;</span><br><span class="line">    &#125;</span><br><span class="line">    return endDigital;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实可以在短的前面添0补齐，就会方便一些。而且也可以通过 <code>%2, /2</code> 来得到更简洁的代码（前提是允许使用加减乘除）。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string addBinary(string a, string b) &#123;  </span><br><span class="line">    string res;</span><br><span class="line">    reverse(a.begin(), a.end());</span><br><span class="line">    reverse(b.begin(), b.end());</span><br><span class="line"></span><br><span class="line">    int n = max(a.size(), b.size()), carry = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        carry += i &lt; a.size() ? (a[i] == &#x27;1&#x27;) : 0;</span><br><span class="line">        carry += i &lt; b.size() ? (b[i] == &#x27;1&#x27;) : 0;</span><br><span class="line">        res.push_back((carry % 2) ? &#x27;1&#x27; : &#x27;0&#x27;);</span><br><span class="line">        carry /= 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (carry) &#123;</span><br><span class="line">        res.push_back(&#x27;1&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(l)。l为最长的位数。<br>空间复杂度O(1)。</p>
</li>
<li><p>先转为10进制运算后再转回来。但是如果有很多位，就会导致溢出。<br>（代码略）</p>
</li>
</ol>
<h1 id="6月24日-16-最接近的三数之和（中等）"><a href="#6月24日-16-最接近的三数之和（中等）" class="headerlink" title="6月24日 16. 最接近的三数之和（中等）"></a>6月24日 <a href="https://leetcode-cn.com/problems/3sum-closest/">16. 最接近的三数之和（中等）</a></h1><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,2,1,-4], target = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</span><br></pre></td></tr></table></figure>

<p>题解：<br>排序+双指针。类似的题：<a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></p>
<p>暴力法的话时间复杂度是O(n^3)。我们需要想办法来降低时间复杂度：先枚举第一个数nums[i]，再剩下<code>nums</code>中找和最接近<code>target-nums[i]</code>。经过排序之后，可以用两数和与<code>target-nums[i]</code>的大小关系来决定两数和的变化趋势。</p>
<p>这样寻找后两个数是，只需遍历一遍，相当于把O(n^2)的时间降到了O(n)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    if(nums.size()==3)</span><br><span class="line">        return nums[0] + nums[1] + nums[2];</span><br><span class="line"></span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    int diff = INT_MAX;</span><br><span class="line">    for (int i = 0; i &lt; n-2;i++)&#123;</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) //防止重复元素</span><br><span class="line">            continue;</span><br><span class="line">        int find = target - nums[i];</span><br><span class="line">        int idxL = i + 1, idxR = n - 1;</span><br><span class="line">        while (idxL &lt; idxR)</span><br><span class="line">        &#123;</span><br><span class="line">            int sumLR = nums[idxL] + nums[idxR];</span><br><span class="line">            if(sumLR == find) //如果相等，直接返回target</span><br><span class="line">                return target;</span><br><span class="line">            diff = abs(diff) &lt; abs(sumLR - find) ? diff : (sumLR - find);//更新最小差值</span><br><span class="line">            if (sumLR &gt; find) idxR--;</span><br><span class="line">            else idxL++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return target + diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)。排序需要O(nlogn)，算法主体O(n^2)。<br>空间复杂度：如果nums可以修改，则只需要排序算法的空间复杂度。如果nums不能修改，则需要O(n)来存储nums。</p>
<h1 id="6月25日-139-单词拆分（中等）-https-leetcode-cn-com-problems-word-break"><a href="#6月25日-139-单词拆分（中等）-https-leetcode-cn-com-problems-word-break" class="headerlink" title="6月25日 [139. 单词拆分（中等）(https://leetcode-cn.com/problems/word-break/)"></a>6月25日 [139. 单词拆分（中等）(<a href="https://leetcode-cn.com/problems/word-break/">https://leetcode-cn.com/problems/word-break/</a>)</h1><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>存一个首字母map，用递归的方法查找。超时。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool wordBreakCore(string s, vector&lt;string&gt;&amp; wordDict, int idx, unordered_map&lt;char, vector&lt;string&gt; &gt; &amp;alphaMap)&#123;</span><br><span class="line">    if(idx==s.size())</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if(alphaMap.find(s[idx])==alphaMap.end())</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    bool find = false;</span><br><span class="line">    int initIdx = idx;</span><br><span class="line">    for (string str : alphaMap[s[idx]])</span><br><span class="line">    &#123;</span><br><span class="line">        idx = initIdx;</span><br><span class="line">        if (idx + str.size() &gt; s.size())</span><br><span class="line">            continue;</span><br><span class="line">        int nxtIdx = idx + str.size();</span><br><span class="line">        for (int i = 0; i &lt; str.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[i]!=s[idx])</span><br><span class="line">                break;</span><br><span class="line">            else</span><br><span class="line">                idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(idx==nxtIdx)</span><br><span class="line">            find = wordBreakCore(s, wordDict, idx, alphaMap);</span><br><span class="line">        if(find)</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return find;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)&#123;</span><br><span class="line">    unordered_map&lt;char, vector&lt;string&gt; &gt; alphaMap;</span><br><span class="line">    for (auto word : wordDict)</span><br><span class="line">        alphaMap[word[0]].push_back(word);</span><br><span class="line"></span><br><span class="line">    return wordBreakCore(s, wordDict, 0, alphaMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>dp。<br><code>dp[i]=dp[j] &amp;&amp; check(s[j..i−1])</code><br>其中 dp[i] 表示字符串 s 前 i 个字符组成的字符串 s[0..i-1] 是否能被空格拆分成若干个字典中出现的单词。check(s[j..i-1]) 表示子串 s[j..i-1] 是否出现在字典中。<br>可以记录<code>set</code>中单词的最大长度和最小长度，缩小<code>j</code>的遍历范围。但是不会减小时间复杂度  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)&#123;</span><br><span class="line">    unordered_set&lt;string&gt; wordSet;</span><br><span class="line">    int minLength = 0, maxLength = INT_MAX;</span><br><span class="line">    for (string word : wordDict)&#123;</span><br><span class="line">        wordSet.insert(word);</span><br><span class="line">        minLength = word.size() &gt; minLength ? minLength : word.size();</span><br><span class="line">        maxLength = word.size() &lt; maxLength ? maxLength : word.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;bool&gt; dp(s.size() + 1);</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    for (int i = 1; i &lt;= s.size();i++)&#123;</span><br><span class="line">        for (int j = max(0,i-maxLength); i-j&gt;=minLength;j++)&#123;</span><br><span class="line">            if(dp[j] &amp;&amp; wordSet.find(s.substr(j,i-j))!=wordSet.end())&#123;</span><br><span class="line">                dp[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n^2)。n为字符串s的长度。<br>空间复杂度：O(max{m,n})。m为<code>wordDict</code>的长度，n为s的长度。</li>
</ol>
<h1 id="6月26日-面试题-02-01-移除重复节点（简单）"><a href="#6月26日-面试题-02-01-移除重复节点（简单）" class="headerlink" title="6月26日 面试题 02.01. 移除重复节点（简单）"></a>6月26日 <a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/">面试题 02.01. 移除重复节点（简单）</a></h1><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<p>示例1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1, 2, 3, 3, 2, 1]</span><br><span class="line">输出：[1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1, 1, 1, 1, 2]</span><br><span class="line">输出：[1, 2]</span><br></pre></td></tr></table></figure>
<p>题解：<br>用一个哈希表(<code>unordered_set</code>)保存已有元素。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode* removeDuplicateNodes(ListNode* head) &#123;</span><br><span class="line">    if(head==nullptr || head-&gt;next==nullptr)</span><br><span class="line">        return head;</span><br><span class="line"></span><br><span class="line">    unordered_set&lt;int&gt; valSet;</span><br><span class="line">    ListNode *lastNode = head;</span><br><span class="line">    ListNode *cur = head-&gt;next;</span><br><span class="line">    valSet.insert(head-&gt;val);</span><br><span class="line">    while (cur != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if(valSet.find(cur-&gt;val) == valSet.end())&#123;//非重复节点</span><br><span class="line">            valSet.insert(cur-&gt;val);</span><br><span class="line">            lastNode-&gt;next = cur;</span><br><span class="line">            lastNode = lastNode-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;else&#123;//重复节点</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lastNode-&gt;next = cur;//nullptr</span><br><span class="line"></span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)  </p>
<p><em>ps. 在不允许用额外空间的情况下，可以用两重循环。时间O(n^2) ，空间o(1)。</em></p>
<h1 id="6月27日-41-缺失的第一个正数"><a href="#6月27日-41-缺失的第一个正数" class="headerlink" title="6月27日 41. 缺失的第一个正数"></a>6月27日 <a href="https://leetcode-cn.com/problems/first-missing-positive/">41. 缺失的第一个正数</a></h1><p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,0]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,4,-1,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [7,8,9,11,12]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>排序之后用二分查找从1开始找，可以达到O(mlogn)的时间复杂度。m是缺失正整数的大小。<br>（代码略）</p>
</li>
<li><p>用O(n)的时间把数组存入<code>unordered_set</code>，在从1开始查找，时间复杂度为O(max{m,n})，m是缺失正整数的大小，n是数组的长度。但是就得用O(n)的空间复杂度。（不符合要求，但是还是通过了哈哈哈）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    if(nums.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    unordered_set&lt;int&gt; numSet;</span><br><span class="line">    int maxNum = INT_MIN;</span><br><span class="line">    for (int n : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        numSet.insert(n);</span><br><span class="line">        maxNum = max(maxNum, n);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; maxNum;i++)&#123;</span><br><span class="line">        if(numSet.find(i)==numSet.end())</span><br><span class="line">            return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxNum &lt; 0 ? 1 : maxNum + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有缺失，数组从1开始存放元素，则<code>nums[i]==i+1</code>。可以在遍历的时候把元素从<code>idx==0</code>开始放正确位置对应的数，再次遍历时第一个元素与位置不对应的索引即是最小的正整数。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    for (int i = 0; i &lt; nums.size();i++)&#123;</span><br><span class="line">        while(nums[i]!=i+1)&#123;</span><br><span class="line">            if(nums[i]&lt;=0 || nums[i]&gt;nums.size() || nums[i] == nums[nums[i] - 1])</span><br><span class="line">                //如果 nums[i] == nums[rightPos] 相等，就会无限交换下去。</span><br><span class="line">                break;</span><br><span class="line">            int rightPos = nums[i] - 1;//这个要在if后面，因为当nums[i]太大时，容易溢出</span><br><span class="line">            nums[i] = nums[rightPos];</span><br><span class="line">            nums[rightPos] = rightPos + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">        if(nums[i] != (i+1))</span><br><span class="line">            return i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.size() + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="第29场双周赛（6月27日）"><a href="#第29场双周赛（6月27日）" class="headerlink" title="第29场双周赛（6月27日）"></a>第29场双周赛（6月27日）</h1><h2 id="5432-去掉最低工资和最高工资后的工资平均值（简单）"><a href="#5432-去掉最低工资和最高工资后的工资平均值（简单）" class="headerlink" title="5432. 去掉最低工资和最高工资后的工资平均值（简单）"></a><a href="https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/">5432. 去掉最低工资和最高工资后的工资平均值（简单）</a></h2><p>给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。<br>请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：salary = [4000,3000,1000,2000]</span><br><span class="line">输出：2500.00000</span><br><span class="line">解释：最低工资和最高工资分别是 1000 和 4000 。</span><br><span class="line">去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double average(vector&lt;int&gt;&amp; salary) &#123;</span><br><span class="line">    int maxS = INT_MIN, minS = INT_MAX;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int s:salary)&#123;</span><br><span class="line">        sum += s;</span><br><span class="line">        maxS = max(maxS, s);</span><br><span class="line">        minS = min(minS, s);</span><br><span class="line">    &#125;</span><br><span class="line">    return (double)(sum - maxS - minS) / (salary.size() - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5433-n-的第-k-个因子（中等）"><a href="#5433-n-的第-k-个因子（中等）" class="headerlink" title="5433. n 的第 k 个因子（中等）"></a><a href="https://leetcode-cn.com/contest/biweekly-contest-29/problems/the-kth-factor-of-n/">5433. n 的第 k 个因子（中等）</a></h2><p>给你两个正整数 n 和 k 。<br>如果正整数 i 满足 n % i &#x3D;&#x3D; 0 ，那么我们就说正整数 i 是整数 n 的因子。<br>考虑整数 n 的所有因子，将它们 升序排列 。请你返回第 k 个因子。如果 n 的因子数少于 k ，请你返回 -1 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 12, k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：因子列表包括 [1, 2, 3, 4, 6, 12]，第 3 个因子是 3 。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int kthFactor(int n, int k) &#123;</span><br><span class="line">    vector&lt;int&gt; factors;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n%i==0)</span><br><span class="line">            factors.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    if(factors.size()&lt;k)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    return factors[k - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5434-删掉一个元素以后全为-1-的最长子数组（中等）"><a href="#5434-删掉一个元素以后全为-1-的最长子数组（中等）" class="headerlink" title="5434. 删掉一个元素以后全为 1 的最长子数组（中等）"></a><a href="https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element/">5434. 删掉一个元素以后全为 1 的最长子数组（中等）</a></h2><p>给你一个二进制数组 nums ，你需要从中删掉一个元素。<br>请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。<br>如果不存在这样的子数组，请返回 0 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,0,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,1,1,0,1,1,0,1]</span><br><span class="line">输出：5</span><br><span class="line">解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：你必须要删除一个元素。</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,0,0,1,1,1,0,1]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<p>示例 5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p>题解：<br>找到0，之后<strong>双指针</strong>分别往前和往后直到碰到下一个0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int longestSubarray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    if (sum == n)</span><br><span class="line">        return n-1;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nums[i] == 1) continue;</span><br><span class="line">        int L = i, R = i;</span><br><span class="line">        while (L-1 &gt;= 0 &amp;&amp; nums[L-1] == 1) -- L;</span><br><span class="line">        while (R+1 &lt; n &amp;&amp; nums[R+1] == 1) ++ R;</span><br><span class="line">        res = max(res, R-L);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6月28日-209-长度最小的子数组（中等）"><a href="#6月28日-209-长度最小的子数组（中等）" class="headerlink" title="6月28日 209. 长度最小的子数组（中等）"></a>6月28日 <a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组（中等）</a></h1><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。</p>
<p>示例: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</span><br></pre></td></tr></table></figure>
<p>题解：<br>双指针。<code>i</code>是左边的指针，<code>j</code>是右边的指针。<code>sum&lt;s</code>时，<code>j++</code> ，<code>sum&gt;=s</code>时，<code>i++</code>。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    if(nums.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int i = 0, j = 0, sum = nums[0], minSub = INT_MAX;</span><br><span class="line">    while(j&lt;nums.size())&#123;</span><br><span class="line">        if(sum&lt;s)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            if(j&lt;nums.size())</span><br><span class="line">                sum += nums[j];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            minSub = min(minSub, j - i + 1);</span><br><span class="line">            sum -= nums[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(minSub==1)</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return minSub == INT_MAX ? 0 : minSub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)<br>空间复杂度O(1)</p>
<h1 id="6月29日-215-数组中的第K个最大元素（中等）"><a href="#6月29日-215-数组中的第K个最大元素（中等）" class="headerlink" title="6月29日 215. 数组中的第K个最大元素（中等）"></a>6月29日 <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素（中等）</a></h1><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>排序。时间复杂度O(nlogn)。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int findKthLargest(vector&lt;int&gt; &amp;nums, int k) &#123;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        //默认的升序</span><br><span class="line">        sort(begin(nums), end(nums));</span><br><span class="line">        return nums[size - k];</span><br><span class="line"></span><br><span class="line">        // 降序</span><br><span class="line">        // sort(begin(nums), end(nums), greater&lt;int&gt;());</span><br><span class="line">        // return nums[k-1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>快排的<code>partition</code>函数（可以看这篇<a href="https://suzhilong.github.io/2020/05/25/algorithm/">博客</a>中的算法类例题——排序）。每次可以找到一个正确的位置i，当<code>k&gt;i</code>时，在 <code>i</code> 的右边找；当<code>k&lt;i</code>时，在 <code>i</code> 的左边找；当<code>k==i时</code>，直接输出<code>nums[i]</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Partition(vector&lt;int&gt; &amp;arr, int start, int end)&#123;</span><br><span class="line">    if(arr.size()&lt;2 || start&lt;0 || end&gt;arr.size())</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    int pivot = arr[start];  //除了选择第一个，也可以随机选择一个元素作为pivot</span><br><span class="line">    while (start&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        while(start&lt;end &amp;&amp; arr[end]&gt;=pivot)</span><br><span class="line">            end--;</span><br><span class="line">        arr[start] = arr[end];</span><br><span class="line">        while (start &lt; end &amp;&amp; arr[start] &lt;= pivot)</span><br><span class="line">            start++;</span><br><span class="line">        arr[end] = arr[start];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[start] = pivot;</span><br><span class="line">    return start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">    int len = nums.size();</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = len - 1;</span><br><span class="line">    int target = len - k;</span><br><span class="line"></span><br><span class="line">    while (left&lt;right) &#123;</span><br><span class="line">        int index = Partition(nums, left, right);</span><br><span class="line">        if (index == target) &#123;</span><br><span class="line">            return nums[index];</span><br><span class="line">        &#125; else if (index &lt; target) &#123;</span><br><span class="line">            left = index + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right = index - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n)。证明过程可以参考 <strong>算法导论 9.2：期望为线性的选择算法</strong><br>空间复杂度：O(1)</li>
</ol>
<h1 id="6月30日-剑指-Offer-09-用两个栈实现队列"><a href="#6月30日-剑指-Offer-09-用两个栈实现队列" class="headerlink" title="6月30日 剑指 Offer 09. 用两个栈实现队列"></a>6月30日 <a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h1><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 <code>-1</code> )</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>
<p>题解：<br>一个栈入，一个栈出。当要插入数据时，直接插入入栈；当要取出数据时，如果出栈不为空，则从入栈依次取出放入出栈，直到入栈为空。这样就能保证<strong>后进先出</strong>。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CQueue &#123;</span><br><span class="line">    stack&lt;int&gt; inputStack, outputStack;</span><br><span class="line">public:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">        while(!inputStack.empty())</span><br><span class="line">            inputStack.pop();</span><br><span class="line">        while(!outputStack.empty())</span><br><span class="line">            outputStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void appendTail(int value) &#123;</span><br><span class="line">        inputStack.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int deleteHead() &#123;</span><br><span class="line">        if(outputStack.empty())&#123;</span><br><span class="line">            while(!inputStack.empty())&#123;</span><br><span class="line">                outputStack.push(inputStack.top());</span><br><span class="line">                inputStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(outputStack.empty())</span><br><span class="line">            return -1;</span><br><span class="line">        else&#123;</span><br><span class="line">            int output = outputStack.top();</span><br><span class="line">            outputStack.pop();</span><br><span class="line">            return output;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Leetcode daily</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Review</title>
    <url>/2020/06/05/cppReview/</url>
    <content><![CDATA[<h1 id="C-源文件到可执行文件的过程"><a href="#C-源文件到可执行文件的过程" class="headerlink" title="C++源文件到可执行文件的过程"></a>C++源文件到可执行文件的过程</h1><p>对于C&#x2F;C++编写的程序，从源代码到可执行文件，一般经过下面四个步骤：</p>
<ol>
<li>预处理，产生.ii文件<ul>
<li>对所有的“#define”进行宏展开；</li>
<li>处理所有的条件编译指令，比如“#if”,“#ifdef”，“#elif”，“#else”,“#endif”</li>
<li>处理“#include”指令，这个过程是递归的，也就是说被包含的文件可能还包含其他文件</li>
<li>删除所有的注释“&#x2F;&#x2F;”和“&#x2F;**&#x2F;”</li>
<li>添加行号和文件标识</li>
<li>保留所有的“#pragma”编译器指令</li>
</ul>
</li>
<li>编译，产生汇编文件(.s文件)<br> 编译的过程就是将预处理完的文件进行一系列<strong>词法分析</strong>，<strong>语法分析</strong>，<strong>语义分析</strong>及优化后生成相应的汇编代码文件(.s文件)</li>
<li>汇编，产生目标文件(.o或.obj文件)<br>汇编器是将汇编代码转变成机器可以执行的代码（二进制文件），每一个汇编语句几乎都对应一条机器指令。最终产生目标文件(.o或.obj文件)。</li>
<li>链接,产生可执行文件(.out或.exe文件)<br>链接的过程主要包括了地址和空间分配(Address and Storage Allocation)、符号决议(Symbol Resolution)和重定位(Relocation)</li>
</ol>
<h1 id="Clang-x2F-LLVM-x2F-lldb-x2F-GCC-x2F-gdb"><a href="#Clang-x2F-LLVM-x2F-lldb-x2F-GCC-x2F-gdb" class="headerlink" title="Clang&#x2F;LLVM&#x2F;lldb&#x2F;GCC&#x2F;gdb"></a>Clang&#x2F;LLVM&#x2F;lldb&#x2F;GCC&#x2F;gdb</h1><ul>
<li>Clang 是 LLVM <strong>编译器工具集</strong>的前端（front-end），目的是输出代码对应的抽象语法树（Abstract Syntax Tree, AST），并将代码编译成LLVM Bitcode。接着在后端（back-end）使用LLVM编译成平台相关的机器语言 。Clang支持C、C++、Objective C。</li>
<li>LLVM 提供了完整编译系统的中间层，它会将中间语言（Intermediate form，IF）从编译器取出与最优化，最优化后的 IF 接着被转换及链接到目标平台的汇编语言。LLVM 后端也可以接受来自GCC工具链所编译的 IF。</li>
<li>lldb 是 LLVM 调试器(断点原理)。lldb是个开源的内置于XCode的具有REPL(read-eval-print-loop)特征的Debugger，其可以安装C++或者Python插件。</li>
<li>GCC（GNU Compiler Collection）在所有平台上都使用同一个前端处理程序（支持很多语言），产生一样的中介码，因此此中介码在各个其他平台上使用GCC编译，有很大的机会可得到正确无误的输出程序。</li>
<li>gdb 是 GCC 调试器。UNIX及UNIX-like下的调试工具。</li>
</ul>
<p>ref <a href="https://note.xianqiao.wang/post/clang-llvm-lldb-gcc-gdb-guan-xi">Clang&#x2F;LLVM&#x2F;lldb&#x2F;GCC&#x2F;gdb 关系</a></p>
<h1 id="头文件中的ifndef-x2F-define-x2F-endif有什么作用"><a href="#头文件中的ifndef-x2F-define-x2F-endif有什么作用" class="headerlink" title="头文件中的ifndef&#x2F;define&#x2F;endif有什么作用"></a>头文件中的ifndef&#x2F;define&#x2F;endif有什么作用</h1><p>这是C++预编译头文件保护符，保证即使文件被多次包含，头文件也只定义一次。</p>
<h1 id="typedef-和-define-有什么区别"><a href="#typedef-和-define-有什么区别" class="headerlink" title="typedef 和 define 有什么区别"></a>typedef 和 define 有什么区别</h1><ul>
<li>用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义常量，以及书写复杂使用频繁的宏。</li>
<li>执行时间不同：typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。</li>
<li>作用域不同：typedef 有作用域限定。define 不受作用域约束，只要是在 define 声明后的引用都是正确的。</li>
<li>对指针的操作不同：typedef 和 define 定义的指针时有很大的区别。</li>
</ul>
<p><em>注意：typedef 定义是语句，因为句尾要加上分号。而 define 不是语句，千万不能在句尾加分号。</em></p>
<h1 id="include-的顺序以及尖叫括号和双引号的区别"><a href="#include-的顺序以及尖叫括号和双引号的区别" class="headerlink" title="#include 的顺序以及尖叫括号和双引号的区别"></a>#include 的顺序以及尖叫括号和双引号的区别</h1><ul>
<li>#include的顺序的区别：<br>头文件的引用顺序对于程序的编译还是有一定影响的。如果要在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误，也就是常见的某行少个“；”符号。</li>
<li>#include尖括号和双引号的区别：  <ol>
<li>#include  &lt;&gt; ，认为该头文件是标准头文件。编译器将会在预定义的位置集查找该头文件，这些预定义的位置可以通过设置查找路径环境变量或者通过命令行选项来修改。使用的查找方式因编译器的不同而差别迥异。</li>
<li>#include “”，认为它是非系统头文件，非系统头文件的查找通常开始于源文件所在的路径。查找范围大于&lt;&gt;。</li>
</ol>
</li>
</ul>
<h1 id="main-函数执行以前，还会执行什么代码？"><a href="#main-函数执行以前，还会执行什么代码？" class="headerlink" title="main 函数执行以前，还会执行什么代码？"></a>main 函数执行以前，还会执行什么代码？</h1><p>全局对象的构造函数会在main 函数之前执行。</p>
<h1 id="内联函数和普通函数的区别"><a href="#内联函数和普通函数的区别" class="headerlink" title="内联函数和普通函数的区别"></a>内联函数和普通函数的区别</h1><ol>
<li>复杂程度不同：<br>内联函数比较简单，在内联函数中不允许使用循环语句和switch结果，带有异常接口声明的函数也不能声明为内联函数。</li>
<li>编译结果不同：<br>内联函数（有时称作在线函数或编译时期展开函数）是一种编程语言结构，用来建议编译器对一些特殊函数进行内联扩展（有时称作在线扩展）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文）。普通函数则会编译为单独的模块。</li>
<li>编译的时间不同：<br>对于基于C的编译系统，内联函数的使用可能大大增加编译时间，因为每个调用该函数的地方都需要替换成函数体，代码量的增加也同时带来了潜在的编译时间的增加。</li>
<li>运行的效率不同：<br>使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。</li>
</ol>
<h1 id="内联函数和宏定义的区别"><a href="#内联函数和宏定义的区别" class="headerlink" title="内联函数和宏定义的区别"></a>内联函数和宏定义的区别</h1><p>内联函数和宏的区别在于：</p>
<ul>
<li>宏是由预处理器对宏进行替代</li>
<li>内联函数是通过编译器控制来实现的</li>
</ul>
<p>而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。</p>
<p>内联函数与带参数的宏定义进行下比较，它们的代码效率是一样，但是内联函数要优于宏定义，因为内联函数遵循的类型和作用域规则，它与一般函数更相近，在一些编译器中，一旦关联上内联扩展，将与一般函数一样进行调用，比较方便。 </p>
<p>另外，宏定义在使用时只是简单的文本替换，并没有做严格的参数检查，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</p>
<p>C++的inline的提出就是为了完全取代宏定义，因为inline函数取消了宏定义的缺点，又很好地继承了宏定义的优点，《Effective C++》中就提到了尽量使用Inline替代宏定义的条款，足以说明inline的作用之大。</p>
<h1 id="定义MAX和MIN宏"><a href="#定义MAX和MIN宏" class="headerlink" title="定义MAX和MIN宏"></a>定义MAX和MIN宏</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAX(a,b) ((a) &gt; (b) ? (a) : (b))</span><br><span class="line">#define MIN(a,b) ((a) &lt; (b) ? (a) : (b))</span><br></pre></td></tr></table></figure>

<h1 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h1><p><strong>大端</strong>：高位存在低地址，低位存在高地址。</p>
<p><strong>小端</strong>：高位存在高地址，低位存在低地址。</p>
<p>大小端和CPU有关。</p>
<p>现代PC大多采用小段，所以<strong>小端字节序</strong>又被成为<strong>主机字节序</strong>。而<strong>大端字节序</strong>又被成为<strong>网络字节序</strong>。</p>
<p>判断大小端代码：</p>
<ul>
<li>方法一</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void byteOrder()&#123;</span><br><span class="line">	union</span><br><span class="line">	&#123;</span><br><span class="line">		short val;</span><br><span class="line">		char c_val[sizeof(short)];</span><br><span class="line">	&#125; test;</span><br><span class="line">	test.val = 0x0102;</span><br><span class="line">	if((test.c_val[0]==1) &amp;&amp; (test.c_val[1]==2))</span><br><span class="line">		cout &lt;&lt; &quot;Big endian&quot; &lt;&lt; endl;</span><br><span class="line">	else</span><br><span class="line">		cout &lt;&lt; &quot;Little endian&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void byteOrder()&#123;</span><br><span class="line">	int num = 0x0102;</span><br><span class="line">    char q = *(char *)&amp;num;</span><br><span class="line">    if (q == 0x02)</span><br><span class="line">		cout &lt;&lt; &quot;Little endian&quot; &lt;&lt; endl;</span><br><span class="line">	else</span><br><span class="line">        cout&lt;&lt;&quot;Big endian&quot; &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h1><ul>
<li>左值 (lvalue, locator value)：表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。</li>
<li>右值 (rvalue)：一个表达式不是 左值 就是 右值 。 那么，右值是一个 不 表示内存中某个可识别位置的对象的表达式。</li>
</ul>
<h2 id="左值引用-和-右值引用"><a href="#左值引用-和-右值引用" class="headerlink" title="左值引用 和 右值引用"></a>左值引用 和 右值引用</h2><p>C++11标准添加了右值引用(rvalue reference)，这种引用只能绑定右值，不能绑定左值，它使用两个&amp;&amp;来声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line"></span><br><span class="line">int&amp; b = a; //左值引用</span><br><span class="line">int&amp;&amp; c = 1; //右值引用</span><br><span class="line">int&amp;&amp; b = a; // 编译失败</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/">理解 C&#x2F;C++ 中的左值和右值</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/55229582">右值引用，移动语义，移动构造函数和移动赋值运算符</a></li>
</ul>
<h1 id="面向对象的三个基本特征"><a href="#面向对象的三个基本特征" class="headerlink" title="面向对象的三个基本特征"></a>面向对象的三个基本特征</h1><p>面向对象的三个基本特征是：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。<br><strong>封装</strong>可以隐藏实现细节，使得代码模块化；<strong>继承</strong>可以扩展已存在的代码模块（类）。它们的目的都是<strong>代码重用</strong>；而<strong>多态</strong>则是为了实现另一个目的——<strong>接口重用</strong>。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。</p>
<p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<p>不同的类成员访问修饰符权限：</p>
<table>
<thead>
<tr>
<th>访问修饰符</th>
<th align="center">同一个类</th>
<th align="center">同包</th>
<th align="center">不同包，子类</th>
<th align="center">不同包，非子类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td>public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td>默认</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>使用继承时需要注意：<br>1、子类拥有父类非private的属性和方法。<br>2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。<br>3、子类可以用自己的方式实现父类的方法。</p>
<h3 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h3><p>在C++中 struct和class唯一的区别就在于<strong>默认的继承访问权限</strong>不同。</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class 默认权限为私有</li>
</ul>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class listNode&#123;//链表类</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    listNode *next;</span><br><span class="line">    listNode(int a) : val(a), next(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct biTree&#123;二叉树结构</span><br><span class="line">    int val;</span><br><span class="line">    biTree *lc;</span><br><span class="line">    biTree *rc;</span><br><span class="line">    biTree(int x) : val(x), lc(nullptr), rc(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //链表</span><br><span class="line">	listNode *ln = new listNode(1);</span><br><span class="line">    listNode *cur = ln;</span><br><span class="line">    cur-&gt;next = new listNode(2);</span><br><span class="line">    cur = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = new listNode(3);</span><br><span class="line"></span><br><span class="line">	//二叉树</span><br><span class="line">    biTree parent(1);</span><br><span class="line">	biTree *root = new biTree(1);//也可以只有</span><br><span class="line">    biTree lc(2);</span><br><span class="line">    biTree rc(3);</span><br><span class="line">    parent.lc = &amp;lc;</span><br><span class="line">    parent.rc = &amp;rc;</span><br><span class="line"></span><br><span class="line">    biTree *root = &amp;parent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><p>构造函数和析构函数解决了<strong>对象的初始化和清理</strong>这两个非常重要的安全问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供构造函数和析构函数的空实现。</p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>
<ol>
<li>没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>
<ol>
<li>没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号 ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
<li>public、private、protected等权限控制对析构函数无效</li>
</ol>
<h4 id="构造函数与析构函数的特点"><a href="#构造函数与析构函数的特点" class="headerlink" title="构造函数与析构函数的特点"></a>构造函数与析构函数的特点</h4><ul>
<li>构造函数有如下特点：<ol>
<li>构造函数的名字必须与类名相同；</li>
<li>构造函数可以有任意类型的参数，但不能有返回类型；</li>
<li>定义对象时，编译系统会自动调用构造函数；</li>
<li>构造函数是特殊的成员函数，函数体可以在类体内也可以在类体外；</li>
<li>构造函数被声明为公有函数，但它不能像其他成员函数那样被显式调用，它是在定义对象的同时被调用的。</li>
</ol>
</li>
<li>析构函数有如下特点：<ol>
<li>析构函数的名字必须与类名相同，但它前面必须加一个波浪号；</li>
<li>析构函数没有参数，也没有返回值，而且不能被重载，因此在一个类中只能有一个析构函数；</li>
<li>当撤销对象时，编译系统会自动调用析构函数；</li>
<li>析构函数可以是virtual，而构造函数不能是虚函数。</li>
</ol>
</li>
</ul>
<h4 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h4><p>两种分类方式：</p>
<ul>
<li>按参数分为： 有参构造和无参构造</li>
<li>按类型分为： 普通构造和拷贝构造<br><em>ps. 有参构造有的可能会成为类型转换构造函数，比如在隐式转换调用的时候</em></li>
</ul>
<p>三种调用方式：</p>
<ul>
<li>括号法</li>
<li>显示法</li>
<li>隐式转换法</li>
</ul>
<p>构造函数分类示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span><br><span class="line">// 按照类型分类分为 普通构造和拷贝构造</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	//无参（默认）构造函数</span><br><span class="line">	Person() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	//有参构造函数</span><br><span class="line">	Person(int a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	//拷贝构造函数</span><br><span class="line">	Person(const Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	//析构函数</span><br><span class="line">	~Person() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>构造函数的调用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//调用无参构造函数</span><br><span class="line">void test01() &#123;</span><br><span class="line">	Person p; //调用无参构造函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用有参的构造函数</span><br><span class="line">void test02() &#123;</span><br><span class="line"></span><br><span class="line">	//2.1  括号法，常用</span><br><span class="line">	Person p1(10);</span><br><span class="line">	//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span><br><span class="line">	//Person p2();</span><br><span class="line"></span><br><span class="line">	//2.2 显式法</span><br><span class="line">	Person p2 = Person(10); </span><br><span class="line">	Person p3 = Person(p2);</span><br><span class="line">	//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span><br><span class="line"></span><br><span class="line">	//2.3 隐式转换法</span><br><span class="line">	Person p4 = 10; // Person p4 = Person(10); </span><br><span class="line">	Person p5 = p4; // Person p5 = Person(p4); </span><br><span class="line"></span><br><span class="line">	//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span><br><span class="line">	//Person p5(p4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line">	//test02();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拷贝构造函数和赋值运算符的认识"><a href="#拷贝构造函数和赋值运算符的认识" class="headerlink" title="拷贝构造函数和赋值运算符的认识"></a>拷贝构造函数和赋值运算符的认识</h4><p>拷贝构造函数和赋值运算符重载有以下两个不同之处：</p>
<ul>
<li>拷贝构造函数生成新的类对象，而赋值运算符不能。</li>
<li>由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对象之前不用检验源对象是否和新建对象相同。而赋值运算符则需要这个操作，另外赋值运算中如果原来的对象中有内存分配要先把内存释放掉</li>
</ul>
<p><em>注意：当有类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符，不要使用默认的。</em></p>
<h4 id="构造函数和析构函数可以是虚函数吗？"><a href="#构造函数和析构函数可以是虚函数吗？" class="headerlink" title="构造函数和析构函数可以是虚函数吗？"></a>构造函数和析构函数可以是虚函数吗？</h4><ol>
<li><p>构造函数不能是虚函数</p>
<ul>
<li>存储空间角度<br>虚函数的调用需要 vptr 指针，而该指针存放在对象的内容空间中，需要调用构造函数才可以创建它的值，否则即使开辟了空间，该 vptr 指针为随机值；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有 vptr 地址用来调用虚函数之一的构造函数了。</li>
<li>使用，多态角度<br>虚函数主要是实现多态，在运行时才可以明确调用对象，根据传入的对象类型来调用函数，例如通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。那使用虚函数也没有实际意义。  </li>
<li>从实现角度<br>vtable在构造函数调用后才建立，所以构造函数不能是虚函数。在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，没有必要成为虚函数。</li>
</ul>
</li>
<li><p>析构函数常常是虚函数<br>创建一个对象时我们总是要明白指定对象的类型。虽然我们可能通过基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候假设析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。<br>如果基类的析构函数不是虚函数，派生类的析构函数用不上，会造成资源的泄漏。</p>
</li>
</ol>
<h4 id="构造函数和析构函数，可以调用其他的虚函数吗？"><a href="#构造函数和析构函数，可以调用其他的虚函数吗？" class="headerlink" title="构造函数和析构函数，可以调用其他的虚函数吗？"></a>构造函数和析构函数，可以调用其他的虚函数吗？</h4><p>《Effective C++》条款09：绝不在构造函数或析构函数中调用虚函数。</p>
<p>从语法上讲，调用完全没有问题。</p>
<p>但是从效果上看，往往不能达到需要的目的：派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。同样，进入基类析构函数时，对象也是基类类型。所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。</p>
<h4 id="子类和父类中，构造函数和析构函数的调用顺序是什么？"><a href="#子类和父类中，构造函数和析构函数的调用顺序是什么？" class="headerlink" title="子类和父类中，构造函数和析构函数的调用顺序是什么？"></a>子类和父类中，构造函数和析构函数的调用顺序是什么？</h4><ul>
<li>构造时，先调用父类构造函数，再调用子类构造函数</li>
<li>析构时，先调用子类析构函数，再调用父类析构函数</li>
</ul>
<p><strong>ps.</strong></p>
<ul>
<li>若一个类包含对象成员，在建立该类的对象时，先调用对象成员的构造函数，初始化相应的对象成员，然后才执行该类的构造函数。</li>
<li>如果一个类包含多个对象成员，对象成员的构造函数的调用顺序由它们在该类中的说明顺序决定，而它们在初始化表中的顺序无关。</li>
</ul>
<h4 id="虚析构函数有什么作用？"><a href="#虚析构函数有什么作用？" class="headerlink" title="虚析构函数有什么作用？"></a>虚析构函数有什么作用？</h4><ul>
<li>析构函数的工作方式是：最底层的派生类的析构函数最先被调用，然后调用每一个基类的析构函数；</li>
<li>在C++中，当一个派生类对象通过使用一个基类指针删除，而这个基类有一个非虚的析构函数，则可能导致运行时派生类不能被销毁。然而基类部分很有可能已经被销毁，这就导致“部分析构”现象，造成内存泄漏；</li>
<li>给基类一个虚析构函数，删除一个派生类对象的时候就将销毁整个对象，包括父类和全部的派生类部分。</li>
</ul>
<h4 id="拷贝构造函数在什么情况下会自动被调用"><a href="#拷贝构造函数在什么情况下会自动被调用" class="headerlink" title="拷贝构造函数在什么情况下会自动被调用"></a>拷贝构造函数在什么情况下会自动被调用</h4><ul>
<li>当类的一个对象去初始化该类的另一个对象时；</li>
<li>如果函数的形参是类的对象，调用函数进行形参和实参结合时；</li>
<li>如果函数的返回值是类对象，函数调用完成返回时。</li>
</ul>
<h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><ul>
<li><p>浅拷贝：简单的赋值拷贝操作。使用默认拷贝构造函数，拷贝过程中是按字节复制的，对于指针型成员变量只复制指针本身，而不复制指针所指向的目标，因此涉及堆区开辟内存时，会将两个成员属性指向相同的内存空间，从而在释放时导致内存空间被多次释放。</p>
</li>
<li><p>深拷贝：在堆区重新申请空间，进行拷贝操作。自定义拷贝构造函数，在堆内存中另外申请空间来储存数据，从而解决指针悬挂的问题。需要注意自定义析构函数中应该释放掉申请的内存。</p>
</li>
</ul>
<p>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的重复释放堆区问题。</p>
<p>拷贝构造函数的参数必须加const，因为防止修改，本来就是用现有的对象初始化新的对象。</p>
<p><em>ps. 在定义类或者结构体，这些结构的时候，最后都重写拷贝函数，避免浅拷贝这类不易发现但后果严重的错误产生</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//拷贝构造函数  </span><br><span class="line">Person(const Person&amp; p) &#123;</span><br><span class="line">  cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">  //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span><br><span class="line">  m_age = p.m_age;</span><br><span class="line">  m_height = new int(*p.m_height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//析构函数</span><br><span class="line">~Person() &#123;</span><br><span class="line">  cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">  if (m_height != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    delete m_height;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为<strong>对象成员</strong>。</p>
<p>当类中有对象成员时，构造的顺序是：<strong>先调用对象成员的构造，再调用本类构造。析构顺序与构造相反</strong>。<br>如：B类中有对象A作为成员，A为对象成员。那么当创建B对象时，先调用A的构造，再调用B的构造。结束时先析构B，再析构A。</p>
<h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>成员变量和成员函数前加上关键字static，称为静态成员。<br>静态成员变量：</p>
<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
<p>静态成员函数：</p>
<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
<p>静态成员两种访问方式：</p>
<ol>
<li>通过对象。如：p1.m_A</li>
<li>通过类名。如：Person::m_B（私有权限访问不到）</li>
</ol>
<h4 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h4><ul>
<li>非静态成员变量占对象空间。int mA;</li>
<li>静态成员变量不占对象空间。static int mB; </li>
<li>函数也不占对象空间，所有函数共享一个函数实例。每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">	cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>静态成员函数也不占对象空间</li>
</ul>
<h3 id="对象模型和this指针"><a href="#对象模型和this指针" class="headerlink" title="对象模型和this指针"></a>对象模型和this指针</h3><h4 id="this指针概念"><a href="#this指针概念" class="headerlink" title="this指针概念"></a>this指针概念</h4><p>在类实例化对象时，只有非静态成员变量属于对象本身，剩余的静态成员变量，静态函数，非静态函数都不属于对象本身，因此非静态成员函数只会实例一份，多个同类型对象会共用一块代码。c++通过提供特殊的对象指针——this指针——区分调用自己的对象。this指针指向被调用的成员函数所属的对象。  </p>
<p>this指针的本质是一个指针常量，指针的指向不可修改。this的目的总是指向这个对象，  </p>
<p>this 是一个指向类的实例的一个指针，指向该实例的首地址，但是 this 不是 该对象实例的一部分，即在sizeof（某对象）中不包含this指针的大小。</p>
<h4 id="this指针的作用"><a href="#this指针的作用" class="headerlink" title="this指针的作用"></a>this指针的作用</h4><p>this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来做到这一点，因为this所指的正是这个对象。任何对类成员的直接访问都被看成this的隐式使用。</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用<code>return *this</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Person(int age)</span><br><span class="line">	&#123;</span><br><span class="line">		//1、当形参和成员变量同名时，可用this指针来区分</span><br><span class="line">		this-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person&amp; PersonAddPerson(Person p)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;age += p.age;</span><br><span class="line">		//返回对象本身</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="this-指针需要注意的地方。"><a href="#this-指针需要注意的地方。" class="headerlink" title="this 指针需要注意的地方。"></a>this 指针需要注意的地方。</h4><ul>
<li>this 指针只能用于成员函数，成员变量，对于静态函数和静态变量，是不允许使用this（因为静态函数或变量，都是属于对象本身，即所有实例都可以访问他们，但是this只是指向自身实例的地址，是一个个例。）</li>
<li>友元函数也没有this指针。(友元函数至少需要一个参数)</li>
<li>this引用成员变量用法有二： <code>this-&gt;val</code> 或者 <code>(*this).val.</code> 这就像指针引用类似。</li>
</ul>
<h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>友元的目的就是让一个函数或者类访问另一个类中私有成员（包括属性和方法），会破坏C++的封装性，尽量不使用。</p>
<p>友元的关键字为 <code>friend</code></p>
<p>友元的三种实现：</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。</p>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承方式一共有三种：</p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<h3 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h3><p>继承中，先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
<h3 id="继承同名成员处理方式"><a href="#继承同名成员处理方式" class="headerlink" title="继承同名成员处理方式"></a>继承同名成员处理方式</h3><p>当子类与父类出现同名的成员，通过子类对象访问子类或父类中同名的数据的方法：</p>
<ul>
<li>访问<strong>子类</strong>同名成员：直接访问即可</li>
<li>访问<strong>父类</strong>同名成员：需要加作用域</li>
</ul>
<p><em>ps. 同名静态成员处理方式和非静态处理方式一样</em></p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>C++允许一个类继承多个类<br>语法：<code>class子类：继承方式 父类1，继承方式 父类2...</code></p>
<p><em>ps. 多继承可能会引发父类中有同名成员出现，需要加作用域区分</em></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<p>多态性允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。</p>
<p>简而言之就是用<strong>父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数</strong>。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。</p>
<h3 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h3><ul>
<li>当类中存在虚函数时，编译器会在类中自动生成一个虚函数表</li>
<li>虚函数表是一个存储类成员函数指针的数据结构</li>
<li>虚函数表由编译器自动生成和维护</li>
<li>virtual 修饰的成员函数会被编译器放入虚函数表中</li>
<li>存在虚函数时，编译器会为对象自动生成一个指向虚函数表的指针（通常称之为 vptr 指针）</li>
</ul>
<h3 id="多态实现的三个条件"><a href="#多态实现的三个条件" class="headerlink" title="多态实现的三个条件"></a>多态实现的三个条件</h3><ol>
<li>要有继承</li>
<li>要有虚函数重写</li>
<li>要有父类指针指（父类引用）向子类对象</li>
</ol>
<h3 id="多态分为两类（实现多态的两种方法）"><a href="#多态分为两类（实现多态的两种方法）" class="headerlink" title="多态分为两类（实现多态的两种方法）"></a>多态分为两类（实现多态的两种方法）</h3><ul>
<li>重载——静态多态：<strong>函数重载</strong> 和 <strong>运算符重载</strong> 属于静态多态，复用函数名</li>
<li>重写（覆盖）——动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li>
</ul>
<p>其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。<br>如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。</p>
<p>也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚邦定）。</p>
<p>结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关。</p>
<h3 id="动态多态代码示例"><a href="#动态多态代码示例" class="headerlink" title="动态多态代码示例"></a>动态多态代码示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">		virtual void Print() = 0;</span><br><span class="line">		virtual ~Base()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class child_1 : public Base</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">	void Print()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;child_1 Print function&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~child_1()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;child_1 destructor function&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class child_2: public Base</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">		void Print()</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; &quot;child_2 Print function&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		~child_2()</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; &quot;child_2 destructor function&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Base *p = new child_1; //父类指针指向子类对象</span><br><span class="line">	p-&gt;Print();</span><br><span class="line">	delete p;  //记住释放,否则内存泄露</span><br><span class="line">	p = new child_2;</span><br><span class="line">	p-&gt;Print();</span><br><span class="line">	delete p;</span><br><span class="line">	p = NULL;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态多态代码示例"><a href="#静态多态代码示例" class="headerlink" title="静态多态代码示例"></a>静态多态代码示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//宏多态：a,b可以不同类型</span><br><span class="line">#define  sum(a,b)  ((a) + (b))</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">		void Print() //不需要定义为虚函数</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; &quot;base Print() functions&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		void Print(int val) //重载,根据参数列表不同实现函数多态</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; &quot;base Print(int) functions&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class child : public Base</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">		void Print() //不需要定义为虚函数</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; &quot;child Print() functions&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		void Print(int val) //重载,根据参数列表不同实现函数多态</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; &quot;child Print(int) functions&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	p.Print();</span><br><span class="line">	p.Print(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Base base ;</span><br><span class="line">	child ch;</span><br><span class="line">	int a = 23, b = 19;</span><br><span class="line">	double fa = 13.32, fb = 29.36;</span><br><span class="line">	func(base);</span><br><span class="line">	func(ch);</span><br><span class="line"></span><br><span class="line">	//宏多态：a,b可以不同类型</span><br><span class="line">	cout &lt;&lt; sum(a,b) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; sum(fa,fb) &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><ul>
<li>虚函数的作用主要是实现了多态的机制。</li>
<li>定义一个函数为虚函数，不代表函数为不被实现的函数。定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。</li>
<li>定义一个函数为纯虚函数，才代表函数没有被实现。定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</li>
<li>虚函数的功能是使子类可以用同名的函数对父类函数进行覆盖，并且在通过父类指针调用时，如果有覆盖则自动调用子类覆盖函数，如果没有覆盖则调用父类中的函数，从而实现灵活扩展和多态性；</li>
<li>如果是纯虚函数，则纯粹是为了在子类覆盖时有个统一的命名而已，子类必须覆盖纯虚函数，则否子类也是抽象类；</li>
<li>含有纯虚函数的类称为抽象类，不能实例化对象，主要用作接口类。</li>
</ul>
<p>示例：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void foo()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;A::foo() is called&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B:public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void foo()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;B::foo() is called&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    A *a = new B();</span><br><span class="line">    a-&gt;foo();   // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为<strong>纯虚函数</strong>。<br>当类中有了纯虚函数，这个类也称为<strong>抽象类</strong></p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0;</code></p>
<p>注意：</p>
<ol>
<li>纯虚函数没有函数体</li>
<li>最后的<code>=0</code>并不是表示返回值为0，只是形式上的作用，告诉编译系统<code>这是虚函数</code></li>
<li>这是一个声明，最后有分号</li>
</ol>
<h4 id="抽象类特点："><a href="#抽象类特点：" class="headerlink" title="抽象类特点："></a>抽象类特点：</h4><ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
<li>类中只要有一个纯虚函数就称为抽象类</li>
</ul>
<h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码。<br>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：<br><code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法：<br><code>virtual ~类名() = 0;</code><br><code>类名::~类名()&#123;&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Animal()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual void Speak() = 0;</span><br><span class="line"></span><br><span class="line">	//析构函数加上virtual关键字，变成虚析构函数</span><br><span class="line">	//virtual ~Animal()</span><br><span class="line">	//&#123;</span><br><span class="line">	//	cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">	//&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	virtual ~Animal() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~Animal()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚基类和虚继承"><a href="#虚基类和虚继承" class="headerlink" title="虚基类和虚继承"></a>虚基类和虚继承</h3><p>多继承（Multiple Inheritance）是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。</p>
<p>多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是<strong>菱形继承</strong>。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//间接基类A</span><br><span class="line">class A&#123;</span><br><span class="line">protected:</span><br><span class="line">    int m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//直接基类B</span><br><span class="line">class B: public A&#123;</span><br><span class="line">protected:</span><br><span class="line">    int m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//直接基类C</span><br><span class="line">class C: public A&#123;</span><br><span class="line">protected:</span><br><span class="line">    int m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//派生类D</span><br><span class="line">class D: public B, public C&#123;</span><br><span class="line">public:</span><br><span class="line">    void seta(int a)&#123; m_a = a; &#125;  //命名冲突</span><br><span class="line">    void setb(int b)&#123; m_b = b; &#125;  //正确</span><br><span class="line">    void setc(int c)&#123; m_c = c; &#125;  //正确</span><br><span class="line">    void setd(int d)&#123; m_d = d; &#125;  //正确</span><br><span class="line">private:</span><br><span class="line">    int m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    D d;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>虚继承</strong>目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为<strong>虚基类</strong>（Virtual Base Class），继承的时候用关键字<code>virtual</code>声明。</p>
<p><strong>虚继承</strong>主要用来解决继承中的二义性问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//间接基类A</span><br><span class="line">class A&#123;</span><br><span class="line">protected:</span><br><span class="line">    int m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//直接基类B</span><br><span class="line">class B: virtual public A&#123;  //虚继承</span><br><span class="line">protected:</span><br><span class="line">    int m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//直接基类C</span><br><span class="line">class C: virtual public A&#123;  //虚继承</span><br><span class="line">protected:</span><br><span class="line">    int m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//派生类D</span><br><span class="line">class D: public B, public C&#123;</span><br><span class="line">public:</span><br><span class="line">    void seta(int a)&#123; m_a = a; &#125;  //正确</span><br><span class="line">    void setb(int b)&#123; m_b = b; &#125;  //正确</span><br><span class="line">    void setc(int c)&#123; m_c = c; &#125;  //正确</span><br><span class="line">    void setd(int d)&#123; m_d = d; &#125;  //正确</span><br><span class="line">private:</span><br><span class="line">    int m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    D d;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ref. <a href="http://c.biancheng.net/cpp/biancheng/view/238.html">C++虚继承和虚基类</a></p>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>虚函数表是指在每个包含虚函数的类中都存在着一个函数地址的数组。当我们用父类的指针来操作一个子类的时候，这张虚函数表指明了实际所应该调用的函数。</p>
<p>虚函数表指针vptr一般存储在对象实例的最开头，里面又虚函数表vtable的地址。虚函数表vtable在Linux&#x2F;Unix中存放在可执行文件的只读数据段 .<strong>rodata</strong> 中<br><img src="https://i.loli.net/2020/08/05/2eGU6kMy8Xp5v4Y.png" alt="虚函数表的存储"></p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref."></a>ref.</h3><ul>
<li><a href="https://blog.csdn.net/afei__/article/details/82142775">多态的实现原理分析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/104605966">C++ 一篇搞懂多态的实现原理</a></li>
<li><a href="https://songlee24.github.io/2014/09/02/cpp-virtual-table/">C++进阶之虚函数表</a></li>
<li><a href="https://www.cnblogs.com/yunlambert/p/9876564.html">C++虚函数表</a></li>
<li><a href="https://blog.csdn.net/jiary5201314/article/details/52627630">虚函数表存放在哪里</a></li>
</ul>
<h3 id="多态用法示例"><a href="#多态用法示例" class="headerlink" title="多态用法示例"></a>多态用法示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//抽象CPU类</span><br><span class="line">class CPU</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//抽象的计算函数</span><br><span class="line">	virtual void calculate() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//抽象显卡类</span><br><span class="line">class VideoCard</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//抽象的显示函数</span><br><span class="line">	virtual void display() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//抽象内存条类</span><br><span class="line">class Memory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//抽象的存储函数</span><br><span class="line">	virtual void storage() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//电脑类</span><br><span class="line">class Computer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Computer(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">	&#123;</span><br><span class="line">		m_cpu = cpu;</span><br><span class="line">		m_vc = vc;</span><br><span class="line">		m_mem = mem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//提供工作的函数</span><br><span class="line">	void work()</span><br><span class="line">	&#123;</span><br><span class="line">		//让零件工作起来，调用接口</span><br><span class="line">		m_cpu-&gt;calculate();</span><br><span class="line"></span><br><span class="line">		m_vc-&gt;display();</span><br><span class="line"></span><br><span class="line">		m_mem-&gt;storage();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//提供析构函数 释放3个电脑零件</span><br><span class="line">	~Computer()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		//释放CPU零件</span><br><span class="line">		if (m_cpu != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			delete m_cpu;</span><br><span class="line">			m_cpu = NULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//释放显卡零件</span><br><span class="line">		if (m_vc != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			delete m_vc;</span><br><span class="line">			m_vc = NULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//释放内存条零件</span><br><span class="line">		if (m_mem != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			delete m_mem;</span><br><span class="line">			m_mem = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">	CPU * m_cpu; //CPU的零件指针</span><br><span class="line">	VideoCard * m_vc; //显卡零件指针</span><br><span class="line">	Memory * m_mem; //内存条零件指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//具体厂商</span><br><span class="line">//Intel厂商</span><br><span class="line">class IntelCPU :public CPU</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void calculate()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IntelVideoCard :public VideoCard</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void display()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IntelMemory :public Memory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void storage()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//Lenovo厂商</span><br><span class="line">class LenovoCPU :public CPU</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void calculate()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LenovoVideoCard :public VideoCard</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void display()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LenovoMemory :public Memory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void storage()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	//第一台电脑零件</span><br><span class="line">	CPU * intelCpu = new IntelCPU;</span><br><span class="line">	VideoCard * intelCard = new IntelVideoCard;</span><br><span class="line">	Memory * intelMem = new IntelMemory;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;</span><br><span class="line">	//创建第一台电脑</span><br><span class="line">	Computer * computer1 = new Computer(intelCpu, intelCard, intelMem);</span><br><span class="line">	computer1-&gt;work();</span><br><span class="line">	delete computer1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;</span><br><span class="line">	//第二台电脑组装</span><br><span class="line">	Computer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;</span><br><span class="line">	computer2-&gt;work();</span><br><span class="line">	delete computer2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;</span><br><span class="line">	//第三台电脑组装</span><br><span class="line">	Computer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;</span><br><span class="line">	computer3-&gt;work();</span><br><span class="line">	delete computer3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>主要用来解决命名冲突的问题</p>
<ul>
<li>必须在全局作用域下声明</li>
<li>命名空间下可以放函数，变量、结构体和类</li>
<li>命名空间可以嵌套命名空间</li>
<li>命名空间是开放的，可以随时加入新成员（添加时只需要再次声明namespace，然后添加新成员即可</li>
</ul>
<h3 id="（作用域运算符）"><a href="#（作用域运算符）" class="headerlink" title="::（作用域运算符）"></a><code>::</code>（作用域运算符）</h3><ul>
<li>全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li>
<li>类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的</li>
<li>命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的</li>
</ul>
<h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><ul>
<li>using声明<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using std::cout;</span><br></pre></td></tr></table></figure></li>
<li>using编译指令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><em>ps. 尽量使用声明而不是编译指令，不同命名空间中可能会有相同的变量名，编译指令执行两个命名空间后，会产生二义性</em></p>
<h2 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h2><p><a href="https://github.com/AnkerLeng/Cpp-0-1-Resource/blob/master/%E7%AC%AC3%E9%98%B6%E6%AE%B5-C%2B%2B%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%20%E8%B5%84%E6%96%99/%E8%AE%B2%E4%B9%89/C%2B%2B%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B.md">C++核心编程</a><br><a href="https://blog.csdn.net/ma1kong/article/details/4457044">面向对象的三大特性</a></p>
<h1 id="函数重载（overload）、重写（override，也叫覆盖）和隐藏（也叫重定义）"><a href="#函数重载（overload）、重写（override，也叫覆盖）和隐藏（也叫重定义）" class="headerlink" title="函数重载（overload）、重写（override，也叫覆盖）和隐藏（也叫重定义）"></a>函数重载（overload）、重写（override，也叫覆盖）和隐藏（也叫重定义）</h1><h2 id="重载（overload）"><a href="#重载（overload）" class="headerlink" title="重载（overload）"></a>重载（overload）</h2><p>当函数具有相同的名称，但是参数列表不相同的情形（包括参数的个数不同或参数的类型不同），这样的同名而不同参数的函数之间，互相被称之为重载函数。<br>(函数名相同，参数列表不同，overload只是在类的内部存在)<br>特征：</p>
<ol>
<li>具有相同的作用域（即同一个类定义中）；</li>
<li>函数名字相同；</li>
<li>函数参数 <strong>类型不同</strong> 或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong>；</li>
<li>virtual 关键字可有可无；</li>
<li>返回类型也可以不同。<br><em>ps:函数的访问权限、返回类型、抛出的异常不可以作为函数重载的条件</em></li>
</ol>
<p>函数重载实例判断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以下的集中写法，分别表示了哪些是重载的，哪些不是重载的。</span><br><span class="line">(1) void func1( int arg1);</span><br><span class="line">(2) void func1( double arg1);</span><br><span class="line">(3) void func1( int arg1, int arg2);</span><br><span class="line">(4) bool func1(int arg1, double arg2)</span><br><span class="line">(5) int func1(int arg1);</span><br><span class="line"></span><br><span class="line">在上述的5个函数中，函数名称都是func1，完全相同；但是：</span><br><span class="line">(2)与(1)的参数个数相同，参数类型不同，构成重载；</span><br><span class="line">(3)与(1)和(2)的参数个数不同，构成重载；</span><br><span class="line">(4)与(1)和(2)的参数个数不同，与(3)的参数个数相同，但是第二个参数类型不同，构成重载；</span><br><span class="line">(5)与(1)的参数个数和参数类型均相同，仅返回值的类型不相同，不构成重载；但是(5)与(2),(3)和(4)除返回值不同外，均有参数类型或参数个数不同的情况，因此构成重载关系。</span><br></pre></td></tr></table></figure>

<h2 id="重写（覆盖，override）"><a href="#重写（覆盖，override）" class="headerlink" title="重写（覆盖，override）"></a>重写（覆盖，override）</h2><p>重写（覆盖）是指派生类重新实现（或者改写）基类的成员函数，在继承关系之间。C++利用虚函数实现多态。其特征是：</p>
<ol>
<li>不同的<strong>作用域</strong>（分别位于派生类和基类中）；</li>
<li>完全相同的<strong>函数名</strong>，<strong>参数列表</strong> 和 <strong>返回类型</strong>；</li>
<li>基类函数必须是虚函数。即<strong>必须有virtual</strong>关键字，不能是static；</li>
<li>重写函数的<strong>访问修饰符</strong>可以不同。尽管父类的virtual方法是private的，派生类中重写改写为public、protected也是可以的；</li>
</ol>
<p>重写（override）代码示例：B中fun1重写了A中的fun1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fun1(int, int)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B : class A&#123;</span><br><span class="line">public:</span><br><span class="line">    void fun1(int, int)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="隐藏（重定义）"><a href="#隐藏（重定义）" class="headerlink" title="隐藏（重定义）"></a>隐藏（重定义）</h2><p>子类重新定义父类有相同名称的非虚函数(参数列表可以不同)。</p>
<ol>
<li>不在同一个<strong>作用域</strong>（分别位于派生类与基类） ；</li>
<li>函数<strong>名字相同</strong>，<strong>返回值可以不同</strong>；</li>
<li>函数名相同但<strong>参数不同</strong>。如果派生类的函数和基类的函数同名，但是参数不同，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载以及覆盖混淆）；</li>
<li>函数名相同且<strong>参数相同</strong>，但是基类函数没有 virtual关键字。此时，基类的函数被隐藏（否则就是重写了）。</li>
</ol>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序:"></a>示例程序:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void A(int x)&#123; cout &lt;&lt; &quot;Base::A(int)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    void A(float x)&#123; cout &lt;&lt; &quot;Base::A(float)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void B(void)&#123; cout &lt;&lt; &quot;Base::B(void)&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void C(float x)&#123; cout &lt;&lt; &quot;Base::C(float)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void D(float x)&#123; cout &lt;&lt; &quot;Base::D(float)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    void E(float x)&#123; cout &lt;&lt; &quot;Base::E(float) &quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void B(void)&#123; cout &lt;&lt; &quot;Derived::B(void)&quot; &lt;&lt; endl;&#125;</span><br><span class="line">    virtual void C(float x)&#123; cout &lt;&lt; &quot;Derived::C(float)&quot; &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">    virtual void D(int x)&#123; cout &lt;&lt; &quot;Derived::D(int)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    void E(float x)&#123; cout &lt;&lt; &quot;Derived::E(float)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>重载：函数Base::A(int)与Base::A(float)相互重载</li>
<li>重写：函数Derived::B(void)重写了Base::B(void)，函数Derived::C(float)重写了Base::C(float)</li>
<li>隐藏：函数Derived:: D(int)隐藏了Base:: D(float)，函数Derived::E(float)隐藏了Base::E(float)</li>
</ul>
<h2 id="ref-2"><a href="#ref-2" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://blog.csdn.net/qq_26437925/article/details/54933326">C++ 类成员函数的重载(overload)，重写&#x2F;覆盖(override)，隐藏</a></li>
<li><a href="https://www.cnblogs.com/-Mr-y/p/8352074.html#_lab2_1_1">函数重载(overload)和函数重写(override)</a></li>
<li><a href="https://www.cnblogs.com/luxiaoxun/archive/2012/08/09/2630751.html">C++的重载（overload）与重写（override）</a></li>
</ul>
<h1 id="函数模板与函数重载的异同？"><a href="#函数模板与函数重载的异同？" class="headerlink" title="函数模板与函数重载的异同？"></a>函数模板与函数重载的异同？</h1><ul>
<li>函数的重载是指定义了几个名字相同，但参数的类型或参数的个数不同的函数；</li>
<li>模板函数是指的几个函数的具体算法相同，而参数类型不同的函数；</li>
<li>模板函数可以减少重载函数，但也可能引发错误。</li>
</ul>
<h1 id="C-中的空类，默认会产生哪些类成员函数"><a href="#C-中的空类，默认会产生哪些类成员函数" class="headerlink" title="C++中的空类，默认会产生哪些类成员函数"></a>C++中的空类，默认会产生哪些类成员函数</h1><ul>
<li>默认构造函数 </li>
<li>析构函数 </li>
<li>拷贝构造函数 </li>
<li>赋值运算符（operator&#x3D;） </li>
<li>取址运算符（operator&amp;）（一对，一个非const的，一个const的）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Empty</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    Empty(); // 缺省构造函数</span><br><span class="line">    Empty( const Empty&amp; ); // 拷贝构造函数</span><br><span class="line">    ~Empty(); // 析构函数</span><br><span class="line">    Empty&amp; operator=( const Empty&amp; ); // 赋值运算符</span><br><span class="line">    Empty* operator&amp;(); // 取址运算符</span><br><span class="line">    const Empty* operator&amp;() const; // 取址运算符 const</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="类在内存中的存储方式"><a href="#类在内存中的存储方式" class="headerlink" title="类在内存中的存储方式"></a>类在内存中的存储方式</h1><ul>
<li>类的静态成员变量编译时被分配到静态&#x2F;全局区，因此静态成员变量是属于类的，所有对象共用一份，不计入类的内存空间</li>
<li>静态成员函数和非静态成员函数都是存放在代码区的，是属于类的，类可以直接调用静态成员函数，不可以直接调用非静态成员函数，两者主要的区别是有无this指针</li>
<li>派生类对象的存储空间 &#x3D; 基类存储空间 + 派生类特有的非static数据成员的空间<br><a href="https://zhuanlan.zhihu.com/p/103384358">C++类在内存中的存储方式</a></li>
</ul>
<h1 id="类成员变量的初始化顺序"><a href="#类成员变量的初始化顺序" class="headerlink" title="类成员变量的初始化顺序"></a>类成员变量的初始化顺序</h1><p>成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。</p>
<p><a href="https://www.cnblogs.com/littleswan/p/12511022.html">C++类成员变量的初始化顺序</a></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><img src="https://i.loli.net/2020/08/27/ZNPO91H7jUeS6Ti.png" alt="数据类型"></p>
<h1 id="sizeof-与-strlen-的区别"><a href="#sizeof-与-strlen-的区别" class="headerlink" title="sizeof 与 strlen 的区别"></a>sizeof 与 strlen 的区别</h1><ul>
<li>sizeof是一个操作符，而strlen是库函数。</li>
<li>sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为’\0’的字符串作参数。</li>
<li>编译器在编译时就计算出了sizeof的结果，而strlen必须在运行时才能计算出来。</li>
<li>sizeof计算数据类型占内存的大小，strlen计算字符串实际长度。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; strlen(&quot;123&quot;) &lt;&lt; endl; //3</span><br><span class="line">cout &lt;&lt; sizeof(&quot;123&quot;) &lt;&lt; endl; //4</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="strcpy-和-memcpy-的区别"><a href="#strcpy-和-memcpy-的区别" class="headerlink" title="strcpy 和 memcpy 的区别"></a>strcpy 和 memcpy 的区别</h1><p>strcpy 和 memcpy 都是标准C库函数</p>
<h2 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h2><p>strcpy提供了字符串的复制。即strcpy只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符。</p>
<p><code>char* strcpy(char* dest, const char* src);</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char * strcpy(char * dest, const char * src) // 实现src到dest的复制</span><br><span class="line">&#123;</span><br><span class="line">　　if ((src == NULL) || (dest == NULL)) //判断参数src和dest的有效性</span><br><span class="line">　　　　　　return NULL;</span><br><span class="line">　　char *strdest = dest;        //保存目标字符串的首地址</span><br><span class="line">　　while ((*strDest++ = *strSrc++)!=&#x27;\0&#x27;); //把src字符串的内容复制到dest下</span><br><span class="line">　　return strdest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h2><p>memcpy提供了一般内存的复制。即memcpy对于需要复制的内容没有限制，因此用途更广。</p>
<p><code>void *memcpy( void *dest, const void *src, size_t count );</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *memcpy(void *memTo, const void *memFrom, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">　　if((memTo == NULL) || (memFrom == NULL)) //memTo和memFrom必须有效</span><br><span class="line">         return NULL;</span><br><span class="line">　　char *tempFrom = (char *)memFrom;             //保存memFrom首地址</span><br><span class="line">　　char *tempTo = (char *)memTo;                  //保存memTo首地址      </span><br><span class="line">　　while(size -- &gt; 0)                //循环size次，复制memFrom的值到memTo中</span><br><span class="line">       　　*tempTo++ = *tempFrom++ ;  </span><br><span class="line">　　return memTo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li>
<li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</li>
<li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li>
</ol>
<h1 id="x-amp-x-1"><a href="#x-amp-x-1" class="headerlink" title="x &amp; (x-1)"></a>x &amp; (x-1)</h1><p>相当于消除了 x 从右向左数遇到的第一个1。</p>
<h1 id="short-i-x3D-0-i-x3D-i-1L；这两句有错吗"><a href="#short-i-x3D-0-i-x3D-i-1L；这两句有错吗" class="headerlink" title="short i &#x3D; 0; i &#x3D; i + 1L；这两句有错吗"></a>short i &#x3D; 0; i &#x3D; i + 1L；这两句有错吗</h1><p>代码一是错的，代码二是正确的。</p>
<p><strong>说明</strong>：在数据安全的情况下大类型的数据向小类型的数据转换一定要显示的强制类型转换。</p>
<h1 id="amp-amp-和-amp-、-和-有什么区别"><a href="#amp-amp-和-amp-、-和-有什么区别" class="headerlink" title="&amp;&amp;和&amp;、||和|有什么区别"></a>&amp;&amp;和&amp;、||和|有什么区别</h1><ul>
<li>&amp;和|对操作数进行求值运算，&amp;&amp;和||只是判断逻辑关系。</li>
<li>&amp;&amp;和||在在判断左侧操作数就能确定结果的情况下就不再对右侧操作数求值。</li>
</ul>
<p><em>注意：在编程的时候有些时候将&amp;&amp;或||替换成&amp;或|没有出错，但是其逻辑是错误的，可能会导致不可预想的后果（比如当两个操作数一个是 1 另一个是 2 时。</em></p>
<h1 id="struct定义的四种方法"><a href="#struct定义的四种方法" class="headerlink" title="struct定义的四种方法"></a>struct定义的四种方法</h1><p>第一种</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct 结构体名称&#123; </span><br><span class="line">   数据类型 member1； </span><br><span class="line">   数据类型 member2; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>第二种</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct 结构体名称&#123; </span><br><span class="line">   数据类型 member1； </span><br><span class="line">   数据类型 member2; </span><br><span class="line">&#125;结构体名称别名; </span><br></pre></td></tr></table></figure>

<p>第三种</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct 结构体名称&#123; </span><br><span class="line">   数据类型 member1； </span><br><span class="line">   数据类型 member2; </span><br><span class="line">&#125;结构体变量;</span><br></pre></td></tr></table></figure>

<p>第四种：此方式是匿名结构体，在定义时同时声明结构体变量，但不能在其它地方声明，因为我们无法得知该结构体的标识符，所以就无法通过标识符来声明变量。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct &#123; </span><br><span class="line">   数据类型 member1； </span><br><span class="line">   数据类型 member2; </span><br><span class="line">&#125;结构体变量名;</span><br></pre></td></tr></table></figure>

<h1 id="联合（union）、结构（struct）、类（class）"><a href="#联合（union）、结构（struct）、类（class）" class="headerlink" title="联合（union）、结构（struct）、类（class）"></a>联合（union）、结构（struct）、类（class）</h1><ul>
<li><p>联合<br>在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的。<strong>union变量所占用的内存长度等于最长的成员的内存长度</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union A</span><br><span class="line">&#123;//sizeof(union A)的值为8</span><br><span class="line">    char mark;</span><br><span class="line">    long num;</span><br><span class="line">    float score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>结构<br>将不同类型的数据组合成一个整体，是自定义类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct B</span><br><span class="line">&#123;//sizeof(struct B)的值为24</span><br><span class="line">    char mark;</span><br><span class="line">    long num;</span><br><span class="line">    float score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体：将不同类型的数据组合成一个整体，是自定义类型</p>
</li>
</ul>
<p>区别：</p>
<ol>
<li><strong>结构体</strong>中的每个成员都有自己独立的地址，它们是同时存在的；<strong>共同体</strong>中的所有成员占用同一段内存，它们不能同时存在；</li>
<li>sizeof(struct)是内存对齐后所有成员长度的总和，sizeof(union)是内存对齐后最长数据成员的长度</li>
</ol>
<h2 id="结构体为什么要内存对齐呢？"><a href="#结构体为什么要内存对齐呢？" class="headerlink" title="结构体为什么要内存对齐呢？"></a>结构体为什么要内存对齐呢？</h2><p>看下面</p>
<h1 id="内存对齐（字节对齐）"><a href="#内存对齐（字节对齐）" class="headerlink" title="内存对齐（字节对齐）"></a>内存对齐（字节对齐）</h1><p><code>#pragma pack(n)</code> 表示的是设置n字节对齐，windows默认是8，linux是4。</p>
<h2 id="内存对齐规则"><a href="#内存对齐规则" class="headerlink" title="内存对齐规则"></a>内存对齐规则</h2><p>对于结构的各个成员，第一个成员位于偏移为0的位置，以后的每个数据成员的偏移量必须是 min(#pragma pack()指定的数,这个数据成员的自身长度)的倍数。</p>
<p>在所有的数据成员完成各自对齐之后，结构或联合体本身也要进行对齐，对齐将按照 #pragam pack指定的数值和结构或者联合体最大数据成员长度中比较小的那个，也就是 min(#pragram pack() , 长度最长的数据成员)。</p>
<h2 id="需要对齐的原因"><a href="#需要对齐的原因" class="headerlink" title="需要对齐的原因"></a>需要对齐的原因</h2><ul>
<li>平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</li>
<li>硬件原因：经过内存对齐之后，CPU的内存访问速度大大提升。访问未对齐的内存，处理器要访问两次（数据先读高位，再读低位），访问对齐的内存，处理器只要访问一次，为了提高处理器读取数据的效率，我们使用内存对齐</li>
</ul>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">    char a;</span><br><span class="line">    int b;</span><br><span class="line">    short c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>char占一个字节，起始偏移为零，int占四个字节，min(8,4)&#x3D;4；所以应该偏移量为4，所以应该在char后面加上三个字节，不存放任何东西，short占两个字节，min(8,2)&#x3D;2;所以偏移量是2的倍数，而short偏移量是8，是2的倍数，所以无需添加任何字节，所以第一个规则对齐之后内存状态为0xxx|0000|00</li>
<li>此时一共占了10个字节，但是还有结构体本身的对齐，min(8,4)&#x3D;4；所以总体应该是4的倍数，所以还需要添加两个字节在最后面，所以内存存储状态变为了 0xxx|0000|00xx，一共占据了12个字节</li>
</ul>
<p>ref. <a href="https://songlee24.github.io/2014/09/20/memory-alignment/">C&#x2F;C++内存对齐</a></p>
<h1 id="c-资源管理机制"><a href="#c-资源管理机制" class="headerlink" title="c++资源管理机制"></a>c++资源管理机制</h1><h2 id="内存的分类"><a href="#内存的分类" class="headerlink" title="内存的分类"></a>内存的分类</h2><ol>
<li><p><strong>堆（heap）</strong>：指的是动态分配内存的区域。这里的内存，<strong>需要程序员手动分配和释放（new,delete）</strong>，否则，就会造成内存泄漏。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。<br>与之相关的一个概念是<strong>自由存储区(free store)<strong>，特指使用 new 和 delete 来分配和释放内存的区域。一般来说，这是</strong>堆的一个子集</strong>。<br>new 和 delete 操作的区域是 free store<br>malloc 和 free 操作的区域是 heap<br><em>ps: new 和 delete 通常底层使用 malloc 和 free 来实现，所以 free store 也属于 heap</em></p>
</li>
<li><p><strong>栈（stack）</strong>：函数调用过程中产生的本地变量和调用数据的区域。由编译器自动分配和释放。<br>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
</li>
</ol>
<p><em>凡生命周期超出当前函数的，一般需要用堆（或者使用对象移动传递）。反之，生命周期在当前函数内的，就该用栈。</em></p>
<ol start="3">
<li><p><strong>全局&#x2F;静态存储区（static）</strong>：全局变量和静态变量被分配到同一块内存中。<strong>程序结束后由系统释放。</strong><br>它们是在程序编译、链接时完全确定下来的，具有固定的存储位置（暂不考虑某些系统的地址扰乱机制）。堆和栈上的变量则都是动态的，地址无法确定。</p>
</li>
<li><p><strong>常量存储区</strong>：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。<strong>程序结束后由系统释放</strong>。</p>
</li>
<li><p><strong>程序代码区</strong>：存放程序的二进制代码。</p>
</li>
</ol>
<h2 id="栈展开（stack-unwinding）"><a href="#栈展开（stack-unwinding）" class="headerlink" title="栈展开（stack unwinding）"></a>栈展开（stack unwinding）</h2><p>指的是：如果在一个函数内部抛出异常，而此异常并未在该函数内部被捕捉，就将导致该函数的运行在抛出异常处结束，所有已经分配在栈上的局部变量都要被释放。<br><a href="https://www.dazhuanlan.com/2019/09/29/5d8fb29e775ec/">示例</a></p>
<p>最常见的栈展开就是正常的函数调用，任何一个函数返回都存在栈展开。C++引入异常机制后，当程序抛出异常，在异常向上传递的过程中，其函数调用栈也会展开。</p>
<p><a href="https://time.geekbang.org/column/article/169225">栈展开演示：</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">class Obj &#123;</span><br><span class="line">public:</span><br><span class="line">  Obj() &#123; puts(&quot;Obj()&quot;); &#125;</span><br><span class="line">  ~Obj() &#123; puts(&quot;~Obj()&quot;); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(int n)</span><br><span class="line">&#123;</span><br><span class="line">  Obj obj;</span><br><span class="line">  if (n == 42)</span><br><span class="line">    throw &quot;life, the universe and everything&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    foo(41);</span><br><span class="line">    foo(42);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (const char* s) &#123;</span><br><span class="line">    puts(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码执行结果：不管是否发生了异常，obj 的析构函数都会得到执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Obj()</span><br><span class="line">~Obj()</span><br><span class="line">Obj()</span><br><span class="line">~Obj()</span><br><span class="line">life, the universe and everything</span><br></pre></td></tr></table></figure>

<h2 id="RAII-Resource-Acquisition-Is-Initialization"><a href="#RAII-Resource-Acquisition-Is-Initialization" class="headerlink" title="RAII(Resource Acquisition Is Initialization)"></a>RAII(Resource Acquisition Is Initialization)</h2><p>是 C++ 所特有的资源管理方式。RAII 依托栈和析构函数，来对所有的资源（包括堆内存在内）进行管理。</p>
<p>其原理是在对象析构函数中释放该对象获取的资源，利用栈展开过程栈上对象的析构函数将被自动调用的保证，从而正确地释放先前获取的资源。</p>
<p>RAII只有在栈展开正常执行的前提下才能正常工作。函数调用和正常的C++异常处理流程(异常处于try-catch块)都存在栈展开。</p>
<h2 id="申请后系统的响应"><a href="#申请后系统的响应" class="headerlink" title="申请后系统的响应"></a>申请后系统的响应</h2><p>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。<br>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>
<h2 id="malloc-x2F-free-和-new-x2F-delete-区别："><a href="#malloc-x2F-free-和-new-x2F-delete-区别：" class="headerlink" title="malloc&#x2F;free 和 new&#x2F;delete 区别："></a>malloc&#x2F;free 和 new&#x2F;delete 区别：</h2><ol>
<li><p>属性不同：malloc&#x2F;free是标准库函数，new&#x2F;delete是操作符（运算符）。</p>
</li>
<li><p>申请的内存所在位置：new操作符从<strong>自由存储区（free store）</strong>上为对象动态分配内存空间，而malloc函数从<strong>堆</strong>上动态分配内存。 </p>
</li>
<li><p>内存分配失败时的返回值：new内存分配失败时，会抛出<strong>bad_alloc异常</strong>，它不会返回NULL；malloc分配内存失败时返回<strong>NULL</strong>。</p>
</li>
<li><p>是否需要指定内存大小：new&#x2F;delete分配可以自动计算需要的字节数，malloc&#x2F;free需要人为指定。</p>
</li>
<li><p>是否调用构造函数&#x2F;析构函数：</p>
<ul>
<li>new会先调用operator_new函数，申请足够的内存（通常底层使用malloc实现），然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator_delete函数释放内存（通常底层使用free实现）。  </li>
<li>malloc&#x2F;free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</li>
</ul>
</li>
<li><p>能否重载：new&#x2F;delete允许重载,malloc&#x2F;free不允许重载</p>
</li>
<li><p>已分配内存的扩充：malloc&#x2F;free可以通过realloc函数扩充，new&#x2F;free无法直观地处理</p>
</li>
<li><p>能否相互调用：operator_new&#x2F;operator _delete的实现可以基于malloc&#x2F;free，而malloc的实现不可以去调用new。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//main.cpp</span><br><span class="line">int a = 0; //全局初始化区</span><br><span class="line">char *p1; //全局未初始化区</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">int b; //栈</span><br><span class="line">char s[] = &quot;abc&quot;; //栈</span><br><span class="line">char *p2; //栈</span><br><span class="line">char *p3 = &quot;123456&quot;; //123456\0在常量区，p3在栈上。</span><br><span class="line">static int c =0； //全局（静态）初始化区</span><br><span class="line">p1 = (char *)malloc(10);</span><br><span class="line">p2 = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区。</span><br><span class="line">strcpy(p1, &quot;123456&quot;); //123456\0放在常量区，编译器可能会将它与p3所指的&quot;123456&quot;优化成一个地方</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="malloc实现原理"><a href="#malloc实现原理" class="headerlink" title="malloc实现原理"></a>malloc实现原理</h2><ol>
<li>malloc 函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。</li>
<li>调用 malloc（）函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。 然后，将该内存块一分为二（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节）。 接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块（如果有的话）返回到连接表上。</li>
<li>调用 free 函数时，它将用户释放的内存块连接到空闲链表上。</li>
<li>到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段， 那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc（）函数请求延时，并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。</li>
</ol>
<p>malloc会出现的问题：初始化的问题。没有初始化的内存中内容是随机的，所以如果直接使用的话，就可能造成程序运行结果不正确。</p>
<p><em>ps. malloc 函数可以向程序的虚拟空间申请一块虚拟地址空间，与物理内存没有直接的关系，所以是有可能用malloc函数申请超过该机器物理内存大小的内存块的</em></p>
<p>ref. <a href="https://blog.csdn.net/mmshixing/article/details/51679571">linux-malloc底层实现原理</a></p>
<h2 id="delete-与-delete-区别"><a href="#delete-与-delete-区别" class="headerlink" title="delete 与 delete[] 区别"></a>delete 与 delete[] 区别</h2><p>delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。delete与new配套，delete []与new []配套。</p>
<p>在More Effective C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator delete来释放内存。”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MemTest *mTest1 = new MemTest[10];</span><br><span class="line">MemTest *mTest2 = new MemTest;</span><br><span class="line"></span><br><span class="line">Int *pInt1 = new int [10];</span><br><span class="line">Int *pInt2 = new int;</span><br><span class="line"></span><br><span class="line">delete[] pInt1;   //-1-</span><br><span class="line">delete[] pInt2;   //-2-</span><br><span class="line">delete[] mTest1;  //-3-</span><br><span class="line">delete[] mTest2;  //-4-  在-4-处报错。</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。  </p>
<p>delete[]删除一个数组，delete删除一个指针。</p>
<p>简单来说，用new分配的内存用delete删除；用new[]分配的内存用delete[]删除。delete[]会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。内存泄漏会最终会导致内存溢出。</p>
<p>内存泄漏的原因：</p>
<ol>
<li>异常或分支导致delete未得到执行</li>
<li>分配和释放不在一个函数里导致的遗漏delete</li>
</ol>
<h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，于是就发生了内存溢出。</p>
<h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p>野指针指向一个已删除的对象 或 申请访问受限内存区域的指针。</p>
<p>原因：</p>
<ol>
<li>指针变量未初始化。<strong>解决办法</strong>：指针声明时初始化，可以是具体的地址值，也可让它指向 NULL。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *p;   //此时p为野指针</span><br></pre></td></tr></table></figure></li>
<li>指针释放未置空：指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。<strong>解决办法</strong>：指针指向的内存空间被释放后指针应该指向。NULL。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *p=new char[10];  //指向堆中分配的内存首地址</span><br><span class="line">cin&gt;&gt; p;</span><br><span class="line">delete []p; //p重新变为野指针</span><br></pre></td></tr></table></figure></li>
<li>指针操作超出作用域。返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。<strong>解决办法</strong>：在变量的作用域结束前释放掉变量的地址空间并且让指针指向 NULL。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *p=new char[10];  //指向堆中分配的内存首地址</span><br><span class="line">cin&gt;&gt; p;</span><br><span class="line">cout&lt;&lt;*(p+10);  //可能输出未知数据</span><br></pre></td></tr></table></figure>
<em>ps. “野指针”的解决方法也是编程规范的基本原则，平时使用指针时一定要避免产生“野指针”，在使用指针前一定要检验指针的合法性。</em></li>
</ol>
<h2 id="栈内存与文字常量区"><a href="#栈内存与文字常量区" class="headerlink" title="栈内存与文字常量区"></a>栈内存与文字常量区</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char str1[] = &quot;abc&quot;;</span><br><span class="line">char str2[] = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">const char str3[] = &quot;abc&quot;;</span><br><span class="line">const char str4[] = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">const char *str5 = &quot;abc&quot;;</span><br><span class="line">const char *str6 = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">char *str7 = &quot;abc&quot;;</span><br><span class="line">char *str8 = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl;//0 分别指向各自的栈内存</span><br><span class="line">cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl;//0 分别指向各自的栈内存</span><br><span class="line">cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl;//1 指向文字常量区地址相同</span><br><span class="line">cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl;//1 指向文字常量区地址相同</span><br></pre></td></tr></table></figure>
<p>str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。</p>
<h2 id="ref-3"><a href="#ref-3" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://time.geekbang.org/column/article/169225">极客时间《现代C++实战30讲》：01 | 堆、栈、RAII：C++里该如何管理资源？</a></li>
<li><a href="https://zh.wikipedia.org/zh-cn/RAII">RAII(wiki)</a></li>
<li><a href="https://www.cnblogs.com/qg-whz/p/5060894.html">C++ 自由存储区是否等价于堆？</a></li>
<li><a href="https://www.zhihu.com/question/281940376">为什么c++中要分为heap（堆）和stack（栈）</a>  </li>
<li><a href="https://zhuanlan.zhihu.com/p/82298443">C&#x2F;C++内存分配</a></li>
<li><a href="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/">C&#x2F;C++内存管理详解</a></li>
</ul>
<h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><p>声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。</p>
<ol>
<li><strong>引用</strong>只是变量的一个别名，<strong>指针</strong>是变量的地址，有分配内存。</li>
<li><strong>指针</strong>可以指向空值，但是在任何情况下都不能使用指向空值的<strong>引用</strong>。引用在声明时必须初始化。</li>
<li>指针与引用的另一个重要的不同是：<strong>指针</strong>可以被重新赋值以指向另一个不同的对象，但是<strong>引用</strong>则总是指向在初始化时被指定的对象，以后不能改变。  </li>
<li><strong>sizeof的意义</strong>不同：使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小。</li>
<li>指针和引用的<strong>自增运算符意义</strong>不同：指针是对内存地址的自增，引用是对值的自增</li>
<li>没有引用常量，有指针常量</li>
<li>参数传递：作为参数传递时，指针需要被<strong>解引用</strong>才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象</li>
<li>多级指针，一级引用. 指针可以有多级指针（**p），而引用只有一级</li>
<li>作为参数时，引用更安全，因为指针传递时会涉及到形参和实参，会多开辟内存。</li>
</ol>
<p>在以下情况下你应该使用指针：</p>
<ul>
<li>你考虑到存在不指向任何对象的可能(在 这种情况下，你能够设置指针为空)</li>
<li>你需要能够在不同的时刻指向不同的对象(在这种情况下，你能改变指针的指向)。</li>
</ul>
<p>如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。</p>
<p><em>ps: 函数传参时，可以使用引用。<br>&amp;emsp;&amp;emsp;引用也可以作为函数的返回值。但是要注意<code>不要返回局部变量引用</code>。</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//返回局部变量引用</span><br><span class="line">int&amp; test01() &#123;</span><br><span class="line">	int a = 10; //局部变量</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回静态变量引用</span><br><span class="line">int&amp; test02() &#123;</span><br><span class="line">	static int a = 20;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ref-4"><a href="#ref-4" class="headerlink" title="ref"></a>ref</h2><ul>
<li>《more effective C++》 Item M1:指针与引用的区别  </li>
<li><a href="https://blog.csdn.net/weikangc/article/details/49762929">C++中指针和引用的区别</a></li>
<li><a href="https://github.com/twomonkeyclub/BackEnd/tree/master/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">C&#x2F;C++基础知识</a></li>
</ul>
<h1 id="函数参数传递中值传递、地址传递、引用传递有什么区别？"><a href="#函数参数传递中值传递、地址传递、引用传递有什么区别？" class="headerlink" title="函数参数传递中值传递、地址传递、引用传递有什么区别？"></a>函数参数传递中值传递、地址传递、引用传递有什么区别？</h1><ul>
<li>值传递，会为形参重新分配内存空间，将实参的值拷贝给形参，形参的值不会影响实参的值，函数调用结束后形参被释放；</li>
<li>引用传递，不会为形参重新分配内存空间，形参只是实参的别名，形参的改变会影响实参的值，函数调用结束后形参不会被释放；</li>
<li>地址传递，形参为指针变量，将实参的地址传递给函数，可以在函数中改变实参的值，调用时为形参指针变量分配内存，结束时释放指针变量。</li>
</ul>
<h1 id="常量指针，指针常量，常量引用，没有引用常量"><a href="#常量指针，指针常量，常量引用，没有引用常量" class="headerlink" title="常量指针，指针常量，常量引用，没有引用常量"></a>常量指针，指针常量，常量引用，没有引用常量</h1><ul>
<li>常量指针（常指针）：是一个指针，指向一个常量。</li>
<li>指针常量：是一个常量，这个常量的类型是指针</li>
<li>常量引用：是一个引用，是常量的引用</li>
<li>没有引用常量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//常量指针</span><br><span class="line">const int* p = &amp;a;  // *p 为常量，不能通过*p改变它指向的内容 </span><br><span class="line">int const* p = &amp;a;  // *p 为常量，同上</span><br><span class="line"></span><br><span class="line">//指针常量</span><br><span class="line">int* const p = &amp;a;  // p 为常量，初始化后不能再指向其它内容</span><br><span class="line"></span><br><span class="line">//指向常量的 常指针</span><br><span class="line">const int * const p;</span><br><span class="line">int const * const p;</span><br><span class="line"></span><br><span class="line">//常量引用</span><br><span class="line">int a = 10;</span><br><span class="line">const int &amp;r = a;</span><br><span class="line">const int &amp;r = 10;</span><br></pre></td></tr></table></figure>

<h1 id="常引用有什么作用"><a href="#常引用有什么作用" class="headerlink" title="常引用有什么作用"></a>常引用有什么作用</h1><p>常引用的引入主要是为了避免使用变量的引用时，在不知情的情况下改变变量的值。</p>
<p>常引用主要用于定义一个普通变量的只读属性的别名、作为函数的传入形参，避免实参在调用函数中被意外的改变。</p>
<p><strong>说明</strong>：很多情况下，需要用常引用做形参，被引用对象等效于常对象，不能在函数中改变实参的值，这样的好处是有较高的易读性和较小的出错率。</p>
<h1 id="指针常量与常量指针区别"><a href="#指针常量与常量指针区别" class="headerlink" title="指针常量与常量指针区别"></a>指针常量与常量指针区别</h1><ul>
<li><strong>指针常量</strong>是指这个指针的值只能在定义时初始化，其他地方不能改变。（重点在常量）</li>
<li><strong>常量指针</strong>是指这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。（重点在指针）</li>
</ul>
<p>指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。</p>
<p><em>注意：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。</em></p>
<h1 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h1><h2 id="指针和数组的区别"><a href="#指针和数组的区别" class="headerlink" title="指针和数组的区别"></a>指针和数组的区别</h2><ul>
<li><strong>概念不同</strong>。指针相当于一个变量，它存放的是数据在内存中的地址；数组是用于储存多个相同类型数据的集合</li>
<li><strong>赋值不同</strong>。同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝</li>
<li><strong>访问数据不同</strong>。指针是间接访问数据，获取指针，先解引用，再访问指针指向的地址中的内容；数组是直接访问</li>
<li><strong>sizeof意义不同</strong>。数组所占存储空间的内存：sizeof（数组名） 数组的大小：sizeof（数组名）&#x2F;sizeof（数据类型） 在32位平台下，sizeof（指针名）是4，在64位平台下，sizeof（指针名）是8</li>
<li><strong>指针和数组名异同</strong>。指针和数组名都可以表示地址，但指针是变量，可以修改；数组名是常量，不可修改赋值</li>
<li><strong>传参</strong>。数组传参时会退化成指针</li>
</ul>
<h2 id="指针数组和数组指针"><a href="#指针数组和数组指针" class="headerlink" title="指针数组和数组指针"></a>指针数组和数组指针</h2><ul>
<li><p>指针数组：它本质上是一个数组，数组的每个元素存放的是一个指针类型的元素。 int* arr[8];</p>
<ol>
<li>优先级问题：[]的优先级比*高</li>
<li>说明arr是一个数组，而int*是数组里面的内容</li>
<li>这句话的意思就是：arr是一个含有8和int*的数组</li>
</ol>
</li>
<li><p>数组指针：它本质上是一个指针，该指针指向一个数组。 int (*arr)[8];</p>
<ol>
<li>由于[]的优先级比<em>高，因此在写数组指针的时候必须将</em>arr用括号括起来</li>
<li>arr先和*结合，说明p是一个指针变量</li>
<li>这句话的意思就是：指针arr指向一个大小为8个整型的数组。</li>
</ol>
</li>
</ul>
<p><em>ps. 谁优先级高，本质是谁</em></p>
<h2 id="数组名和指针的区别"><a href="#数组名和指针的区别" class="headerlink" title="数组名和指针的区别"></a>数组名和指针的区别</h2><p>数组名并不是真正意义上的指针，它的内涵要比指针丰富的多。但是当数组名当做参数传递给函数后，其失去原来的含义，变作普通的指针。另外要注意 sizeof 不是函数，只是操作符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">	char str[13]=&quot;Hello world!&quot;;</span><br><span class="line">	char *pStr=&quot;Hello world!&quot;;</span><br><span class="line">	cout&lt;&lt;sizeof(str)&lt;&lt;endl; //13</span><br><span class="line">	cout&lt;&lt;sizeof(pStr)&lt;&lt;endl; //4</span><br><span class="line">	cout&lt;&lt;strlen(str)&lt;&lt;endl; //12</span><br><span class="line">	cout&lt;&lt;strlen(pStr)&lt;&lt;endl; //12</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>int a[10]和int* a &#x3D; new int[10]的区别：  </p>
<ul>
<li>int a[10]是静态分配</li>
<li>int* a&#x3D;new int[10]]是动态分配</li>
</ul>
<h2 id="数组的存放"><a href="#数组的存放" class="headerlink" title="数组的存放"></a>数组的存放</h2><ul>
<li>固定数组<ul>
<li>在函数体内分配的（不带static）是在栈中</li>
<li>全局变量&#x2F;带static的局部变量 是在全局数据存储区</li>
<li>类中分配的在堆中</li>
</ul>
</li>
<li>动态数组，都在堆中</li>
</ul>
<p>说明：</p>
<ol>
<li><code>int a[10]</code>使用简单，系统会自动实现内存的分配和回收。<code>int* a = new int[10]</code>需要判断内存是否分配成功，以及在不用时需要使用<code>delete[] a</code>进行内存释放，否则会造成内存泄漏； </li>
<li>如果不是<code>a[10]</code>，而是<code>a[1000000000]</code>或者更大的话，那一般情况下，就只能使用<code>int* a = new</code>这种方式了。这个涉及到内存存放位置的问题，<code>int a[]</code>这种方式，内存是存放在栈上；<code>int* a ＝ new</code>这种方式，内存是存放在堆上，栈的实际内存是连续内存，因此可分配空间较小，堆可以是非连续内存，因此可以分配较大内存。因此，如果需要分配较大内存，需要分配在堆上；（注意，同一个new出来的是连续内存，new一个一维数组确实是连续内存，但多个new出来的就不是连续内存了。）</li>
<li>使用<code>int a[10]</code>这种方式，内存大小需要用常量指定，比如这里的10。不能用<code>int m＝10; int a[m]</code>这种方式。但是<code>int* a= new</code>这种方式可以，因此在动态分配内存上，后者有非常大的优势。</li>
</ol>
<h2 id="ref-5"><a href="#ref-5" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://github.com/twomonkeyclub/BackEnd/tree/master/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">C&#x2F;C++基础知识</a></li>
<li><a href="https://blog.csdn.net/anycodes/article/details/41087785">C&#x2F;C++ 数组的初始化</a></li>
</ul>
<h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><p>C++另一种编程思想称为<strong>泛型编程</strong>，主要利用的技术就是模板。</p>
<p>C++提供两种模板机制：<strong>函数模板</strong> 和 <strong>类模板</strong></p>
<h2 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h2><p>函数模板作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>
<ul>
<li>template：声明创建模板  </li>
<li>typename：表面其后面的符号是一种数据类型，可以用class代替  </li>
<li>T：通用的数据类型，名称可以替换，通常为大写字母</li>
</ul>
<p>使用函数模板有两种方式：</p>
<ol>
<li>自动类型推导</li>
<li>显示指定类型</li>
</ol>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void mySwap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//利用模板实现交换</span><br><span class="line">//1、自动类型推导</span><br><span class="line">int a = 1, b = 2;</span><br><span class="line">mySwap(a, b);</span><br><span class="line"></span><br><span class="line">//2、显示指定类型</span><br><span class="line">mySwap&lt;int&gt;(a, b);</span><br></pre></td></tr></table></figure>

<h3 id="普通函数与函数模板的区别"><a href="#普通函数与函数模板的区别" class="headerlink" title="普通函数与函数模板的区别"></a>普通函数与函数模板的区别</h3><ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<h3 id="普通函数与函数模板的调用规则"><a href="#普通函数与函数模板的调用规则" class="headerlink" title="普通函数与函数模板的调用规则"></a>普通函数与函数模板的调用规则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//普通函数与函数模板调用规则</span><br><span class="line">void myPrint(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void myPrint(T a, T b) </span><br><span class="line">&#123; </span><br><span class="line">	cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void myPrint(T a, T b, T c) </span><br><span class="line">&#123; </span><br><span class="line">	cout &lt;&lt; &quot;调用重载的模板&quot; &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span><br><span class="line">	// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span><br><span class="line">	int a = 10;</span><br><span class="line">	int b = 20;</span><br><span class="line">	myPrint(a, b); //调用普通函数</span><br><span class="line"></span><br><span class="line">	//2、可以通过空模板参数列表来强制调用函数模板</span><br><span class="line">	myPrint&lt;&gt;(a, b); //调用函数模板</span><br><span class="line"></span><br><span class="line">	//3、函数模板也可以发生重载</span><br><span class="line">	int c = 30;</span><br><span class="line">	myPrint(a, b, c); //调用重载的函数模板</span><br><span class="line"></span><br><span class="line">	//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span><br><span class="line">	char c1 = &#x27;a&#x27;;</span><br><span class="line">	char c2 = &#x27;b&#x27;;</span><br><span class="line">	myPrint(c1, c2); //调用函数模板</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数模版实例"><a href="#函数模版实例" class="headerlink" title="函数模版实例"></a>函数模版实例</h3><p><em>转自下方参考1</em></p>
<p>利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序<br>排序规则从大到小，排序算法为选择排序<br>分别利用char数组和int数组进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//交换的函数模板</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void mySwap(T &amp;a, T&amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;class T&gt; // 也可以替换成typename</span><br><span class="line">//利用选择排序，进行对数组从大到小的排序</span><br><span class="line">void mySort(T arr[], int len)</span><br><span class="line">&#123;</span><br><span class="line">	for (int i = 0; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int max = i; //最大数的下标</span><br><span class="line">		for (int j = i + 1; j &lt; len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (arr[max] &lt; arr[j])</span><br><span class="line">			&#123;</span><br><span class="line">				max = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (max != i) //如果最大数的下标不是i，交换两者</span><br><span class="line">		&#123;</span><br><span class="line">			mySwap(arr[max], arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void printArray(T arr[], int len) &#123;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	//测试char数组</span><br><span class="line">	char charArr[] = &quot;bdcfeagh&quot;;</span><br><span class="line">	int num = sizeof(charArr) / sizeof(char);</span><br><span class="line">	mySort(charArr, num);</span><br><span class="line">	printArray(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	//测试int数组</span><br><span class="line">	int intArr[] = &#123; 7, 5, 8, 1, 3, 9, 2, 4, 6 &#125;;</span><br><span class="line">	int num = sizeof(intArr) / sizeof(int);</span><br><span class="line">	mySort(intArr, num);</span><br><span class="line">	printArray(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line">	test02();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类模版"><a href="#类模版" class="headerlink" title="类模版"></a>类模版</h2><p>类模板作用：建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>
<ul>
<li>template：声明创建模板</li>
<li>typename：表面其后面的符号是一种数据类型，可以用class代替</li>
<li>T：通用的数据类型，名称可以替换，通常为大写字母</li>
</ul>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;class NameType, class AgeType&gt; </span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;mName = name;</span><br><span class="line">		this-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	void showPerson()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="类模板与函数模板区别"><a href="#类模板与函数模板区别" class="headerlink" title="类模板与函数模板区别"></a>类模板与函数模板区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">//类模板</span><br><span class="line">template&lt;class NameType, class AgeType = int&gt; </span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;mName = name;</span><br><span class="line">		this-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	void showPerson()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//1、类模板没有自动类型推导的使用方式</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span><br><span class="line">	Person &lt;string ,int&gt;p(&quot;孙悟空&quot;, 1000); //必须使用显示指定类型的方式，使用类模板</span><br><span class="line">	p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2、类模板在模板参数列表中可以有默认参数</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	Person &lt;string&gt; p(&quot;猪八戒&quot;, 999); //类模板中的模板参数列表 可以指定默认参数</span><br><span class="line">	p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test01();</span><br><span class="line"></span><br><span class="line">	test02();</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ref-6"><a href="#ref-6" class="headerlink" title="ref"></a>ref</h2><p><a href="https://github.com/AnkerLeng/Cpp-0-1-Resource/blob/master/%E7%AC%AC5%E9%98%B6%E6%AE%B5-C%2B%2B%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E8%B5%84%E6%96%99/%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E8%B5%84%E6%96%99/%E8%AE%B2%E4%B9%89/C%2B%2B%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B.md">C++提高编程</a></p>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>不可修改</p>
<ul>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针和指针常量；int *const p和const int *p</li>
<li>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量，本质是const this指针。</li>
</ul>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>对外不可见</p>
<ul>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，在整个程序运行期间一直存在，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它，<strong>自动初始化为0</strong>。  <ul>
<li>全局变量作用域：全局静态变量在声明他的文件之外是不可见的，即便是 extern 外部声明也不可以。准确地说是从定义之处开始，到文件结尾。</li>
<li>局部变量作用域：仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</li>
</ul>
</li>
<li>修饰普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用</li>
<li>修饰类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过&lt;类名&gt;::&lt;静态成员&gt;来使用。在 static 函数内不能访问非静态成员</li>
</ul>
<p><a href="https://www.runoob.com/w3cnote/cpp-static-usage.html">static的用法</a></p>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>修饰变量或函数，表示该函数可以跨文件访问，或者表明该变量在其他文件定义，在此处引用。</p>
<p><strong>extern</strong>关键字的作用是共享代码。</p>
<ol>
<li>在其他文件中定义过的全局变量，在另一个文件中要调用时，只需在声明语句前加关键字extern。</li>
<li>对于常量，要调用其他文件的常量时，做法如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//文件1,定义常量</span><br><span class="line">extern const int i = 1;</span><br><span class="line"></span><br><span class="line">//文件2，声明常量</span><br><span class="line">extern const int i;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意：  </p>
<ul>
<li>定义也是声明，因为当定义变量时我们也向程序表明了它的类型和名字</li>
<li>但声明不是定义，可以通过使用extern关键字声明变量而不定义它。不定义变量的声明包括对象名、对象类型和对象类型前的关键字extern</li>
<li>extern声明不是定义，不分配存储空间</li>
</ul>
<p>ref.</p>
<ul>
<li><a href="https://blog.csdn.net/CSDNwei/article/details/51836182">extern使用方法总结</a></li>
</ul>
<h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef _cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">#include &quot;XXX.h&quot;</span><br><span class="line">#ifdef _cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>extern “C”的作用是，告诉C++编译器，下面的代码按照C的方式进行编译，不要对这些函数进行名字重整（function name mangling）。通常在C++程序中使用C函数或者模块时，需要用到这个功能。</p>
<p>ref.</p>
<ul>
<li><a href="https://blog.csdn.net/qq_38880380/article/details/80035710">C–变量的存储方式、作用域和生命周期</a></li>
<li><a href="https://blog.csdn.net/scottly1/article/details/44221157">extern “C”用法总结</a></li>
</ul>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>explicit关键字的作用就是防止对象间实现使用 “&#x3D;” 赋值，防止类构造函数的隐式自动转换,类构造函数默认情况下即声明为implicit(隐式)，另外explicit只用于单参数的构造函数，或者除了第一个参数以外的其他参数都有默认值.</p>
<ul>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换</li>
</ul>
<h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>用于程序中定义内联函数。</p>
<p>内联函数是C++中的一种特殊函数，它可以像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是通过将函数体直接插入调用处来实现的，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。一般来说inline用于定义类的成员函数。</p>
<p>在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。类内声明可以不用加上inline关键字，但是类外定义函数体时必须要加上，这样才能保证编译器能够识别其为内联函数。</p>
<p><em>ps. 内联函数不能包括复杂的控制语句，如循环语句和switch语句</em></p>
<p>示例：使用内联函数来返回两个数中的最大值  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inline int Max(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">   return (x &gt; y)? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h2><p>restrict只能修饰指针，restrict修饰的指针是能够访问所指区域的唯一入口，限制多个指针指向同一地址。</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile是给编译器的指示来说明对它所修饰的对象不应该执行优化。volatile的作用就是用来进行多线程编程。在单线程中那就是只能起到限制编译器优化的作用。</p>
<p>如果一个基本变量被volatile修饰，编译器将不会把它保存到寄存器中，而是每一次都去访问内存中实际保存该变量的位置上。这一点就避免了没有volatile修饰的变量在多线程的读写中所产生的由于编译器优化所导致的灾难性问题。所以多线程中必须要共享的基本变量一定要加上volatile修饰符。</p>
<h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><p>C++中4种类型转换为：</p>
<ol>
<li>static_cast<br>完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换，不能用于普通指针的转换（void空指针除外）</li>
<li>dynamic_cast<br>动态类型转换，用于实现RTTI（运行时类型检查）。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常bad_cast</li>
<li>const_cast<br>用于删除 const、volatile特性</li>
<li>reinterpret_cast<br>几乎什么都可以转,不能丢掉 const、volatile特性</li>
</ol>
<h1 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h1><p>多重继承（多继承，Multiple Inheritance，MI）指的是一个类可以同时继承多个类，比如A类继承自B类和C类，这就是多重继承。</p>
<h2 id="ref-7"><a href="#ref-7" class="headerlink" title="ref"></a>ref</h2><ul>
<li>Effective C++ 40：明智地使用多继承</li>
</ul>
<h1 id="变量的声明和定义有什么区别"><a href="#变量的声明和定义有什么区别" class="headerlink" title="变量的声明和定义有什么区别"></a>变量的声明和定义有什么区别</h1><p>为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但是只在一个地方定义。加入 <code>extern</code> 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。</p>
<h1 id="局部变量，静态局部变量，全局变量，静态全局变量的区别"><a href="#局部变量，静态局部变量，全局变量，静态全局变量的区别" class="headerlink" title="局部变量，静态局部变量，全局变量，静态全局变量的区别"></a>局部变量，静态局部变量，全局变量，静态全局变量的区别</h1><h2 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h2><ul>
<li>该变量在全局数据区分配内存；</li>
<li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li>
<li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0；</li>
<li>它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。</li>
</ul>
<h2 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h2><ul>
<li>静态变量都在全局数据区分配内存;</li>
<li>未经初始化的静态全局变量会被程序自动初始化为0（在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为 0）；</li>
<li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。</li>
</ul>
<h2 id="全局变量-和-静态全局变量-的区别"><a href="#全局变量-和-静态全局变量-的区别" class="headerlink" title="全局变量 和 静态全局变量 的区别"></a>全局变量 和 静态全局变量 的区别</h2><ul>
<li>全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。</li>
<li>静态全局变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。</li>
</ul>
<h2 id="存放区别"><a href="#存放区别" class="headerlink" title="存放区别"></a>存放区别</h2><p>全局（静态）存储区：分为 DATA 段和 BSS 段。DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。</p>
<p>全局初始化的变量：.data:<br>全局未初始化变量：.bss<br>全局只读：.rdata</p>
<h2 id="ref-8"><a href="#ref-8" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://www.runoob.com/w3cnote/cpp-static-usage.html">C&#x2F;C++ 中 static 的用法全局变量与局部变量</a></li>
<li><a href="https://www.cnblogs.com/bakari/archive/2012/08/05/2623637.html">局部变量，静态局部变量，全局变量，静态全局变量在内存中的存放区别</a></li>
<li><a href="https://blog.csdn.net/youyou519/article/details/82701083">全局初始化变量&#x2F;全局未初始化变量&#x2F;全局静态变量&#x2F;局部变量的存储位置，作用域，与生命周期</a></li>
</ul>
<h1 id="C-中哪些运算符不可以重载？"><a href="#C-中哪些运算符不可以重载？" class="headerlink" title="C++中哪些运算符不可以重载？"></a>C++中哪些运算符不可以重载？</h1><ol>
<li>.</li>
<li>?:</li>
<li>sizeof</li>
<li>::</li>
<li>*</li>
</ol>
<h1 id="简述C-异常处理方式"><a href="#简述C-异常处理方式" class="headerlink" title="简述C++异常处理方式"></a>简述C++异常处理方式</h1><p>一个典型的C++异常处理包含以下几个步骤：</p>
<ol>
<li>程序执行时发生错误；</li>
<li>以一个异常对象(最简单是一个整数)记录错误的原因及相关信息；</li>
<li>程序监测到这个错误(读取异常对象)；</li>
<li>程序决定如何处理错误；</li>
<li>进行错误处理，并在此后恢复&#x2F;终止程序的执行。</li>
</ol>
<h1 id="STL-Standard-Template-Library-标准模板库"><a href="#STL-Standard-Template-Library-标准模板库" class="headerlink" title="STL(Standard Template Library,标准模板库)"></a>STL(Standard Template Library,标准模板库)</h1><p>STL从广义上分为: <strong>容器(container)<strong>、</strong>算法(algorithm)<strong>、</strong>迭代器(iterator)</strong>  </p>
<p>容器和算法之间通过<strong>迭代器</strong>进行无缝连接。STL几乎所有的代码都采用了模板类或者模板函数。</p>
<p>STL大体分为六大组件，分别是：</p>
<ul>
<li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等</li>
<li>迭代器：扮演了容器与算法之间的胶合剂。</li>
<li>仿函数：行为类似函数，可作为算法的某种策略。</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>空间配置器：负责空间的配置与管理。</li>
</ul>
<h2 id="常用STL容器、算法、迭代器"><a href="#常用STL容器、算法、迭代器" class="headerlink" title="常用STL容器、算法、迭代器"></a>常用STL容器、算法、迭代器</h2><p>请看<a href="https://suzhilong.github.io/2020/07/12/STL/">「STL常用方法」</a></p>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>重载函数调用操作符的类，其对象常称为<strong>函数对象</strong></p>
<h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><p>函数对象使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong>。函数对象(仿函数)是一个类，不是一个函数。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class Multiply&#123;</span><br><span class="line">public:</span><br><span class="line">    double operator()(double x, double y) const &#123;return x*y;&#125;</span><br><span class="line">    double operator()(double x, int y) const &#123;return x*y;&#125;</span><br><span class="line">    double operator()(int x, double y) const &#123;return x*y;&#125;</span><br><span class="line">    int operator()(int x, int y) const &#123;return x*y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Multiply multiply;</span><br><span class="line">    cout &lt;&lt; &quot; 3.6 * 7 = &quot; &lt;&lt; multiply(3.6,7) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot; 3 * 7 = &quot; &lt;&lt; multiply(3,7) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数对象的特点"><a href="#函数对象的特点" class="headerlink" title="函数对象的特点"></a>函数对象的特点</h3><ul>
<li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul>
<h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>返回bool类型的仿函数称为<strong>谓词</strong>。如果operator()接受一个参数，那么叫做<strong>一元谓词</strong>；如果operator()接受两个参数，那么叫做<strong>二元谓词</strong>。</p>
<ol>
<li>一元谓词<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct GreaterFive&#123;</span><br><span class="line">	bool operator()(int val) &#123;</span><br><span class="line">		return val &gt; 5;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());</span><br></pre></td></tr></table></figure></li>
<li>二元谓词<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyCompare</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator()(int num1, int num2)</span><br><span class="line">	&#123;</span><br><span class="line">		return num1 &gt; num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sort(v.begin(), v.end());//默认从小到大</span><br><span class="line">sort(v.begin(), v.end(), MyCompare());//使用函数对象改变算法策略，排序从大到小</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="STL容器的底层数据结构"><a href="#STL容器的底层数据结构" class="headerlink" title="STL容器的底层数据结构"></a>STL容器的底层数据结构</h2><ol>
<li><p>vector  </p>
<ul>
<li>底层使用数组保存。  </li>
<li>push_back时若已经满了，则会2*n扩展空间，若实际元素数量低于分配空间的1&#x2F;4，则会将空间回收为原来的一半。  </li>
<li>扩容时，先申请新的空间，然后将旧空间的内容拷贝过去，然后再释放旧的空间。  </li>
<li>只适用于快速查找及只在末尾增删，而不适用于动态增删（可能涉及到元素的移动）。对元素进行增删时，可能导致旧的迭代器失效。防止迭代器失效的删除方法： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (vector&lt;int&gt;::iterator it = vec.begin();ite!=vec.end();)</span><br><span class="line">   &#123;</span><br><span class="line">       if(*it % 2 != 0) //删除vec中的奇数</span><br><span class="line">           it = vec.erase(it);</span><br><span class="line">       else</span><br><span class="line">           it++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>clear()可以清空所有元素，但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。可以用swap()来帮助你释放内存，也可以使用erase循环删除第一个。</li>
<li>vector和数组的区别<br> <img src="https://i.loli.net/2020/10/14/HijrufaCD6Rwebq.png" alt="vector和数组的区别"></li>
</ul>
</li>
<li><p>list  </p>
<ul>
<li>底层是双向链表，支持头尾增删，并且是一个环。  </li>
<li>不适用于查找频繁的情况，但适用于动态增删。</li>
</ul>
</li>
<li><p>stack  </p>
<ul>
<li>适配器。默认底层使用deque，适配之后只能从头插入和删除。</li>
</ul>
</li>
<li><p>queue  </p>
<ul>
<li>适配器。默认底层使用deque，适配之后只能从尾插入，从头删除。</li>
</ul>
</li>
<li><p>priority_queue</p>
<ul>
<li>适配器。一般以vector为底层容器，堆heap为处理规则来管理。</li>
</ul>
</li>
<li><p>map、multimap、set、multiset  </p>
<ul>
<li>底层使用红黑树实现，multimap是key值可重复的map。</li>
<li>防止迭代器失效的删除方法 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (auto it = m.begin(); it != m.end();)&#123;</span><br><span class="line">	if(it-&gt;second == 10)//删除val==10的元素</span><br><span class="line">		m.erase(it++);</span><br><span class="line">	else</span><br><span class="line">		it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>hash_map、hash_multimap、hash_set、hash_multiset  </p>
<ul>
<li>底层使用hashtable实现，其中hashtable是采用开链法来防止哈希冲突的。</li>
</ul>
</li>
<li><p>deque：  </p>
<ul>
<li>底层是一个分段的线性表。笼统的说就是使用了一个二维指针，第一维是每段的信息，而第二维就是一个数组了，实际保存的元素就是在这里。  </li>
<li>头尾都支持插入，但是维护麻烦很多。</li>
</ul>
</li>
<li><p>slist  </p>
<ul>
<li>使用单向链表实现的列表。</li>
</ul>
</li>
</ol>
<p><em>ps. queue，priority_queue，stack不是容器，是适配器，是对容器的再封装，没有迭代器</em></p>
<h2 id="vector和list的异同"><a href="#vector和list的异同" class="headerlink" title="vector和list的异同"></a>vector和list的异同</h2><ol>
<li>数据结构上的不同<ul>
<li>vector是用连续数组存储，内存空间连续，随机访问O(1)。内存不足是扩容一倍，申请更大的内存。</li>
<li>list底层是双向链表，不需要连续内存。插入删除O(1)，查找O(n)。</li>
</ul>
</li>
<li>迭代器<ul>
<li>vector中iterator支持”+”,”+&#x3D;”,”&lt;”等操作，list中不支持。</li>
</ul>
</li>
</ol>
<h2 id="push-back-和-emplace-back"><a href="#push-back-和-emplace-back" class="headerlink" title="push_back 和 emplace_back"></a>push_back 和 emplace_back</h2><p>C++11中，针对顺序容器(如vector、deque、list)，新标准引入了三个新成员：emplace_front、emplace和emplace_back，这些操作构造而不是拷贝元素。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定位置之前或容器尾部。</p>
<p>当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。</p>
<p>push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p>
<h2 id="map和unordered-map的区别"><a href="#map和unordered-map的区别" class="headerlink" title="map和unordered_map的区别"></a>map和unordered_map的区别</h2><ul>
<li>排序：map在缺省下，map按照递增的顺序进行排序；unordered_map不排序</li>
<li>内部原理：map内部采用了红黑树（自平衡的二叉搜索树），实现了数据排序；unordered_map内部采用了哈希表</li>
<li>搜索操作时间：map的搜索时间复杂度为O(log(n))；unordered_map平均搜索时间O(1)，最坏情况为O(n)</li>
<li>插入操作时间：map复杂度为log(n)+再平衡时间；unordered_map平均插入时间O(1)，最坏情况为O(n)</li>
<li>删除操作时间：与插入操作时间复杂度一样</li>
</ul>
<h2 id="ref-9"><a href="#ref-9" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://github.com/AnkerLeng/Cpp-0-1-Resource/blob/master/%E7%AC%AC5%E9%98%B6%E6%AE%B5-C%2B%2B%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E8%B5%84%E6%96%99/%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E8%B5%84%E6%96%99/%E8%AE%B2%E4%B9%89/C%2B%2B%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B.md">C++提高编程</a>：后半部分有STL库的常用方法</li>
<li><a href="https://blog.csdn.net/BostonRayAlen/article/details/93041395?utm_medium=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">C&#x2F;C++ 最常见50道面试题</a></li>
<li><a href="https://blog.csdn.net/hsq1596753614/article/details/80249605?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">C&#x2F;C++ 经典面试题（一）之常考概念</a></li>
<li><a href="https://blog.csdn.net/ljh0302/article/details/81098764?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">常见C++笔试面试题整理</a></li>
</ul>
<h1 id="C-11-新特性"><a href="#C-11-新特性" class="headerlink" title="C++ 11 新特性"></a>C++ 11 新特性</h1><ol>
<li>关键字及新语法：auto、nullptr、for</li>
<li>STL容器：std::array、std::forward_list、std::unordered_map、std::unordered_set</li>
<li>多线程：std::thread、std::atomic、std::condition_variable</li>
<li>智能指针内存管理：std::shared_ptr、std::weak_ptr、std::unique_ptr</li>
<li>其他：std::function、std::bind和lamda表达式</li>
<li>C++11中对类(class)新增的特性：<ul>
<li>default&#x2F;delete 控制默认函数</li>
<li>override &#x2F;final 强制重写&#x2F;禁止重写虚函数</li>
<li>委托构造函数 Delegating constructors</li>
<li>继承的构造函数 Inheriting constructors</li>
<li>类内部成员的初始化 Non-static data member initializers</li>
<li>移动构造和移动赋值</li>
</ul>
</li>
</ol>
<h2 id="nullptr常量"><a href="#nullptr常量" class="headerlink" title="nullptr常量"></a>nullptr常量</h2><p>C++中NULL仅仅是define NULL 0的一个宏定义，因此，有时候会产生歧义。<br>    - 比如f（char*）和f（int），参数传NULL的话到底该调用哪个？事实上，在VS下测试这样的函数重载会优先调用f（int），但是f（char *）也是正确的，因此C++引入nullptr来避免这个问题<br>    - nullptr是一个空指针，可以被转换成其他任意指针的类型</p>
<h2 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h2><p>让编译器替我们去分析表达式所属的类型，直接推导。尤其是STL中map的迭代器这种很长的类型，适合用auto。</p>
<h2 id="decltype操作符"><a href="#decltype操作符" class="headerlink" title="decltype操作符"></a>decltype操作符</h2><p>从表达式的类型推断出要定义的变量的类型，跟表达式的类型也就是参数类型紧密相关<br>    - delctype (f()) sum &#x3D; x; 并不实际调用函数f()，只是使用f()的返回值当做sum的类型<br>    - delctype (i) sum &#x3D; x;和delctype ((i)) sum &#x3D; x; 其中i为int类型，前面的为int类型，后面的为int&amp;引用</p>
<h2 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h2><p>多与auto配合使用。如 <code>for(auto n:nums)</code></p>
<h2 id="多线程互斥锁"><a href="#多线程互斥锁" class="headerlink" title="多线程互斥锁"></a>多线程互斥锁</h2><h3 id="pthread-mutex-t"><a href="#pthread-mutex-t" class="headerlink" title="pthread_mutex_t"></a>pthread_mutex_t</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//互斥量的创建</span><br><span class="line">pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); ///attr不写或传入NULL即可</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line">//加锁</span><br><span class="line">pthread_mutex_lock(pthread_mutex_t *mutex); //如果其他线程已经加锁了, 则阻塞让出CPU直到其他线程Unlock</span><br><span class="line">//pthread_mutex_trylock(pthread_mutex_t *mutex); //如果不能加锁立即返回</span><br><span class="line">·</span><br><span class="line">·</span><br><span class="line">·</span><br><span class="line">//解锁</span><br><span class="line">pthread_mutex_unlock(pthread_mutex_t *mutex);</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line">//互斥量的删除</span><br><span class="line">pthread_mutex_destroy(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure>

<h3 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h3><p><code>.lock()</code>、<code>.unlock()</code>、<code>lock_guard</code>、<code>unique_lock</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;mutex&gt;</span><br><span class="line"></span><br><span class="line">std::mutex m_mutex;</span><br><span class="line"></span><br><span class="line">//方法1</span><br><span class="line">m_mutex.lock();</span><br><span class="line">···</span><br><span class="line">m_mutex.unlock();</span><br><span class="line"></span><br><span class="line">//方法2：初始化的时候就是锁的lock操作的时候，超出它的作用域之后析构时unlock</span><br><span class="line">lock_guard&lt;mutex&gt; lock(m_mutex);</span><br><span class="line">···</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="双层vector"><a href="#双层vector" class="headerlink" title="双层vector"></a>双层vector</h2><p>vector&lt;vector<int> &gt;(n, vector<int>(n, 0))</p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>用于实现匿名函数，匿名函数只有函数体，没有函数名。  </p>
<p>用法：<code>[capture](parameters)-&gt;return-type &#123;body&#125;</code></p>
<p><code>[]</code>叫做捕获说明符，表示一个lambda表达式的开始。接下来<code>()</code>是参数列表，即这个匿名的lambda函数的参数，<code>-&gt;return-type</code>表示返回类型，如果没有返回类型，则可以省略这部分。最后<code>&#123;&#125;</code>就是函数体部分了。</p>
<p>lambda函数能够捕获lambda函数外的具有自动存储时期的变量。函数体与这些变量的集合合起来叫闭包。</p>
<ul>
<li>[] 不截取任何变量</li>
<li>[&amp;} 截取外部作用域中所有变量，并作为引用在函数体中使用</li>
<li>[&#x3D;] 截取外部作用域中所有变量，并拷贝一份在函数体中使用</li>
<li>[&#x3D;, &amp;foo] 截取外部作用域中所有变量，并拷贝一份在函数体中使用，但是对foo变量使用引用</li>
<li>[bar] 截取bar变量并且拷贝一份在函数体重使用，同时不截取其他变量</li>
<li>[x, &amp;y] x按值传递，y按引用传递</li>
<li>[this] 截取当前类中的this指针。如果已经使用了&amp;或者&#x3D;就默认添加此选项。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto func = [] () &#123; cout &lt;&lt; &quot;hello,world&quot;; &#125;;</span><br><span class="line">func(); //call the function</span><br><span class="line"></span><br><span class="line">auto func2 = [] () &#123; &#125;</span><br><span class="line"></span><br><span class="line">//sort函数的后面可以用lambda函数</span><br><span class="line">sort(vec.begin(), vec.end(), [](int a, int b)-&gt;bool&#123;return a &lt; b&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>放弃了C++98提供了第一个智能指针：<code>auto_ptr</code>。增加了3个新的智能指针：</p>
<ul>
<li>shared_ptr</li>
<li>weak_ptr</li>
<li>unique_ptr</li>
</ul>
<p>智能指针本质上是一个<strong>类</strong>，它将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。智能指针的出现实际上就是为了可以方便的控制对象的生命期，是 RAII 资源管理功能的自然展现。</p>
<p>STL一共给我们提供了四种智能指针：</p>
<ul>
<li>auto_ptr<br>C++98提供的解决方案，C+11已将将其摒弃。原因是避免潜在的内存崩溃问题：<strong>将一个auto_ptr赋值给另一个auto_ptr时，程序将试图删除同一个对象两次</strong>。</li>
<li>unique_ptr<br>当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做。</li>
<li>shared_ptr<br>采用<strong>引用计数</strong>的策略</li>
<li>weak_ptr<br>对于引用计数法实现的计数，总是避免不了循环引用（或环形引用）的问题，shared_ptr也不例外。为了解决类似这样的问题，C++11引入了weak_ptr，来打破这种循环引用。<br>weak_ptr是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是将一个shared_ptr赋值给weak_ptr不会改变shared_ptr的引用计数。不论是否有weak_ptr指向，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。</li>
</ul>
<p><em>ps：将一个智能指针赋值给另一个智能指针时有多种方法：<br>1）定义陚值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本，缺点是浪费空间，所以智能指针都未采用此方案。<br>2）建立所有权（ownership）概念。对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的构造函数会删除该对象。然后让赋值操作转让所有权。这就是用于auto_ptr和uniqiie_ptr 的策略，但unique_ptr的策略更严格。<br>3）创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1,。当减为0时才调用delete。这是shared_ptr采用的策略。</em></p>
<h2 id="ref-10"><a href="#ref-10" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://www.cnblogs.com/feng-sc/p/5710724.html">C++11常用特性的使用经验总结</a></li>
<li><a href="https://www.cnblogs.com/me115/p/4777997.html">C++11中对类(class)新增的特性</a></li>
<li><a href="https://time.geekbang.org/column/article/169263">极客时间《现代C++实战30讲》：02 | 自己动手，实现C++的智能指针</a></li>
<li><a href="https://www.cnblogs.com/lanxuezaipiao/p/4132096.html">C++智能指针简单剖析</a></li>
</ul>
<h1 id="C-中常用的设计模式"><a href="#C-中常用的设计模式" class="headerlink" title="C++中常用的设计模式"></a>C++中常用的设计模式</h1><p>共有23种设计模式，但真正在开发中常用的模式有：</p>
<ol>
<li><p>Factory Method(工厂模式)；</p>
</li>
<li><p>Strategy(策略模式)；</p>
</li>
<li><p>Singleton(单例模式)；</p>
<ul>
<li><a href="https://www.cnblogs.com/sunchaothu/p/10389842.html">C++ 单例模式总结与剖析</a></li>
<li>懒汉模式：不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//普通懒汉</span><br><span class="line">class Singleton</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	Singleton()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;constructor called&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Singleton(Singleton&amp;) = delete;</span><br><span class="line">	Singleton &amp;operator=(const Singleton&amp;) = delete;</span><br><span class="line">	static Singleton *instance_ptr;</span><br><span class="line">public:</span><br><span class="line">	~Singleton()&#123;</span><br><span class="line">		std::cout&lt;&lt;&quot;destructor called&quot;&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static Singleton* get_instance()&#123;</span><br><span class="line">		if(instance_ptr==nullptr)&#123;</span><br><span class="line">			instance_ptr = new Singleton;</span><br><span class="line">		&#125;</span><br><span class="line">		return instance_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance_ptr = nullptr;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	Singleton* instance = Singleton::get_instance();</span><br><span class="line">	Singleton* instance2 = Singleton::get_instance();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//线程安全、内存安全的懒汉式单例（智能指针，锁）</span><br><span class="line">class Singleton&#123;</span><br><span class="line">public:</span><br><span class="line">	typedef shared_ptr&lt;Singleton&gt; Ptr;</span><br><span class="line">	~Singleton()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static Ptr get_instance()&#123;</span><br><span class="line">		if(instance_ptr==nullptr)&#123;// &quot;double checked lock&quot;</span><br><span class="line">			std::lock_guard&lt;mutex&gt; lk(m_mutex);</span><br><span class="line">			if (instance_ptr == nullptr)</span><br><span class="line">				instance_ptr = Ptr(new Singleton);</span><br><span class="line">		&#125;</span><br><span class="line">		return instance_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	Singleton()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Singleton(Singleton &amp;) = delete;</span><br><span class="line">	Singleton &amp;operator=(const Singleton &amp;) = delete;</span><br><span class="line">	static Ptr instance_ptr;</span><br><span class="line">	static mutex m_mutex;//锁</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// initialization static variables out of class</span><br><span class="line">Singleton::Ptr Singleton::instance_ptr = nullptr;</span><br><span class="line">mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	Singleton::Ptr instance = Singleton::get_instance();</span><br><span class="line">	Singleton::Ptr instance1 = Singleton::get_instance();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//局部静态变量懒汉，最推荐</span><br><span class="line">class Singleton&#123;</span><br><span class="line">public:</span><br><span class="line">	~Singleton()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static Singleton&amp; get_instance()&#123;//返回指针而不是返回引用无法避免用户使用 delete instance 导致对象被提前销毁。</span><br><span class="line">		static Singleton instance;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	Singleton()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Singleton(Singleton &amp;) = delete;</span><br><span class="line">	Singleton &amp;operator=(const Singleton &amp;) = delete;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	Singleton&amp; instance = Singleton::get_instance();</span><br><span class="line">	Singleton&amp; instance1 = Singleton::get_instance();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>饿汉：在单例类定义的时候就进行实例化 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">public:</span><br><span class="line">	~Singleton()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	static Singleton* get_instance()&#123;</span><br><span class="line">		return instance_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	static Singleton* instance_ptr;</span><br><span class="line">	Singleton()&#123;</span><br><span class="line">		cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Singleton(Singleton &amp;) = delete;</span><br><span class="line">	Singleton &amp;operator=(const Singleton &amp;) = delete;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton *Singleton::instance_ptr = new Singleton();</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	Singleton* instance = Singleton::get_instance();</span><br><span class="line">	Singleton* instance1 = Singleton::get_instance();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Iterator(迭代器模式)；</p>
</li>
<li><p>Abstract Factory(抽象工厂模式)；</p>
</li>
<li><p>Builder(建造者模式)；</p>
</li>
<li><p>Adapter(适配器模式)；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Target &#123;  // Target，客户期望的接口，可以使具体或抽象的类，也可以是接口</span><br><span class="line">public:</span><br><span class="line">    virtual void Request() = 0;</span><br><span class="line">    virtual ~Target()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Adaptee &#123; //需适配的类</span><br><span class="line">public:</span><br><span class="line">    void SpecificRequest() &#123; cout &lt;&lt; &quot;Adaptee&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Adapter1 : public Target &#123; //通过内部包装一个Adaptee对象，把源接口转换为目标接口：</span><br><span class="line">private:</span><br><span class="line">    Adaptee* adaptee;</span><br><span class="line">public:</span><br><span class="line">    Adapter1() &#123; adaptee = new Adaptee(); &#125;</span><br><span class="line">    void Request() &#123; adaptee-&gt;SpecificRequest(); &#125;  // 调用Request()方法会转换成调用adaptee.SpecificRequest()</span><br><span class="line">    ~Adapter1() &#123; delete adaptee; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Adapter2 : public Target&#123;</span><br><span class="line">private:</span><br><span class="line">    Adaptee *adaptee;</span><br><span class="line">public:</span><br><span class="line">    Adapter2() &#123; adaptee = new Adaptee(); &#125;</span><br><span class="line">    void Request() &#123; adaptee-&gt;SpecificRequest(); &#125;</span><br><span class="line">    ~Adapter2() &#123; delete adaptee; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Target *target = new Adapter1();</span><br><span class="line">    target-&gt;Request();</span><br><span class="line">    delete target;</span><br><span class="line"></span><br><span class="line">    Target *target2 = new Adapter2();</span><br><span class="line">    target-&gt;Request();</span><br><span class="line">    delete target2;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Bridge(桥接模式)；</p>
</li>
<li><p>Composite(组合模式)；</p>
</li>
<li><p>Interpreter(解释器模式)；</p>
</li>
<li><p>Command(命令模式)；</p>
</li>
<li><p>Mediator(中介者模式)；</p>
</li>
<li><p>Observer(观察者模式)；</p>
</li>
<li><p>State(状态模式)；</p>
</li>
<li><p>Proxy(代理模式)。</p>
</li>
</ol>
<h1 id="设计模式6大原则"><a href="#设计模式6大原则" class="headerlink" title="设计模式6大原则"></a>设计模式6大原则</h1><ol>
<li>单一职责原则(Single Responsibility Principle)</li>
<li>开放封闭原则（Open Close Principle）</li>
<li>里氏替换原则（Liskov Substitution Principle）</li>
<li>依赖倒置原则（Dependence Inversion Principle）</li>
<li>接口隔离原则（InterfaceSegregation Principles）</li>
<li>迪米特原则（Law of Demeter）也称最少知识原则</li>
</ol>
<h1 id="对编程规范的理解或认识"><a href="#对编程规范的理解或认识" class="headerlink" title="对编程规范的理解或认识"></a>对编程规范的理解或认识</h1><p>编程规范可总结为：</p>
<ul>
<li>可行性</li>
<li>可读性</li>
<li>可移植性</li>
<li>可测试性</li>
</ul>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/153444857?utm_source=wechat_session&utm_medium=social&utm_oi=717486596282130432">C++ 继承、多态、重载、友元</a></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>SOUSIC的algorithm总结</title>
    <url>/2020/05/25/algorithm/</url>
    <content><![CDATA[<h1 id="一、算法基础"><a href="#一、算法基础" class="headerlink" title="一、算法基础"></a>一、算法基础</h1><!--&emsp;&emsp;春节后疫情一直没开学，赋闲在家刷了一个多月的算法，总结了一下，形成了下面的文章。包含了`数据结构类`例题和`算法类`例题，-->
<p>大部分是Leecode中的典型题目，也有笔试中的真题和剑指Offer中的题目。题解使用C++，代码均由本人在参考题解之后所写。<br><a href="https://github.com/suzhilong/CS">相关github</a>  </p>
<span id="more"></span>
<h2 id="1-1-常用数据结构"><a href="#1-1-常用数据结构" class="headerlink" title="1.1 常用数据结构"></a>1.1 常用数据结构</h2><h3 id="1-1-1-链表"><a href="#1-1-1-链表" class="headerlink" title="1.1.1 链表"></a>1.1.1 链表</h3><p>链表又分为<code>单链表（线性链表）</code>、<code>双向链表</code>、<code>循环链表</code></p>
<h3 id="1-1-2-栈和队列"><a href="#1-1-2-栈和队列" class="headerlink" title="1.1.2 栈和队列"></a>1.1.2 栈和队列</h3><p><code>栈</code>：后进先出（last-in,first-out,LIFO）<br><code>队列</code>：先进先出（first-in,first-out,FIFO）<br><code>双端队列</code>：一种特殊的队列，两端都可以进出</p>
<h3 id="1-1-3-二叉树"><a href="#1-1-3-二叉树" class="headerlink" title="1.1.3 二叉树"></a>1.1.3 二叉树</h3><p>是树型结构的一种特殊形式。二叉树中，刷题中用到的有</p>
<ul>
<li><code>二叉搜索树/二叉查找树</code>，即左子树中的结点都比父结点小，右子树中的结点都比父结点大。</li>
<li><code>平衡树二叉树（AVL树）</code>，就是在二叉树的基础上，若树中每棵子树都满足其左子树和右子树的深度差都不超过 1，则这棵二叉树就是平衡二叉树。</li>
</ul>
<p>按照访问结点顺序的不同，可以将二叉树的<code>遍历</code>分为 <code>前序遍历</code>、<code>中序遍历</code>、<code>后序遍历</code>。</p>
<h3 id="1-1-4-图"><a href="#1-1-4-图" class="headerlink" title="1.1.4 图"></a>1.1.4 图</h3><p>图是由<code>顶点</code>和<code>边</code>构成的数据结构，一般来说，顶点表示的是数据，边表示数据之间的联系。图可以简单的分为<code>有向图</code>和<code>无向图</code>。<br>可以用<code>二维数组</code>来存储一个图。</p>
<h3 id="1-1-5-堆"><a href="#1-1-5-堆" class="headerlink" title="1.1.5 堆"></a>1.1.5 堆</h3><ul>
<li>大根堆</li>
<li>小根堆</li>
</ul>
<h2 id="1-2-时间复杂度、空间复杂度"><a href="#1-2-时间复杂度、空间复杂度" class="headerlink" title="1.2 时间复杂度、空间复杂度"></a>1.2 时间复杂度、空间复杂度</h2><p>算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，把算法的执行时间记为T(n)&#x3D;O(f(n))，他们的增长率相同，称做算法的渐进时间复杂度，简称<code>时间复杂度</code>。<br>相似的，<code>空间复杂度</code>S(n)&#x3D;O(f(n))用来度量算法所需的存储空间。</p>
<h2 id="1-3-排序（Sorting）、查找-x2F-搜索（Search）"><a href="#1-3-排序（Sorting）、查找-x2F-搜索（Search）" class="headerlink" title="1.3 排序（Sorting）、查找&#x2F;搜索（Search）"></a>1.3 排序（Sorting）、查找&#x2F;搜索（Search）</h2><h3 id="1-3-1-排序"><a href="#1-3-1-排序" class="headerlink" title="1.3.1 排序"></a>1.3.1 排序</h3><p>常用的八大排序：  </p>
<ul>
<li>插入排序</li>
<li>希尔排序</li>
<li>选择排序</li>
<li>冒泡排序</li>
<li>快速排序</li>
<li>堆排序</li>
<li>归并排序</li>
<li>基数排序</li>
</ul>
<p><img src="https://i.loli.net/2020/06/19/eLGVs6wMJf9BOyr.png" alt="排序复杂度"></p>
<h3 id="1-3-2-查找-x2F-搜索"><a href="#1-3-2-查找-x2F-搜索" class="headerlink" title="1.3.2 查找&#x2F;搜索"></a>1.3.2 查找&#x2F;搜索</h3><p><code>顺序查找</code>：一般情况下步长为1。根据不同的要求，会设置不同的步长。时间复杂度为O(n)。<br><code>二分查找（Binary Search，又叫折半查找）</code>：每次都与一个中点 <code>mid = (low+hight)/2</code> 相比较，时间复杂度为O(logn)。<br><code>二叉搜索/查找树</code>：见1.1.3。<code>中序遍历</code>二叉搜索树可以<code>有序</code>的输出关键字。<br><code>树的遍历</code>：前序遍历（根、左、右）、中序遍历（左、根、右）、后序遍历（左、右、根）。<br><code>广度优先搜索（BFS）</code>：类似于树的层序遍历，先访问最近一层所有的结点，再访问下一层的。<br><code>深度优先（DFS）</code>：类似于树的先序遍历，直到没有下一个结点才返回父结点。</p>
<h2 id="1-4-递归"><a href="#1-4-递归" class="headerlink" title="1.4 递归"></a>1.4 递归</h2><p>简单来说，递归的基本思想就是自己调用自己，这样就把问题变成了更小的子问题。<br>需要注意的是，递归函数中需要设置一个<code>终止条件</code>，以保证子问题最小时不再往下递归。</p>
<h2 id="1-5-分治"><a href="#1-5-分治" class="headerlink" title="1.5 分治"></a>1.5 分治</h2><p>分治策略中，需要递归的求解一个问题，在每层递归中会用到三个步骤[算法导论]：</p>
<ul>
<li>分解(Divide)：将原问题划分为规模更小的子问题。</li>
<li>解决(Conquer)：递归的求解子问题。如果子问题足够小，停止递归直接求解。</li>
<li>合并(Combine)：将子问题的解合成原问题的解。</li>
</ul>
<h1 id="二、数据结构类例题"><a href="#二、数据结构类例题" class="headerlink" title="二、数据结构类例题"></a>二、数据结构类例题</h1><p>主要从Leetcode的题中选出的代表性例题，也包括笔试或者其他资料上看到的比较好的题目。解答使用的cpp。  </p>
<h2 id="2-1-栈"><a href="#2-1-栈" class="headerlink" title="2.1 栈"></a>2.1 栈</h2><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><h4 id="1-739-每日温度（中等）"><a href="#1-739-每日温度（中等）" class="headerlink" title="1. 739. 每日温度（中等）"></a>1. <a href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度（中等）</a></h4><p>根据每日 <code>气温</code> 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 <code>0</code> 来代替。<br>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</span><br></pre></td></tr></table></figure>

<p>题解：<br>维护一个单调递减的栈，栈中元素为温度值的索引。当前温度比栈顶索引温度低时，直接进栈；当前温度比栈顶索引温度高时，两个索引之间的差就是栈顶索引值所求结果。<br><a href="https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/">视频讲解</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;</span><br><span class="line">    int n = T.size();</span><br><span class="line">    vector&lt;int&gt; res(n,0);</span><br><span class="line">    stack&lt;int&gt; s;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        while (!s.empty() &amp;&amp; T[i] &gt; T[s.top()]) &#123;</span><br><span class="line">            int previousIndex = s.top();</span><br><span class="line">            res[previousIndex] = i - previousIndex;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)。空间复杂度O(n)。</p>
<h3 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h3><h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h4><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 <code>-1</code> )</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>
<p>题解：<br>一个栈入，一个栈出。当要插入数据时，直接插入入栈；当要取出数据时，如果出栈不为空，则从入栈依次取出放入出栈，直到入栈为空。这样就能保证<strong>后进先出</strong>。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CQueue &#123;</span><br><span class="line">    stack&lt;int&gt; inputStack, outputStack;</span><br><span class="line">public:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">        while(!inputStack.empty())</span><br><span class="line">            inputStack.pop();</span><br><span class="line">        while(!outputStack.empty())</span><br><span class="line">            outputStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void appendTail(int value) &#123;</span><br><span class="line">        inputStack.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int deleteHead() &#123;</span><br><span class="line">        if(outputStack.empty())&#123;</span><br><span class="line">            while(!inputStack.empty())&#123;</span><br><span class="line">                outputStack.push(inputStack.top());</span><br><span class="line">                inputStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(outputStack.empty())</span><br><span class="line">            return -1;</span><br><span class="line">        else&#123;</span><br><span class="line">            int output = outputStack.top();</span><br><span class="line">            outputStack.pop();</span><br><span class="line">            return output;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="栈排序"><a href="#栈排序" class="headerlink" title="栈排序"></a>栈排序</h3><h4 id="使用两个栈进行排序（或着说使用一个辅助栈对栈进行排序）"><a href="#使用两个栈进行排序（或着说使用一个辅助栈对栈进行排序）" class="headerlink" title="使用两个栈进行排序（或着说使用一个辅助栈对栈进行排序）"></a>使用两个栈进行排序（或着说使用一个辅助栈对栈进行排序）</h4><p>每次都往辅助栈中放如当前剩余的最大的值，最后直到当前栈空了，再把辅助栈转移回去就可以完成排序。</p>
<p>弹出一个数：</p>
<ul>
<li>辅助栈为空，push</li>
<li>辅助栈不为空，如果弹出值大于辅助栈顶，则弹出辅助栈的元素放入当前栈，直到遇到小于或等于的就push进辅助栈。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//栈顶最大</span><br><span class="line">void sortStackByStack(stack&lt;int&gt; &amp;st)&#123;</span><br><span class="line">    stack&lt;int&gt; help;</span><br><span class="line">    while(!st.empty())&#123;</span><br><span class="line">        int curr=st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        while(!help.empty() &amp;&amp; curr&gt;help.top() )&#123;</span><br><span class="line">            st.push(help.top());</span><br><span class="line">            help.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        help.push(curr);</span><br><span class="line">    &#125;</span><br><span class="line">    while(!help.empty())&#123;</span><br><span class="line">        int tmp=help.top();</span><br><span class="line">        help.pop();</span><br><span class="line">        st.push(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-2-二叉树"><a href="#2-2-二叉树" class="headerlink" title="2.2 二叉树"></a>2.2 二叉树</h2><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历可以实现很多树相关的操作，如二叉树的序列化。二叉树的序列化本质上是对其值进行编码，更重要的是对其结构进行编码。可以遍历树来完成。  </p>
<p><a href="https://github.com/suzhilong/Algorithm/blob/master/BinaryTree/BinaryTreeTraversal.cpp">二叉树遍历的cpp实现</a></p>
<p>我们一般有两个策略：</p>
<h4 id="BFS（即层序遍历）：BFS-可以按照层次的顺序从上到下遍历所有的节点"><a href="#BFS（即层序遍历）：BFS-可以按照层次的顺序从上到下遍历所有的节点" class="headerlink" title="BFS（即层序遍历）：BFS 可以按照层次的顺序从上到下遍历所有的节点"></a>BFS（即层序遍历）：BFS 可以按照层次的顺序从上到下遍历所有的节点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void levelOrder(BinaryTree *root)&#123;</span><br><span class="line">    queue&lt;BinaryTree *&gt; que;</span><br><span class="line">    que.push(root);</span><br><span class="line"></span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        BinaryTree *curNode = que.front();</span><br><span class="line">        cout &lt;&lt; curNode-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">        que.pop();</span><br><span class="line">        if(curNode-&gt;lc!=nullptr)</span><br><span class="line">            que.push(curNode-&gt;lc);</span><br><span class="line">        if(curNode-&gt;rc!=nullptr)</span><br><span class="line">            que.push(curNode-&gt;rc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DFS：DFS-可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将DFS策略区分为："><a href="#DFS：DFS-可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将DFS策略区分为：" class="headerlink" title="DFS：DFS 可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将DFS策略区分为："></a>DFS：DFS 可以从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。根据根节点、左节点和右节点之间的相对顺序，可以进一步将DFS策略区分为：</h4><h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//递归</span><br><span class="line">void preOrder_recursion(BinaryTree *root)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return;</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">    preOrder_recursion(root-&gt;lc);</span><br><span class="line">    preOrder_recursion(root-&gt;rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//非递归</span><br><span class="line">void preOrder_non_recursion(BinaryTree *root)&#123;</span><br><span class="line">    stack&lt;BinaryTree *&gt; st;</span><br><span class="line"></span><br><span class="line">    while(root!=nullptr || !st.empty())&#123;</span><br><span class="line">        if(root!=nullptr)&#123;</span><br><span class="line">            cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">            st.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            root = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            root = root-&gt;rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//递归</span><br><span class="line">void inOrder_recursion(BinaryTree *root)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return;</span><br><span class="line">    inOrder_recursion(root-&gt;lc);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">    inOrder_recursion(root-&gt;rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//非递归</span><br><span class="line">void inOrder_non_recursion(BinaryTree *root)&#123;</span><br><span class="line">    stack&lt;BinaryTree *&gt; st;</span><br><span class="line"></span><br><span class="line">    while(root!=nullptr || !st.empty())&#123;</span><br><span class="line">        if(root!=nullptr)&#123;</span><br><span class="line">            st.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            root = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">            root = root-&gt;rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//递归</span><br><span class="line">void posOrder_recursion(BinaryTree *root)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return;</span><br><span class="line">    posOrder_recursion(root-&gt;lc);</span><br><span class="line">    posOrder_recursion(root-&gt;rc);</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//非递归</span><br><span class="line">void posOrder_non_recursion(BinaryTree *root)&#123;</span><br><span class="line">    stack&lt;BinaryTree *&gt; st;</span><br><span class="line">    BinaryTree *lastVisited = root;</span><br><span class="line"></span><br><span class="line">    while(root!=nullptr || !st.empty())&#123;</span><br><span class="line">        if(root!=nullptr)&#123;</span><br><span class="line">            st.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            root = st.top();</span><br><span class="line">            if(root-&gt;lc == nullptr || root-&gt;rc == lastVisited)&#123;</span><br><span class="line">                cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">                st.pop();</span><br><span class="line">                lastVisited = root;</span><br><span class="line">                root = nullptr;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                root = root-&gt;rc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Z形遍历-x2F-锯齿形遍历"><a href="#Z形遍历-x2F-锯齿形遍历" class="headerlink" title="Z形遍历&#x2F;锯齿形遍历"></a>Z形遍历&#x2F;锯齿形遍历</h4><p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">Leetcode 103. 二叉树的锯齿形层次遍历（中等）</a><br>在层序遍历的基础上加了一个<code>reverse</code>标记，<code>reverse</code>为<code>true</code>时反向遍历。由于头和尾都要插入和弹出，使用双端队列<code>deque</code>会好一些，使用<code>vector</code>的<code>insert</code>比较耗时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    deque&lt;TreeNode *&gt; dque;</span><br><span class="line">    dque.push_back(root);</span><br><span class="line">    bool reverse = false;</span><br><span class="line">    while(!dque.empty())&#123;</span><br><span class="line">        int n = dque.size();</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        TreeNode *cur;</span><br><span class="line">        while(n--)&#123;</span><br><span class="line">            if(reverse)&#123;//后取前放</span><br><span class="line">                cur = dque.back();</span><br><span class="line">                dque.pop_back();</span><br><span class="line">                if(cur-&gt;right) dque.push_front(cur-&gt;right);//先右再左</span><br><span class="line">                if(cur-&gt;left) dque.push_front(cur-&gt;left);</span><br><span class="line">            &#125;else&#123;//前取后放</span><br><span class="line">                cur = dque.front();</span><br><span class="line">                dque.pop_front();</span><br><span class="line">                if(cur-&gt;left) dque.push_back(cur-&gt;left);//先左再右</span><br><span class="line">                if(cur-&gt;right) dque.push_back(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.push_back(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        reverse = !reverse;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h3 id="1-1028-从先序遍历还原二叉树（困难）"><a href="#1-1028-从先序遍历还原二叉树（困难）" class="headerlink" title="1. 1028. 从先序遍历还原二叉树（困难）"></a>1. <a href="https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/">1028. 从先序遍历还原二叉树（困难）</a></h3><p>我们从二叉树的根节点 root 开始进行深度优先搜索。<br>在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。<br>如果节点只有一个子节点，那么保证该子节点为左子节点。<br>给出遍历输出 S，还原树并返回其根节点 root。</p>
<p>示例1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;1-2--3--4-5--6--7&quot;</span><br><span class="line">输出：[1,2,5,3,4,6,7]</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;1-2--3---4-5--6---7&quot;</span><br><span class="line">输出：[1,2,5,3,null,6,null,4,null,7]</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;1-401--349---90--88&quot;</span><br><span class="line">输出：[1,401,null,349,88,90]</span><br></pre></td></tr></table></figure>
<p>题解：<br>当前节点为T，上一个节点为S，只有两种情况：</p>
<ul>
<li>T 是 S 的左子节点；</li>
<li>T 是根节点到 S 这一条路径上（不包括 S，因为题目中规定了如果节点只有一个子节点，那么保证该子节点为左子节点）某一个节点的右子节点。</li>
</ul>
<p>所以，我们用一个栈保存<strong>根节点</strong>到当前节点的<strong>上一个节点</strong>的路径：</p>
<ol>
<li><strong>当前节点</strong>的深度刚好比<strong>栈的高度</strong>大1：<strong>当前节点</strong>正好是<strong>栈顶节点</strong>的<strong>左子节点</strong>；<em>ps. 深度是从0开始，所以当深度的值和栈高度相等时，就是深度刚好比栈的高度大1</em></li>
<li><strong>当前节点</strong>的深度小于等于<strong>栈的高度</strong>：<ul>
<li><strong>当前节点</strong>的深度刚和<strong>栈的高度</strong>相等：<strong>当前节点</strong>是<strong>栈顶节点右兄弟节点</strong>即<strong>栈顶节点父节点的右子节点</strong>；</li>
<li><strong>当前节点</strong>的深度小于<strong>栈的高度</strong>：<strong>当前节点</strong>是<strong>根节点</strong>到<strong>栈顶节点</strong>路径上某一个节点的<strong>右子节点</strong>。一直弹出栈顶节点直到满足情况<code>1</code>。</li>
<li>*ps. <strong>当前节点</strong>的深度刚和<strong>栈的高度</strong>相等 即 <code>level=path.size()-1</code>，也是需要弹出栈顶节点一次*<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeNode* recoverFromPreorder(string S) &#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; path;</span><br><span class="line">    int pos = 0;</span><br><span class="line">    while(pos&lt;S.size())&#123;</span><br><span class="line">        int level = 0;</span><br><span class="line">        while(S[pos]==&#x27;-&#x27;)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int value = 0;</span><br><span class="line">        while (pos &lt; S.size() &amp;&amp; isdigit(S[pos]))&#123;//取当前节点的值</span><br><span class="line">            value = value * 10 + (S[pos] - &#x27;0&#x27;);</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *node = new TreeNode(value);</span><br><span class="line">        if(level==path.size())&#123;//第1种情况</span><br><span class="line">            if(!path.empty())</span><br><span class="line">                path.top()-&gt;left = node;</span><br><span class="line">        &#125;else&#123;//第2种情况</span><br><span class="line">            while(level!=path.size())</span><br><span class="line">                path.pop();</span><br><span class="line">            path.top()-&gt;right = node;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    while(path.size()&gt;1)</span><br><span class="line">        path.pop();</span><br><span class="line">    return path.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n)。n为S的长度<br>空间复杂度：O(h)。h为树的高度</li>
</ul>
</li>
</ol>
<h3 id="2-104-二叉树的最大深度（简单）"><a href="#2-104-二叉树的最大深度（简单）" class="headerlink" title="2. 104. 二叉树的最大深度（简单）"></a>2. <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度（简单）</a></h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明</strong>: 叶子节点是指没有子节点的节点。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>层序遍历（BFS）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxDepth(TreeNode* root)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return 0;</span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">    que.push(root);</span><br><span class="line">    int hight = 0;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        hight++;</span><br><span class="line">        int n = que.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *curNode = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            if(curNode-&gt;left!=nullptr)</span><br><span class="line">                que.push(curNode-&gt;left);</span><br><span class="line">            if(curNode-&gt;right!=nullptr)</span><br><span class="line">                que.push(curNode-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return hight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
</li>
<li><p>递归。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxDepth(TreeNode* root)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return 0;</span><br><span class="line">    return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(hight)</p>
</li>
</ol>
<h3 id="3-110-平衡二叉树（简单）"><a href="#3-110-平衡二叉树（简单）" class="headerlink" title="3. 110. 平衡二叉树（简单）"></a>3. <a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树（简单）</a></h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回 true 。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   2</span><br><span class="line">    / \</span><br><span class="line">   3   3</span><br><span class="line">  / \</span><br><span class="line"> 4   4</span><br><span class="line">返回 false 。</span><br></pre></td></tr></table></figure>
<p>题解：<br>用到上一题的求深度。</p>
<ol>
<li><p>自上而下递归。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int getHight(TreeNode *root)&#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return 0;</span><br><span class="line">    return max(getHight(root-&gt;left),getHight(root-&gt;right))+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">    if(root==nullptr)</span><br><span class="line">        return true;</span><br><span class="line">    return abs(getHight(root-&gt;left)-getHight(root-&gt;right))&lt;2 </span><br><span class="line">            &amp;&amp; isBalanced(root-&gt;left)</span><br><span class="line">            &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)<br>空间复杂度：O(n)</p>
</li>
<li><p>自下而上递归。加了一个<code>hight</code>记录子树高度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool helper(TreeNode *root, int &amp;height)&#123;</span><br><span class="line">    if(root==nullptr)&#123;</span><br><span class="line">        height = -1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int left,right;</span><br><span class="line">    if(helper(root-&gt;left,left) &amp;&amp; helper(root-&gt;right,right) &amp;&amp; abs(left-right)&lt;2)&#123;</span><br><span class="line">        height = max(left,right)+1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">    int height;</span><br><span class="line">    return helper(root,height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
</li>
</ol>
<h3 id="4-530-二叉搜索树的最小绝对差（简单）"><a href="#4-530-二叉搜索树的最小绝对差（简单）" class="headerlink" title="4. 530. 二叉搜索树的最小绝对差（简单）"></a>4. <a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差（简单）</a></h3><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    /</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。</span><br></pre></td></tr></table></figure>
<p>题解：<br>搜索二叉树的中序遍历就是升序排列，所以中序遍历是记录上一个节点的值，就可以求差值，维护一个最小值可以一边遍历得到答案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int res = INT_MAX;</span><br><span class="line">void midOrder(TreeNode* root, int &amp;last)&#123; //注意last要用引用，不然弹栈的时候上一个节点的值不能被记录</span><br><span class="line">    if(!root)</span><br><span class="line">        return;</span><br><span class="line">    midOrder(root-&gt;left, last);</span><br><span class="line">    if(last==-1)</span><br><span class="line">        last = root-&gt;val;</span><br><span class="line">    else</span><br><span class="line">        res = min(res, abs(root-&gt;val-last));</span><br><span class="line">    last = root-&gt;val;</span><br><span class="line">    midOrder(root-&gt;right, last);</span><br><span class="line">&#125;</span><br><span class="line">int getMinimumDifference(TreeNode* root) &#123;</span><br><span class="line">    int last = -1;</span><br><span class="line">    midOrder(root, last);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)，搜索二叉树可以会退化成链</p>
<h3 id="5-剑指-Offer-68-I-二叉搜索树的最近公共祖先（简单）"><a href="#5-剑指-Offer-68-I-二叉搜索树的最近公共祖先（简单）" class="headerlink" title="5. 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先（简单）"></a>5. <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先（简单）</a></h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br><span class="line">    6</span><br><span class="line">   / \</span><br><span class="line">  2   8</span><br><span class="line"> /\   /\</span><br><span class="line">0  4 7  9</span><br><span class="line">  /\</span><br><span class="line"> 3  5</span><br></pre></td></tr></table></figure>
<p>题解：<br>要判断一个节点的左子树里有p，右子树里有q，那么当前节点就是最近公共祖先。从上往下遍历的时候，如果<code>(p-&gt;val &lt;= cur-&gt;val &amp;&amp; cur-&gt;val &lt;= q-&gt;val)</code>则说明该节点cur就是最近公共祖先了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">    while(root)&#123;</span><br><span class="line">        if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        else if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        else</span><br><span class="line">            return root;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h3 id="6-236-二叉树的最近公共祖先（中等）"><a href="#6-236-二叉树的最近公共祖先（中等）" class="headerlink" title="6. 236. 二叉树的最近公共祖先（中等）"></a>6. <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先（中等）</a></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先 Lowest Common Ancestor(LCA)。上一题是二叉搜索树。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  5   1</span><br><span class="line"> /\   /\</span><br><span class="line">6  2 0  8</span><br><span class="line">  /\</span><br><span class="line"> 7  4</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>递归。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeNode* ans;</span><br><span class="line">bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">    if (root == nullptr) return false;</span><br><span class="line">    bool lson = dfs(root-&gt;left, p, q);</span><br><span class="line">    bool rson = dfs(root-&gt;right, p, q);</span><br><span class="line">    if ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson)))&#123;// (左右都包含p/q) || (一边子树包含另p/q + 一边root节点是p/q)</span><br><span class="line">        ans = root;</span><br><span class="line">    &#125; </span><br><span class="line">    return lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val); //左子树包含||右子树包含||root为p/q</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">    dfs(root, p, q);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>可以用哈希表存储所有节点的父节点，然后就可以利用节点的父节点信息从 p 结点开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;int, TreeNode*&gt; parents;</span><br><span class="line">unordered_map&lt;int, bool&gt; visited;</span><br><span class="line">void dfs(TreeNode* root)&#123;//记录父节点</span><br><span class="line">    if (root-&gt;left != nullptr) &#123;</span><br><span class="line">        parents[root-&gt;left-&gt;val] = root;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    if (root-&gt;right != nullptr) &#123;</span><br><span class="line">        parents[root-&gt;right-&gt;val] = root;</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">    parents[root-&gt;val] = nullptr;</span><br><span class="line">    dfs(root);</span><br><span class="line">    while (p != nullptr) &#123;//从p往上走，也可以从q</span><br><span class="line">        visited[p-&gt;val] = true;</span><br><span class="line">        p = parents[p-&gt;val];</span><br><span class="line">    &#125;</span><br><span class="line">    while (q != nullptr) &#123;</span><br><span class="line">        if (visited[q-&gt;val]) return q;</span><br><span class="line">        q = parents[q-&gt;val];//从q往上走，碰到的第一个已经访问过的节点即为LCA节点</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h2 id="2-3-链表"><a href="#2-3-链表" class="headerlink" title="2.3 链表"></a>2.3 链表</h2><h3 id="面试题-02-01-移除重复节点（简单）"><a href="#面试题-02-01-移除重复节点（简单）" class="headerlink" title="面试题 02.01. 移除重复节点（简单）"></a><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/">面试题 02.01. 移除重复节点（简单）</a></h3><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<p>示例1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1, 2, 3, 3, 2, 1]</span><br><span class="line">输出：[1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1, 1, 1, 1, 2]</span><br><span class="line">输出：[1, 2]</span><br></pre></td></tr></table></figure>
<p>题解：<br>用一个哈希表(<code>unordered_set</code>)保存已有元素。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode* removeDuplicateNodes(ListNode* head) &#123;</span><br><span class="line">    if(head==nullptr || head-&gt;next==nullptr)</span><br><span class="line">        return head;</span><br><span class="line"></span><br><span class="line">    unordered_set&lt;int&gt; valSet;</span><br><span class="line">    ListNode *lastNode = head;</span><br><span class="line">    ListNode *cur = head-&gt;next;</span><br><span class="line">    valSet.insert(head-&gt;val);</span><br><span class="line">    while (cur != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if(valSet.find(cur-&gt;val) == valSet.end())&#123;//非重复节点</span><br><span class="line">            valSet.insert(cur-&gt;val);</span><br><span class="line">            lastNode-&gt;next = cur;</span><br><span class="line">            lastNode = lastNode-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;else&#123;//重复节点</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lastNode-&gt;next = cur;//nullptr</span><br><span class="line"></span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)  </p>
<p><em>ps. 在不允许用额外空间的情况下，可以用两重循环。时间O(n^2) ，空间o(1)。</em></p>
<h3 id="206-反转链表（简单）"><a href="#206-反转链表（简单）" class="headerlink" title="206. 反转链表（简单）"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表（简单）</a></h3><p>反转一个单链表。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>遍历反转。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">    if(head==nullptr || head-&gt;next==nullptr)</span><br><span class="line">        return head;</span><br><span class="line">    ListNode *pre = nullptr;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    while(cur!=nullptr)&#123;</span><br><span class="line">        ListNode *tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1) </p>
<ol start="2">
<li>递归。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">    if(head==nullptr || head-&gt;next==nullptr)</span><br><span class="line">        return head;</span><br><span class="line">    ListNode *cur = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = nullptr;</span><br><span class="line">    return cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h3 id="25-K-个一组翻转链表（困难）"><a href="#25-K-个一组翻转链表（困难）" class="headerlink" title="25. K 个一组翻转链表（困难）"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表（困难）</a></h3><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</span><br><span class="line"></span><br><span class="line">当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair&lt;ListNode*, ListNode*&gt; reverseList(ListNode* head, ListNode* rear)&#123;</span><br><span class="line">    ListNode *pre = rear-&gt;next;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    while(pre != rear)&#123;</span><br><span class="line">        ListNode *tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;rear, head&#125;;//非递归反转链表并返回新链表头尾</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode* reverseKGroup(ListNode* head, int k) &#123;</span><br><span class="line">	ListNode *res = new ListNode(0);</span><br><span class="line">	res-&gt;next = head;</span><br><span class="line">	ListNode *preNode = res, *L = head;</span><br><span class="line">	ListNode *R, *nextNode;</span><br><span class="line">	while(L)&#123;</span><br><span class="line">		R = preNode;</span><br><span class="line">		for (int i = 0; i &lt; k; i++)&#123;  //选出要反转的k个</span><br><span class="line">			R = R-&gt;next;</span><br><span class="line">			if(R==nullptr)//剩下的不足k个直接返回</span><br><span class="line">				return res-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		nextNode = R-&gt;next;</span><br><span class="line">		auto ret = reverseList(L, R);</span><br><span class="line">		L = ret.first;</span><br><span class="line">		R = ret.second;</span><br><span class="line">        //把子链表重新接回原链表</span><br><span class="line">		preNode-&gt;next = L;</span><br><span class="line">		R-&gt;next = nextNode;</span><br><span class="line">		preNode = R;</span><br><span class="line">		L = R-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return res-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h3 id="92-反转链表-II（中等）"><a href="#92-反转链表-II（中等）" class="headerlink" title="92. 反转链表 II（中等）"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II（中等）</a></h3><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p><strong>说明</strong>:1 ≤ m ≤ n ≤ 链表长度。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>遍历交换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode* reverseBetween(ListNode* head, int m, int n) &#123;</span><br><span class="line">    if(m==n)</span><br><span class="line">        return head;</span><br><span class="line">    if(m==1)&#123;</span><br><span class="line">        ListNode *lastRevers = head;</span><br><span class="line">        ListNode *pre = lastRevers;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        for(int i=m;i&lt;n;i++)&#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        lastRevers-&gt;next = cur;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        ListNode *before = head;</span><br><span class="line">        for(int i=1;i&lt;m-1;i++)</span><br><span class="line">            before = before-&gt;next;</span><br><span class="line">        ListNode *lastRevers = before-&gt;next;</span><br><span class="line">        ListNode *pre = lastRevers;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        for(int i=m;i&lt;n;i++)&#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        before-&gt;next = pre;</span><br><span class="line">        lastRevers-&gt;next = cur;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
</li>
<li><p>头插法。双指针，一个指针 A 指向要反转的前一个节点<code>m-1</code>，一个指针 B 指向要反转的第一个节点<code>m</code>。B在往后移动时，不停的把B后面的一个节点移到A后面，一直到<code>n-1</code>结束。这时已经反转了要求的链表。<br><em>ps. new一个节点指向头节点，就可以解决<code>m=1</code>的情况</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode* reverseBetween(ListNode* head, int m, int n) &#123;</span><br><span class="line">    ListNode *preHead = new ListNode(0);</span><br><span class="line">    preHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    ListNode *A = preHead;</span><br><span class="line">    ListNode *B = head;</span><br><span class="line"></span><br><span class="line">    int step = 0;</span><br><span class="line">    while (step &lt; m - 1) &#123;</span><br><span class="line">        A = A-&gt;next; B = B-&gt;next;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n - m; i++) &#123;</span><br><span class="line">        ListNode *removed = B-&gt;next;</span><br><span class="line">        B-&gt;next = B-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        removed-&gt;next = A-&gt;next;</span><br><span class="line">        A-&gt;next = removed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return preHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
</li>
</ol>
<h3 id="142-环形链表-II（中等）"><a href="#142-环形链表-II（中等）" class="headerlink" title="142. 环形链表 II（中等）"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II（中等）</a></h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p><strong>说明</strong>：不允许修改给定的链表。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li><p>哈希表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">    unordered_map&lt;ListNode*,int&gt; nodeMap;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    while(cur)&#123;</span><br><span class="line">        if(++nodeMap[cur]&gt;1)</span><br><span class="line">            return cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
</li>
<li><p>快慢指针。<br>快指针一次走2步，慢指针一次走一步。</p>
</li>
</ol>
<ul>
<li>快指针走到nullptr，说明无环</li>
<li>快指针慢指针第一次相遇节点记为<code>mark</code>，这时把慢指针移到头节点，快指针不变。他们都继续移动，都是一次走一步。当两个指针再次相遇时，就是头节点。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">    if(head == nullptr || head-&gt;next == nullptr)</span><br><span class="line">        return nullptr;</span><br><span class="line">    ListNode *fast = head, *slow = head;</span><br><span class="line">    do&#123;</span><br><span class="line">        if(fast == nullptr || fast-&gt;next == nullptr)</span><br><span class="line">            return nullptr;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;while(fast!=slow);</span><br><span class="line"></span><br><span class="line">    slow = head;</span><br><span class="line">    while(fast!=slow)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n)<br>空间复杂度：O(1)</li>
</ul>
<h2 id="2-4-图"><a href="#2-4-图" class="headerlink" title="2.4 图"></a>2.4 图</h2><h3 id="1-5211-概率最大的路径（中等）"><a href="#1-5211-概率最大的路径（中等）" class="headerlink" title="1. 5211. 概率最大的路径（中等）"></a>1. <a href="https://leetcode-cn.com/problems/path-with-maximum-probability/">5211. 概率最大的路径（中等）</a></h3><p>给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 edges[i] &#x3D; [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。</p>
<p>指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。</p>
<p>如果不存在从 start 到 end 的路径，请 返回 0 。只要答案与标准答案的误差不超过 1e-5 ，就会被视作正确答案。</p>
<p>示例 1：<br><img src="https://i.loli.net/2020/07/12/GXVphrYafON5jFw.png" alt="ex1"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ul>
<li>先建图。<code>graph[i]</code> 表示第 <code>i</code> 个节点能够到达的下一个节点及概率。</li>
<li>bfs把与当前节点有连接的节点存入一个大根堆。（如果只用队列会出错）</li>
<li><code>hasVisited[i]</code> 表示 <code>i</code> 节点是否被访问过</li>
<li>循环直到堆为空</li>
</ul>
<p>其实就是 <code>Dijkstra</code> 算法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const double zero = 1e-8;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;pair&lt;int,double&gt; &gt; &gt; buildGrapg(vector&lt;vector&lt;int&gt; &gt; &amp;edges, vector&lt;double&gt;&amp; succProb, int n)&#123;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;int,double&gt; &gt; &gt; graph(n);</span><br><span class="line">    for (int i = 0; i &lt; edges.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        graph[edges[i][0]].emplace_back(edges[i][1],succProb[i]);</span><br><span class="line">        graph[edges[i][1]].emplace_back(edges[i][0],succProb[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double maxProbability(int n, vector&lt;vector&lt;int&gt; &gt;&amp; edges, vector&lt;double&gt;&amp; succProb, int start, int end) &#123;</span><br><span class="line">    if(edges.empty())</span><br><span class="line">        return 0.0;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;int,double&gt; &gt; &gt; graph = buildGrapg(edges, succProb, n);</span><br><span class="line">    if(graph[end].empty() || graph[start].empty())</span><br><span class="line">        return 0.0;</span><br><span class="line"></span><br><span class="line">    vector&lt;double&gt; prob(n, 0.0); //从start到每个节点的最大概率</span><br><span class="line">    prob[start] = 1;</span><br><span class="line">    priority_queue&lt;pair&lt;double, int&gt; &gt; que;</span><br><span class="line">    vector&lt;bool&gt; hasVisited(n， false);</span><br><span class="line">    que.push(&#123;1, start&#125;);</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        auto cur = que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        double p = cur.first;</span><br><span class="line">        int node = cur.second;</span><br><span class="line">        if(hasVisited[node])</span><br><span class="line">            continue;</span><br><span class="line">        hasVisited[node] = true;</span><br><span class="line">        if(p&lt;zero)</span><br><span class="line">            continue;</span><br><span class="line">        for(auto edge:graph[node])&#123;</span><br><span class="line">            int v = edge.first;</span><br><span class="line">            double curProb = p * edge.second;</span><br><span class="line">            if(prob[v]&lt;curProb)&#123;</span><br><span class="line">                prob[v] = curProb;</span><br><span class="line">                que.push(&#123;prob[v], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return prob[end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-207-课程表（中等）有向图的拓扑排序"><a href="#2-207-课程表（中等）有向图的拓扑排序" class="headerlink" title="2. 207. 课程表（中等）有向图的拓扑排序"></a>2. <a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表（中等）</a>有向图的拓扑排序</h3><p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p>
<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。</span><br><span class="line">你可以假定输入的先决条件中没有重复的边。</span><br><span class="line">1 &lt;= numCourses &lt;= 10^5</span><br></pre></td></tr></table></figure>

<p>题解：  </p>
<ol>
<li>有向图的dfs遍历。<br><code>visited[i]</code>表示第i和节点的状态，0表示没有被访问过，1表示正在被访问，2表示访问结束的节点。<code>circle</code>表示有向图有环。使用dfs遍历有向图：</li>
</ol>
<ul>
<li>当正在访问的节点（visited[i]&#x3D;1）又被访问时，说明有向图存在环，返回false。</li>
<li>全部节点访问完毕，返回true<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool circle = false;</span><br><span class="line"></span><br><span class="line">void dfs(int u, vector&lt;vector&lt;int&gt; &gt; &amp;graph, vector&lt;int&gt; &amp;visited)&#123;</span><br><span class="line">    visited[u] = 1;//正在访问该节点</span><br><span class="line">    for(int v:graph[u])&#123;</span><br><span class="line">        if(visited[v]==0)&#123;</span><br><span class="line">            dfs(v, graph, visited);</span><br><span class="line">            if(circle)</span><br><span class="line">                return;</span><br><span class="line">        &#125;else if(visited[v]==1)&#123;</span><br><span class="line">            circle = true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123;</span><br><span class="line">    if(prerequisites.empty())</span><br><span class="line">        return true;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graph(numCourses);</span><br><span class="line">    for (auto course : prerequisites)</span><br><span class="line">    &#123;//build graph</span><br><span class="line">        graph[course[1]].push_back(course[0]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; visited(numCourses);</span><br><span class="line">    for (int i = 0; i &lt; numCourses &amp;&amp; !circle; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visited[i])</span><br><span class="line">            dfs(i, graph, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    return !circle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(m+n)。m是有向图的边，n是有向图的节点。<br>空间复杂度：O(m+n)</li>
</ul>
<ol start="2">
<li>bfs入度为0的点<br>拓扑排序中，起点都是入度为0的点。把所有入度为0的节点放入队列，依次访问队列中的节点。访问的时候把所有从该节点出去的边都删掉，即该节点出发连接的边的入度都减1。再把入度减到0的点加入队列。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123;</span><br><span class="line">    if(prerequisites.empty())</span><br><span class="line">        return true;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graph(numCourses);</span><br><span class="line">    vector&lt;int&gt; inDegree(numCourses, 0);</span><br><span class="line">    for (auto course : prerequisites)</span><br><span class="line">    &#123;//build graph</span><br><span class="line">        graph[course[1]].push_back(course[0]);</span><br><span class="line">        inDegree[course[0]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    for (int i = 0; i &lt; numCourses;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(inDegree[i]==0)</span><br><span class="line">            que.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int visited = 0;</span><br><span class="line">    while (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        visited++;</span><br><span class="line">        int u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int v:graph[u])&#123;</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            if(inDegree[v]==0)</span><br><span class="line">                que.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return visited == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(m+n)。m是有向图的边，n是有向图的节点。<br>空间复杂度：O(m+n)</li>
</ol>
<h3 id="3-210-课程表-II（中等）"><a href="#3-210-课程表-II（中等）" class="headerlink" title="3.210. 课程表 II（中等）"></a>3.<a href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II（中等）</a></h3><p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p>
<p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: [0,1]</span><br><span class="line">解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。</span><br><span class="line">你可以假定输入的先决条件中没有重复的边。</span><br></pre></td></tr></table></figure>
<p>提示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</span><br><span class="line">通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</span><br><span class="line">拓扑排序也可以通过 BFS 完成。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>dfs。和上一题基本相同，只需要在节点访问完成时放入结果向量，因为dfs先访问的是最后的节点，所以需要把向量反转一下。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool circle = false;</span><br><span class="line">vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">void dfs(int u, vector&lt;vector&lt;int&gt; &gt; &amp;graph, vector&lt;int&gt; &amp;visited)&#123;</span><br><span class="line">    visited[u] = 1;//正在访问该节点</span><br><span class="line">    for(int v:graph[u])&#123;</span><br><span class="line">        if(visited[v]==0)&#123;</span><br><span class="line">            dfs(v, graph, visited);</span><br><span class="line">            if(circle)</span><br><span class="line">                return;</span><br><span class="line">        &#125;else if(visited[v]==1)&#123;</span><br><span class="line">            circle = true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = 2;</span><br><span class="line">    res.push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graph(numCourses);</span><br><span class="line">    for (auto course : prerequisites)</span><br><span class="line">    &#123;//build graph</span><br><span class="line">        graph[course[1]].push_back(course[0]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; visited(numCourses);</span><br><span class="line">    for (int i = 0; i &lt; numCourses &amp;&amp; !circle; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visited[i])</span><br><span class="line">            dfs(i, graph, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    if(circle)</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>bfs。同上题，只需要在节点访问完成时放入结果向量。时空复杂度与上题相同。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; graph(numCourses);</span><br><span class="line">    vector&lt;int&gt; inDegree(numCourses, 0);</span><br><span class="line">    for (auto course : prerequisites)</span><br><span class="line">    &#123;//build graph</span><br><span class="line">        graph[course[1]].push_back(course[0]);</span><br><span class="line">        inDegree[course[0]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    for (int i = 0; i &lt; numCourses;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(inDegree[i]==0)</span><br><span class="line">            que.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    int visited = 0;</span><br><span class="line">    while (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        visited++;</span><br><span class="line">        int u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        res.push_back(u);</span><br><span class="line">        for (int v : graph[u])</span><br><span class="line">        &#123;</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            if(inDegree[v]==0)</span><br><span class="line">                que.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(visited!=numCourses)</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-133-克隆图（中等）"><a href="#4-133-克隆图（中等）" class="headerlink" title="4.133. 克隆图（中等）"></a>4.<a href="https://leetcode-cn.com/problems/clone-graph/">133. 克隆图（中等）</a></h3><p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p>
<p>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>bfs</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Node* cloneGraph(Node* node) &#123;</span><br><span class="line">    if (node == nullptr) &#123;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line"></span><br><span class="line">    // 将题目给定的节点添加到队列</span><br><span class="line">    queue&lt;Node*&gt; que;</span><br><span class="line">    que.push(node);</span><br><span class="line">    // 克隆第一个节点并存储到哈希表中</span><br><span class="line">    visited[node] = new Node(node-&gt;val);</span><br><span class="line"></span><br><span class="line">    // 广度优先搜索</span><br><span class="line">    while (!que.empty()) &#123;</span><br><span class="line">        // 取出队列的头节点</span><br><span class="line">        auto curNode = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        // 遍历该节点的邻居</span><br><span class="line">        for (auto&amp; neighbor: curNode-&gt;neighbors) &#123;</span><br><span class="line">            if (visited.find(neighbor) == visited.end()) &#123;</span><br><span class="line">                // 如果没有被访问过，就克隆并存储在哈希表中</span><br><span class="line">                visited[neighbor] = new Node(neighbor-&gt;val);</span><br><span class="line">                // 将邻居节点加入队列中</span><br><span class="line">                que.push(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新当前节点的邻居列表</span><br><span class="line">            visited[curNode]-&gt;neighbors.emplace_back(visited[neighbor]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return visited[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>dfs<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line"></span><br><span class="line">Node* cloneGraph(Node* node) &#123;</span><br><span class="line">    if (node == nullptr) &#123;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(visited.find(node) != visited.end())</span><br><span class="line">        return visited[node];</span><br><span class="line"></span><br><span class="line">    Node *cloneNode = new Node(node-&gt;val);</span><br><span class="line">    visited[node] = cloneNode;</span><br><span class="line"></span><br><span class="line">    for(auto &amp;neighbor:node-&gt;neighbors)&#123;</span><br><span class="line">        cloneNode-&gt;neighbors.push_back(cloneGraph(neighbor));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return visited[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n)<br>空间复杂度：O(n)</li>
</ol>
<h2 id="2-5-堆"><a href="#2-5-堆" class="headerlink" title="2.5 堆"></a>2.5 堆</h2><h3 id="1-给一个数组h，h有n个元素；每次可以给数组h中最小的元素加x；总共可以加m次。求m次运算后的数组最小值。"><a href="#1-给一个数组h，h有n个元素；每次可以给数组h中最小的元素加x；总共可以加m次。求m次运算后的数组最小值。" class="headerlink" title="1. 给一个数组h，h有n个元素；每次可以给数组h中最小的元素加x；总共可以加m次。求m次运算后的数组最小值。"></a>1. 给一个数组<code>h</code>，<code>h</code>有<code>n</code>个元素；每次可以给数组<code>h</code>中最小的元素加<code>x</code>；总共可以加<code>m</code>次。求<code>m</code>次运算后的数组最小值。</h3><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：a = &#123;1,2,3&#125;, n = 3, x = 1, m =2</span><br><span class="line"></span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p>题解：<br>维护一个小根堆。每次从堆顶取出最小值，加上<code>x</code>后在放入堆中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int minimalAfterAdd(vector&lt;int&gt; &amp;h, int n, int m, int x)&#123;</span><br><span class="line">    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; pq;</span><br><span class="line">    for(int i:h)</span><br><span class="line">        pq.push(i);</span><br><span class="line"></span><br><span class="line">    while(m&gt;0)&#123;</span><br><span class="line">        int tmp = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        pq.push(tmp + x);</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pq.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-重复数组变换"><a href="#2-重复数组变换" class="headerlink" title="2. 重复数组变换"></a>2. 重复数组变换</h3><p><img src="https://i.loli.net/2020/07/29/N1O2xGlCm54yuQI.png" alt="堆例题"></p>
<p>题解：<br>用一个<code>map&lt;int,索引小根堆&gt;</code>来保存数组元素和索引。map是默认是按key升序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool repeat(map&lt;int, priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; &gt; &amp;numMap, map&lt;int, priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; &gt;::iterator &amp;iter)&#123;</span><br><span class="line">    /*检查有没有重复的元素，并返回了重复元素的 it*/</span><br><span class="line">    for (auto it = numMap.begin(); it != numMap.end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(it-&gt;second.size()&gt;1)&#123;</span><br><span class="line">            iter = it;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; delRepeat(vector&lt;int&gt; &amp;a)&#123;</span><br><span class="line">    int n = a.size();</span><br><span class="line">    //map&lt;元素，索引小根堆&gt;</span><br><span class="line">    map&lt;int, priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; &gt; numMap;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">        numMap[a[i]].push(i);</span><br><span class="line"></span><br><span class="line">    auto it = numMap.begin();</span><br><span class="line">    while (repeat(numMap,it))</span><br><span class="line">    &#123;</span><br><span class="line">        //it: &#123;第一个重复的元素,索引堆&#125;</span><br><span class="line">        it-&gt;second.pop();</span><br><span class="line">        int idx = it-&gt;second.top();</span><br><span class="line">        it-&gt;second.pop();</span><br><span class="line">        numMap[it-&gt;first * 2].push(idx);</span><br><span class="line">        a[idx] *= 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set&lt;int&gt; sIdx;</span><br><span class="line">    for (auto m : numMap)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!m.second.empty())&#123;</span><br><span class="line">            sIdx.insert(m.second.top());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for(int i:sIdx)&#123;</span><br><span class="line">        res.push_back(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、算法类例题"><a href="#三、算法类例题" class="headerlink" title="三、算法类例题"></a>三、算法类例题</h1><p>主要从Leetcode的题中选出的代表性例题，也包括笔试或者其他资料上看到的比较好的题目。<br><em>ps: 题解使用的 <code>cpp</code></em>  </p>
<h2 id="3-1-分治算法（Divide-and-conquer）"><a href="#3-1-分治算法（Divide-and-conquer）" class="headerlink" title="3.1 分治算法（Divide and conquer）"></a>3.1 分治算法（Divide and conquer）</h2><h3 id="Leetcode-241-为运算表达式设计优先级（中等）"><a href="#Leetcode-241-为运算表达式设计优先级（中等）" class="headerlink" title="Leetcode 241. 为运算表达式设计优先级（中等）"></a><a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">Leetcode 241. 为运算表达式设计优先级（中等）</a></h3><p>给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: &quot;2-1-1&quot; </span><br><span class="line">((2-1)-1) = 0</span><br><span class="line">(2-(1-1)) = 2</span><br><span class="line">Output : [0, 2]</span><br></pre></td></tr></table></figure>
<p>题解：<br>符号分开成左右两边，递归求出左右两边的结果，再排列组合成新结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; diffWaysToCompute(string s)&#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for (int i = 0; i &lt; s.size();i++)&#123;</span><br><span class="line">        if(s[i]==&#x27;+&#x27; || s[i]==&#x27;-&#x27; || s[i]==&#x27;*&#x27;)&#123;</span><br><span class="line">            vector&lt;int&gt; left = diffWaysToCompute(s.substr(0, i));</span><br><span class="line">            vector&lt;int&gt; right = diffWaysToCompute(s.substr(i + 1));</span><br><span class="line">            for(int l:left)&#123;</span><br><span class="line">                for(int r:right)&#123;</span><br><span class="line">                    if(s[i]==&#x27;+&#x27;)&#123;</span><br><span class="line">                        res.push_back(l + r);</span><br><span class="line">                    &#125;else if (s[i] == &#x27;-&#x27;)&#123;</span><br><span class="line">                        res.push_back(l - r);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (s[i] == &#x27;*&#x27;)&#123;</span><br><span class="line">                        res.push_back(l * r);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(res.empty())</span><br><span class="line">        res.push_back(stoi(s));</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Leetcode-95-不同的二叉搜索树-II（中等）"><a href="#Leetcode-95-不同的二叉搜索树-II（中等）" class="headerlink" title="Leetcode 95. 不同的二叉搜索树 II（中等）"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">Leetcode 95. 不同的二叉搜索树 II（中等）</a></h3><p>给定一个数字 n，要求生成所有值为 1…n 的二叉搜索树。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: 3  </span><br><span class="line">Output:  </span><br><span class="line">[ </span><br><span class="line">  [1,null,3,2],  </span><br><span class="line">  [3,2,null,1],  </span><br><span class="line">  [3,1,null,null,2],  </span><br><span class="line">  [2,1,3],  </span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Explanation:  </span><br><span class="line">The above output corresponds to the 5 unique BST&#x27;s shown below:  </span><br><span class="line"></span><br><span class="line">1         3     3      2      1  </span><br><span class="line"> \       /     /      / \      \  </span><br><span class="line">  3     2     1      1   3      2  </span><br><span class="line"> /     /       \                 \  </span><br><span class="line">2     1         2                 3   </span><br></pre></td></tr></table></figure>

<p>题解：<br>把每一个节点当作父节点，递归求解左右子数，在把每个左右子树组合起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;TreeNode *&gt; generateTreesCore(int start, int end)&#123;</span><br><span class="line">    if(start &gt; end)</span><br><span class="line">        return &#123;nullptr&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;TreeNode *&gt; res;</span><br><span class="line">    for (int i = start; i &lt;= end;i++)&#123;</span><br><span class="line">        vector&lt;TreeNode *&gt; left = generateTreesCore(start, i - 1);</span><br><span class="line">        vector&lt;TreeNode *&gt; right = generateTreesCore(i + 1, end);</span><br><span class="line">        for(auto l:left)&#123;</span><br><span class="line">            for(auto r:right)&#123;</span><br><span class="line">                TreeNode *root = new TreeNode(i);</span><br><span class="line">                root-&gt;left = l;</span><br><span class="line">                root-&gt;right = r;</span><br><span class="line">                res.push_back(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;TreeNode *&gt; generateTrees(int n)&#123;</span><br><span class="line">    if(n==0)</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    return generateTreesCore(1, n);</span><br><span class="line">    cout &lt;&lt; &quot;visual tree by debug.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-动态规划（Dynamic-programming）"><a href="#3-2-动态规划（Dynamic-programming）" class="headerlink" title="3.2 动态规划（Dynamic programming）"></a>3.2 动态规划（Dynamic programming）</h2><p><code>递归</code>和<code>动态规划</code>都是将原问题拆成多个子问题然后求解，他们之间最本质的<code>区别</code>是，动态规划保存了子问题的解，避免重复计算。<br>递归一般是<code>自上而下</code>——从愿问题开始，逐步往下求解；动态规划一般是<code>自下而上</code>——从最小子问题开始，逐步扩大问题规模。<br>（这里写一个动态规划算法伪代码模版） </p>
<h3 id="3-2-1-斐波那契数列（fabonacci）"><a href="#3-2-1-斐波那契数列（fabonacci）" class="headerlink" title="3.2.1 斐波那契数列（fabonacci）"></a>3.2.1 斐波那契数列（fabonacci）</h3><h4 id="Leetcode-70-爬楼梯（简单）"><a href="#Leetcode-70-爬楼梯（简单）" class="headerlink" title="Leetcode 70. 爬楼梯（简单）"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">Leetcode 70. 爬楼梯（简单）</a></h4><p>题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。  </p>
<p>题解：<br>dp。dp[i] 表示走到第 i 个楼梯的方法数目。第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。<br><code>dp[i] = dp[i - 1] + dp[i - 2]</code></p>
<ol>
<li>空间复杂度O(n)的方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int climbStairs(int n)&#123;</span><br><span class="line">    vector&lt;int&gt; dp(n+1, 1);//dp[0]=1, dp[1]=1</span><br><span class="line">    for (int i = 2; i &lt;= n;i++)</span><br><span class="line">        dp[i] = dp[i - 1] + dp[i - 2];</span><br><span class="line"></span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>空间复杂度O(1)的方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int climbStairs(int n)&#123;</span><br><span class="line">    vector&lt;int&gt; dp(3, 1);//dp[0]=1, dp[1]=1</span><br><span class="line">    for (int i = 2; i &lt;= n;i++)&#123;</span><br><span class="line">        dp[2] = dp[1] + dp[0];</span><br><span class="line">        dp[0] = dp[1];</span><br><span class="line">        dp[1] = dp[2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-198-打家劫舍（简单）"><a href="#Leetcode-198-打家劫舍（简单）" class="headerlink" title="Leetcode 198. 打家劫舍（简单）"></a><a href="https://leetcode-cn.com/problems/house-robber/">Leetcode 198. 打家劫舍（简单）</a></h4><p>题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure>

<p>题解：<br>dp。dp[i] 表示抢到第 i 个住户时的最大抢劫量。由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以：<br><code>dp[i] = max(dp[i-2]+nums[i],dp[i-1])</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    if(n==0)</span><br><span class="line">        return 0;</span><br><span class="line">    vector&lt;int&gt; dp(3, 0);</span><br><span class="line">    dp[1] = nums[0];</span><br><span class="line">    for (int i = 2; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[2] = max(dp[0] + nums[i - 1], dp[1]);</span><br><span class="line">        dp[0] = dp[1];</span><br><span class="line">        dp[1] = dp[2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[1];//防止只有一个元素的情况</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-213-House-Robber-II-（中等）"><a href="#Leetcode-213-House-Robber-II-（中等）" class="headerlink" title="Leetcode 213. House Robber II （中等）"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/">Leetcode 213. House Robber II （中等）</a></h4><p>强盗在环形街区抢劫</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>
<p>题解：<br>在上一题的基础上，分成两个数组，一个包含第一家不包含最后一家，另一个不包含第一家但包含最后一家。分别 dp 求 max。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int helper(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line">    if(n==0)</span><br><span class="line">        return 0;</span><br><span class="line">    vector&lt;int&gt; dp(3, 0);</span><br><span class="line">    dp[1] = nums[0];</span><br><span class="line">    for (int i = 2; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[2] = max(dp[0] + nums[i - 1], dp[1]);</span><br><span class="line">        dp[0] = dp[1];</span><br><span class="line">        dp[1] = dp[2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int rob(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">    if(nums.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    if(nums.size()==1)</span><br><span class="line">        return nums[0];</span><br><span class="line">    vector&lt;int&gt; nums1(nums.begin(), nums.end() - 1);</span><br><span class="line">    vector&lt;int&gt; nums2(nums.begin()+1, nums.end());</span><br><span class="line">    return max(helper(nums1), helper(nums2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(2n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-634-寻找数组的错位排列（中等，会员题）"><a href="#Leetcode-634-寻找数组的错位排列（中等，会员题）" class="headerlink" title="Leetcode 634. 寻找数组的错位排列（中等，会员题）"></a>Leetcode 634. 寻找数组的错位排列（中等，会员题）</h4><p>题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量（所有信封都没有装各自的信）。</p>
<p>题解：<br>定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。</p>
<p>假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：</p>
<ul>
<li><code>i == k</code>，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 <code>dp[i-2]</code> 种错误装信的方式。<br>由于 j 有 i-1 种取值，因此共有 <code>(i-1)*dp[i-2]</code> 种错误装信方式。</li>
<li><code>i != k</code>，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 <code>dp[i-1]</code> 种错误装信方式。<br>由于 j 有 i-1 种取值，因此共有 <code>(i-1)*dp[i-1]</code> 种错误装信方式。</li>
</ul>
<p><code>dp[i] = (i-1)*dp[i-2] + (i-1)*dp[i-1]</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int wrongLetterRank(int n)&#123;</span><br><span class="line">    if(n&lt;2)</span><br><span class="line">        return n;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; dp(3, 0);</span><br><span class="line">    dp[1] = 1;</span><br><span class="line">    for (int i = 2; i &lt;= n;i++)&#123;</span><br><span class="line">        dp[2] = (i - 1) * dp[0] + (i - 1) * dp[1];</span><br><span class="line">        dp[0] = dp[1];</span><br><span class="line">        dp[1] = dp[2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="母牛生小牛问题"><a href="#母牛生小牛问题" class="headerlink" title="母牛生小牛问题"></a>母牛生小牛问题</h4><p>题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。  </p>
<p>题解：<br><code>dp[i]</code>表示第 i 年成熟的牛的数量：</p>
<ul>
<li><code>dp[i] = dp[i-1] + dp[i-3]</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int cowProduce(int n)&#123;</span><br><span class="line">    if(n&lt;=4)</span><br><span class="line">        return n;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; dp(4, 1); //dp[0] = 1;</span><br><span class="line">    dp[1] = 2;</span><br><span class="line">    dp[2] = 3;</span><br><span class="line">    for (int i = 4; i &lt;= n;i++)&#123;</span><br><span class="line">        dp[3] = dp[2] + dp[0];</span><br><span class="line">        dp[0] = dp[1];</span><br><span class="line">        dp[1] = dp[2];</span><br><span class="line">        dp[2] = dp[3];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n)<br>空间复杂度：O(1)</li>
</ul>
<h3 id="3-2-2-二维dp：二维网格路径问题"><a href="#3-2-2-二维dp：二维网格路径问题" class="headerlink" title="3.2.2 二维dp：二维网格路径问题"></a>3.2.2 二维dp：二维网格路径问题</h3><h4 id="Leetcode-64-最小路径和（中等）"><a href="#Leetcode-64-最小路径和（中等）" class="headerlink" title="Leetcode 64. 最小路径和（中等）"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/">Leetcode 64. 最小路径和（中等）</a></h4><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明</strong>：每次只能向下或者向右移动一步。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">    [1,3,1],  </span><br><span class="line">    [1,5,1],  </span><br><span class="line">    [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>二维dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int minPathSum(vector&lt;vector&lt;int&gt; &gt;&amp; grid) &#123;</span><br><span class="line">    if(grid.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int m = grid.size(), n = grid[0].size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(m, vector&lt;int&gt;(n,0));</span><br><span class="line"></span><br><span class="line">    dp[0][0] = grid[0][0];</span><br><span class="line">    for (int i = 1; i &lt; m; i++)</span><br><span class="line">        dp[i][0] = dp[i-1][0] + grid[i][0];</span><br><span class="line">    for (int j = 1; j &lt; n; j++)</span><br><span class="line">        dp[0][j] = dp[0][j-1] + grid[0][j];</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt; m;i++)&#123;</span><br><span class="line">        for (int j = 1; j &lt; n;j++)&#123;</span><br><span class="line">            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m - 1][n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m*n)<br>空间复杂度：O(m*n)</p>
<ol start="2">
<li>一维dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int minPathSum(vector&lt;vector&lt;int&gt; &gt;&amp; grid) &#123;</span><br><span class="line">    if(grid.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int m = grid.size(), n = grid[0].size();</span><br><span class="line">    vector&lt;int&gt; dp(n, 0);</span><br><span class="line"></span><br><span class="line">    dp[0] = grid[0][0];</span><br><span class="line">    for(int i = 1;i&lt;n;i++)</span><br><span class="line">        dp[i] = dp[i - 1] + grid[0][i];</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; m; i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">            if(j == 0)</span><br><span class="line">                dp[j] = dp[j] + grid[i][0];</span><br><span class="line">            else</span><br><span class="line">                dp[j] = min(dp[j - 1], dp[j]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m*n)<br>空间复杂度：O(n)</p>
<h4 id="Leetcode-62-不同路径（中等）"><a href="#Leetcode-62-不同路径（中等）" class="headerlink" title="Leetcode 62. 不同路径（中等）"></a><a href="https://leetcode-cn.com/problems/unique-paths/">Leetcode 62. 不同路径（中等）</a></h4><p>题目描述：统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移</p>
<ul>
<li><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code> 只用一行存储，空间复杂度可以优化为O(col)</li>
<li>也可以直接用数学公式求解，这是一个组合问题。<br>机器人总共移动的次数 S&#x3D;m+n-2，向下移动的次数 D&#x3D;m-1，那么问题可以看成从 S 中取出 D 个位置的组合数量，这个问题的解为 C(S, D)。</li>
</ul>
<p>题解：<br>一维dp。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int uniquePaths(int m, int n) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(n + 1, 1); //dp[0]==1  最左边一列都是1</span><br><span class="line">    for (int i = 1; i &lt; m;i++)&#123;//从第二行开始</span><br><span class="line">        for (int j = 1; j &lt; n;j++)</span><br><span class="line">            dp[j] = dp[j - 1] + dp[j];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m*n)<br>空间复杂度：O(n)</p>
<h3 id="3-2-3-子序列-x2F-子集-x2F-子数组-x2F-子矩阵"><a href="#3-2-3-子序列-x2F-子集-x2F-子数组-x2F-子矩阵" class="headerlink" title="3.2.3 子序列&#x2F;子集&#x2F;子数组&#x2F;子矩阵"></a>3.2.3 子序列&#x2F;子集&#x2F;子数组&#x2F;子矩阵</h3><p><strong>！！！注意！！！</strong>：<code>子序列</code> 和 <code>子串</code>并不相等，子序列&#x2F;子集可以不连续，字串是连续的。</p>
<h4 id="Leetcode-303-区域和检索-数组不可变（简单）"><a href="#Leetcode-303-区域和检索-数组不可变（简单）" class="headerlink" title="Leetcode 303. 区域和检索 - 数组不可变（简单）"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">Leetcode 303. 区域和检索 - 数组不可变（简单）</a></h4><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure>
<p>题解：<br>前缀和。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class NumArray &#123;</span><br><span class="line">public:</span><br><span class="line">    NumArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sums = new int[nums.size() + 1];</span><br><span class="line">        sums[0] = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.size();i++)</span><br><span class="line">            sums[i + 1] = sums[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~NumArray() &#123; delete[] sums; &#125;</span><br><span class="line"></span><br><span class="line">    int sumRange(int i, int j) &#123;</span><br><span class="line">        return sums[j + 1] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int *sums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-413-等差数列划分（中等）"><a href="#Leetcode-413-等差数列划分（中等）" class="headerlink" title="Leetcode 413. 等差数列划分（中等）"></a><a href="https://leetcode-cn.com/problems/arithmetic-slices/">Leetcode 413. 等差数列划分（中等）</a></h4><p>函数要返回数组 A 中所有为等差数组的子数组个数。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = [0, 1, 2, 3, 4]  </span><br><span class="line">return: 6, for 3 arithmetic slices in A:  </span><br><span class="line">[0, 1, 2],  </span><br><span class="line">[1, 2, 3],  </span><br><span class="line">[0, 1, 2, 3],  </span><br><span class="line">[0, 1, 2, 3, 4],  </span><br><span class="line">[ 1, 2, 3, 4],  </span><br><span class="line">[2, 3, 4]  </span><br></pre></td></tr></table></figure>
<p>题解：<br>dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。</p>
<p>当 A[i] - A[i-1] &#x3D;&#x3D; A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。  </p>
<p>dp[2] &#x3D; 1<br>[0, 1, 2]  </p>
<p>dp[3] &#x3D; dp[2] + 1 &#x3D; 2<br>[0, 1, 2, 3], &#x2F;&#x2F; [0, 1, 2] 之后加一个 3<br>[1, 2, 3]     &#x2F;&#x2F; 新的递增子区间  </p>
<p>dp[4] &#x3D; dp[3] + 1 &#x3D; 3<br>[0, 1, 2, 3, 4], &#x2F;&#x2F; [0, 1, 2, 3] 之后加一个 4<br>[1, 2, 3, 4],    &#x2F;&#x2F; [1, 2, 3] 之后加一个 4<br>[2, 3, 4]        &#x2F;&#x2F; 新的递增子区间  </p>
<p>综上，在 A[i] - A[i-1] &#x3D;&#x3D; A[i-1] - A[i-2] 时，dp[i] &#x3D; dp[i-1] + 1。因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 dp 数组累加的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A)&#123;</span><br><span class="line">    if(A.size()&lt;3)</span><br><span class="line">        return 0;</span><br><span class="line">    vector&lt;int&gt; dp(A.size(), 0);</span><br><span class="line">    for (int i = 2; i &lt; dp.size(); i++)&#123;</span><br><span class="line">        if(A[i]-A[i-1] == A[i-1]-A[i-2])</span><br><span class="line">            dp[i] = dp[i - 1] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for(auto dpi:dp)&#123;</span><br><span class="line">        res += dpi;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h4 id="Leetcode-343-整数拆分（中等）"><a href="#Leetcode-343-整数拆分（中等）" class="headerlink" title="Leetcode 343. 整数拆分（中等）"></a><a href="https://leetcode-cn.com/problems/integer-break/">Leetcode 343. 整数拆分（中等）</a></h4><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<p>就是割绳子问题，剑指offer也有</p>
<p>For example, given n &#x3D; 2, return 1 (2 &#x3D; 1 + 1); given n &#x3D; 10, return 36 (10 &#x3D; 3 + 3 + 4). </p>
<p>题解：<br>dp。<code>dp[i]</code>表示 i 能分割出的最大积</p>
<p>当 <code>i ≥ 2</code> 时，假设对正整数 i 拆分出的其中一个正整数是 <code>j(1 ≤ j &lt; i)</code>，则有两种情况：</p>
<ul>
<li>将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 <code>j×(i−j)</code>；</li>
<li>将 i 拆分成 j 和 i-j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 <code>j×dp[i−j]</code>。</li>
</ul>
<p>当固定时：<code>dp[i] = max(j * dp[i - j], j * (i - j))</code>，所以遍历 j 的可能值，就可以求出 dp[i]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int integerBreak(int n)&#123;</span><br><span class="line">    vector&lt;int&gt; dp(n+1,0);</span><br><span class="line">    for (int i = 2; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(n)</p>
<h4 id="Leetcode-279-完全平方数（中等）"><a href="#Leetcode-279-完全平方数（中等）" class="headerlink" title="Leetcode 279. 完全平方数（中等）"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">Leetcode 279. 完全平方数（中等）</a></h4><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>For example, given n &#x3D; 12, return 3 because 12 &#x3D; 4 + 4 + 4;<br>given n &#x3D; 13, return 2 because 13 &#x3D; 4 + 9.  </p>
<p>题解：<br>dp。dp[i]表示组成和的完全平方数最少的个数：</p>
<ul>
<li><code>dp[i] = dp[i-sqr] + 1</code></li>
</ul>
<p>可以用四平方定理减少运算次数：任何一个正整数都可以表示成不超过四个整数的平方之和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int numSquares(int n) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(n + 1, 5); //四平方定理</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n;i++)&#123;</span><br><span class="line">        for (int j = 1; j * j &lt;= i;j++)&#123;</span><br><span class="line">            dp[i] = min(dp[i], dp[i - j * j] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n * √n)<br>空间复杂度：O(n)</p>
<h4 id="Leetcode-91-解码方法（中等）"><a href="#Leetcode-91-解码方法（中等）" class="headerlink" title="Leetcode 91.解码方法（中等）"></a><a href="https://leetcode-cn.com/problems/decode-ways/">Leetcode 91.解码方法（中等）</a></h4><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;A&#x27; -&gt; 1</span><br><span class="line">&#x27;B&#x27; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#x27;Z&#x27; -&gt; 26</span><br></pre></td></tr></table></figure>
<p>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p>
<p>Given encoded message “12”, return 2<br>It could be decoded as “AB” (1 2) or “L” (12). The number of ways decoding “12” is 2.</p>
<p>题解：<br>二维dp。dp[i]表示前i个字符有几种解码方式。分几种情况：</p>
<ul>
<li>s[i-1]!&#x3D;0 &amp;&amp; s[i-2]&#x3D;&#x3D;0 如“101”，最近两位为”01”不能解码，所以dp[i] &#x3D; dp[i-1]</li>
<li>s[i-1]&#x3D;&#x3D;0 &amp;&amp; s[i-2]&#x3D;&#x3D;0 即有两个连续的零，如“100” 则不可能转为字符，dp[i] &#x3D; 0</li>
<li>dp[i-2]dp[i-1]组成的数字 &gt;26：dp[i] &#x3D; dp[i-1]</li>
<li>dp[i-2]dp[i-1]组成的数字 &lt;&#x3D;26：dp[i] &#x3D; dp[i-1] + dp[i-2]<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int numDecodings(string s)&#123;</span><br><span class="line">    vector&lt;int&gt; dp(s.size()+1, 0);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    dp[1] = s[0] == &#x27;0&#x27; ? 0 : 1;</span><br><span class="line">    for (int i = 2; i &lt;= s.size();i++)&#123;</span><br><span class="line">        //s[i-1]!=0 &amp;&amp; s[i-2]==0 如“101”，最近两位为&quot;01&quot;不能解码，所以dp[i] = dp[i-1];</span><br><span class="line">        //s[i-1]==0 &amp;&amp; s[i-2]==0 即有两个连续的零，如“100” 则不可能转为字符，dp[i] = 0。</span><br><span class="line">        if(s[i-1]!=&#x27;0&#x27;)</span><br><span class="line">            dp[i] = dp[i - 1];</span><br><span class="line">        if(s[i-2]==&#x27;0&#x27;)</span><br><span class="line">            continue;</span><br><span class="line">        //根据最近两位的大小判断能不能解码</span><br><span class="line">        int two = stoi(s.substr(i - 2, 2)); //= (s[i - 1] - &#x27;0&#x27;) * 10 + (s[i] - &#x27;0&#x27;);</span><br><span class="line">        if (two &lt;= 26)</span><br><span class="line">            dp[i] += dp[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n)<br>空间复杂度：O(n)</li>
</ul>
<p>一维dp。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int numDecodings(string s)&#123;</span><br><span class="line">    vector&lt;int&gt; dp(3, 0);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    dp[1] = s[0] == &#x27;0&#x27; ? 0 : 1;</span><br><span class="line">    for (int i = 2; i &lt;= s.size();i++)&#123;</span><br><span class="line">        //s[i-1]!=0 &amp;&amp; s[i-2]==0 如“101”，最近两位为&quot;01&quot;不能解码，所以dp[i] = dp[i-1];</span><br><span class="line">        //s[i-1]==0 &amp;&amp; s[i-2]==0 即有两个连续的零，如“100” 则不可能转为字符，dp[i] = 0。</span><br><span class="line">        dp[2] = 0;</span><br><span class="line">        if(s[i - 1] != &#x27;0&#x27;)</span><br><span class="line">            dp[2] = dp[1];</span><br><span class="line">        if (s[i - 2] == &#x27;0&#x27;)&#123;</span><br><span class="line">            dp[0] = dp[1];</span><br><span class="line">            dp[1] = dp[2];</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //根据最近两位的大小判断能不能解码</span><br><span class="line">        int two = stoi(s.substr(i - 2, 2)); //= (s[i - 1] - &#x27;0&#x27;) * 10 + (s[i] - &#x27;0&#x27;);</span><br><span class="line">        if (two &lt;= 26)</span><br><span class="line">            dp[2] += dp[0];</span><br><span class="line">        dp[0] = dp[1];</span><br><span class="line">        dp[1] = dp[2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="和为-k-的-子序列-x2F-子数组"><a href="#和为-k-的-子序列-x2F-子数组" class="headerlink" title="和为 k 的 子序列&#x2F;子数组"></a>和为 k 的 子序列&#x2F;子数组</h4><h5 id="和为-k-的-子数组"><a href="#和为-k-的-子数组" class="headerlink" title="和为 k 的 子数组"></a>和为 k 的 子数组</h5><ol>
<li><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">Leetcode 560. 和为K的子数组（中等）</a></li>
</ol>
<p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p>示例 1 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:nums = [1,1,1], k = 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure>
<p>题解：<br>前缀和。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int subArrySumCnt(vector&lt;int&gt; &amp;A, int &amp;d)&#123;</span><br><span class="line">    unordered_map&lt;int, int&gt; umap; //key:前缀和  val:出现次数</span><br><span class="line">    int pre = 0, cnt = 0;</span><br><span class="line">    umap[0] = 1;</span><br><span class="line">    for (int &amp;a : A)&#123;</span><br><span class="line">        pre += a;</span><br><span class="line">        if(umap.find(pre-d) != umap.end())</span><br><span class="line">            cnt += umap[pre - d];</span><br><span class="line">        umap[pre]++;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>在 <code>1.</code> 的基础上，输出每一个子数组</li>
</ol>
<p>题解：<br>保留索引的前缀和。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; subArrySum(vector&lt;int&gt; &amp;A, int &amp;d)&#123;</span><br><span class="line">    unordered_map&lt;int, vector&lt;pair&lt;int,int&gt; &gt; &gt; umap; //key:前缀和  val:出现的开始和结束索引 序列</span><br><span class="line">    int pre = 0;</span><br><span class="line">    umap[0].push_back(&#123;0, -1&#125;);</span><br><span class="line">    vector&lt;pair&lt;int, int&gt; &gt; idxs;</span><br><span class="line">    for (int i = 0; i &lt; A.size(); i++)&#123;</span><br><span class="line">        pre += A[i];</span><br><span class="line">        if(umap.find(pre-d) != umap.end())&#123;</span><br><span class="line">            for(auto &amp;p : umap[pre-d])//记录满足的索引</span><br><span class="line">                idxs.push_back(&#123;p.second + 1, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        umap[pre].push_back(&#123;0, i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    for(auto &amp;idx : idxs)&#123;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        for (int i = idx.first; i &lt;= idx.second; i++)</span><br><span class="line">            tmp.push_back(A[i]);</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="和为-k-的-子集合-x2F-子序列"><a href="#和为-k-的-子集合-x2F-子序列" class="headerlink" title="和为 k 的 子集合&#x2F;子序列"></a>和为 k 的 子集合&#x2F;子序列</h5><p>题解：<br>剪枝回溯，当和<code>&gt;k</code>时丢弃该分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set&lt;vector&lt;int&gt; &gt; resSet;</span><br><span class="line"></span><br><span class="line">void backtracking(vector&lt;int&gt; &amp;pre, int preSum, int idx, vector&lt;int&gt; &amp;nums, int &amp;k)&#123;</span><br><span class="line">    if(preSum &gt; k)</span><br><span class="line">        return;</span><br><span class="line">    if(preSum == k)&#123;</span><br><span class="line">        sort(pre.begin(), pre.end());</span><br><span class="line">        resSet.insert(pre);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int curSum = preSum;</span><br><span class="line">    for (int i = idx; i &lt; nums.size(); i++)&#123;</span><br><span class="line">        pre.push_back(nums[i]);</span><br><span class="line">        curSum += nums[i];</span><br><span class="line">        backtracking(pre, curSum, i + 1, nums, k);</span><br><span class="line">        curSum -= nums[i];</span><br><span class="line">        pre.erase(pre.end() - 1, pre.end());</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; subSetSum(vector&lt;int&gt; &amp;nums, int &amp;k)&#123;//子集</span><br><span class="line">    vector&lt;int&gt; pre;</span><br><span class="line">    backtracking(pre, 0, 0, nums, k);</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res(resSet.begin(), resSet.end());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h4><p>&amp;emsp;&amp;emsp;已知一个序列 {S1, S2,…,Sn}，取出若干数组成新的序列 {Si1, Si2,…, Sim}，其中 i1、i2 … im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个子序列。如果在子序列中，当下标 ix &gt; iy 时，Six &gt; Siy，称子序列为原序列的一个递增子序列。<br>&amp;emsp;&amp;emsp;定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 Sn 结尾的序列的最长递增子序列长度。对于一个递增子序列 {Si1, Si2,…,Sim}，如果 im &lt; n 并且 Sim &lt; Sn，此时 {Si1, Si2,…, Sim, Sn} 为一个递增子序列，递增子序列的长度增加 1。<br>&amp;emsp;&amp;emsp;满足上述条件的递增子序列中，长度最长的那个递增子序列就是要找的，在长度最长的递增子序列上加上 Sn 就构成了以 Sn 为结尾的最长递增子序列。<br>&amp;emsp;&amp;emsp;因此 <code>dp[n] = max&#123; dp[i]+1 | Si &lt; Sn &amp;&amp; i &lt; n&#125;</code><br>&amp;emsp;&amp;emsp;因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 {Sn} 就构成了递增子序列，需要对前面的求解方程做修改，令 dp[n] 最小为 1，即：</p>
<ul>
<li><code>dp[n] = max&#123;1, dp[i] + 1 | Si &lt; Sn &amp;&amp; i &lt; n&#125;</code><br>&amp;emsp;&amp;emsp;对于一个长度为 N 的序列，最长递增子序列并不一定会以 SN 为结尾，因此 dp[N] 不是序列的最长递增子序列的长度，需要遍历 dp 数组找出最大值才是所要的结果，<code>max&#123; dp[i] | 1 &lt;= i &lt;= N&#125;</code> 即为所求。</li>
</ul>
<p>ref. <a href="https://blog.csdn.net/u013178472/article/details/54926531">最长递增子序列的三种算法</a>  </p>
<ol>
<li>以上解法的时间复杂度为 O(N2)  </li>
<li>可以使用二分查找将时间复杂度降低为 O(NlogN)  </li>
<li>也可以用最长公共子序列法：查找原序列和排序后的序列的最长公共自序列，具体参见链接</li>
</ol>
<h5 id="Leetcode-300-最长上升（递增）子序列（中等）"><a href="#Leetcode-300-最长上升（递增）子序列（中等）" class="headerlink" title="Leetcode 300.  最长上升（递增）子序列（中等）"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">Leetcode 300.  最长上升（递增）子序列（中等）</a></h5><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>题解：  </p>
<ol>
<li>dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(nums.size(), 1); //至少是自身，1个</span><br><span class="line">    for (int i = 0; i &lt; nums.size();i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; i;j++)&#123;</span><br><span class="line">            if(nums[j]&lt;nums[i])</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for(int n:dp)</span><br><span class="line">        res = max(res, n);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>二分查找+贪心。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int BinarySearch(vector&lt;int&gt; &amp;tails,int len,int num)&#123;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = len - 1;</span><br><span class="line">    int mid;</span><br><span class="line">    while(left&lt;=right)&#123;</span><br><span class="line">        mid = (left + right) / 2;</span><br><span class="line">        if (tails[mid]&gt;num)</span><br><span class="line">            right = mid - 1;</span><br><span class="line">        else if(tails[mid]&lt;num)</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        else</span><br><span class="line">            return mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;//数组中不存在该元素，则返回该元素应该插入的位置</span><br><span class="line">&#125;</span><br><span class="line">int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    //tails[i]表示长度为 i+1 的最长上升子序列的末尾元素的最小值</span><br><span class="line">    if(nums.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    vector&lt;int&gt; tails(nums.size(), 0);</span><br><span class="line">    int res = 1;</span><br><span class="line">    tails[0] = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nums[i]&gt;tails[res-1])&#123;</span><br><span class="line">            tails[res] = nums[i];</span><br><span class="line">            res++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int pos = BinarySearch(tails,res,nums[i]);</span><br><span class="line">            tails[pos] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)<br>空间复杂度：O(n)</p>
<h5 id="Leetcode-646-最长数对链（中等）"><a href="#Leetcode-646-最长数对链（中等）" class="headerlink" title="Leetcode 646. 最长数对链（中等）"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/">Leetcode 646. 最长数对链（中等）</a></h5><p>给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。</p>
<p>现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。</p>
<p>给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p>
<p><strong>说明</strong>：对于 (a, b) 和 (c, d) ，如果 b &lt; c，则它们可以构成一条链。求一组整数对能够构成的最长链。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: [[1,2], [2,3], [3,4]]  </span><br><span class="line">Output: 2  </span><br><span class="line">Explanation: The longest chain is [1,2] -&gt; [3,4]  </span><br></pre></td></tr></table></figure>

<p>题解：<br>和最长递增子序列很像。 </p>
<ol>
<li>dp。dp[i]是以i结尾时的最长链长度：<code>dp[i] = max&#123;dp[j]+1 | j~(1,i) &amp;&amp; pairs[i][0]&gt;pairs[j][1]&#125;</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool cmp(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b)&#123;</span><br><span class="line">    if(a[0]==b[0])</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    return a[0] &lt; b[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findLongestChain(vector&lt;vector&lt;int&gt; &gt;&amp; pairs) &#123;</span><br><span class="line">    if(pairs.size()&lt;2)</span><br><span class="line">        return pairs.size();</span><br><span class="line">    </span><br><span class="line">    sort(pairs.begin(), pairs.end(), cmp);</span><br><span class="line">    vector&lt;int&gt; dp(pairs.size(), 1);</span><br><span class="line">    for (int i = 1; i &lt; pairs.size(); i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; i;j++)&#123;</span><br><span class="line">            if (pairs[i][0] &gt; pairs[j][1])</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int res = 0;</span><br><span class="line">    for(auto d:dp)</span><br><span class="line">        res = max(res, d);</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>二分+贪心。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int BinarySearch(vector&lt; vector&lt;int&gt; &gt; &amp;tails,int len,vector&lt;int&gt; inputPair)&#123;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = len-1;</span><br><span class="line">    int mid;</span><br><span class="line">    while (left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left + right) / 2;</span><br><span class="line">        if(tails[mid][1]&lt;inputPair[0])</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        else if(tails[mid][0]&gt;inputPair[1])</span><br><span class="line">            right = mid - 1;</span><br><span class="line">        else</span><br><span class="line">            return mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b)&#123;</span><br><span class="line">    if(a[0]==b[0])</span><br><span class="line">        return a[1] &lt; b[1];</span><br><span class="line">    return a[0] &lt; b[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findLongestChain(vector&lt;vector&lt;int&gt; &gt;&amp; pairs) &#123;</span><br><span class="line">    if(pairs.size()&lt;2)</span><br><span class="line">        return pairs.size();</span><br><span class="line">    </span><br><span class="line">    sort(pairs.begin(), pairs.end(), cmp);</span><br><span class="line">    vector&lt; vector&lt;int&gt; &gt; tails(pairs.size(),vector&lt;int&gt;(2,0));</span><br><span class="line">    tails[0] = pairs[0];</span><br><span class="line">    int res = 1;</span><br><span class="line">    for (int i = 1; i &lt; pairs.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pairs[i][0]&gt;tails[res-1][1])&#123;</span><br><span class="line">            tails[res] = pairs[i];</span><br><span class="line">            res++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int pos = BinarySearch(tails,res,pairs[i]);</span><br><span class="line">            if(tails[pos][1]&gt;pairs[i][1])</span><br><span class="line">                tails[pos] = pairs[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)<br>空间复杂度：O(n)</p>
<h5 id="Leetcode-376-摆动序列（中等）"><a href="#Leetcode-376-摆动序列（中等）" class="headerlink" title="Leetcode 376. 摆动序列（中等）"></a><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">Leetcode 376. 摆动序列（中等）</a></h5><p>如果一个序列中连续的数之间的差值在正数和负数之间来回交替，那么这个序列被称作摆动序列。如果存在第一个差值的话，可能为正数或者负数。长度小于2的序列被认为是摆动序列。  </p>
<p>例如：[1,7,4,9,2,5]为摆动序列。而[1,4,7,2,5] 和[1,7,4,5,5]不是摆动序列  </p>
<p>给定一组数，返回最长的摆动子序列。注意序列是由原数组删除一些元素(也可以不删除)并且保留元素顺序得到的。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: [1,7,4,9,2,5]  </span><br><span class="line">Output: 6  </span><br><span class="line">The entire sequence is a wiggle sequence.  </span><br><span class="line">Input: [1,17,5,10,13,15,10,5,16,8]  </span><br><span class="line">Output: 7  </span><br><span class="line">There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].  </span><br><span class="line">Input: [1,2,3,4,5,6,7,8,9]  </span><br><span class="line">Output: 2  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>dp。用两个分别保存上升和下降的最长长度。<ul>
<li><code>dpUp[i]</code> 表示 i 之前上升序列最长的子序列长度</li>
<li><code>dpDown[i]</code> 表示 i 之前下降序列最长的子序列长度</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    if(nums.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    vector&lt;int&gt; dpUp(nums.size());</span><br><span class="line">    vector&lt;int&gt; dpDown(nums.size());</span><br><span class="line">    dpUp[0] = 1;</span><br><span class="line">    dpDown[0] = 1;</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nums[i]&gt;nums[i-1])&#123;//状态是上升,应该接下降，并改状态</span><br><span class="line">            dpUp[i] = dpDown[i - 1] + 1;</span><br><span class="line">            dpDown[i] = dpDown[i - 1];</span><br><span class="line">        &#125;else if(nums[i]&lt;nums[i-1])&#123;//状态是下降，应该接上升，并改状态</span><br><span class="line">            dpDown[i] = dpUp[i - 1] + 1;</span><br><span class="line">            dpUp[i] = dpUp[i - 1];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            dpUp[i] = dpUp[i - 1];</span><br><span class="line">            dpDown[i] = dpDown[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for(auto d:dpUp)</span><br><span class="line">        res = max(res, d);</span><br><span class="line">    for(auto d:dpDown)</span><br><span class="line">        res = max(res, d);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(2n)<br>空间复杂度：O(2n)</p>
<ol start="2">
<li>因为只用到了前一个值，所以可以优化空间复杂度。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    if(nums.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int up = 1, down = 1;</span><br><span class="line">    for (int i = 1; i &lt; nums.size();i++)&#123;</span><br><span class="line">        if(nums[i]&gt;nums[i-1])</span><br><span class="line">            up = down + 1;</span><br><span class="line">        else if(nums[i]&lt;nums[i-1])</span><br><span class="line">            down = up + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return max(up, down);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="公共子序列"><a href="#公共子序列" class="headerlink" title="公共子序列"></a>公共子序列</h4><p><code>dp[i][j]</code> 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。  </p>
<p>考虑 <code>S1[i]</code> 与 <code>S2j</code> 值是否相等，分为两种情况：</p>
<ul>
<li>当 <code>S1[i] == S2[j]</code> 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，<br>最长公共子序列长度加 1，即 <code>dp[i][j] = dp[i-1][j-1] + 1</code>。</li>
<li>当 <code>S1[i] != S2[j]</code> 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，<br>或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，<br>即 <code>dp[i][j] = max&#123;dp[i-1][j], dp[i][j-1]&#125;</code>。</li>
</ul>
<p>对于长度为 N 的序列 S1 和长度为 M 的序列 S2，<code>dp[N][M]</code> 就是序列 S1 和序列 S2 的最长公共子序列长度。</p>
<h5 id="Leetcode-1143-最长公共子序列Longest-Common-Subsequence（中等）"><a href="#Leetcode-1143-最长公共子序列Longest-Common-Subsequence（中等）" class="headerlink" title="Leetcode 1143. 最长公共子序列Longest Common Subsequence（中等）"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">Leetcode 1143. 最长公共子序列Longest Common Subsequence（中等）</a></h5><p>求最长公共子序列</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure>

<p>题解：  </p>
<ol>
<li>二维dp。<code>dp[i][j]</code>表示第一个字符串的前 i 个和第二个字符串的前 j 个字符的LCS。<ul>
<li>当<code>s1[i-1] == s2[j-1]</code>时，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li>
<li>当<code>s1[i-1] != s2[j-1]</code>时，<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code></li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int longestCommonSubsequence(string text1, string text2) &#123;</span><br><span class="line">    if(text1.size()==0||text2.size()==0)</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    vector&lt; vector&lt;int&gt; &gt; dp(text1.size()+1,vector&lt;int&gt;(text2.size()+1));</span><br><span class="line">    for (int i = 1; i &lt;= text1.size();i++)&#123;</span><br><span class="line">        for (int j = 1; j &lt;= text2.size();j++)&#123;</span><br><span class="line">            if(text2[j-1]==text1[i-1])</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">            else</span><br><span class="line">                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[text1.size()][text2.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p>
<ol start="2">
<li>一维dp。注意：使用一维dp的时候，需要上一行的前一个数，所以不能使用上一个数和前一个数更新，还要保留上一行。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int longestCommonSubsequence(string text1, string text2) &#123;</span><br><span class="line">    if(text1.size()==0||text2.size()==0)</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; dp(text2.size()+1, 0);</span><br><span class="line">    vector&lt;int&gt; last(text2.size()+1, 0);</span><br><span class="line">    for (int i = 1; i &lt;= text1.size();i++)&#123;</span><br><span class="line">        for (int j = 1; j &lt;= text2.size();j++)&#123;</span><br><span class="line">            if(text2[j-1]==text1[i-1])</span><br><span class="line">                dp[j] = last[j - 1] + 1;</span><br><span class="line">            else</span><br><span class="line">                dp[j] = max(last[j], dp[j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        last = dp;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[text2.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(2n)</p>
<h5 id="Leetcode-583-两个字符串的删除操作（中等）"><a href="#Leetcode-583-两个字符串的删除操作（中等）" class="headerlink" title="Leetcode 583. 两个字符串的删除操作（中等）"></a><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">Leetcode 583. 两个字符串的删除操作（中等）</a></h5><p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;sea&quot;, &quot;eat&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 第一步将&quot;sea&quot;变为&quot;ea&quot;，第二步将&quot;eat&quot;变为&quot;ea&quot;</span><br></pre></td></tr></table></figure>
<p>题解：<br>其实就是算最长公共子序列。  </p>
<ol>
<li>二维dp</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int minDistance(string word1, string word2) &#123;</span><br><span class="line">    if(word1.empty())</span><br><span class="line">        return word2.size();</span><br><span class="line">    if(word2.empty())</span><br><span class="line">        return word1.size();</span><br><span class="line"></span><br><span class="line">    int m = word1.size(), n = word2.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(m+1,vector&lt;int&gt;(n+1, 0));</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            if(word1[i-1]==word2[j-1])</span><br><span class="line">                dp[i][j] = dp[i-1][j-1]+1;</span><br><span class="line">            else</span><br><span class="line">                dp[i][j] = max(dp[i-1][j],dp[i][j-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return m+n-2*dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p>
<ol start="2">
<li>一维dp。注意：使用一维dp的时候，需要上一行的前一个数，所以不能使用上一个数和前一个数更新，还要保留上一行。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int minDistance(string word1, string word2) &#123;</span><br><span class="line">    if(word1.empty())</span><br><span class="line">        return word2.size();</span><br><span class="line">    if(word2.empty())</span><br><span class="line">        return word1.size();</span><br><span class="line"></span><br><span class="line">    int m = word1.size(), n = word2.size();</span><br><span class="line">    vector&lt;int&gt; dp(n+1);</span><br><span class="line">    vector&lt;int&gt; last(n+1);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        for (int j = 1; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (word1[i - 1] == word2[j - 1])</span><br><span class="line">                dp[j] = last[j-1] + 1;</span><br><span class="line">            else</span><br><span class="line">                dp[j] = max(last[j],dp[j-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        last = dp;</span><br><span class="line">    &#125;</span><br><span class="line">    return m+n-2*dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(2n)</p>
<h4 id="最大连续子数组"><a href="#最大连续子数组" class="headerlink" title="最大连续子数组"></a>最大连续子数组</h4><h5 id="Leetcode-53-最大子序和（简单）"><a href="#Leetcode-53-最大子序和（简单）" class="headerlink" title="Leetcode 53. 最大子序和（简单）"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">Leetcode 53. 最大子序和（简单）</a></h5><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>
<p>题解：<br>dp。优化空间复杂度为O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int pre = 0, res = nums[0];</span><br><span class="line">    for (const auto &amp;x: nums) &#123;</span><br><span class="line">        pre = max(pre + x, x);</span><br><span class="line">        res = max(res, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h5 id="返回最大子数组"><a href="#返回最大子数组" class="headerlink" title="返回最大子数组"></a>返回最大子数组</h5><p>在上题的基础上，要返回这个最大子数组，不只是和。</p>
<p>题解：<br>对于<code>dp[i]=max(dp[i-1]+nums[i], nums[i])</code></p>
<ul>
<li>当<code>dp[i-1]&lt;0</code>时，<code>nums[i]</code>大</li>
<li>当<code>dp[i-1]&gt;0</code>时，<code>dp[i-1]+nums[i]</code>大<br>因为要返回数组，所以在状态转移时需要更新一下开始索引。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int pre = nums[0], start = 0;</span><br><span class="line">    int maxSum = INT_MIN;</span><br><span class="line">    vector&lt;int&gt; resIdx(2);</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pre &gt; 0)&#123; //如果返回最长的子数组，这个就应该是 if(pre &gt;= 0)</span><br><span class="line">            pre = pre + nums[i];</span><br><span class="line">        &#125;else&#123;//子数组的开始索引要更新了</span><br><span class="line">            pre = nums[i];</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre &gt; maxSum)&#123;//更新答案</span><br><span class="line">            maxSum = pre;</span><br><span class="line">            resIdx[0] = start;</span><br><span class="line">            resIdx[1] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for (int i = resIdx[0]; i &lt;= resIdx[1]; i++)&#123;</span><br><span class="line">        res.push_back(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度：O(n)<br>空间复杂度：O(1)</li>
</ul>
<h4 id="旋转数组的最大连续子数组"><a href="#旋转数组的最大连续子数组" class="headerlink" title="旋转数组的最大连续子数组"></a>旋转数组的最大连续子数组</h4><h5 id="旋转连续子数组和"><a href="#旋转连续子数组和" class="headerlink" title="旋转连续子数组和"></a>旋转连续子数组和</h5><p>给定一个<strong>旋转</strong>数组<code>nums</code>，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>注意</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">旋转数组为首位相连的数组，如：</span><br><span class="line">[1,2,3] 的子数组有 [1,2],[2,3],[3,1]</span><br></pre></td></tr></table></figure>
<p>题解：<br>以<code>[2,1,3]</code>为例，最大子数组可能位于 <strong>中间</strong><code>(如[1,3])</code> 或者 <strong>两边</strong><code>([3,2])</code>。</p>
<ul>
<li>若最大子数组在中间，则用上题方法可得；</li>
<li>若最大子数组在两边，使用dp求出位于中间的最小子数组的和，就得到了位于两边的最大子数组和。因为数组和是一定的，中间的子数组和越小，位于两边的子数组和越大。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxSubArray(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">    //位于中间 最大和 的 子数组</span><br><span class="line">    int pre = 0, maxMid = nums[0];</span><br><span class="line">    for (const int n : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        pre = max(n, pre + n);</span><br><span class="line">        maxMid = max(maxMid, pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //位于两边 最大和 的 子数组</span><br><span class="line">    //中间最小和</span><br><span class="line">    pre = nums[0];</span><br><span class="line">    int minMid = nums[0], sumn = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre = min(nums[i], pre + nums[i]);</span><br><span class="line">        minMid = min(minMid, pre);</span><br><span class="line">        sumn += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int maxSide = sumn - minMid; //两边 最大和</span><br><span class="line"></span><br><span class="line">    return maxMid &gt; maxSide ? maxMid : maxSide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h5 id="返回最大和的旋转连续子数组"><a href="#返回最大和的旋转连续子数组" class="headerlink" title="返回最大和的旋转连续子数组"></a>返回最大和的旋转连续子数组</h5><p>给定一个<strong>旋转</strong>数组<code>nums</code>，返回一个具有最大和的连续子数组，不只是和。<br>题解：<br>在上题状态转移的基础上，增加了索引的记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    //位于中间 最大和 的 子数组</span><br><span class="line">    int pre = nums[0], start = 0;</span><br><span class="line">    int maxMid = INT_MIN;    </span><br><span class="line">    vector&lt;int&gt; maxIdx(2);</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pre &gt; 0)&#123; //如果返回最长的子数组，这个就应该是 if(pre &gt;= 0)</span><br><span class="line">            pre = pre + nums[i];</span><br><span class="line">        &#125;else&#123;//子数组的开始索引要更新了</span><br><span class="line">            pre = nums[i];</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre &gt; maxMid)&#123;//更新答案</span><br><span class="line">            maxMid = pre;</span><br><span class="line">            maxIdx[0] = start;</span><br><span class="line">            maxIdx[1] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //位于两边 最大和 的 子数组</span><br><span class="line">    //中间最小和</span><br><span class="line">    pre = nums[0]; start = 0;</span><br><span class="line">    int minMid = nums[0], sumn = nums[0];</span><br><span class="line">    vector&lt;int&gt; minIdx(2);</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sumn += nums[i];</span><br><span class="line">        if(pre &lt; 0)&#123;</span><br><span class="line">            pre = pre + nums[i];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            pre = nums[i];</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre &lt; minMid)&#123;</span><br><span class="line">            minMid = pre;</span><br><span class="line">            minIdx[0] = start;</span><br><span class="line">            minIdx[1] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; resIdx(2);</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    if(maxMid &gt; (sumn - minMid))&#123;//子数组在中间</span><br><span class="line">        resIdx = maxIdx;</span><br><span class="line"></span><br><span class="line">        for (int i = resIdx[0]; i &lt;= resIdx[1]; i++)&#123;</span><br><span class="line">            res.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;//子数组在两边</span><br><span class="line">        resIdx[0] = (minIdx[1] + 1) % nums.size();</span><br><span class="line">        resIdx[1] = (minIdx[0] - 1 + nums.size()) % nums.size();</span><br><span class="line"></span><br><span class="line">        for (int i = resIdx[0]; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            res.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt;= resIdx[1]; i++)&#123;</span><br><span class="line">            res.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="二维矩阵最大子矩阵和"><a href="#二维矩阵最大子矩阵和" class="headerlink" title="二维矩阵最大子矩阵和"></a>二维矩阵最大子矩阵和</h4><h5 id="最大子矩阵和"><a href="#最大子矩阵和" class="headerlink" title="最大子矩阵和"></a>最大子矩阵和</h5><p>给定一个正整数和负整数组成的矩阵<code>matrix</code>，返回元素总和最大的子矩阵。</p>
<p>题解：<br>我们在前面已经会求最大子数组和，最大矩阵和只需要把二维矩阵压缩为一维数组，再用之前求最大子数组和的方法，就可以得到最大矩阵和。</p>
<p>我们把矩阵垂直压缩成一维数组，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">matrix = [[1,2,3],</span><br><span class="line">          [1,2,3]]</span><br><span class="line"></span><br><span class="line">可以压缩成：nums = [2,4,6]</span><br><span class="line"></span><br><span class="line">其中: </span><br><span class="line">nums[0] = matrix[0][0] + matrix[1][0]</span><br><span class="line">nums[1] = matrix[0][1] + matrix[1][1]</span><br><span class="line">nums[2] = matrix[0][2] + matrix[1][2]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int pre = 0, res = nums[0];</span><br><span class="line">    for (const auto &amp;x: nums) &#123;</span><br><span class="line">        pre = max(pre + x, x);</span><br><span class="line">        res = max(res, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int maxSubMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)&#123;</span><br><span class="line">    if(matrix.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int rows = matrix.size();</span><br><span class="line">    int cols = matrix[0].size();</span><br><span class="line"></span><br><span class="line">    int res = INT_MIN;</span><br><span class="line">    for (int up = 0; up &lt; rows; up++)//上界</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; nums(cols, 0);//压缩为一维数组</span><br><span class="line">        for (int buttom = up; buttom &lt; rows; buttom++)//下界</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; cols;i++)//每次往下一行，就只需在之前的nums上加上这一行</span><br><span class="line">                nums[i] += matrix[buttom][i];</span><br><span class="line"></span><br><span class="line">            int maxArr = maxSubArray(nums);</span><br><span class="line">            res = max(maxArr, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="返回最大子矩阵"><a href="#返回最大子矩阵" class="headerlink" title="返回最大子矩阵"></a>返回最大子矩阵</h5><p>在更新最大和的时候记录左上角和右下角的索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxSubArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt; &amp;maxIdx) &#123;</span><br><span class="line">    int pre = nums[0], start = 0;</span><br><span class="line">    int maxSum = INT_MIN;</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pre &gt; 0)&#123; //如果返回最长的子数组，这个就应该是 if(pre &gt;= 0)</span><br><span class="line">            pre = pre + nums[i];</span><br><span class="line">        &#125;else&#123;//子数组的开始索引要更新了</span><br><span class="line">            pre = nums[i];</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre &gt; maxSum)&#123;//更新答案</span><br><span class="line">            maxSum = pre;</span><br><span class="line">            maxIdx[0] = start;</span><br><span class="line">            maxIdx[1] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; maxSubMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)&#123;</span><br><span class="line">    if(matrix.empty())</span><br><span class="line">        return matrix;</span><br><span class="line">    int rows = matrix.size();</span><br><span class="line">    int cols = matrix[0].size();</span><br><span class="line"></span><br><span class="line">    int maxArr = INT_MIN;</span><br><span class="line">    vector&lt;int&gt; maxIdx(4);//0上、1左、2下、3右</span><br><span class="line">    for (int up = 0; up &lt; rows; up++)//上界</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; nums(cols, 0);//压缩为一维数组</span><br><span class="line">        for (int down = up; down &lt; rows; down++)//下界</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; cols;i++)//每次往下一行，就只需在之前的nums上加上这一行</span><br><span class="line">                nums[i] += matrix[down][i];</span><br><span class="line"></span><br><span class="line">            vector&lt;int&gt; tmpIdx(2);</span><br><span class="line">            int tmp = maxSubArray(nums, tmpIdx);</span><br><span class="line">            if(tmp &gt; maxArr)&#123;</span><br><span class="line">                maxArr = tmp;</span><br><span class="line">                maxIdx[0] = up;</span><br><span class="line">                maxIdx[1] = tmpIdx[0];</span><br><span class="line">                maxIdx[2] = down;</span><br><span class="line">                maxIdx[3] = tmpIdx[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int subRows = maxIdx[2] - maxIdx[0] + 1;</span><br><span class="line">    int subCols = maxIdx[3] - maxIdx[1] + 1;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res(subRows,vector&lt;int&gt;(subCols));</span><br><span class="line">    for (int row = maxIdx[0], i = 0; row &lt;= maxIdx[2]; row++, i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int col = maxIdx[1], j = 0; col &lt;= maxIdx[3]; col++, j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i][j] = matrix[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="二维矩阵最大旋转子矩阵"><a href="#二维矩阵最大旋转子矩阵" class="headerlink" title="二维矩阵最大旋转子矩阵"></a>二维矩阵最大旋转子矩阵</h4><h5 id="最旋转大子矩阵和"><a href="#最旋转大子矩阵和" class="headerlink" title="最旋转大子矩阵和"></a>最旋转大子矩阵和</h5><p>给定一个正整数和负整数组成的旋转矩阵<code>matrix</code>，返回元素总和最大的子矩阵。</p>
<p>题解：<br>只需要把上题求最大子数组和的函数换为上面提到的最大旋转子数组的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxSubArray(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">    //位于中间 最大和 的 子数组</span><br><span class="line">    int pre = 0, maxMid = nums[0];</span><br><span class="line">    for (const int n : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        pre = max(n, pre + n);</span><br><span class="line">        maxMid = max(maxMid, pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //位于两边 最大和 的 子数组</span><br><span class="line">    //中间最小和</span><br><span class="line">    pre = nums[0];</span><br><span class="line">    int minMid = nums[0], sumn = nums[0];</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre = min(nums[i], pre + nums[i]);</span><br><span class="line">        minMid = min(minMid, pre);</span><br><span class="line">        sumn += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int maxSide = sumn - minMid;</span><br><span class="line"></span><br><span class="line">    return maxMid &gt; maxSide ? maxMid : maxSide;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int maxSubMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)&#123;</span><br><span class="line">    if(matrix.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int rows = matrix.size();</span><br><span class="line">    int cols = matrix[0].size();</span><br><span class="line"></span><br><span class="line">    int res = INT_MIN;</span><br><span class="line">    for (int up = 0; up &lt; rows; up++)//上界</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; nums(cols, 0);//压缩为一维数组</span><br><span class="line">        for (int buttom = up; buttom &lt; rows; buttom++)//下界</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; cols;i++)//每次往下一行，就只需在之前的nums上加上这一行</span><br><span class="line">                nums[i] += matrix[buttom][i];</span><br><span class="line"></span><br><span class="line">            int maxArr = maxSubArray(nums);</span><br><span class="line">            res = max(maxArr, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="返回最大旋转子矩阵"><a href="#返回最大旋转子矩阵" class="headerlink" title="返回最大旋转子矩阵"></a>返回最大旋转子矩阵</h5><p>在上题的基础上记录坐标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxSubArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt; &amp;resIdx) &#123;</span><br><span class="line">    //位于中间 最大和 的 子数组</span><br><span class="line">    int pre = nums[0], start = 0;</span><br><span class="line">    int maxMid = INT_MIN;    </span><br><span class="line">    vector&lt;int&gt; maxIdx(2);</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pre &gt; 0)&#123; //如果返回最长的子数组，这个就应该是 if(pre &gt;= 0)</span><br><span class="line">            pre = pre + nums[i];</span><br><span class="line">        &#125;else&#123;//子数组的开始索引要更新了</span><br><span class="line">            pre = nums[i];</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre &gt; maxMid)&#123;//更新答案</span><br><span class="line">            maxMid = pre;</span><br><span class="line">            maxIdx[0] = start;</span><br><span class="line">            maxIdx[1] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //位于两边 最大和 的 子数组</span><br><span class="line">    //中间最小和</span><br><span class="line">    pre = nums[0]; start = 0;</span><br><span class="line">    int minMid = nums[0], sumn = nums[0];</span><br><span class="line">    vector&lt;int&gt; minIdx(2);</span><br><span class="line">    for (int i = 1; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sumn += nums[i];</span><br><span class="line">        if(pre &lt; 0)&#123;</span><br><span class="line">            pre = pre + nums[i];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            pre = nums[i];</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pre &lt; minMid)&#123;</span><br><span class="line">            minMid = pre;</span><br><span class="line">            minIdx[0] = start;</span><br><span class="line">            minIdx[1] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maxArr = sumn - minMid;</span><br><span class="line">    if (maxMid &gt; maxArr)&#123; //子数组在中间</span><br><span class="line">        resIdx = maxIdx;</span><br><span class="line">        maxArr = maxMid;</span><br><span class="line">    &#125;else&#123;//子数组在两边</span><br><span class="line">        resIdx[0] = (minIdx[1] + 1) % nums.size();</span><br><span class="line">        resIdx[1] = (minIdx[0] - 1 + nums.size()) % nums.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; maxSubMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)&#123;</span><br><span class="line">    if(matrix.empty())</span><br><span class="line">        return matrix;</span><br><span class="line">    int rows = matrix.size();</span><br><span class="line">    int cols = matrix[0].size();</span><br><span class="line"></span><br><span class="line">    int maxArr = INT_MIN;</span><br><span class="line">    vector&lt;int&gt; maxIdx(4);//0上、1左、2下、3右</span><br><span class="line">    for (int up = 0; up &lt; rows; up++)//上界</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; nums(cols, 0);//压缩为一维数组</span><br><span class="line">        for (int down = up; down &lt; rows; down++)//下界</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; cols;i++)//每次往下一行，就只需在之前的nums上加上这一行</span><br><span class="line">                nums[i] += matrix[down][i];</span><br><span class="line"></span><br><span class="line">            vector&lt;int&gt; tmpIdx(2);</span><br><span class="line">            int tmp = maxSubArray(nums, tmpIdx);</span><br><span class="line">            if(tmp &gt; maxArr)&#123;</span><br><span class="line">                maxArr = tmp;</span><br><span class="line">                maxIdx[0] = up;</span><br><span class="line">                maxIdx[1] = tmpIdx[0];</span><br><span class="line">                maxIdx[2] = down;</span><br><span class="line">                maxIdx[3] = tmpIdx[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int subRows = maxIdx[2] - maxIdx[0] + 1;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    if (maxIdx[3] &gt;= maxIdx[1])</span><br><span class="line">    &#123; //子矩阵在中间</span><br><span class="line">        int subCols = maxIdx[3] - maxIdx[1] + 1;</span><br><span class="line">        // vector&lt;int&gt; tmpVec(subCols);</span><br><span class="line">        res.resize(subRows, vector&lt;int&gt;(subCols));</span><br><span class="line">        for (int row = maxIdx[0], i = 0; row &lt;= maxIdx[2]; row++, i++)&#123;</span><br><span class="line">            for (int col = maxIdx[1], j = 0; col &lt;= maxIdx[3]; col++, j++)</span><br><span class="line">                res[i][j] = matrix[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123; //子矩阵在两边</span><br><span class="line">        int subCols = cols - (maxIdx[1] - maxIdx[3] - 1);</span><br><span class="line">        res.resize(subRows,vector&lt;int&gt;(subCols));</span><br><span class="line">        for (int row = maxIdx[0], i = 0; row &lt;= maxIdx[2]; row++, i++)&#123;</span><br><span class="line">            int j = 0;</span><br><span class="line">            for (int col = maxIdx[1]; col &lt; cols; col++, j++)</span><br><span class="line">                res[i][j] = matrix[row][col];</span><br><span class="line">            for (int col = 0; col &lt;= maxIdx[3]; col++,j++)</span><br><span class="line">                res[i][j] = matrix[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-2-4-0-1背包问题"><a href="#3-2-4-0-1背包问题" class="headerlink" title="3.2.4 0-1背包问题"></a>3.2.4 0-1背包问题</h3><p>&amp;emsp;&amp;emsp;有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。<br>&amp;emsp;设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：  </p>
<ul>
<li>第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值<br>就是总体积不超过 j 的前 i-1 件物品的最大价值，<code>dp[i][j] = dp[i-1][j]</code>。</li>
<li>第 i 件物品添加到背包中，<code>dp[i][j] = dp[i-1][j-w] + v</code>。</li>
</ul>
<p>&amp;emsp;&amp;emsp;第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：</p>
<ul>
<li><code>dp[i][j]=max(dp[i-1][j],dp[i-1][j-w]+v)</code></li>
</ul>
<h4 id="二维dp-0-1-背包"><a href="#二维dp-0-1-背包" class="headerlink" title="二维dp 0-1 背包"></a>二维dp 0-1 背包</h4><p><code>dp[i][j]</code>表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int knapsack(vector&lt;vector&lt;int&gt; &gt; &amp;nums, int N)&#123;</span><br><span class="line">    //nums = &#123; &#123;5,12&#125;,&#123;4,3&#125;,&#123;7,10&#125;,&#123;2,3&#125;,&#123;6,6&#125; &#125;;//&#123;wight,val&#125;</span><br><span class="line">    //N = 15;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(nums.size()+1,vector&lt;int&gt;(N+1));</span><br><span class="line">    for (int i = 1; i &lt;= nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= N;j++)&#123;</span><br><span class="line">            int weight = nums[i - 1][0];</span><br><span class="line">            int val = nums[i - 1][1];</span><br><span class="line">            if (j &gt;= weight)</span><br><span class="line">                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight] + val);</span><br><span class="line">            else</span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[nums.size()][N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p>
<h4 id="空间优化：一维dp-0-1-背包"><a href="#空间优化：一维dp-0-1-背包" class="headerlink" title="空间优化：一维dp 0-1 背包"></a>空间优化：一维dp 0-1 背包</h4><p>观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。</p>
<ul>
<li><code>d[j] = max(d[j],d[j-w]+v)</code></li>
</ul>
<p>因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，防止将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int knapsack(vector&lt;vector&lt;int&gt; &gt; &amp;nums, int N)&#123;</span><br><span class="line">    vector&lt;int&gt; dp(N+1);</span><br><span class="line">    for (int i = 1; i &lt;=nums.size();i++)&#123;</span><br><span class="line">        int weight = nums[i - 1][0];</span><br><span class="line">        int val = nums[i - 1][1];</span><br><span class="line">        for (int j = N; j &gt;= 1;j--)&#123;</span><br><span class="line">            if(j&gt;=weight)</span><br><span class="line">                dp[j] = max(dp[j], dp[j - weight] + val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(n)</p>
<h4 id="Leetcode-416-分割等和子集（中等）"><a href="#Leetcode-416-分割等和子集（中等）" class="headerlink" title="Leetcode 416. 分割等和子集（中等）"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">Leetcode 416. 分割等和子集（中等）</a></h4><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>示例：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: [1, 5, 11, 5]  </span><br><span class="line">Output: true  </span><br><span class="line">Explanation: The array can be partitioned as [1, 5, 5] and [11].  </span><br></pre></td></tr></table></figure>
<p>题解：<br>可以看成一个背包大小为 sum&#x2F;2 的 0-1 背包问题。</p>
<ol>
<li>二维dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.size();i++)</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    if(sum &amp; 1)//奇数</span><br><span class="line">        return false;</span><br><span class="line">    int W = sum / 2;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; dp(nums.size()+1,vector&lt;bool&gt;(W+1,false));</span><br><span class="line">    for (int m = 0; m &lt; nums.size();m++)</span><br><span class="line">        dp[m][0] = true;</span><br><span class="line">    for (int i = 1; i &lt;= nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt;= W; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = dp[i - 1][j];</span><br><span class="line">            if((!dp[i][j]) &amp;&amp; j&gt;=nums[i-1])</span><br><span class="line">                dp[i][j] = dp[i - 1][j - nums[i - 1]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[nums.size()][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>一维dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.size();i++)</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    if(sum &amp; 1)//奇数</span><br><span class="line">        return false;</span><br><span class="line">    int W = sum / 2;</span><br><span class="line"></span><br><span class="line">    vector&lt;bool&gt; dp1(W + 1,false);</span><br><span class="line">    dp1[0] = true;</span><br><span class="line">    for(auto num:nums)&#123;</span><br><span class="line">        for (int j = W; j &gt;= num;j--)</span><br><span class="line">            dp1[j] = dp1[j] || dp1[j - num];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp1[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="leetcode-494-目标和（中等）"><a href="#leetcode-494-目标和（中等）" class="headerlink" title="leetcode 494. 目标和（中等）"></a><a href="https://leetcode-cn.com/problems/target-sum/">leetcode 494. 目标和（中等）</a></h4><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>示例：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums is [1, 1, 1, 1, 1], S is 3.  </span><br><span class="line">Output: 5   </span><br><span class="line">Explanation:  </span><br><span class="line">-1+1+1+1+1 = 3  </span><br><span class="line">+1-1+1+1+1 = 3  </span><br><span class="line">+1+1-1+1+1 = 3  </span><br><span class="line">+1+1+1-1+1 = 3  </span><br><span class="line">+1+1+1+1-1 = 3  </span><br><span class="line">There are 5 ways to assign symbols to make the sum of nums be target 3.  </span><br></pre></td></tr></table></figure>
<p>题解：<br>该问题可以转换为 Subset Sum 问题，从而使用 0-1 背包的方法来求解。</p>
<p>可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：</p>
<ul>
<li>sum(P) - sum(N) &#x3D; target</li>
<li>sum(P) + sum(N) + sum(P) - sum(N) &#x3D; target + sum(P) + sum(N)</li>
<li>2 * sum(P) &#x3D; target + sum(nums)</li>
</ul>
<p>因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))&#x2F;2，就证明存在解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123;</span><br><span class="line">    long sum = 0;</span><br><span class="line">    for (const int &amp;num : nums) sum += num;</span><br><span class="line">    if ((S + sum) % 2 == 1 || S &gt; sum) return 0;</span><br><span class="line">    S = (S + sum) / 2;</span><br><span class="line">    vector&lt;int&gt; dp(S+1);</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    for (const int &amp;num : nums) &#123;</span><br><span class="line">        for (int j = S; j &gt;= num; j--)</span><br><span class="line">            dp[j] += dp[j - num];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[S];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nW)<br>空间复杂度：O(W)</p>
<h3 id="0-1-背包问题无法使用贪心算法的解释"><a href="#0-1-背包问题无法使用贪心算法的解释" class="headerlink" title="0-1 背包问题无法使用贪心算法的解释"></a>0-1 背包问题无法使用贪心算法的解释</h3><p>0-1 背包问题无法使用贪心算法来求解，也就是说不能按照先添加性价比最高的物品来达到最优，这是因为这种方式可能造成背包空间的浪费，从而无法达到最优。考虑下面的物品和一个容量为 5 的背包，如果先添加物品 0 再添加物品 1，那么只能存放的价值为 16，浪费了大小为 2 的空间。最优的方式是存放物品 1 和物品 2，价值为 22.  </p>
<table>
<thead>
<tr>
<th>id</th>
<th>w</th>
<th>v</th>
<th>v&#x2F;w</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>10</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>12</td>
<td>4</td>
</tr>
</tbody></table>
<h4 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h4><ul>
<li>完全背包：物品数量为无限个</li>
<li>多重背包：物品数量有限制</li>
<li>多维费用背包：物品不仅有重量，还有体积，同时考虑这两种限制</li>
<li>其它：物品之间相互约束或者依赖</li>
</ul>
<h3 id="3-2-5-股票问题"><a href="#3-2-5-股票问题" class="headerlink" title="3.2.5 股票问题"></a>3.2.5 股票问题</h3><h4 id="Leetcode-121-买卖股票的最佳时机（简单）"><a href="#Leetcode-121-买卖股票的最佳时机（简单）" class="headerlink" title="Leetcode 121. 买卖股票的最佳时机（简单）"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">Leetcode 121. 买卖股票的最佳时机（简单）</a></h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>
<p>题解：<br>用<code>minPrices</code>来记录历史最低价，<code>res</code>目前的最大收益。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if(prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int minPrices = prices[0], res = 0;</span><br><span class="line">    for(int &amp;p:prices)&#123;</span><br><span class="line">        res = max(res, p - minPrices);</span><br><span class="line">        minPrices = min(p,minPrices);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-122-买卖股票的最佳时机-II（简单）"><a href="#Leetcode-122-买卖股票的最佳时机-II（简单）" class="headerlink" title="Leetcode 122. 买卖股票的最佳时机 II（简单）"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">Leetcode 122. 买卖股票的最佳时机 II（简单）</a></h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>示例：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>贪心。只要第二天价格有上升，就可以获利。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">        if (prices[i] &gt; prices[i - 1])</span><br><span class="line">            res += prices[i] - prices[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<ol start="2">
<li>空间优化dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if (prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int dp0 = 0, dp1 = -prices[0];</span><br><span class="line">    int n = prices.size();</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        int dp0_new = max(dp0, dp1 + prices[i]);</span><br><span class="line">        int dp1_new = max(dp1, dp0 - prices[i]);</span><br><span class="line">        dp0 = dp0_new;</span><br><span class="line">        dp1 = dp1_new;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-123-买卖股票的最佳时机-III（困难）"><a href="#Leetcode-123-买卖股票的最佳时机-III（困难）" class="headerlink" title="Leetcode 123. 买卖股票的最佳时机 III（困难）"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">Leetcode 123. 买卖股票的最佳时机 III（困难）</a></h4><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,3,5,0,0,3,1,4]  </span><br><span class="line">输出: 6  </span><br><span class="line">解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。  </span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5]  </span><br><span class="line">输出: 4  </span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出,这笔交易所能获得利润 = 5-1 = 4。`注意`你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。  </span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]   </span><br><span class="line">输出: 0   </span><br><span class="line">解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if (prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    int n = prices.size();</span><br><span class="line">    vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; dp(n,vector&lt;vector&lt;int&gt; &gt;(3, vector&lt;int&gt;(2)));</span><br><span class="line">    dp[0][1][0] = 0;</span><br><span class="line">    dp[0][1][1] = -prices[0];</span><br><span class="line">    dp[0][2][0] = 0;</span><br><span class="line">    dp[0][2][1] = -prices[0];</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][2][0] = max(dp[i - 1][2][0], dp[i - 1][2][1] + prices[i]);</span><br><span class="line">        dp[i][2][1] = max(dp[i - 1][2][1], dp[i - 1][1][0] - prices[i]);</span><br><span class="line">        dp[i][1][0] = max(dp[i - 1][1][0], dp[i - 1][1][1] + prices[i]);</span><br><span class="line">        dp[i][1][1] = max(dp[i - 1][1][1], dp[i - 1][0][0] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n - 1][2][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>空间优化dp</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if (prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    int n = prices.size();</span><br><span class="line">    int dp10 = 0;</span><br><span class="line">    int dp11 = -prices[0];</span><br><span class="line">    int dp20 = 0;</span><br><span class="line">    int dp21 = -prices[0];</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        dp20 = max(dp20, dp21 + prices[i]);</span><br><span class="line">        dp21 = max(dp21, dp10 - prices[i]);</span><br><span class="line">        dp10 = max(dp10, dp11 + prices[i]);</span><br><span class="line">        dp11 = max(dp11, -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-188-买卖股票的最佳时机-IV（困难）"><a href="#Leetcode-188-买卖股票的最佳时机-IV（困难）" class="headerlink" title="Leetcode 188. 买卖股票的最佳时机 IV（困难）"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">Leetcode 188. 买卖股票的最佳时机 IV（困难）</a></h4><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [2,4,1], k = 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</span><br></pre></td></tr></table></figure>
<p>题解：<br>一个有收益的交易至少需要两天（在前一天买入，在后一天卖出，前提是买入价格低于卖出价格）。如果股票价格数组的长度为 n，则有收益的交易的数量最多为 n &#x2F; 2（整数除法）。因此 k 的临界值是 n &#x2F; 2。如果给定的 k 不小于临界值，即 k &gt;&#x3D; n &#x2F; 2，则可以将 k 扩展为正无穷，此时问题等价于Leetcode 122。</p>
<p>其中用到了函数重载。</p>
<ol>
<li>dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">        if (prices[i] &gt; prices[i - 1])</span><br><span class="line">            res += prices[i] - prices[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if (prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int n = prices.size();</span><br><span class="line">    if (k &gt;= n / 2)</span><br><span class="line">        return maxProfit(prices);</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; dp(n,vector&lt;vector&lt;int&gt; &gt;(k+1, vector&lt;int&gt;(2)));</span><br><span class="line">    for (int i = 1; i &lt;= k; i++) &#123;</span><br><span class="line">        dp[0][i][0] = 0;</span><br><span class="line">        dp[0][i][1] = -prices[0];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = k; j &gt; 0; j--) &#123;</span><br><span class="line">            dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);</span><br><span class="line">            dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n - 1][k][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nk)<br>空间复杂度：O(nk)</p>
<ol start="2">
<li>空间优化。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 1; i &lt; prices.size(); i++) &#123;</span><br><span class="line">        if (prices[i] &gt; prices[i - 1])</span><br><span class="line">            res += prices[i] - prices[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if (prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int n = prices.size();</span><br><span class="line">    if (k &gt;= n / 2)</span><br><span class="line">        return maxProfit(prices);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(k+1, vector&lt;int&gt;(2));</span><br><span class="line">    for (int i = 1; i &lt;= k; i++) &#123;</span><br><span class="line">        dp[i][0] = 0;</span><br><span class="line">        dp[i][1] = -prices[0];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = k; j &gt; 0; j--) &#123;</span><br><span class="line">            dp[j][0] = max(dp[j][0], dp[j][1] + prices[i]);</span><br><span class="line">            dp[j][1] = max(dp[j][1], dp[j - 1][0] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[k][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nk)<br>空间复杂度：O(n)</p>
<h4 id="Leetcode-309-最佳买卖股票时机含冷冻期（中等）"><a href="#Leetcode-309-最佳买卖股票时机含冷冻期（中等）" class="headerlink" title="Leetcode 309. 最佳买卖股票时机含冷冻期（中等）"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">Leetcode 309. 最佳买卖股票时机含冷冻期（中等）</a></h4><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,0,2]  </span><br><span class="line">输出: 3   </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>dp。<code>dp[i]</code>表示第 i 天结束之后的<strong>累计最大收益</strong>。<ul>
<li><code>dp[i][0]</code>表示目前持有一支股票，对应的累计最大收益</li>
<li><code>dp[i][1]</code>表示目前不持有任何股票，并且处于冷冻期中，对应的累计最大收益</li>
<li><code>dp[i][2]</code>表示目前不持有任何股票，并且不处于冷冻期中，对应的累计最大收益</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if(prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(prices.size(), vector&lt;int&gt;(3));</span><br><span class="line">    dp[0][0] = -prices[0]; //dp[0][1] = dp[0][2] = 0</span><br><span class="line">    for (int i = 1; i &lt; prices.size();i++)&#123;</span><br><span class="line">        dp[i][0] = max(dp[i - 1][2] - prices[i], dp[i - 1][0]); //买了，或者没有买。不可能从冷却期直接到持有</span><br><span class="line">        dp[i][1] = dp[i - 1][0] + prices[i]; //卖了</span><br><span class="line">        dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]); //冷却期过度，或者没有买</span><br><span class="line">    &#125;</span><br><span class="line">    return max(dp[prices.size() - 1][1], dp[prices.size() - 1][2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>空间优化。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">    if(prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int dp0 = -prices[0];</span><br><span class="line">    int dp1 = 0;</span><br><span class="line">    int dp2 = 0;</span><br><span class="line">    for (int i = 1; i &lt; prices.size(); ++i) &#123;</span><br><span class="line">        int dp0_new = max(dp0, dp2 - prices[i]);</span><br><span class="line">        int dp1_new = dp0 + prices[i];</span><br><span class="line">        int dp2_new = max(dp1, dp2);</span><br><span class="line">        dp0 = dp0_new;</span><br><span class="line">        dp1 = dp1_new;</span><br><span class="line">        dp2 = dp2_new;</span><br><span class="line">    &#125;</span><br><span class="line">    return max(dp1, dp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-714-买卖股票的最佳时机含手续费（中等）"><a href="#Leetcode-714-买卖股票的最佳时机含手续费（中等）" class="headerlink" title="Leetcode 714. 买卖股票的最佳时机含手续费（中等）"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">Leetcode 714. 买卖股票的最佳时机含手续费（中等）</a></h4><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [1, 3, 2, 8, 4, 9], fee = 2  </span><br><span class="line">Output: 8  </span><br><span class="line">Explanation: The maximum profit can be achieved by:  </span><br><span class="line">Buying at prices[0] = 1  </span><br><span class="line">Selling at prices[3] = 8  </span><br><span class="line">Buying at prices[4] = 4  </span><br><span class="line">Selling at prices[5] = 9  </span><br><span class="line">The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>dp。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">    if (prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int n = prices.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(n,vector&lt;int&gt;(2));</span><br><span class="line">    dp[0][0] = 0;</span><br><span class="line">    dp[0][1] = -prices[0];</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);</span><br><span class="line">        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n - 1][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>空间优化。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">    if (prices.empty())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    int n = prices.size();</span><br><span class="line">    int dp0 = 0;</span><br><span class="line">    int dp1 = -prices[0];</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        int dp0_new = max(dp0, dp1 + prices[i] - fee);</span><br><span class="line">        int dp1_new = max(dp1, dp0 - prices[i]);</span><br><span class="line">        dp0 = dp0_new;</span><br><span class="line">        dp1 = dp1_new;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="res"><a href="#res" class="headerlink" title="res"></a>res</h4><p><a href="https://leetcode-cn.com/circle/article/qiAgHn/">股票问题系列通解</a></p>
<h3 id="3-2-6-字符串问题"><a href="#3-2-6-字符串问题" class="headerlink" title="3.2.6 字符串问题"></a>3.2.6 字符串问题</h3><h4 id="Leetcode-650-只有两个键的键盘（中等）"><a href="#Leetcode-650-只有两个键的键盘（中等）" class="headerlink" title="Leetcode 650. 只有两个键的键盘（中等）"></a><a href="https://leetcode-cn.com/problems/2-keys-keyboard/">Leetcode 650. 只有两个键的键盘（中等）</a></h4><p>最开始只有一个字符 A，问需要多少次操作能够得到 n 个字符 A，每次操作可以复制当前所有的字符，或者粘贴。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">最初, 我们只有一个字符 &#x27;A&#x27;。</span><br><span class="line">第 1 步, 我们使用 Copy All 操作。</span><br><span class="line">第 2 步, 我们使用 Paste 操作来获得 &#x27;AA&#x27;。</span><br><span class="line">第 3 步, 我们使用 Paste 操作来获得 &#x27;AAA&#x27;。</span><br></pre></td></tr></table></figure>
<p>题解：<br>dp。<code>dp[i]</code>表示通过复制粘贴操作，得到 i 个字符，最少需要几步操作。  </p>
<p>如果一个数是素数，那么最少操作就是一开始复制一个，最后一个个粘贴；如果一个数不是素数，那么最少操作就可以按它的因数分解一下，简化操作。  </p>
<p>比如12，可以分解为 以下几种情况：  </p>
<ul>
<li>12 &#x3D; 2*6, 需要操作CPCPPPPP总共8步  </li>
<li>12 &#x3D; 3*4, 需要操作CPPCPPP总共7步  </li>
<li>12 &#x3D; 4*3, 需要操作CPPPCPP总共7步  </li>
<li>12 &#x3D; 6*2, 需要操作CPPPPPCP总共8步</li>
</ul>
<p>其实可以发现，因子相同的情况下，交换因子相乘的顺序，需要的步骤是一样的。所以我们可以简化一下分解的步骤，只需要找到小于<code>sqrt(n)</code>的因子即可。假设找到的因子是 j ，那么需要的最小步骤就是 <code>dp[j] + dp[i/j]</code>，其中，<code>dp[j]</code>表示需要多少步生成这个因子，<code>dp[i/j]</code>表示需要多少步基于这个因子得到 i。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int minSteps(int n)&#123;</span><br><span class="line">    vector&lt;int&gt; dp(n + 1);</span><br><span class="line">    int h = sqrt(n);</span><br><span class="line">    for (int i = 2; i &lt;= n;i++)&#123;</span><br><span class="line">        dp[i] = i;</span><br><span class="line">        for (int j = 2; j &lt;= h; j++)&#123;</span><br><span class="line">            if(i%j==0)&#123;</span><br><span class="line">                dp[i] = dp[j] + dp[i / j];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^(1&#x2F;2))<br>空间复杂度：O(1)</p>
<h2 id="3-3-贪心算法-greedy"><a href="#3-3-贪心算法-greedy" class="headerlink" title="3.3 贪心算法(greedy)"></a>3.3 贪心算法(greedy)</h2><p>每次都选择局部最优的策略，最后达到全局最优。但是，有的问题使用贪心算法不能保证达到全局最优，如 0-1背包问题。  </p>
<h3 id="Leetcode-455-分发饼干（简单）"><a href="#Leetcode-455-分发饼干（简单）" class="headerlink" title="Leetcode 455. 分发饼干（简单）"></a><a href="https://leetcode-cn.com/problems/assign-cookies/">Leetcode 455. 分发饼干（简单）</a></h3><p>每个孩子都有一个满足度 grid，每个饼干都有一个大小 size，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。  </p>
<p>示例：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: grid[1,3], size[1,2,4]  </span><br><span class="line">Output: 2  </span><br></pre></td></tr></table></figure>
<p>题解：<br>给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;</span><br><span class="line">    sort(g.begin(), g.end());</span><br><span class="line">    sort(s.begin(), s.end());</span><br><span class="line"></span><br><span class="line">    int m = g.size();</span><br><span class="line">    int n = s.size();</span><br><span class="line">    int idxG = 0, idxS = 0;</span><br><span class="line">    while(idxG&lt;m &amp;&amp; idxS&lt;n)&#123;</span><br><span class="line">        if(g[idxG]&lt;=s[idxS])</span><br><span class="line">            idxG++;</span><br><span class="line">        idxS++;</span><br><span class="line">    &#125;</span><br><span class="line">    return idxG;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)，因为要排序<br>空间复杂度：O(1)</p>
<h3 id="上一题的变体"><a href="#上一题的变体" class="headerlink" title="上一题的变体"></a>上一题的变体</h3><p>要求出满足最多孩子的方法中每个孩子得到的的饼干编号。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = &#123;90, 33, 16&#125; size = &#123;9, 20, 50, 40, 99, 1&#125;</span><br><span class="line"></span><br><span class="line">输出： 5 4 2</span><br></pre></td></tr></table></figure>
<p>题解：<br>使用了map的自动key排序功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; cookiesAssign2(vector&lt;int&gt; &amp;grid, vector&lt;int&gt; &amp;size)&#123;</span><br><span class="line">    map&lt;int, int&gt; sizeMap; //key: grid val: idx</span><br><span class="line">    map&lt;int, int&gt; gridMap; //key: size val: idx</span><br><span class="line">    for (int i = 0; i &lt; grid.size(); i++)</span><br><span class="line">        gridMap.insert(&#123;grid[i], i&#125;);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; size.size();i++)</span><br><span class="line">        sizeMap.insert(&#123;size[i], i&#125;);</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; res(grid.size(), -1);</span><br><span class="line">    for (auto itG = gridMap.begin(), itS = sizeMap.begin(); itG != gridMap.end() &amp;&amp; itS!=sizeMap.end(); itG++, itS++)</span><br><span class="line">    &#123;</span><br><span class="line">        while(itS!=sizeMap.end() &amp;&amp; itS-&gt;first &lt; itG-&gt;first)</span><br><span class="line">            itS++;</span><br><span class="line">        if(itS==sizeMap.end())</span><br><span class="line">            break;</span><br><span class="line">        res[itG-&gt;second] = itS-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Leetcode-435-无重叠区间（中等）"><a href="#Leetcode-435-无重叠区间（中等）" class="headerlink" title="Leetcode 435. 无重叠区间（中等）"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">Leetcode 435. 无重叠区间（中等）</a></h3><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: [ [1,2], [1,2], [1,2] ]  </span><br><span class="line">Output: 2  </span><br><span class="line">Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.  </span><br><span class="line">Input: [ [1,2], [2,3] ]  </span><br><span class="line">Output: 0  </span><br><span class="line">Explanation: You don&#x27;t need to remove any of the intervals since they&#x27;re already non-overlapping.  </span><br></pre></td></tr></table></figure>
<p>题解：<br>先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123;</span><br><span class="line">    return a[1] &lt; b[1];</span><br><span class="line">&#125;</span><br><span class="line">int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals)&#123;</span><br><span class="line">    if(intervals.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    int end = intervals[0][0];</span><br><span class="line">    for(auto num:intervals)&#123;</span><br><span class="line">        if(num[0]&gt;=end)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            end = num[1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return intervals.size()-cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)，因为要排序<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-452-用最少数量的箭引爆气球（中等）"><a href="#Leetcode-452-用最少数量的箭引爆气球（中等）" class="headerlink" title="Leetcode 452. 用最少数量的箭引爆气球（中等）"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">Leetcode 452. 用最少数量的箭引爆气球（中等）</a></h3><p>气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input:[[10,16], [2,8], [1,6], [7,12]]  </span><br><span class="line">Output:2  </span><br></pre></td></tr></table></figure>
<p>题解：<br>求解最小的投飞镖次数使所有气球都被刺破。也是计算不重叠的区间个数，不过和 Leetcode 435 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。所以if判定条件不要”&#x3D;”，<code>end</code>初始化要比<code>points[0][0]</code>小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123;</span><br><span class="line">    return a[1] &lt; b[1];</span><br><span class="line">&#125;</span><br><span class="line">int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;</span><br><span class="line">    if(points.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    sort(points.begin(), points.end(), cmp);</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    long end = (long)points[0][0]-1;</span><br><span class="line">    for(auto num:points)&#123;</span><br><span class="line">        if(num[0]&gt;end)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            end = num[1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)，因为要排序<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-406-根据身高重建队列（中等）"><a href="#Leetcode-406-根据身高重建队列（中等）" class="headerlink" title="Leetcode 406. 根据身高重建队列（中等）"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">Leetcode 406. 根据身高重建队列（中等）</a></h3><p>乱序重建：一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]  </span><br><span class="line">Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]  </span><br></pre></td></tr></table></figure>
<p>题解：<br>为了使插入操作不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置。身高 h 降序、个数 k 值升序，然后将某个学生插入队列的第 k 个位置中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool cmp0aca1dec(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123;</span><br><span class="line">    return a[0] == b[0] ? a[1] &lt;= b[1] : a[0] &gt; b[0];</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">    if(people.empty())</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    sort(people.begin(), people.end(), cmp0aca1dec);</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    for (int i = 0; i &lt; people.size(); i++)&#123;</span><br><span class="line">        auto pos = res.begin();</span><br><span class="line">        res.insert(pos+people[i][1], people[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Leetcode-605-种花问题（简单）"><a href="#Leetcode-605-种花问题（简单）" class="headerlink" title="Leetcode 605. 种花问题（简单）"></a><a href="https://leetcode-cn.com/problems/can-place-flowers/">Leetcode 605. 种花问题（简单）</a></h3><p>flowerbed 数组中 1 表示已经种下了花朵。花朵之间至少需要一个单位的间隔，求解是否能种下 n 朵花。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: flowerbed = [1,0,0,0,1], n = 1  </span><br><span class="line">Output: True  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123;</span><br><span class="line">    int nFlower = flowerbed.size();</span><br><span class="line">    if(n==0)</span><br><span class="line">        return true;</span><br><span class="line">    for (int i = 0; i &lt; nFlower; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(flowerbed[i]==1)</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        int pre = i-1 &gt;= 0 ? flowerbed[i - 1] : 0; //第一个位置?</span><br><span class="line">        int next = i+1 &lt;= nFlower-1 ? flowerbed[i + 1] : flowerbed[nFlower-1];//最后一个位置?</span><br><span class="line">        if(pre==0 &amp;&amp; next==0 )&#123;</span><br><span class="line">            flowerbed[i] = 1;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n==0)</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-392-判断子序列（简单）"><a href="#Leetcode-392-判断子序列（简单）" class="headerlink" title="Leetcode 392.判断子序列（简单）"></a><a href="https://leetcode-cn.com/problems/is-subsequence/">Leetcode 392.判断子序列（简单）</a></h3><p>判断是否为子序列 </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &quot;abc&quot;, t = &quot;ahbgdc&quot;  </span><br><span class="line">Return true.  </span><br></pre></td></tr></table></figure>
<p>题解：<br>双指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isSubsequence(string s, string t) &#123;</span><br><span class="line">    if(t.empty())&#123;</span><br><span class="line">        if(s.empty())</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int idxS=0,idxT=0;</span><br><span class="line">    while(idxS&lt;s.size() &amp;&amp; idxT&lt;t.size())&#123;</span><br><span class="line">        if(s[idxS]==t[idxT])</span><br><span class="line">            idxS++;</span><br><span class="line">        idxT++;</span><br><span class="line">    &#125;</span><br><span class="line">    return idxS==s.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m+n)<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-665-非递减数列（简单）"><a href="#Leetcode-665-非递减数列（简单）" class="headerlink" title="Leetcode 665. 非递减数列（简单）"></a><a href="https://leetcode-cn.com/problems/non-decreasing-array/">Leetcode 665. 非递减数列（简单）</a></h3><p>判断一个数组是否能只修改一个数就成为非递减数组。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: [4,2,3]  </span><br><span class="line">Output: True  </span><br><span class="line">Explanation: You could modify the first 4 to 1 to get a non-decreasing array.  </span><br></pre></td></tr></table></figure>
<p>题解：<br>如果下一个点有下降，我们当前点称为拐点，如[1,3,2]中的3。</p>
<ul>
<li>如果拐点前一个数小于等于拐点后一个数，如[1,3,2,4,5]中1&lt;2，则改变拐点的数，把 3 变成 2 能保证数列不减，且不改变前后的拐点数。</li>
<li>如果拐点前一个数大于拐点后一个数，如[2,3,1,4,5]中2&gt;1，则改变拐点后的数，把 1 变成 3 能保证数列不减，且不改变前后的拐点数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (int i = 1; i &lt; nums.size() &amp;&amp; cnt &lt; 2;i++)&#123;</span><br><span class="line">        if(nums[i]&gt;=nums[i-1])</span><br><span class="line">            continue;</span><br><span class="line">        cnt++;</span><br><span class="line">        if(i&gt;=2 &amp;&amp; nums[i-2]&gt;nums[i])</span><br><span class="line">            nums[i] = nums[i - 1];</span><br><span class="line">        else</span><br><span class="line">            nums[i - 1] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return (cnt &lt;= 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-763-划分字母区间（中等）"><a href="#Leetcode-763-划分字母区间（中等）" class="headerlink" title="Leetcode 763. 划分字母区间（中等）"></a><a href="https://leetcode-cn.com/problems/partition-labels/">Leetcode 763. 划分字母区间（中等）</a></h3><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: S = &quot;ababcbacadefegdehijhklij&quot;  </span><br><span class="line">Output: [9,7,8]  </span><br><span class="line">Explanation:  </span><br><span class="line">The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.  </span><br><span class="line">This is a partition so that each letter appears in at most one part. A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts.  </span><br></pre></td></tr></table></figure>
<p>题解：<br>策略就是不断地选择从最左边起最小的区间。</p>
<p>可以从第一个字母开始分析，假设第一个字母是 ‘a’，那么第一个区间一定包含最后一次出现的 ‘a’。但第一个出现的 ‘a’ 和最后一个出现的 ‘a’ 之间可能还有其他字母，这些字母会让区间变大。举个例子，在 “abccaddbeffe” 字符串中，第一个最小的区间是 “abccaddb”。  </p>
<p>通过以上的分析，我们可以得出一个算法：对于遇到的每一个字母，去找这个字母最后一次出现的位置，用来更新当前的最小区间。如果要输出所有子串，把备注取消就可以。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; partitionLabels(string S) &#123;</span><br><span class="line">    vector&lt;int&gt; alphabet(26);</span><br><span class="line">    for (int i = 0; i &lt; S.size();i++)</span><br><span class="line">        alphabet[S[i] - &#x27;a&#x27;] = i;</span><br><span class="line"></span><br><span class="line">    int startIdx = 0, lastIdx = 0;</span><br><span class="line">    //vector&lt;string&gt; subS;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for (int i = 0; i &lt; S.size(); i++)&#123;</span><br><span class="line">        char tmp = S[i];</span><br><span class="line">        lastIdx = max(alphabet[tmp - &#x27;a&#x27;], lastIdx);</span><br><span class="line">        if(lastIdx==i)&#123;</span><br><span class="line">            res.push_back(lastIdx - startIdx + 1);</span><br><span class="line">            //string tmpStr = S.substr(startIdx, lastIdx - startIdx + 1);</span><br><span class="line">            //subS.push_back(tmpStr);</span><br><span class="line">            startIdx = i + 1;</span><br><span class="line">            lastIdx = i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h2 id="3-4-双指针"><a href="#3-4-双指针" class="headerlink" title="3.4 双指针"></a>3.4 双指针</h2><p>双指针主要用于遍历数组，两个指针指向不同的位置，协同完成任务。  </p>
<p>（剑指offer的双指针操作）</p>
<h3 id="Leetcode-167-两数之和-II-输入有序数组（简单）"><a href="#Leetcode-167-两数之和-II-输入有序数组（简单）" class="headerlink" title="Leetcode 167. 两数之和 II - 输入有序数组（简单）"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">Leetcode 167. 两数之和 II - 输入有序数组（简单）</a></h3><p>给定一个已按照<strong>升序排列</strong>的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<p><strong>说明</strong>:</p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: numbers=&#123;2, 7, 11, 15&#125;, target=9  </span><br><span class="line">Output: index1=1, index2=2  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历：</li>
</ol>
<ul>
<li>如果两个指针指向元素的和 sum &#x3D;&#x3D; target，那么得到要求的结果；</li>
<li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li>
<li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">    if(numbers.empty())</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    int start = 0;</span><br><span class="line">    int end = numbers.size()-1;</span><br><span class="line">    while(start&lt;end)&#123;</span><br><span class="line">        if(numbers[start]+numbers[end] == target)</span><br><span class="line">            return &#123;start+1, end+1&#125;;</span><br><span class="line">        if(numbers[start]+numbers[end]&gt;target)</span><br><span class="line">            end --;</span><br><span class="line">        else if(numbers[start]+numbers[end]&lt;target)</span><br><span class="line">            start ++;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<ol start="2">
<li>哈希表。无序的序列也适用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">    unordered_map&lt;int, int&gt; numMap;</span><br><span class="line">    for (int i = 0; i &lt; numbers.size();i++)</span><br><span class="line">        numMap[numbers[i]] = i;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; numbers.size();i++)&#123;</span><br><span class="line">        auto it = numMap.find(target - numbers[i]);</span><br><span class="line">        if (it != numMap.end())</span><br><span class="line">            return &#123;i + 1, it-&gt;second+1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h3 id="Leetcode-633-平方数之和（简单）"><a href="#Leetcode-633-平方数之和（简单）" class="headerlink" title="Leetcode 633. 平方数之和（简单）"></a><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/">Leetcode 633. 平方数之和（简单）</a></h3><p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 &#x3D; c 。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: 5  </span><br><span class="line">Output: True  </span><br><span class="line">Explanation: 1 * 1 + 2 * 2 = 5  </span><br></pre></td></tr></table></figure>
<p>题解：<br>本题和 「167. 两数之和 II - 输入有序数组」 类似，只有一个明显区别：一个是和为 target，一个是平方和为 target。本题同样可以使用双指针得到两个数，使其平方和为 target。<br>本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 0^2 + x^2 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。因为最多只需要遍历一次 0-sqrt(target)，所以时间复杂度为 O(sqrt(target))。又因为只使用了两个额外的变量，因此空间复杂度为 O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool judgeSquareSum(int c) &#123;</span><br><span class="line">    if(c &lt; 0) </span><br><span class="line">        return false;</span><br><span class="line">    int start = 0;</span><br><span class="line">    int end = sqrt(c);</span><br><span class="line">    while(start&lt;=end)&#123;</span><br><span class="line">        if((long)start*start + (long)end*end == (long)c)</span><br><span class="line">            return true;</span><br><span class="line">        else if((long)start*start + (long)end*end &gt; (long)c)</span><br><span class="line">            end--;</span><br><span class="line">        else</span><br><span class="line">            start++;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(c^(1&#x2F;2))<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-345-反转字符串中的元音字母（简单）"><a href="#Leetcode-345-反转字符串中的元音字母（简单）" class="headerlink" title="Leetcode 345. 反转字符串中的元音字母（简单）"></a><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">Leetcode 345. 反转字符串中的元音字母（简单）</a></h3><p>反转字符串中的元音字符</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given s = &quot;Leetcode&quot;, return &quot;Leotcede&quot;.  </span><br></pre></td></tr></table></figure>
<p>题解：<br>使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。为了快速判断一个字符是不是元音字符，我们将全部元音字符添加到集合 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string reverseVowels(string s) &#123;</span><br><span class="line">    unordered_set&lt;char&gt; hs = &#123;&#x27;a&#x27;,&#x27;e&#x27;,&#x27;i&#x27;,&#x27;o&#x27;,&#x27;u&#x27;,&#x27;A&#x27;,&#x27;E&#x27;,&#x27;I&#x27;,&#x27;O&#x27;,&#x27;U&#x27;&#125;;//c++11之后才可以这样初始化</span><br><span class="line">    int start = 0;</span><br><span class="line">    int end = s.size() - 1;</span><br><span class="line">    string res = s;</span><br><span class="line">    while (start&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        char tmp_start = s[start];</span><br><span class="line">        char tmp_end = s[end];</span><br><span class="line">        if (hs.find(tmp_start)==hs.end())//tmp不在hs中</span><br><span class="line">            res[start++] = tmp_start;</span><br><span class="line">        else if(hs.find(tmp_end)==hs.end())</span><br><span class="line">            res[end--] = tmp_end;</span><br><span class="line">        else&#123;</span><br><span class="line">            res[start++] = tmp_end;</span><br><span class="line">            res[end--] = tmp_start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-680-验证回文字符串-Ⅱ（简单）"><a href="#Leetcode-680-验证回文字符串-Ⅱ（简单）" class="headerlink" title="Leetcode 680. 验证回文字符串 Ⅱ（简单）"></a><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">Leetcode 680. 验证回文字符串 Ⅱ（简单）</a></h3><p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: &quot;abca&quot;  </span><br><span class="line">Output: True  </span><br><span class="line">Explanation: You could delete the character &#x27;c&#x27;.  </span><br></pre></td></tr></table></figure>
<p>题解：<br>使用双指针可以很容易判断一个字符串是否是回文字符串：<br>令一个指针从左到右遍历，一个指针从右到左遍历，这两个指针同时移动一个位置，每次都判断两个指针指向的字符是否相同，如果都相同，字符串才是具有左右对称性质的回文字符串。在判断是否为回文字符串时，我们不需要判断整个字符串，因为左指针左边和右指针右边的字符之前已经判断过具有对称性质，所以只需要判断中间的子字符串即可。在试着删除字符时，我们既可以删除左指针指向的字符，也可以删除右指针指向的字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isPalindrome(string s,int start,int end)&#123;</span><br><span class="line">    while(start &lt; end)&#123;</span><br><span class="line">        if (s[start++]!=s[end--])</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">bool validPalindrome(string s) &#123;</span><br><span class="line">    if(s.size()&lt;=1)</span><br><span class="line">        return true;</span><br><span class="line">    int start = 0;</span><br><span class="line">    int end = s.size() - 1;</span><br><span class="line">    bool res = true;</span><br><span class="line">    while (start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        if (s[start] != s[end])</span><br><span class="line">        &#123;</span><br><span class="line">            res = isPalindrome(s, start + 1, end) || isPalindrome(s, start, end - 1);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-88-合并两个有序数组（简单）"><a href="#Leetcode-88-合并两个有序数组（简单）" class="headerlink" title="Leetcode 88. 合并两个有序数组（简单）"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/">Leetcode 88. 合并两个有序数组（简单）</a></h3><p>归并两个有序数组，把归并结果存到第一个数组上。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input:  </span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3  </span><br><span class="line">nums2 = [2,5,6],       n = 3  </span><br><span class="line">Output: [1,2,2,3,5,6]  </span><br></pre></td></tr></table></figure>
<p>题解：<br>需要从尾开始遍历，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">    int idx1 = m - 1;</span><br><span class="line">    int idx2 = n - 1;</span><br><span class="line">    int idx = m + n - 1;</span><br><span class="line">    while (idx1&gt;=0 || idx2&gt;=0)&#123;</span><br><span class="line">        if(idx1&lt;0)</span><br><span class="line">            nums1[idx--] = nums2[idx2--];</span><br><span class="line">        else if(idx2&lt;0)//这时候nums2已经插完，其实可以直接return nums1了</span><br><span class="line">            nums1[idx--] = nums1[idx1--];</span><br><span class="line">        else if(nums1[idx1]&gt;nums2[idx2])</span><br><span class="line">            nums1[idx--] = nums1[idx1--];</span><br><span class="line">        else</span><br><span class="line">            nums1[idx--] = nums2[idx2--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m+n)<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-141-环形链表（简单）"><a href="#Leetcode-141-环形链表（简单）" class="headerlink" title="Leetcode 141. 环形链表（简单）"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">Leetcode 141. 环形链表（简单）</a></h3><p>判断链表是否存在环</p>
<ol>
<li>双指针（快慢指针），一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool hasCycle(ListNode *head) &#123;</span><br><span class="line">    if(head == nullptr || head-&gt;next == nullptr)</span><br><span class="line">        return false;</span><br><span class="line">    ListNode *p1 = head-&gt;next;</span><br><span class="line">    ListNode *p2 = head-&gt;next-&gt;next;</span><br><span class="line">    while(p2!=nullptr &amp;&amp; p2-&gt;next!=nullptr)&#123;</span><br><span class="line">        if(p1-&gt;val == p2-&gt;val)</span><br><span class="line">            return true;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<ol start="2">
<li>哈希表。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool hasCycle(ListNode *head) &#123;</span><br><span class="line">    if(head == nullptr || head-&gt;next == nullptr)</span><br><span class="line">        return false;</span><br><span class="line">    unordered_set&lt;ListNode *&gt; us;</span><br><span class="line">    while (head != nullptr)&#123;</span><br><span class="line">        if (us.count(head))</span><br><span class="line">            return true;</span><br><span class="line">        us.insert(head);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<h3 id="Leetcode-524-通过删除字母匹配到字典里最长单词（中等）"><a href="#Leetcode-524-通过删除字母匹配到字典里最长单词（中等）" class="headerlink" title="Leetcode 524. 通过删除字母匹配到字典里最长单词（中等）"></a><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">Leetcode 524. 通过删除字母匹配到字典里最长单词（中等）</a></h3><p>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]  </span><br><span class="line">Output: &quot;apple&quot;  </span><br></pre></td></tr></table></figure>
<p>题解：<br>可以使用双指针来判断一个字符串是否为另一个字符串的子序列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isSubstr(string s, string d)&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line">    while(i&lt;s.size() &amp;&amp; j&lt;d.size())&#123;</span><br><span class="line">        if(s[i]==d[j])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return j == d.size();</span><br><span class="line">&#125;</span><br><span class="line">string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    for (string cur:d)&#123;</span><br><span class="line">        if(res.size()&gt;cur.size() || (res.size()==cur.size() &amp;&amp; res&lt;cur))</span><br><span class="line">            continue;</span><br><span class="line">        if (isSubstr(s, cur))</span><br><span class="line">            res = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nl)，l 是字典里字符串的平均长度<br>空间复杂度：O(n)</p>
<h3 id="Leetcode-75-颜色分类（中等）"><a href="#Leetcode-75-颜色分类（中等）" class="headerlink" title="Leetcode 75. 颜色分类（中等）"></a><a href="https://leetcode-cn.com/problems/sort-colors/">Leetcode 75. 颜色分类（中等）</a></h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: [2,0,2,1,1,0] </span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int zero = -1;</span><br><span class="line">    int one = 0;</span><br><span class="line">    int two = nums.size();</span><br><span class="line">    while(one&lt;two)&#123;</span><br><span class="line">        if(nums[one]==0)</span><br><span class="line">            swap(nums[++zero],nums[one++]);</span><br><span class="line">        else if(nums[one]==2)</span><br><span class="line">            swap(nums[--two], nums[one]); //从后面换上来的可能是0，所以one不能往后移动</span><br><span class="line">        else</span><br><span class="line">            one++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h3 id="Leetcode-42-接雨水（困难）"><a href="#Leetcode-42-接雨水（困难）" class="headerlink" title="Leetcode 42. 接雨水（困难）"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/">Leetcode 42. 接雨水（困难）</a></h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>用<code>left_max[i]</code> 和 <code>right_max[i]</code> 表示 i 左边和右边的最大值。这样就把暴力法时间复杂度的O(n^2)降为O(n)。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int trap(vector&lt;int&gt;&amp; height)</span><br><span class="line">&#123;</span><br><span class="line">    if (height.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int res = 0;</span><br><span class="line">    int n = height.size();</span><br><span class="line">    vector&lt;int&gt; left_max(n), right_max(n);</span><br><span class="line">    left_max[0] = height[0];</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">        left_max[i] = max(height[i], left_max[i - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    right_max[n - 1] = height[n - 1];</span><br><span class="line">    for (int i = n - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">        right_max[i] = max(height[i], right_max[i + 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; n - 1; i++) &#123;</span><br><span class="line">        res += min(left_max[i], right_max[i]) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>双指针。<br><img src="https://i.loli.net/2020/10/16/hGiceXPkE1marBQ.png" alt="算法"></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int trap(vector&lt;int&gt;&amp; height)</span><br><span class="line">&#123;</span><br><span class="line">    int left = 0, right = height.size() - 1;</span><br><span class="line">    int res = 0;</span><br><span class="line">    int left_max = 0, right_max = 0;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        if (height[left] &lt; height[right]) &#123;</span><br><span class="line">            height[left] &gt;= left_max ? (left_max = height[left]) : res += (left_max - height[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            height[right] &gt;= right_max ? (right_max = height[right]) : res += (right_max - height[right]);</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h2 id="3-5-排序（Sorting）"><a href="#3-5-排序（Sorting）" class="headerlink" title="3.5 排序（Sorting）"></a>3.5 排序（Sorting）</h2><p><a href="https://github.com/suzhilong/CS/blob/master/sort.py">python实现的八大排序</a>  </p>
<p>cpp实现八大排序：</p>
<ul>
<li><p><a href="https://github.com/suzhilong/Algorithm/blob/master/sort/cpp/insertSort.cpp">插入排序</a></p>
</li>
<li><p><a href="https://github.com/suzhilong/Algorithm/blob/master/sort/cpp/shellSort.cpp">希尔排序</a></p>
</li>
<li><p><a href="https://github.com/suzhilong/Algorithm/blob/master/sort/cpp/selectionSort.cpp">选择排序</a></p>
</li>
<li><p><a href="https://github.com/suzhilong/Algorithm/blob/master/sort/cpp/bubbleSort.cpp">冒泡排序</a></p>
</li>
<li><p><a href="https://github.com/suzhilong/Algorithm/blob/master/sort/cpp/quickSort.cpp">快速排序</a></p>
</li>
<li><p><a href="https://github.com/suzhilong/Algorithm/blob/master/sort/cpp/heapSort.cpp">堆排序</a></p>
</li>
<li><p><a href="https://github.com/suzhilong/Algorithm/blob/master/sort/cpp/mergeSort.cpp">归并排序</a></p>
</li>
<li><p><a href="https://github.com/suzhilong/Algorithm/blob/master/sort/cpp/radixSort.cpp">基数排序</a></p>
</li>
<li><p>快排变为稳定排序的方法。三遍扫描原序列：</p>
<ol>
<li>第一遍先把小于pivot的元素按先后顺序放到tmp里，然后把pivot放到它的正确位置tmp[k]；</li>
<li>第二遍把大于pivot的元素按先后顺序追加在tmp里，这样除了pivot以前的其他元素，都保持了和原序列中一样的顺序；</li>
<li>第三遍把tmp赋值回原数组A。</li>
</ol>
</li>
</ul>
<h3 id="3-5-1-Partition函数"><a href="#3-5-1-Partition函数" class="headerlink" title="3.5.1 Partition函数"></a>3.5.1 Partition函数</h3><p>Partition函数可以用在快排中，也可以用来实现在长度为n的数组中查找第k大的数字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Partition(std::vector&lt;int&gt; &amp;nums, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    if (nums.size() &lt; 2 || start&lt;0 || end&gt;nums.size())</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    int idx = start + std::rand() % (end - start + 1);//随机生成一个[start,end]的整数</span><br><span class="line">    int pivot = nums[idx];</span><br><span class="line">    nums[idx] = nums[start];//相当于把nums[idx]换到首位</span><br><span class="line">    while (start &lt; end) &#123;</span><br><span class="line">        while (start &lt; end &amp;&amp; nums[end] &gt;= pivot)</span><br><span class="line">            end--;</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        while (start &lt; end &amp;&amp; nums[start] &lt;= pivot)</span><br><span class="line">            start++;</span><br><span class="line">        nums[end] = nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[start] = pivot;</span><br><span class="line">    return start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快排（cpp）"><a href="#快排（cpp）" class="headerlink" title="快排（cpp）"></a>快排（cpp）</h3><h4 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void QuickSort(vector&lt;int&gt; &amp;arr, int start, int end)&#123;</span><br><span class="line">    if(start==end)</span><br><span class="line">        return;</span><br><span class="line">    int mid = Partition(arr, start, end);</span><br><span class="line">    if(mid&gt;start)</span><br><span class="line">        QuickSort(arr, start, mid - 1);</span><br><span class="line">    if(mid&lt;end)</span><br><span class="line">        QuickSort(arr, mid + 1, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非递归版"><a href="#非递归版" class="headerlink" title="非递归版"></a>非递归版</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void QuickSort(vector&lt;int&gt; &amp;nums)&#123;</span><br><span class="line">    if (nums.empty())</span><br><span class="line">        return;</span><br><span class="line">    stack&lt;int&gt; stk;</span><br><span class="line">    stk.push(nums.size()-1);//先压右指针</span><br><span class="line">    stk.push(0);//再压左指针</span><br><span class="line">    while (!stk.empty())&#123;</span><br><span class="line">        int start = stk.top();//先弹出左指针</span><br><span class="line">        stk.pop();</span><br><span class="line">        int end = stk.top();//再弹出右指针</span><br><span class="line">        stk.pop();</span><br><span class="line">        if (start &lt; end)&#123;</span><br><span class="line">            int mid = Partition(nums, start, end);</span><br><span class="line">            if (mid &gt; start)&#123;//保存中间变量</span><br><span class="line">                stk.push(mid - 1);</span><br><span class="line">                stk.push(start);  </span><br><span class="line">            &#125;</span><br><span class="line">            if (end &gt; mid)&#123;</span><br><span class="line">                stk.push(end);</span><br><span class="line">                stk.push(mid + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-2-例题"><a href="#3-5-2-例题" class="headerlink" title="3.5.2 例题"></a>3.5.2 例题</h3><h4 id="TOP-K-问题"><a href="#TOP-K-问题" class="headerlink" title="TOP K 问题"></a>TOP K 问题</h4><ul>
<li>排序 ：时间复杂度 O(NlogN)，空间复杂度 O(1)  </li>
<li>堆 ：时间复杂度 O(NlogK)，空间复杂度 O(K)  </li>
<li>快速选择 ：时间复杂度 O(N)，空间复杂度 O(1)</li>
</ul>
<h5 id="Leetcode-215-数组中的第K个最大元素（中等）"><a href="#Leetcode-215-数组中的第K个最大元素（中等）" class="headerlink" title="Leetcode 215. 数组中的第K个最大元素（中等）"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">Leetcode 215. 数组中的第K个最大元素（中等）</a></h5><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: [3,2,1,5,6,4] and k = 2  </span><br><span class="line">Output: 5  </span><br><span class="line">Kth Element, 在排序数组中 == 找到倒数第 k 个的元素。  </span><br></pre></td></tr></table></figure>

<p>题解：  </p>
<ol>
<li>快排变形。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">    int target = nums.size()-k;</span><br><span class="line">    int l = 0;</span><br><span class="line">    int r = nums.size()-1;</span><br><span class="line">    while(l&lt;r)&#123;</span><br><span class="line">        int m = Partition(nums,l,r);</span><br><span class="line">        if(m==target)</span><br><span class="line">            return nums[m];</span><br><span class="line">        else if(m&lt;target)</span><br><span class="line">            l = m+1;</span><br><span class="line">        else</span><br><span class="line">            r = m-1;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(logn)，递归的栈深度</p>
<ol start="2">
<li>堆</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void adjustHeap(std::vector&lt;int&gt; &amp;nums, int parents, int end)</span><br><span class="line">&#123;</span><br><span class="line">    //非叶子结点parents的两个子节点（假设都存在）</span><br><span class="line">    int lchild = 2 * parents + 1;</span><br><span class="line">    int rchild = 2 * parents + 2;</span><br><span class="line">    int maxIdx = parents;</span><br><span class="line">    if (lchild &lt;= end &amp;&amp; nums[maxIdx] &lt; nums[lchild]) </span><br><span class="line">        maxIdx = lchild;</span><br><span class="line">    if (rchild &lt;= end &amp;&amp; nums[maxIdx] &lt; nums[rchild])</span><br><span class="line">        maxIdx = rchild;</span><br><span class="line">    if (maxIdx != parents) &#123;</span><br><span class="line">        swap(nums[parents],nums[maxIdx]);</span><br><span class="line">        //交换之后，nums[maxIdx]应该是较小的元素，所以应该向下继续调整</span><br><span class="line">        adjustHeap(nums, maxIdx, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void buildHeap(std::vector&lt;int&gt; &amp;nums)</span><br><span class="line">&#123;//建堆</span><br><span class="line">    for (int i = nums.size() / 2 - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        //从倒数第一个非叶子结点开始调整</span><br><span class="line">        adjustHeap(nums, i, nums.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">    int end = nums.size()-1;</span><br><span class="line">    buildHeap(nums);</span><br><span class="line">    for (int i = nums.size() - 1; i &gt;= nums.size() - k + 1; i--) &#123;</span><br><span class="line">        swap(nums[0], nums[i]);</span><br><span class="line">        end--;</span><br><span class="line">        adjustHeap(nums, 0, end);</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)，建堆的时间代价是 O(n)，删除的总代价是 O(klogn)。因为k &lt; n，所以是O(nlogn)<br>空间复杂度：O(logn)</p>
<h5 id="BFPRT"><a href="#BFPRT" class="headerlink" title="BFPRT"></a>BFPRT</h5><p>也可以用BFPRT算法，具体实现如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int BFPRT(vector&lt;int&gt; &amp;nums, int start, int end, int k); //因为findMidIdx与BFPRT互相调用，所以最好在前面声明</span><br><span class="line">int findMidIdx(vector&lt;int&gt; &amp;nums, int start, int end);</span><br><span class="line"></span><br><span class="line">int selectSort(vector&lt;int&gt; &amp;nums,int start,int end)</span><br><span class="line">&#123;//选择排序，返回中位数下标</span><br><span class="line">    int temp;</span><br><span class="line">    for (int i = start; i &lt; end; i++)&#123;</span><br><span class="line">        for (int j = i + 1; j &lt;= end; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[i] &gt; nums[j])</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (((end - start) / 2) + start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int findMidIdx(vector&lt;int&gt; &amp;nums,int start,int end)</span><br><span class="line">&#123;//返回中位数的中位数下标</span><br><span class="line">    if (end - start &lt; 5)</span><br><span class="line">        return (selectSort(nums, start, end));//插入排序也可以</span><br><span class="line"></span><br><span class="line">    int subRIdx = start - 1;</span><br><span class="line">    for (int i = start; i + 4 &lt;= end; i += 5)</span><br><span class="line">    &#123;</span><br><span class="line">        int index = selectSort(nums, i, i + 4); //找到五个元素的中位数的下标</span><br><span class="line">        swap(nums[++subRIdx], nums[index]);   //依次放在左侧</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return BFPRT(nums, start, subRIdx, ((subRIdx - start + 1) / 2) + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Partition(vector&lt;int&gt; &amp;nums,int start,int end,int pivotIdx)</span><br><span class="line">&#123;</span><br><span class="line">    swap(nums[pivotIdx], nums[end]);</span><br><span class="line"></span><br><span class="line">    int divideIdx = start;</span><br><span class="line">    for (int i = start; i &lt; end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nums[i]&lt;nums[end])</span><br><span class="line">            swap(nums[divideIdx++], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(nums[divideIdx], nums[end]);</span><br><span class="line">    return divideIdx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int BFPRT(vector&lt;int&gt; &amp;nums, int start,int end,int k)</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">    求第k小，返回其位置的下标。</span><br><span class="line">    如果求TOP K，改变大小于符号，或者返回 n-K+1</span><br><span class="line">    */</span><br><span class="line">    int pivotIdx = findMidIdx(nums, start, end); //得到中位数的中位数下标</span><br><span class="line">    int divideIdx = Partition(nums, start, end, pivotIdx); //进行划分，返回划分边界</span><br><span class="line">    int n = divideIdx - start + 1;</span><br><span class="line">    if (n == k)</span><br><span class="line">        return divideIdx;</span><br><span class="line">    else if (n &gt; k)</span><br><span class="line">        return BFPRT(nums, start, divideIdx - 1, k);</span><br><span class="line">    else</span><br><span class="line">        return BFPRT(nums, divideIdx + 1, end, k - n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-347-前-K-个高频元素（中等）"><a href="#Leetcode-347-前-K-个高频元素（中等）" class="headerlink" title="Leetcode 347. 前 K 个高频元素（中等）"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">Leetcode 347. 前 K 个高频元素（中等）</a></h4><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given [1,1,1,2,2,3] and k = 2, return [1,2].  </span><br></pre></td></tr></table></figure>

<p>Leetcode提交的答案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class cmp&#123;</span><br><span class="line">public:</span><br><span class="line">    bool operator()(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b)&#123;</span><br><span class="line">        return a.second &gt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; topKFrequent(vector&lt;int&gt; &amp;nums, int k)&#123;</span><br><span class="line">    map&lt;int, int&gt; numMap;</span><br><span class="line">    for(int n:nums)</span><br><span class="line">        numMap[n]++;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;pair&lt;int, int&gt;,vector&lt;pair&lt;int,int&gt; &gt;, cmp &gt; pq;</span><br><span class="line">    for (auto it = numMap.begin(); it != numMap.end(); it++)&#123;</span><br><span class="line">        pq.push(*it);</span><br><span class="line">        if(pq.size()&gt;k)</span><br><span class="line">            pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; res(k);</span><br><span class="line">    for (int i = k - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        res[i] = pq.top().first;</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小根堆：  </p>
<ul>
<li>遍历数组，哈希表录入频率</li>
<li>遍历哈希表，维护一个出现频率前k多的小根堆</li>
<li>优先队列已满，需要判断当前元素的频率是否大于优先队列的最小频率元素的频率，如果大于，则替换。</li>
<li>优先队列未满，进队即可</li>
</ul>
<p>桶：<br>设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void topKFrequent()&#123;</span><br><span class="line">//小根堆</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1, 1, 1, 2, 2, 3&#125;;</span><br><span class="line">    int k = 2;</span><br><span class="line">    //map里面是（元素，频率）</span><br><span class="line">    unordered_map&lt;int,int&gt; freq;</span><br><span class="line">    for (int i = 0; i &lt; nums.size();i++)&#123;</span><br><span class="line">        freq[nums[i]]++; //可以验证，freq[nums[i]]初始化为0哦</span><br><span class="line">    &#125;</span><br><span class="line">    //优先队列中，按频率排序，所以数据对是(频率，元素)形式</span><br><span class="line">    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; pq;</span><br><span class="line">    for (auto it = freq.begin(); it != freq.end();it++)&#123;</span><br><span class="line">        if(pq.size()==k)&#123;//队列满了</span><br><span class="line">            if(pq.top().first &lt; it-&gt;second)&#123;</span><br><span class="line">                pq.pop();</span><br><span class="line">                pq.push(make_pair(it-&gt;second,it-&gt;first));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            pq.push(make_pair(it-&gt;second, it-&gt;first));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    while(!pq.empty())&#123;</span><br><span class="line">        result.push_back(pq.top().second);</span><br><span class="line">        // cout &lt;&lt; pq.top().second &lt;&lt; endl;</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;  </span><br><span class="line">//桶</span><br><span class="line">    int n = nums.size()+1;</span><br><span class="line">    vector&lt; vector&lt;int&gt; &gt; buckets(n);</span><br><span class="line">    for (auto it = freq.begin(); it != freq.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        buckets[it-&gt;second].push_back(it-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; topK;</span><br><span class="line">    for (int i = buckets.size() - 1; i &gt; 0 &amp;&amp; topK.size()&lt;k; i--)&#123;</span><br><span class="line">        if(buckets[i].size()==0)</span><br><span class="line">            continue;</span><br><span class="line">        for (int j = 0; j &lt; buckets[i].size() &amp;&amp; topK.size() &lt; k;j++)&#123;</span><br><span class="line">            topK.push_back(buckets[i].back());</span><br><span class="line">            buckets[i].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-451-根据字符出现频率排序（中等）"><a href="#Leetcode-451-根据字符出现频率排序（中等）" class="headerlink" title="Leetcode 451. 根据字符出现频率排序（中等）"></a><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">Leetcode 451. 根据字符出现频率排序（中等）</a></h4><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">&#x27;c&#x27;和&#x27;a&#x27;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。</span><br><span class="line">注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;Aabb&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">&quot;bbAa&quot;</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。</span><br><span class="line">注意&#x27;A&#x27;和&#x27;a&#x27;被认为是两种不同的字符。</span><br></pre></td></tr></table></figure>

<p>题解：  </p>
<ol>
<li>桶。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string frequencySort(string s) &#123;</span><br><span class="line">    unordered_map&lt;char, int&gt; freq;</span><br><span class="line">    for (int i = 0; i &lt; s.size();i++)</span><br><span class="line">        freq[s[i]]++;</span><br><span class="line">    //桶</span><br><span class="line">    int n = s.size();</span><br><span class="line">    vector&lt;vector&lt;char&gt; &gt; buckets(n + 1);</span><br><span class="line">    for (auto it = freq.begin(); it != freq.end();it++)&#123;</span><br><span class="line">        buckets[it-&gt;second].push_back(it-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    for (int i = buckets.size() - 1; i &gt; 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        if(buckets[i].size()==0)</span><br><span class="line">            continue;</span><br><span class="line">        for(auto s : buckets[i])&#123;</span><br><span class="line">            for (int j = 0; j &lt; i; j++)</span><br><span class="line">                res += s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>堆。方法同Leetcode 347。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string frequencySort(string s) &#123;</span><br><span class="line">    unordered_map&lt;char, int&gt; ump;</span><br><span class="line">    for (char &amp;c : s)</span><br><span class="line">        ump[c]++;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;pair&lt;int, char&gt;&gt; pq;</span><br><span class="line">    for (auto &amp;m : ump)</span><br><span class="line">        pq.push(&#123;m.second, m.first&#125;);</span><br><span class="line"></span><br><span class="line">    string res;</span><br><span class="line">    while (!pq.empty()) &#123;</span><br><span class="line">        auto tmp = pq.top(); </span><br><span class="line">        pq.pop();</span><br><span class="line">        res.append(tmp.first, tmp.second);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(k)，k为不同字母的数量，最大为26</p>
<h4 id="范围排序"><a href="#范围排序" class="headerlink" title="范围排序"></a>范围排序</h4><p>给一个无序不重复的数组<code>nums</code>，两个整数<code>int a</code>和<code>int b</code>，其中<code>a &lt;= b &lt;= nums.size()-1</code>。返回第<code>a</code>到第<code>b</code>个排序子数组。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums = &#123;3,5,4,1,2&#125;, a = 2, b = 4</span><br><span class="line"></span><br><span class="line">输出：[2,3,4]</span><br></pre></td></tr></table></figure>
<p>题解：<br>快排的变形。Partition找位置<code>i</code>，再根据<code>i</code>与<code>a</code>、<code>b</code>的比较来递归往下排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Partition函数在上面</span><br><span class="line"></span><br><span class="line">void quickSort(vector&lt;int&gt; &amp;nums, int start, int end, int a, int b)&#123;</span><br><span class="line">    if(start &gt; end)</span><br><span class="line">        return;</span><br><span class="line">    int mid = Partition(nums, start, end);</span><br><span class="line">    if(mid&gt;=b-1)</span><br><span class="line">        quickSort(nums, start, mid - 1, a, b);</span><br><span class="line">    if(mid&lt;=a-1)</span><br><span class="line">        quickSort(nums, mid + 1, end, a, b);</span><br><span class="line">    if(mid&gt;a-1 &amp;&amp; mid&lt;b-1)&#123;</span><br><span class="line">        quickSort(nums, start, mid - 1, a, b);</span><br><span class="line">        quickSort(nums, mid + 1, end, a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; getVec(vector&lt;int&gt; &amp;nums, int a, int b)&#123;</span><br><span class="line">    quickSort(nums, 0, nums.size() - 1, a, b);</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    for (int i = a-1; i &lt;= b-1; i++)</span><br><span class="line">        res.push_back(nums[i]);</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特殊规则排序"><a href="#特殊规则排序" class="headerlink" title="特殊规则排序"></a>特殊规则排序</h4><p>有一种排序算法：每次只能把一个元素提到数组的开头。输入一个乱序数组，输出最少需要多少次操作才能是数组升序排列。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： [2,1,3,4]</span><br><span class="line"></span><br><span class="line">输出： 1</span><br><span class="line"></span><br><span class="line">解释：把 1 提到开头就能满足要求</span><br></pre></td></tr></table></figure>
<p>题解：<br>只需求有多少个数已经按升序的顺序位于数组中就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int timesToAsc(vector&lt;int&gt; &amp;nums)&#123;</span><br><span class="line">    vector&lt;int&gt; finalNum = nums;</span><br><span class="line">    sort(finalNum.begin(), finalNum.end());</span><br><span class="line">    int i, j , cnt = 0;</span><br><span class="line">    i = j = nums.size() - 1;</span><br><span class="line">    for (; i &gt;= 0;i--)&#123;</span><br><span class="line">        if(finalNum[j] == nums[i])&#123;</span><br><span class="line">            j--;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.size() - cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-6-查找-x2F-搜索（Search）"><a href="#3-6-查找-x2F-搜索（Search）" class="headerlink" title="3.6 查找&#x2F;搜索（Search）"></a>3.6 查找&#x2F;搜索（Search）</h2><h3 id="3-6-1-回溯算法（backtracking）"><a href="#3-6-1-回溯算法（backtracking）" class="headerlink" title="3.6.1 回溯算法（backtracking）"></a>3.6.1 回溯算法（backtracking）</h3><h4 id="回溯法框架"><a href="#回溯法框架" class="headerlink" title="回溯法框架"></a>回溯法框架</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    if 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        return</span><br><span class="line">    for 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-17-电话号码的字母组合（中等）"><a href="#Leetcode-17-电话号码的字母组合（中等）" class="headerlink" title="Leetcode 17. 电话号码的字母组合（中等）"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">Leetcode 17. 电话号码的字母组合（中等）</a></h4><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: &quot;23&quot;  </span><br><span class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>回溯。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;char, string&gt; keys = &#123;</span><br><span class="line">    &#123;&#x27;2&#x27;, &quot;abc&quot;&#125;, &#123;&#x27;3&#x27;, &quot;def&quot;&#125;, &#123;&#x27;4&#x27;, &quot;ghi&quot;&#125;, &#123;&#x27;5&#x27;, &quot;jkl&quot;&#125;, &#123;&#x27;6&#x27;, &quot;mno&quot;&#125;,</span><br><span class="line">    &#123;&#x27;7&#x27;, &quot;pqrs&quot;&#125;, &#123;&#x27;8&#x27;, &quot;tuv&quot;&#125;, &#123;&#x27;9&#x27;, &quot;wxyz&quot;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void backtracking(string preStr, vector&lt;string&gt; &amp;combinations, const string &amp;digits)&#123;</span><br><span class="line">    if(preStr.size()==digits.size())&#123;</span><br><span class="line">        combinations.push_back(preStr);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int curIdx = preStr.size();</span><br><span class="line">    char curDigital = digits[curIdx];</span><br><span class="line">    string curKeys = keys[curDigital];</span><br><span class="line">    for(char &amp;k : curKeys)&#123;</span><br><span class="line">        preStr += k;</span><br><span class="line">        backtracking(preStr,combinations,digits);</span><br><span class="line">        preStr.erase(preStr.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;string&gt; letterCombinations(string digits) &#123;</span><br><span class="line">    if(digits.empty())</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    backtracking(&quot;&quot;, res, digits);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(3^m * 4^n)，其中 m 是输入中对应 3 个字母的数字个数（包括数字 2、3、4、5、6、8），n 是输入中对应 4 个字母的数字个数（包括数字 7、9），m+n 是输入数字的总个数。<br>空间复杂度：O(m+n)</p>
<ol start="2">
<li>队列<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;char, string&gt; keys = &#123;</span><br><span class="line">    &#123;&#x27;2&#x27;, &quot;abc&quot;&#125;, &#123;&#x27;3&#x27;, &quot;def&quot;&#125;, &#123;&#x27;4&#x27;, &quot;ghi&quot;&#125;, &#123;&#x27;5&#x27;, &quot;jkl&quot;&#125;, &#123;&#x27;6&#x27;, &quot;mno&quot;&#125;,</span><br><span class="line">    &#123;&#x27;7&#x27;, &quot;pqrs&quot;&#125;, &#123;&#x27;8&#x27;, &quot;tuv&quot;&#125;, &#123;&#x27;9&#x27;, &quot;wxyz&quot;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; letterCombinations(string digits) &#123;</span><br><span class="line">    queue&lt;string&gt; que;</span><br><span class="line">    for (int idx = 0; idx &lt; digits.size();idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        char s = digits[idx];</span><br><span class="line">        string key = keys[s];</span><br><span class="line">        if(que.empty())&#123;</span><br><span class="line">            for(auto k:key)&#123;</span><br><span class="line">                string tmp(1, k);</span><br><span class="line">                que.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            while(que.front().size()&lt;=idx)&#123;</span><br><span class="line">                string preStr = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                for(auto k:key)</span><br><span class="line">                    que.push(preStr + k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    while (!que.empty())&#123;</span><br><span class="line">        res.push_back(que.front());</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Leetcode-93-复原IP地址（中等）"><a href="#Leetcode-93-复原IP地址（中等）" class="headerlink" title="Leetcode 93. 复原IP地址（中等）"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">Leetcode 93. 复原IP地址（中等）</a></h4><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given &quot;25525511135&quot;,  </span><br><span class="line">return [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;].  </span><br></pre></td></tr></table></figure>
<p>题解：<br>回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void backtracking(int k, string preIp, string resStr, vector&lt;string&gt; &amp;addresses)&#123;</span><br><span class="line">    if(k==4 || resStr.size()==0)&#123;</span><br><span class="line">        if(k==4 &amp;&amp; resStr.size()==0)</span><br><span class="line">            addresses.push_back(preIp);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; resStr.size() &amp;&amp; i &lt; 3;i++)&#123;</span><br><span class="line">        if(i!=0 &amp;&amp; resStr[0]==&#x27;0&#x27;)</span><br><span class="line">            break;</span><br><span class="line">        string part = resStr.substr(0, i + 1);</span><br><span class="line">        if(stoi(part)&lt;=255)&#123;</span><br><span class="line">            if(preIp.size()!=0)</span><br><span class="line">                part = &#x27;.&#x27; + part;</span><br><span class="line">            preIp = preIp + part;</span><br><span class="line">            backtracking(k + 1, preIp, resStr.substr(i + 1), addresses);</span><br><span class="line">            preIp = preIp.erase(preIp.size() - part.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;string&gt; restoreIpAddresses(string s) &#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    backtracking(0, &quot;&quot;, s, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="huawei-真题"><a href="#huawei-真题" class="headerlink" title="huawei 真题"></a>huawei 真题</h4><p>求最大递归调用链栈总和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; inputStack = &#123;</span><br><span class="line">                                    &#123;5,2,3,1,0,0&#125;,</span><br><span class="line">                                    &#123;1,20,2,3&#125;,</span><br><span class="line">                                    &#123;2,30,3,4,5&#125;,</span><br><span class="line">                                    &#123;3,50,4&#125;,</span><br><span class="line">                                    &#123;4,60&#125;,</span><br><span class="line">                                    &#123;5,80&#125;</span><br><span class="line">                                  &#125;;</span><br><span class="line">void backtracking(int fun, vector&lt;bool&gt; &amp;isHead, bool &amp;isRecursive, vector&lt;bool&gt; &amp;hasVisited, vector&lt;int&gt; &amp;preChain, vector&lt;vector&lt;int&gt; &gt; &amp;callChains)&#123;</span><br><span class="line">    if(isRecursive)</span><br><span class="line">        return;</span><br><span class="line">    if (inputStack[0][fun] == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        callChains.push_back(preChain);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 2; i &lt; inputStack[fun].size();i++)&#123;</span><br><span class="line">        int nextFun = inputStack[fun][i];</span><br><span class="line">        if(hasVisited[nextFun])&#123;</span><br><span class="line">            isRecursive = true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        isHead[nextFun] = false;</span><br><span class="line">        hasVisited[nextFun] = true;</span><br><span class="line">        preChain.push_back(nextFun);</span><br><span class="line">        backtracking(nextFun, isHead, isRecursive, hasVisited, preChain, callChains);</span><br><span class="line">        preChain.pop_back();</span><br><span class="line">        hasVisited[nextFun] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void maxStack()&#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; callChains;</span><br><span class="line">    vector&lt;int&gt; preChain;</span><br><span class="line">    vector&lt;bool&gt; isHead(inputStack[0][0]+1,true);</span><br><span class="line">    bool isRecursive = false; //注意！ 如果这个变量不是放在main函数前的全局变量，递归函数传值就必须传引用，不然会因为函数参数传值的复制造成递归的时候不能改变</span><br><span class="line">    for (int i = 1; i &lt;= inputStack[0][0]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(isHead[i])&#123;</span><br><span class="line">            vector&lt;bool&gt; hasVisited(inputStack[0][0] + 1, false);</span><br><span class="line">            preChain.push_back(i);</span><br><span class="line">            hasVisited[i] = true;</span><br><span class="line">            backtracking(i, isHead, isRecursive, hasVisited, preChain, callChains);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(isRecursive)</span><br><span class="line">        cout &lt;&lt; &#x27;R&#x27; &lt;&lt; endl;</span><br><span class="line">    else&#123;</span><br><span class="line">        for (auto cc : callChains)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int c:cc)</span><br><span class="line">                cout &lt;&lt; c &lt;&lt; &quot; &quot;;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-46-全排列（中等）"><a href="#Leetcode-46-全排列（中等）" class="headerlink" title="Leetcode 46. 全排列（中等）"></a><a href="https://leetcode-cn.com/problems/permutations/">Leetcode 46. 全排列（中等）</a></h4><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2,3] have the following permutations:  </span><br><span class="line"></span><br><span class="line">[ [1,2,3],  </span><br><span class="line">  [1,3,2],  </span><br><span class="line">  [2,1,3],  </span><br><span class="line">  [2,3,1],  </span><br><span class="line">  [3,1,2],  </span><br><span class="line">  [3,2,1] ]</span><br></pre></td></tr></table></figure>
<p>题解：<br>回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void backtracking(vector&lt;int&gt; &amp;resNums, vector&lt;int&gt; &amp;preNum, vector&lt;vector&lt;int&gt; &gt; &amp;permuteList)&#123;</span><br><span class="line">    if(resNums.size()==0)&#123;</span><br><span class="line">        permuteList.push_back(preNum);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; resNums.size();i++)&#123;</span><br><span class="line">        int curNum = resNums[i];</span><br><span class="line">        auto it = resNums.begin();</span><br><span class="line">        resNums.erase(it + i);</span><br><span class="line">        preNum.push_back(curNum);</span><br><span class="line">        backtracking(resNums, preNum, permuteList);</span><br><span class="line">        preNum.pop_back();</span><br><span class="line">        resNums.insert(it + i, curNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    vector&lt;int&gt; preNum;</span><br><span class="line">    backtracking(nums, preNum, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n*n!)<br>空间复杂度：O(n)</p>
<h4 id="Leetcode-77-组合（中等）"><a href="#Leetcode-77-组合（中等）" class="headerlink" title="Leetcode 77. 组合（中等）"></a><a href="https://leetcode-cn.com/problems/combinations/">Leetcode 77. 组合（中等）</a></h4><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If n = 4 and k = 2, a solution is:</span><br><span class="line">[ </span><br><span class="line">  [2,4],  </span><br><span class="line">  [3,4],  </span><br><span class="line">  [2,3],  </span><br><span class="line">  [1,2],  </span><br><span class="line">  [1,3],  </span><br><span class="line">  [1,4], ]</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void combinationsCore(int n, int k, int start, vector&lt;int&gt; &amp;preRes, vector&lt;vector&lt;int&gt; &gt; &amp;res)&#123;</span><br><span class="line">    if(preRes.size()==k)&#123;</span><br><span class="line">        res.push_back(preRes);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = start; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        preRes.push_back(i);</span><br><span class="line">        combinationsCore(n, k, i + 1, preRes, res);</span><br><span class="line">        preRes.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    vector&lt;int&gt; preRes;</span><br><span class="line">    combinationsCore(n, k, 1, preRes, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Leetcode-39-组合总和（中等）"><a href="#Leetcode-39-组合总和（中等）" class="headerlink" title="Leetcode 39.组合总和（中等）"></a><a href="https://leetcode-cn.com/problems/combination-sum/">Leetcode 39.组合总和（中等）</a></h4><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">given candidate set [2, 3, 6, 7] and target 7, A solution set is:  </span><br><span class="line">[ [7],[2, 2, 3] ]  </span><br></pre></td></tr></table></figure>
<p>题解：<br>回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void backtracking(int target, vector&lt;int&gt; &amp;preCombination, int start, vector&lt;vector&lt;int&gt; &gt; &amp;combination, vector&lt;int&gt; &amp;candidates)&#123;</span><br><span class="line">    if(target==0)&#123;</span><br><span class="line">        combination.push_back(preCombination);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = start; i &lt; candidates.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int curNum = candidates[i];</span><br><span class="line">        if (target &gt;= curNum)</span><br><span class="line">        &#123;</span><br><span class="line">            preCombination.push_back(curNum);</span><br><span class="line">            backtracking(target - curNum, preCombination, i, combination, candidates);</span><br><span class="line">            preCombination.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    vector&lt;int&gt; preCombination;</span><br><span class="line">    backtracking(target, preCombination, 0, res, candidates);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Leetcode-40-组合总和-II（中等）"><a href="#Leetcode-40-组合总和-II（中等）" class="headerlink" title="Leetcode 40. 组合总和 II（中等）"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/">Leetcode 40. 组合总和 II（中等）</a></h4><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,</span><br><span class="line">A solution set is:  </span><br><span class="line">[ [1, 7],  </span><br><span class="line">[1, 2, 5],  </span><br><span class="line">[2, 6],  </span><br><span class="line">[1, 1, 6]  ]  </span><br></pre></td></tr></table></figure>
<p>题解：<br>回溯</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void backtracking(int target, vector&lt;int&gt; &amp;preCombination, int start, vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;candidates)&#123;</span><br><span class="line">    if(target==0)&#123;</span><br><span class="line">        auto it = find(res.begin(), res.end(), preCombination);</span><br><span class="line">        if(it==res.end())&#123;//因为candidates中有重复元素，会导致重复的解，所以查找是否有重复解，没有再放到解集中</span><br><span class="line">            res.push_back(preCombination);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = start; i &lt; candidates.size();i++)&#123;</span><br><span class="line">        int curNum = candidates[i];</span><br><span class="line">        if(curNum&lt;=target)&#123;</span><br><span class="line">            preCombination.push_back(curNum);</span><br><span class="line">            backtracking(target - curNum, preCombination, i + 1, res, candidates);</span><br><span class="line">            preCombination.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">    sort(candidates.begin(),candidates.end());//先排序才好查重复解</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">    vector&lt;int&gt; preCombination;</span><br><span class="line">    vector&lt;bool&gt; hasVisited(candidates.size(),false);</span><br><span class="line">    backtracking(target, preCombination, 0, res, candidates);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Leetcode-216-组合总和-III（中等）"><a href="#Leetcode-216-组合总和-III（中等）" class="headerlink" title="Leetcode 216. 组合总和 III（中等）"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/">Leetcode 216. 组合总和 III（中等）</a></h4><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: k = 3, n = 9  </span><br><span class="line">Output:  </span><br><span class="line">[[1,2,6], [1,3,5], [2,3,4]]  </span><br><span class="line">从 1-9 数字中选出 k 个数不重复的数，使得它们的和为 n。  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void backtracking(int k, int target, int start, vector&lt;int&gt; &amp;preCombination, vector&lt;vector&lt;int&gt; &gt; &amp;res)&#123;</span><br><span class="line">    // if(target&lt;0)</span><br><span class="line">    //     return;</span><br><span class="line">    if (target == 0 &amp;&amp; k == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(preCombination);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(target==0 || k==0)</span><br><span class="line">        return;</span><br><span class="line">    for (int i = start; i &lt;= 9;i++)&#123;</span><br><span class="line">        if(target&lt;i)//后面的都大于target，不用再往后找了。如果上面用了target&lt;0的判断，这里可以不用，但是下面的调用次数会多一些</span><br><span class="line">            break;</span><br><span class="line">        preCombination.push_back(i);</span><br><span class="line">        backtracking(k - 1, target - i, i+1, preCombination, res);</span><br><span class="line">        preCombination.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    vector&lt;int&gt; preCombination;</span><br><span class="line">    backtracking(k, n, 1, preCombination, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Leetcode-78-子集（中等）"><a href="#Leetcode-78-子集（中等）" class="headerlink" title="Leetcode 78. 子集（中等）"></a><a href="https://leetcode-cn.com/problems/subsets/">Leetcode 78. 子集（中等）</a></h4><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找出集合的所有子集，子集不能重复，[1, 2] 和 [2, 1] 这种子集算重复  </span><br><span class="line">输入: nums = [1,2,3]  </span><br><span class="line">输出:  </span><br><span class="line">[ [3],  </span><br><span class="line">  [1],  </span><br><span class="line">  [2],  </span><br><span class="line">  [1,2,3],  </span><br><span class="line">  [1,3],  </span><br><span class="line">  [2,3],  </span><br><span class="line">  [1,2],  </span><br><span class="line">  []  ]</span><br></pre></td></tr></table></figure>
<p>题解：<br>回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void backtracking(int start, int size, vector&lt;int&gt; &amp;preSet, vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;nums)&#123;</span><br><span class="line">    if(preSet.size()==size)&#123;</span><br><span class="line">        res.push_back(preSet);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = start; i &lt; nums.size();i++)&#123;</span><br><span class="line">        preSet.push_back(nums[i]);</span><br><span class="line">        backtracking(i + 1, size, preSet, res, nums);</span><br><span class="line">        preSet.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;int&gt; preSet;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    for (int size = 0; size &lt;= nums.size();size++)//子集的大小</span><br><span class="line">        backtracking(0, size, preSet, res, nums); </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-90-子集-II（中等）"><a href="#Leetcode-90-子集-II（中等）" class="headerlink" title="Leetcode 90. 子集 II（中等）"></a><a href="https://leetcode-cn.com/problems/subsets-ii/">Leetcode 90. 子集 II（中等）</a></h4><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。  </p>
<p>说明：解集不能包含重复的子集。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,2]  </span><br><span class="line">输出:  </span><br><span class="line">[   [2],</span><br><span class="line">    [1],</span><br><span class="line">    [1,2,2],</span><br><span class="line">    [2,2],</span><br><span class="line">    [1,2],</span><br><span class="line">    [] ]</span><br></pre></td></tr></table></figure>
<p>题解：<br>回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void backtracking(int start, int size, vector&lt;int&gt; &amp;preSet, vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;nums)&#123;</span><br><span class="line">    if(preSet.size()==size)&#123;</span><br><span class="line">        res.push_back(preSet);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = start; i &lt; nums.size();i++)&#123;</span><br><span class="line">        preSet.push_back(nums[i]);</span><br><span class="line">        backtracking(i + 1, size, preSet, res, nums);</span><br><span class="line">        preSet.pop_back();</span><br><span class="line">        while(i&lt;nums.size()-1 &amp;&amp; nums[i+1]==nums[i])//后面的数字如果相等要跳过，不然会导致重复</span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    vector&lt;int&gt; preSet;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    for (int size = 0; size &lt;= nums.size(); size++)</span><br><span class="line">        backtracking(0, size, preSet, res, nums);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-131-分割回文串（中等）"><a href="#Leetcode-131-分割回文串（中等）" class="headerlink" title="Leetcode 131. 分割回文串（中等）"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">Leetcode 131. 分割回文串（中等）</a></h4><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 s 所有可能的分割方案。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For example, given s = &quot;aab&quot;,  </span><br><span class="line">Return  </span><br><span class="line">[ [&quot;aa&quot;,&quot;b&quot;],  </span><br><span class="line">[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]  ]</span><br></pre></td></tr></table></figure>
<p>题解：<br>回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isPalindrome(string s, int start, int end)&#123;</span><br><span class="line">    while(start&lt;end)&#123;</span><br><span class="line">        if(s[start++]!=s[end--])</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">void partitioning(string s, vector&lt;string&gt; &amp;prePartition, vector&lt;vector&lt;string&gt; &gt; &amp;result)&#123;</span><br><span class="line">    if(s.size()==0)&#123;</span><br><span class="line">        result.push_back(prePartition);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; s.size();i++)&#123;</span><br><span class="line">        if(isPalindrome(s,0,i))&#123;</span><br><span class="line">            prePartition.push_back(s.substr(0, i + 1));</span><br><span class="line">            partitioning(s.substr(i + 1, s.size() - (i + 1)), prePartition, result);</span><br><span class="line">            prePartition.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;</span><br><span class="line">    vector&lt;string&gt; prePartition;</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt; res;</span><br><span class="line">    partitioning(s, prePartition, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-37-解数独（困难）"><a href="#Leetcode-37-解数独（困难）" class="headerlink" title="Leetcode 37. 解数独（困难）"></a><a href="https://leetcode-cn.com/problems/sudoku-solver/">Leetcode 37. 解数独（困难）</a></h4><p>通过填充空格来解决数独问题。</p>
<p>一个数独的解法需遵循如下规则：  </p>
<ol>
<li>数字 1-9 在每一行只能出现一次。  </li>
<li>数字 1-9 在每一列只能出现一次。  </li>
<li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</li>
</ol>
<p>空白格用 ‘.’ 表示。  </p>
<p>题解：<br>回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int cube(int i, int j)&#123;</span><br><span class="line">    return (i / 3) * 3 + j / 3; //0-8</span><br><span class="line">&#125;</span><br><span class="line">bool backtracking(int row, int col, vector&lt;vector&lt;bool&gt; &gt; &amp;rowUsed, vector&lt;vector&lt;bool&gt; &gt; colUsed, vector&lt;vector&lt;bool&gt; &gt; cubeUsed, vector&lt;vector&lt;char&gt; &gt; &amp;board)&#123;</span><br><span class="line">    while (row &lt; 9 &amp;&amp; board[row][col]!=&#x27;.&#x27;)&#123;</span><br><span class="line">        row = col == 8 ? row + 1 : row;</span><br><span class="line">        col = col == 8 ? 0 : col + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(row==9)//全部填完</span><br><span class="line">        return true;</span><br><span class="line">    for (int num = 1; num &lt;= 9;num++)&#123;</span><br><span class="line">        if(rowUsed[row][num] || colUsed[col][num] || cubeUsed[cube(row,col)][num])</span><br><span class="line">            continue;</span><br><span class="line">        rowUsed[row][num] = true;</span><br><span class="line">        colUsed[col][num] = true;</span><br><span class="line">        cubeUsed[cube(row, col)][num] = true;</span><br><span class="line">        board[row][col] = &#x27;0&#x27; + num;</span><br><span class="line">        if(backtracking(row,col,rowUsed,colUsed,cubeUsed,board))</span><br><span class="line">            return true;</span><br><span class="line">        board[row][col] = &#x27;.&#x27;;</span><br><span class="line">        rowUsed[row][num] = false;</span><br><span class="line">        colUsed[col][num] = false;</span><br><span class="line">        cubeUsed[cube(row, col)][num] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; rowUsed(9,vector&lt;bool&gt;(10,false));</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; colUsed(9,vector&lt;bool&gt;(10,false));</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; cubeUsed(9,vector&lt;bool&gt;(10,false));</span><br><span class="line">    for (int i = 0; i &lt; 9; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; 9;j++)&#123;</span><br><span class="line">            if(board[i][j]==&#x27;.&#x27;)</span><br><span class="line">                continue;</span><br><span class="line">            int num = board[i][j] - &#x27;0&#x27;;</span><br><span class="line">            rowUsed[i][num] = true;</span><br><span class="line">            colUsed[j][num] = true;</span><br><span class="line">            cubeUsed[cube(i,j)][num] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtracking(0, 0, rowUsed, colUsed, cubeUsed, board);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h4><p>输入n，输出解法的数量。（下一题还需要输出解法）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void solveNQueen(int n, int row, vector&lt;bool&gt; &amp;diagonal45, vector&lt;bool&gt; &amp;diagonal135, vector&lt;bool&gt; &amp;colUsed, int &amp;res)&#123;</span><br><span class="line">    if(row == n)&#123;</span><br><span class="line">        res++;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int col = 0; col &lt; n;col++)&#123;</span><br><span class="line">        int idx45 = row + col;</span><br><span class="line">        int idx135 = n - 1 - (row - col);</span><br><span class="line">        if(colUsed[col] || diagonal135[idx135] || diagonal45[idx45])</span><br><span class="line">            continue;</span><br><span class="line">        colUsed[col] = diagonal45[idx45] = diagonal135[idx135] = true;</span><br><span class="line">        solveNQueen(n, row + 1, diagonal45, diagonal135, colUsed, res);</span><br><span class="line">        colUsed[col] = diagonal45[idx45] = diagonal135[idx135] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int NQueen(int n)&#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    vector&lt;bool&gt; diagonal45(2 * n - 1, false);</span><br><span class="line">    vector&lt;bool&gt; diagonal135(2 * n - 1, false);</span><br><span class="line">    vector&lt;bool&gt; colUsed(n, false);</span><br><span class="line">    solveNQueen(n, 0, diagonal45, diagonal135, colUsed, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-51-N皇后（困难）"><a href="#Leetcode-51-N皇后（困难）" class="headerlink" title="Leetcode 51. N皇后（困难）"></a><a href="https://leetcode-cn.com/problems/n-queens/">Leetcode 51. N皇后（困难）</a></h4><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 4  </span><br><span class="line">输出: [  </span><br><span class="line">[&quot;.Q..&quot;,  // 解法 1  </span><br><span class="line">&quot;...Q&quot;,  </span><br><span class="line">&quot;Q...&quot;,  </span><br><span class="line">&quot;..Q.&quot;],  </span><br><span class="line"></span><br><span class="line">[&quot;..Q.&quot;,  // 解法 2  </span><br><span class="line">&quot;Q...&quot;,  </span><br><span class="line">&quot;...Q&quot;,  </span><br><span class="line">&quot;.Q..&quot;]  </span><br><span class="line">]  </span><br><span class="line">解释: 4 皇后问题存在两个不同的解法。  </span><br></pre></td></tr></table></figure>
<p>题解：<br>回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void backtracking(int n, int row, vector&lt;bool&gt; &amp;diagonal45, vector&lt;bool&gt; &amp;diagonal135, vector&lt;bool&gt; &amp;colUsed, vector&lt;string&gt; &amp;oneSolution, vector&lt;vector&lt;string&gt; &gt; &amp;res)&#123;</span><br><span class="line">    if(row==n)&#123;</span><br><span class="line">        res.push_back(oneSolution);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int col = 0; col &lt; n;col++)&#123;</span><br><span class="line">        int idx45 = row + col;</span><br><span class="line">        int idx135 = n - 1 - (row - col);</span><br><span class="line">        if(colUsed[col] || diagonal135[idx135] || diagonal45[idx45])</span><br><span class="line">            continue;</span><br><span class="line">        oneSolution[row][col] = &#x27;Q&#x27;;</span><br><span class="line">        colUsed[col] = diagonal135[idx135] = diagonal45[idx45] = true;</span><br><span class="line">        backtracking(n, row + 1, diagonal45, diagonal135, colUsed, oneSolution, res);</span><br><span class="line">        colUsed[col] = diagonal135[idx135] = diagonal45[idx45] = false;</span><br><span class="line">        oneSolution[row][col] = &#x27;.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt; res;</span><br><span class="line">    string tmp = &quot;&quot;;</span><br><span class="line">    for (int i = 0; i &lt; n;i++)</span><br><span class="line">        tmp += &quot;.&quot;;</span><br><span class="line">    vector&lt;string&gt; oneSolution(n, tmp);</span><br><span class="line">    vector&lt;bool&gt; diagonal45(2*n-1,false);</span><br><span class="line">    vector&lt;bool&gt; diagonal135(2*n-1,false);</span><br><span class="line">    vector&lt;bool&gt; colUsed(n,false);</span><br><span class="line"></span><br><span class="line">    backtracking(n, 0, diagonal45, diagonal135, colUsed, oneSolution, res);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-2-广度优先（BFS）"><a href="#3-6-2-广度优先（BFS）" class="headerlink" title="3.6.2 广度优先（BFS）"></a>3.6.2 广度优先（BFS）</h3><h4 id="Leetcode-1091-二进制矩阵中的最短路径（中等）"><a href="#Leetcode-1091-二进制矩阵中的最短路径（中等）" class="headerlink" title="Leetcode 1091. 二进制矩阵中的最短路径（中等）"></a><a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">Leetcode 1091. 二进制矩阵中的最短路径（中等）</a></h4><p>可以往8个方向走，0 表示可以经过某个位置，求解从左上角到右下角的最短路径长度。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input:   </span><br><span class="line">0 0 0  </span><br><span class="line">1 1 0  </span><br><span class="line">1 1 0  </span><br><span class="line">output: 4 ([0,0],[0,1],[1,2],[2,2])</span><br></pre></td></tr></table></figure>
<p>题解：<br>队列实现“层序遍历”，bfs。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    int rows = grid.size();</span><br><span class="line">    int cols = grid[0].size();</span><br><span class="line">    if (rows==0 || cols==0 || grid[0][0]==1 || grid[cols-1][rows-1]==1)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    //从当前点的右边开始逆时针</span><br><span class="line">    int direction[8][2] = &#123; &#123;0, 1&#125;, &#123;1, 1&#125;, &#123;1, 0&#125;, &#123;1, -1&#125;, &#123;0, -1&#125;, &#123;-1, -1&#125;, &#123;-1, 0&#125;, &#123;-1, 1&#125; &#125;;</span><br><span class="line">    queue&lt;vector&lt;int&gt; &gt; que;</span><br><span class="line">    que.push(&#123;0,0&#125;);</span><br><span class="line">    int res = 0;</span><br><span class="line">    while (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int size = que.size();//这一层有多少节点</span><br><span class="line">        res++;</span><br><span class="line">        while(size-- &gt;0)&#123;//把这一层的节点处理完</span><br><span class="line">            vector&lt;int&gt; cur = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            if(grid[cur[0]][cur[1]]==1)//已经经过的点</span><br><span class="line">                //由于加入队列的顺序的原因，有些在待处理队列里面的为0的点，会被重复加入队列。</span><br><span class="line">                //如果这里不判断的话，已经更新为1的节点还是会被重复处理</span><br><span class="line">                continue;</span><br><span class="line">            if (cur[0] == rows - 1 &amp;&amp; cur[1] == cols - 1)</span><br><span class="line">                return res;</span><br><span class="line"></span><br><span class="line">            grid[cur[0]][cur[1]] = 1;//走过的路标记为1</span><br><span class="line">            for(auto d:direction)&#123;</span><br><span class="line">                int row = cur[0] + d[0];</span><br><span class="line">                int col = cur[1] + d[1];</span><br><span class="line">                if(row&lt;0 || row&gt;=rows || col&lt;0 || col&gt;=cols || grid[row][col])</span><br><span class="line">                    //超过了上下左右边界 || 不能经过或者已经经过的点</span><br><span class="line">                    continue;</span><br><span class="line">                vector&lt;int&gt; tmp = &#123;row, col&#125;;</span><br><span class="line">                que.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-279-完全平方数（中等）-1"><a href="#Leetcode-279-完全平方数（中等）-1" class="headerlink" title="Leetcode 279. 完全平方数（中等）"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">Leetcode 279. 完全平方数（中等）</a></h4><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">given n = 12</span><br><span class="line">return 3</span><br><span class="line">because 12 = 4 + 4 + 4; </span><br><span class="line"></span><br><span class="line">given n = 13</span><br><span class="line">return 2 </span><br><span class="line">because 13 = 4 + 9.  </span><br></pre></td></tr></table></figure>
<p>题解：<br>bfs。可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。本题也可以用动态规划求解，在之前动态规划部分中已经出现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int numSquares(int n) &#123;</span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    que.push(n);  //从n开始或者从1开始都行</span><br><span class="line">    bool marked[n];</span><br><span class="line">    for (int i = 0; i &lt; n;i++)</span><br><span class="line">        marked[i] = 0;//false</span><br><span class="line"></span><br><span class="line">    int res = 0;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        res++;</span><br><span class="line">        int size = que.size();</span><br><span class="line">        while(size-- &gt; 0)&#123;</span><br><span class="line">            int cur = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            for(int i = 1; i * i &lt;= n; i++)&#123;</span><br><span class="line">                int next = cur - i*i;</span><br><span class="line">                if(next&lt;0)</span><br><span class="line">                    break;</span><br><span class="line">                if(next==0)</span><br><span class="line">                    return res;</span><br><span class="line"></span><br><span class="line">                if(marked[next])</span><br><span class="line">                    continue;</span><br><span class="line">                marked[next] = 1;</span><br><span class="line">                que.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Leetcode-127-单词接龙（中等）"><a href="#Leetcode-127-单词接龙（中等）" class="headerlink" title="Leetcode 127. 单词接龙（中等）"></a><a href="https://leetcode-cn.com/problems/word-ladder/">Leetcode 127. 单词接龙（中等）</a></h4><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p>
<ol>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ol>
<p><strong>说明</strong>:</p>
<ul>
<li>如果不存在这样的转换序列，返回 0。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li>
</ul>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input:  </span><br><span class="line">beginWord = &quot;hit&quot;,  </span><br><span class="line">endWord = &quot;cog&quot;,  </span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]  </span><br><span class="line"></span><br><span class="line">Output: 5  </span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, return its length 5.</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input:  </span><br><span class="line">beginWord = &quot;hit&quot;  </span><br><span class="line">endWord = &quot;cog&quot;  </span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]  </span><br><span class="line"></span><br><span class="line">Output: 0  </span><br><span class="line"></span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.  </span><br><span class="line">题目描述：找出一条从 beginWord 到 endWord 的最短路径，每次移动规定为改变一个字符，并且改变之后的字符串必须在 wordList 中。</span><br></pre></td></tr></table></figure>
<p>题解：<br>bfs。官方双向bfs的C++版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n;</span><br><span class="line">unordered_map&lt;string, vector&lt;string&gt; &gt; umap;</span><br><span class="line"></span><br><span class="line">int bfs(queue&lt;pair&lt;string, int&gt; &gt; &amp;curQueue, unordered_map&lt;string, int&gt;&amp; visited, unordered_map&lt;string, int&gt;&amp; anoVisited)&#123;</span><br><span class="line">    string curWord = curQueue.front().first;</span><br><span class="line">    int len = curQueue.front().second;</span><br><span class="line">    curQueue.pop();</span><br><span class="line">    for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">        string index = curWord.substr(0, i)+&quot;*&quot;+curWord.substr(i+1, n);</span><br><span class="line">        for(string str : umap[index])&#123;</span><br><span class="line">            if(anoVisited[str])</span><br><span class="line">                return len + anoVisited[str]; </span><br><span class="line">            if(!visited[str])&#123;</span><br><span class="line">                curQueue.push(make_pair(str, len+1));</span><br><span class="line">                visited[str] = len+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;</span><br><span class="line">    n = beginWord.size();</span><br><span class="line">    bool flag = false;</span><br><span class="line">    for(string str : wordList)&#123;</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            string tp = str.substr(0,i)+&quot;*&quot;+str.substr(i+1, n);</span><br><span class="line">            umap[tp].push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        if(str == endWord)</span><br><span class="line">            flag = true;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag) return 0;//endWord不在wordList里</span><br><span class="line">    </span><br><span class="line">    unordered_map&lt;string, int&gt; beginVisited, endVisited;</span><br><span class="line">    queue&lt;pair&lt;string, int&gt; &gt; begQueue, endQueue;</span><br><span class="line">    begQueue.push(make_pair(beginWord, 1));</span><br><span class="line">    endQueue.push(make_pair(endWord, 1));</span><br><span class="line">    beginVisited[beginWord] = 1;</span><br><span class="line">    endVisited[endWord] = 1;</span><br><span class="line">    while(!begQueue.empty() &amp;&amp; !endQueue.empty())&#123;</span><br><span class="line">        int curlen = bfs(begQueue, beginVisited, endVisited);</span><br><span class="line">        if(curlen != -1)</span><br><span class="line">            return curlen;</span><br><span class="line">        curlen = bfs(endQueue, endVisited, beginVisited);</span><br><span class="line">        if(curlen != -1)</span><br><span class="line">            return curlen;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-3-深度优先（DFS）"><a href="#3-6-3-深度优先（DFS）" class="headerlink" title="3.6.3 深度优先（DFS）"></a>3.6.3 深度优先（DFS）</h3><h4 id="Leetcode-695-岛屿的最大面积（中等）"><a href="#Leetcode-695-岛屿的最大面积（中等）" class="headerlink" title="Leetcode 695. 岛屿的最大面积（中等）"></a><a href="https://leetcode-cn.com/problems/max-area-of-island/">Leetcode 695. 岛屿的最大面积（中等）</a></h4><p>查找最大的连通面积。一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设<code>grid</code>的四个边缘都被 0（代表水）包围着。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0,0,1,0,0,0,0,1,0,0,0,0,0],  </span><br><span class="line">[0,0,0,0,0,0,0,1,1,1,0,0,0],  </span><br><span class="line">[0,1,1,0,1,0,0,0,0,0,0,0,0],  </span><br><span class="line">[0,1,0,0,1,1,0,0,1,0,1,0,0],  </span><br><span class="line">[0,1,0,0,1,1,0,0,1,1,1,0,0],  </span><br><span class="line">[0,0,0,0,0,0,0,0,0,0,1,0,0],  </span><br><span class="line">[0,0,0,0,0,0,0,1,1,1,0,0,0],  </span><br><span class="line">[0,0,0,0,0,0,0,1,1,0,0,0,0]  </span><br><span class="line">output: 6    </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><ol>
<li>STL栈实现</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; direction = &#123; &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125; &#125;;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; grid.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; grid[0].size();j++)&#123;</span><br><span class="line">            int res_ij = 0;</span><br><span class="line">            stack&lt;vector&lt;int&gt; &gt; st;</span><br><span class="line">            vector&lt;int&gt; tmp = &#123;i, j&#125;;</span><br><span class="line">            st.push(tmp);</span><br><span class="line">            while (!st.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                int cur_i = st.top()[0];</span><br><span class="line">                int cur_j = st.top()[1];</span><br><span class="line">                st.pop();</span><br><span class="line">                if(cur_i&lt;0 || cur_j&lt;0</span><br><span class="line">                    || cur_i&gt;=grid.size() || cur_j&gt;=grid[0].size()</span><br><span class="line">                    || grid[cur_i][cur_j]!=1 )//这个条件一定要放到最后，要先满足坐标的条件，不然grid会越界</span><br><span class="line">                    continue;</span><br><span class="line">                grid[cur_i][cur_j] = 0;</span><br><span class="line">                res_ij++;</span><br><span class="line">                for (auto dir : direction)</span><br><span class="line">                &#123;</span><br><span class="line">                    int next_i = cur_i + dir[0];</span><br><span class="line">                    int next_j = cur_j + dir[1];</span><br><span class="line">                    vector&lt;int&gt; tmp2 = &#123;next_i, next_j&#125;;</span><br><span class="line">                    st.push(tmp2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, res_ij);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>递归。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int dfs(vector&lt;vector&lt;int&gt; &gt; &amp;grid,int cur_i, int cur_j)&#123;</span><br><span class="line">    if(cur_i&lt;0 || cur_j&lt;0 || cur_i &gt;= grid.size() || cur_j &gt;= grid[0].size() || grid[cur_i][cur_j] != 1)</span><br><span class="line">        return 0;</span><br><span class="line">    grid[cur_i][cur_j] = 0;</span><br><span class="line">    int res = 1;</span><br><span class="line">    int dir_i[] = &#123;1, 0, 0, -1&#125;;</span><br><span class="line">    int dir_j[] = &#123;0, 1, -1, 0&#125;;</span><br><span class="line">    for (int i = 0; i &lt; 4;i++)&#123;</span><br><span class="line">        int next_i = cur_i + dir_i[i];</span><br><span class="line">        int next_j = cur_j + dir_j[i];</span><br><span class="line">        res += dfs(grid, next_i, next_j);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; grid.size();i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; grid[0].size();j++)</span><br><span class="line">            res = max(res, dfs(grid, i, j));</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="BFS也可以"><a href="#BFS也可以" class="headerlink" title="BFS也可以"></a>BFS也可以</h5><p>把栈改为队列就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int maxAreaOfIsland(vector&lt;vector&lt;int&gt; &gt; &amp;grid)&#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; direction = &#123; &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125; &#125;;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; grid.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; grid[0].size();j++)&#123;</span><br><span class="line">            int res_ij = 0;</span><br><span class="line">            queue&lt;vector&lt;int&gt; &gt; st;</span><br><span class="line">            vector&lt;int&gt; tmp = &#123;i, j&#125;;</span><br><span class="line">            st.push(tmp);</span><br><span class="line">            while (!st.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                int cur_i = st.front()[0];</span><br><span class="line">                int cur_j = st.front()[1];</span><br><span class="line">                st.pop();</span><br><span class="line">                if(cur_i&lt;0 || cur_j&lt;0</span><br><span class="line">                    || cur_i&gt;=grid.size() || cur_j&gt;=grid[0].size()</span><br><span class="line">                    || grid[cur_i][cur_j]!=1 )//这个条件一定要放到最后，要先满足坐标的条件，不然grid会越界</span><br><span class="line">                    continue;</span><br><span class="line">                grid[cur_i][cur_j] = 0;</span><br><span class="line">                res_ij++;</span><br><span class="line">                for (auto dir : direction)</span><br><span class="line">                &#123;</span><br><span class="line">                    int next_i = cur_i + dir[0];</span><br><span class="line">                    int next_j = cur_j + dir[1];</span><br><span class="line">                    vector&lt;int&gt; tmp2 = &#123;next_i, next_j&#125;;</span><br><span class="line">                    st.push(tmp2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, res_ij);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-200-岛屿数量（中等）"><a href="#Leetcode-200-岛屿数量（中等）" class="headerlink" title="Leetcode 200. 岛屿数量（中等）"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">Leetcode 200. 岛屿数量（中等）</a></h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input:  </span><br><span class="line">[</span><br><span class="line">    [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">    [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">    [&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">    [&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;1&#x27;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Output: 3  </span><br></pre></td></tr></table></figure>
<p>题解：<br>dfs。求矩阵中的连通分量数目。可以将矩阵表示看成一张有向图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void dfs(vector&lt;vector&lt;char&gt; &gt; &amp;grid, int i, int j)&#123;</span><br><span class="line">    if(i&lt;0 || i&gt;=grid.size() || j&lt;0 || j&gt;=grid[0].size() || grid[i][j]==&#x27;0&#x27;)</span><br><span class="line">        return;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; directions = &#123; &#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125; &#125;;</span><br><span class="line">    grid[i][j] = &#x27;0&#x27;;</span><br><span class="line">    for(auto d:directions)&#123;</span><br><span class="line">        int next_i = i + d[0];</span><br><span class="line">        int next_j = j + d[1];</span><br><span class="line">        dfs(grid, next_i, next_j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int numIslands(vector&lt;vector&lt;char&gt; &gt;&amp; grid) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; grid.size();i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; grid[0].size();j++)&#123;</span><br><span class="line">            if(grid[i][j] != &#x27;0&#x27;)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bfs也可以（待补充）</p>
<h4 id="Leetcode-547-朋友圈（中等）"><a href="#Leetcode-547-朋友圈（中等）" class="headerlink" title="Leetcode 547. 朋友圈（中等）"></a><a href="https://leetcode-cn.com/problems/friend-circles/">Leetcode 547. 朋友圈（中等）</a></h4><p>好友关系可以看成是一个无向图，例如第 0 个人与第 1 个人是好友，那么 M[0][1] 和 M[1][0] 的值都为 1。求朋友圈的个数。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input:  </span><br><span class="line">[[1,1,0],  </span><br><span class="line">[1,1,0],  </span><br><span class="line">[0,0,1]]</span><br><span class="line"></span><br><span class="line">Output: 2  </span><br><span class="line"></span><br><span class="line">已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。</span><br><span class="line">第2个学生自己在一个朋友圈。所以返回 2 。</span><br></pre></td></tr></table></figure>
<p>题解：<br>dfs。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void dfs(vector&lt;vector&lt;int&gt; &gt; &amp;nums, int i, vector&lt;bool&gt; &amp;isFriend)&#123;</span><br><span class="line">    isFriend[i] = true;</span><br><span class="line">    for (int j = 0; j &lt; nums.size();j++)&#123;</span><br><span class="line">        if(!isFriend[j] &amp;&amp; nums[i][j]==1)&#123;</span><br><span class="line">            dfs(nums, j, isFriend);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    vector&lt;bool&gt; isFriend(M.size());</span><br><span class="line">    for (int i = 0; i &lt; M.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!isFriend[i])&#123;</span><br><span class="line">            res++;</span><br><span class="line">            dfs(M, i, isFriend);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-130-被围绕的区域（中等）"><a href="#Leetcode-130-被围绕的区域（中等）" class="headerlink" title="Leetcode 130. 被围绕的区域（中等）"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/">Leetcode 130. 被围绕的区域（中等）</a></h4><p>使被 ‘X’ 包围的 ‘O’ 转换为 ‘X’。任何边界上的 ‘O’ 都不会被填充为 ‘X’。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For example,  </span><br><span class="line">X X X X  </span><br><span class="line">X O O X  </span><br><span class="line">X X O X  </span><br><span class="line">X O X X  </span><br><span class="line">After running your function, the board should be:  </span><br><span class="line">X X X X  </span><br><span class="line">X X X X  </span><br><span class="line">X X X X  </span><br><span class="line">X O X X  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>dfs方法一。先把和最外侧的’O’相连的’O’用dfs找出来标记成其他，剩下的就是里侧的需要填充的了。填充的时候顺便把不需要填充的’O’换回来</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void dfs(vector&lt;vector&lt;char&gt; &gt; &amp;board, int i, int j)&#123;</span><br><span class="line">    if(i&lt;0 || i&gt;= board.size() || j&lt;0 || j&gt;=board[0].size() || board[i][j] != &#x27;O&#x27;)</span><br><span class="line">        return;</span><br><span class="line">    board[i][j] = &#x27;*&#x27;;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; directions = &#123; &#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;1,0&#125; &#125;;</span><br><span class="line">    for(auto d:directions)</span><br><span class="line">        dfs(board, i + d[0], j + d[1]);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">    if(board.empty())</span><br><span class="line">        return;</span><br><span class="line">    for (int i = 0; i &lt; board[0].size();i++)&#123;</span><br><span class="line">        dfs(board, 0, i);</span><br><span class="line">        dfs(board, board.size() - 1, i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; board.size();i++)&#123;</span><br><span class="line">        dfs(board, i, 0);</span><br><span class="line">        dfs(board, i, board[0].size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; board.size(); i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; board[0].size(); j++)&#123;</span><br><span class="line">            if(board[i][j]==&#x27;O&#x27;)</span><br><span class="line">                board[i][j] = &#x27;X&#x27;;</span><br><span class="line">            else if (board[i][j]== &#x27;*&#x27;)</span><br><span class="line">                board[i][j] = &#x27;O&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>dfs方法二</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; dirs = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,vector&lt;int&gt; &amp; s,vector&lt;vector&lt;bool&gt; &gt; &amp;marked)&#123;</span><br><span class="line">    int x=s[0],y=s[1];</span><br><span class="line">    if(board[x][y]==&#x27;X&#x27; || marked[x][y])</span><br><span class="line">        return;</span><br><span class="line">    marked[x][y] = true;</span><br><span class="line">    for(auto d:dirs)&#123;</span><br><span class="line">        int next_i = x+d[0], next_j = y+d[1];</span><br><span class="line">        vector&lt;int&gt; tmp = &#123;next_i,next_j&#125;;</span><br><span class="line">        if((next_i &gt; 0 &amp;&amp; next_i &lt; board.size())</span><br><span class="line">        &amp;&amp; (next_j &gt; 0 &amp;&amp; next_j &lt; board[0].size()))</span><br><span class="line">            dfs(board,tmp,marked);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">    if(board.empty())</span><br><span class="line">        return;</span><br><span class="line">    int m = board.size(),n = board[0].size();</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; marked(m,vector&lt;bool&gt;(n, false));</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; side;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        if(board[0][i]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;0,i&#125;);</span><br><span class="line">            //marked[0][i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(board[m-1][i]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;m-1,i&#125;);</span><br><span class="line">            //marked[m-1][i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;m-1;i++)&#123;</span><br><span class="line">        if(board[i][0]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;i,0&#125;);</span><br><span class="line">            //marked[i][0] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(board[i][n-1]==&#x27;O&#x27;)&#123;</span><br><span class="line">            side.push_back(&#123;i,n-1&#125;);</span><br><span class="line">            //marked[i][n-1] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(auto s:side)&#123;</span><br><span class="line">        dfs(board,s,marked);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            if(!marked[i][j] &amp;&amp; board[i][j]==&#x27;O&#x27;)</span><br><span class="line">                board[i][j] = &#x27;X&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-417-太平洋大西洋水流问题（中等）"><a href="#Leetcode-417-太平洋大西洋水流问题（中等）" class="headerlink" title="Leetcode 417. 太平洋大西洋水流问题（中等）"></a><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">Leetcode 417. 太平洋大西洋水流问题（中等）</a></h4><p>左边和上边是太平洋，右边和下边是大西洋，内部的数字代表海拔，海拔高的地方的水能够流到低的地方，求解水能够流到太平洋和大西洋的所有位置。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Given the following 5x5 matrix:</span><br><span class="line"></span><br><span class="line">Pacific ~   ~   ~   ~   ~  </span><br><span class="line">    ~  1   2   2   3  (5) *  </span><br><span class="line">    ~  3   2   3  (4) (4) *  </span><br><span class="line">    ~  2   4  (5)  3   1  *  </span><br><span class="line">    ~ (6) (7)  1   4   5  *  </span><br><span class="line">    ~ (5)  1   1   2   4  *  </span><br><span class="line">    *   *   *   *   * Atlantic</span><br><span class="line"></span><br><span class="line">Return:  </span><br><span class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]   </span><br><span class="line">(positions with parentheses in above matrix).  </span><br></pre></td></tr></table></figure>
<p>题解：<br>从边缘逆流dfs，P逆流能到达的地方的标记，A逆流能到达的地方标记，都为1的位置即所求位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void dfs(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int i, int j, vector&lt;vector&lt;bool&gt; &gt; &amp;canTo)&#123;</span><br><span class="line">    if(canTo[i][j])</span><br><span class="line">        return;</span><br><span class="line">    canTo[i][j] = true;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; directions = &#123; &#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125; &#125;;</span><br><span class="line">    for(auto d:directions)&#123;</span><br><span class="line">        int next_i = i + d[0];</span><br><span class="line">        int next_j = j + d[1];</span><br><span class="line">        if(next_i&lt;0 || next_i&gt;=matrix.size() || </span><br><span class="line">        next_j&lt;0 || next_j&gt;=matrix[0].size() || </span><br><span class="line">        matrix[next_i][next_j]&lt;matrix[i][j])&#123;//这里i j一定要看清楚！因为i j调了一个小时！</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(matrix, next_i, next_j, canTo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    if(matrix.empty())</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    int m = matrix.size();</span><br><span class="line">    int n = matrix[0].size();</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; canToAtlatic(m, vector&lt;bool&gt;(n, false));</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; canToPacific(m,vector&lt;bool&gt;(n,false));</span><br><span class="line">    for (int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        dfs(matrix, i, 0, canToPacific);</span><br><span class="line">        dfs(matrix, i, n - 1, canToAtlatic);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        dfs(matrix, 0, i, canToPacific);</span><br><span class="line">        dfs(matrix, m - 1, i, canToAtlatic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    for (int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; n;j++)&#123;</span><br><span class="line">            if(canToAtlatic[i][j] &amp;&amp; canToPacific[i][j])&#123;</span><br><span class="line">                vector&lt;int&gt; tmp = &#123;i, j&#125;;</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-329-矩阵中的最长递增路径（困难）"><a href="#Leetcode-329-矩阵中的最长递增路径（困难）" class="headerlink" title="Leetcode 329. 矩阵中的最长递增路径（困难）"></a><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">Leetcode 329. 矩阵中的最长递增路径（困难）</a></h4><p>给定一个整数矩阵，找出最长递增路径的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = </span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure>
<p>题解：<br>有记忆的dfs。<br>普通dfs会超时，所以加了二位矩阵来记录已经得到的最长序列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; dirs = &#123; &#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">int dfs(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int i, int j, vector&lt;vector&lt;int&gt; &gt; &amp;memo)&#123;</span><br><span class="line">    if(memo[i][j]!=0)</span><br><span class="line">        return memo[i][j];</span><br><span class="line">    memo[i][j] = 1;</span><br><span class="line">    for(auto d:dirs)&#123;</span><br><span class="line">        if (i + d[0] &gt;= 0 &amp;&amp; i + d[0] &lt; matrix.size() </span><br><span class="line">            &amp;&amp; j + d[1] &gt;= 0 &amp;&amp; j + d[1] &lt; matrix[0].size() </span><br><span class="line">            &amp;&amp; matrix[i + d[0]][j + d[1]] &gt; matrix[i][j])</span><br><span class="line">            memo[i][j] = max(memo[i][j], dfs(matrix, i + d[0], j + d[1], memo) + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return memo[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int longestIncreasingPath(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123;</span><br><span class="line">    if(matrix.empty())</span><br><span class="line">        return 0;</span><br><span class="line">    int m = matrix.size(), n = matrix[0].size();</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; memo(m, vector&lt;int&gt;(n, 0));</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            res = max(res, dfs(matrix, i, j, memo));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(mn)<br>空间复杂度：O(mn)</p>
<h4 id="Leetcode-79-单词搜索（中等）"><a href="#Leetcode-79-单词搜索（中等）" class="headerlink" title="Leetcode 79. 单词搜索（中等）"></a><a href="https://leetcode-cn.com/problems/word-search/">Leetcode 79. 单词搜索（中等）</a></h4><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For example,  </span><br><span class="line">Given board =  </span><br><span class="line">[ [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;],  </span><br><span class="line">[&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;],  </span><br><span class="line">[&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]  ]  </span><br><span class="line">word = &quot;ABCCED&quot;, -&gt; returns true,  </span><br><span class="line">word = &quot;SEE&quot;, -&gt; returns true,  </span><br><span class="line">word = &quot;ABCB&quot;, -&gt; returns false.  </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool dfs(vector&lt;vector&lt;char&gt; &gt; &amp;board, string resWord, vector&lt;vector&lt;bool&gt; &gt; &amp;hasVisited, int i, int j)&#123;</span><br><span class="line">    if(resWord.size()==0)</span><br><span class="line">        return true;</span><br><span class="line">    if(i&lt;0 || i&gt;=board.size() || j&lt;0 || j&gt;=board[0].size() || board[i][j]!=resWord[0] || hasVisited[i][j])</span><br><span class="line">        return false;</span><br><span class="line">    hasVisited[i][j] = true;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; directions = &#123; &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125; &#125;;</span><br><span class="line">    for(auto d:directions)&#123;</span><br><span class="line">        if(dfs(board,resWord.substr(1,resWord.size()-1),hasVisited,i+d[0],j+d[1]))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    hasVisited[i][j] = false;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;</span><br><span class="line">    vector&lt;vector&lt;bool&gt; &gt; hasVisited(board.size(),vector&lt;bool&gt;(board[0].size(),false));</span><br><span class="line">    for (int i = 0; i &lt; board.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; board[0].size();j++)&#123;</span><br><span class="line">            if(dfs(board, word, hasVisited, i, j))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-257-二叉树的所有路径（简单）"><a href="#Leetcode-257-二叉树的所有路径（简单）" class="headerlink" title="Leetcode 257. 二叉树的所有路径（简单）"></a><a href="https://leetcode-cn.com/problems/binary-tree-paths/">Leetcode 257. 二叉树的所有路径（简单）</a></h4><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">     1  </span><br><span class="line">    / \  </span><br><span class="line">   2   3  </span><br><span class="line">    \  </span><br><span class="line">     5 </span><br><span class="line"></span><br><span class="line">输出：[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; res;</span><br><span class="line">void dfs(TreeNode *biTree, string prePath, TreeNode *curNode)&#123;</span><br><span class="line">    if(curNode==NULL)</span><br><span class="line">        return;</span><br><span class="line">    string curStr = to_string(curNode-&gt;val);</span><br><span class="line">    if (prePath.size() != 0)</span><br><span class="line">        curStr = &quot;-&gt;&quot; + curStr;</span><br><span class="line">    prePath = prePath + curStr;</span><br><span class="line">    if (curNode-&gt;left == NULL &amp;&amp; curNode-&gt;right == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(prePath);</span><br><span class="line">        return;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        dfs(biTree, prePath, curNode-&gt;left);</span><br><span class="line">        dfs(biTree, prePath, curNode-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    prePath = prePath.erase(prePath.size()-curStr.size());</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">    dfs(root, &quot;&quot;, root);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(n^2)</p>
<h3 id="3-6-4-滑动窗口"><a href="#3-6-4-滑动窗口" class="headerlink" title="3.6.4 滑动窗口"></a>3.6.4 滑动窗口</h3><h4 id="滑动窗口算法框架"><a href="#滑动窗口算法框架" class="headerlink" title="滑动窗口算法框架"></a>滑动窗口算法框架</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int left = 0, right = 0;</span><br><span class="line"></span><br><span class="line">while (right &lt; s.size()) &#123;`</span><br><span class="line">    // 增大窗口</span><br><span class="line">    window.add(s[right]);</span><br><span class="line">    right++;</span><br><span class="line"></span><br><span class="line">    while (window needs shrink) &#123;</span><br><span class="line">        // 缩小窗口</span><br><span class="line">        window.remove(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-424-替换后的最长重复字符"><a href="#Leetcode-424-替换后的最长重复字符" class="headerlink" title="Leetcode 424.替换后的最长重复字符"></a><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/hua-dong-chuang-kou-chang-gui-tao-lu-by-xiaoneng/">Leetcode 424.替换后的最长重复字符</a></h4><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。  </p>
<p>在执行上述操作后，找到包含重复字母的最长子串的长度。  </p>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int characterReplacement(string s, int k) &#123;</span><br><span class="line">    vector&lt;int&gt; numOfAlpha(26);</span><br><span class="line">    int left = 0, right = 0, res = 0, maxCount = 0;</span><br><span class="line">    while(right&lt;s.size())&#123;</span><br><span class="line">        numOfAlpha[s[right] - &#x27;A&#x27;]++;</span><br><span class="line">        maxCount = max(maxCount, numOfAlpha[s[right]-&#x27;A&#x27;]);</span><br><span class="line">        if(right-left+1 - maxCount &gt;k)&#123;</span><br><span class="line">            numOfAlpha[s[left] - &#x27;A&#x27;]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, right - left + 1);</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leetcode-567-字符串的排列（中等）"><a href="#Leetcode-567-字符串的排列（中等）" class="headerlink" title="Leetcode 567. 字符串的排列（中等）"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">Leetcode 567. 字符串的排列（中等）</a></h4><p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p>
<p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p>
<p>示例1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">输出: False</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题解：<br>用一个哈希表保存字母出现的个数，然后使用滑动窗口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool checkInclusion(string s1, string s2) &#123;</span><br><span class="line">    unordered_map&lt;char, int&gt; cmap;</span><br><span class="line">    for(char &amp;c:s1)</span><br><span class="line">        cmap[c]++;</span><br><span class="line">    int idxL = 0, idxR = 0;</span><br><span class="line">    while(idxR &lt; s2.size())&#123;</span><br><span class="line">        char c = s2[idxR++]; //窗口右边增大</span><br><span class="line">        cmap[c]--;</span><br><span class="line">        while(idxL&lt;idxR &amp;&amp; cmap[c]&lt;0) //窗口左边减小</span><br><span class="line">            cmap[s2[idxL++]]++;</span><br><span class="line">        if(idxR - idxL == s1.size())</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-5-二分查找-x2F-折半查找"><a href="#3-6-5-二分查找-x2F-折半查找" class="headerlink" title="3.6.5 二分查找&#x2F;折半查找"></a>3.6.5 二分查找&#x2F;折半查找</h3><h4 id="二分查找框架"><a href="#二分查找框架" class="headerlink" title="二分查找框架"></a>二分查找框架</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0, right = ...;</span><br><span class="line"></span><br><span class="line">    while(...) &#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两种计算中值 m 的方式：<br>m &#x3D; (l + h) &#x2F; 2<br>m &#x3D; l + (h - l) &#x2F; 2<br>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。<br>所以，最好使用第二种计算法方法。</p>
<h4 id="Leetcode-69-x-的平方根（简单）"><a href="#Leetcode-69-x-的平方根（简单）" class="headerlink" title="Leetcode 69. x 的平方根（简单）"></a><a href="https://leetcode-cn.com/problems/sqrtx/">Leetcode 69. x 的平方根（简单）</a></h4><p>实现 int sqrt(int x) 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: 4  </span><br><span class="line">Output: 2  </span><br><span class="line"></span><br><span class="line">Input: 8  </span><br><span class="line">Output: 2  </span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.</span><br></pre></td></tr></table></figure>
<p>题解：<br>后面 <strong>面试高频</strong> 中有返回不是int的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int mySqrt(int x) &#123;</span><br><span class="line">    if(x&lt;=1)</span><br><span class="line">        return x;</span><br><span class="line"></span><br><span class="line">    int low = 1, hight = x;</span><br><span class="line">    while(low&lt;=hight)&#123;</span><br><span class="line">        int mid = low + (hight - low) / 2;</span><br><span class="line">        if((long)mid * mid==x)</span><br><span class="line">            return mid;</span><br><span class="line">        else if((long)mid * mid&gt;x)</span><br><span class="line">            hight = mid - 1;</span><br><span class="line">        else</span><br><span class="line">            low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return hight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(logx)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-744-寻找比目标字母大的最小字母"><a href="#Leetcode-744-寻找比目标字母大的最小字母" class="headerlink" title="Leetcode 744. 寻找比目标字母大的最小字母"></a><a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">Leetcode 744. 寻找比目标字母大的最小字母</a></h4><p>给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input:  </span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]  </span><br><span class="line">target = &quot;d&quot;  </span><br><span class="line">Output: &quot;f&quot;  </span><br><span class="line">Input:  </span><br><span class="line">letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]  </span><br><span class="line">target = &quot;k&quot;  </span><br><span class="line">Output: &quot;c&quot;   </span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123;</span><br><span class="line">    int n = letters.size();</span><br><span class="line">    int low = 0, hight = n-1;</span><br><span class="line">    while(low&lt;=hight)&#123;</span><br><span class="line">        int mid = low + (hight - low) / 2;</span><br><span class="line">        if(letters[mid]&lt;=target)</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        else</span><br><span class="line">            hight = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    char res = low &lt; n ? letters[low] : letters[0];</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-540-有序数组中的单一元素（中等）"><a href="#Leetcode-540-有序数组中的单一元素（中等）" class="headerlink" title="Leetcode 540. 有序数组中的单一元素（中等）"></a><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">Leetcode 540. 有序数组中的单一元素（中等）</a></h4><p>给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。要求以 O(logN) 时间复杂度进行求解，因此不能遍历数组并进行异或操作来求解，这么做的时间复杂度为 O(N)。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: [1, 1, 2, 3, 3, 4, 4, 8, 8]  </span><br><span class="line">Output: 2  </span><br></pre></td></tr></table></figure>
<p>题解：<br>令 index 为 Single Element 在数组中的位置。在 index 之后，数组中原来存在的成对状态被改变。如果 m 为偶数，并且 m + 1 &lt; index，那么 nums[m] &#x3D;&#x3D; nums[m + 1]；m + 1 &gt;&#x3D; index，那么 nums[m] !&#x3D; nums[m + 1]。  </p>
<p>从上面的规律可以知道，如果 nums[m] &#x3D;&#x3D; nums[m + 1]，那么 index 所在的数组位置为 [m + 2, h]，此时令 l &#x3D; m + 2；如果 nums[m] !&#x3D; nums[m + 1]，那么 index 所在的数组位置为 [l, m]，此时令 h &#x3D; m。因为 h 的赋值表达式为 h &#x3D; m，那么循环条件也就只能使用 l &lt; h 这种形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int low = 0, hight = nums.size() - 1;</span><br><span class="line">    while(low&lt;hight)&#123;</span><br><span class="line">        int mid = low + (hight - low) / 2;</span><br><span class="line">        if(mid%2==1)  //保证m为偶数</span><br><span class="line">            mid--;</span><br><span class="line">        if(nums[mid] == nums[mid+1])</span><br><span class="line">            low = mid + 2;</span><br><span class="line">        else</span><br><span class="line">            hight = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>
<p>类似的题</p>
<h4 id="Leetcode-136-只出现一次的数字（简单）"><a href="#Leetcode-136-只出现一次的数字（简单）" class="headerlink" title="Leetcode 136. 只出现一次的数字（简单）"></a><a href="https://leetcode-cn.com/problems/single-number/">Leetcode 136. 只出现一次的数字（简单）</a></h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p>题解：<br>任何数和其自身做异或运算结果是0，任何数和 0 做异或运算结果仍然是原来的数。所以依次异或就能得到。无序的话也不能用二分来做。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int num : nums) &#123;</span><br><span class="line">        res ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-137-只出现一次的数字-II（中等）"><a href="#Leetcode-137-只出现一次的数字-II（中等）" class="headerlink" title="Leetcode 137. 只出现一次的数字 II（中等）"></a><a href="https://leetcode-cn.com/problems/single-number-ii/">Leetcode 137. 只出现一次的数字 II（中等）</a></h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,1,0,1,99]</span><br><span class="line">输出: 99</span><br></pre></td></tr></table></figure>
<p>题解：<br>哈希表的话空间复杂度为O(n)，但是我们需要空间复杂度为O(1)。具体看题解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int seenOnce = 0, seenTwice = 0;</span><br><span class="line">    for (int num : nums) &#123;</span><br><span class="line">        seenOnce = ~seenTwice &amp; (seenOnce ^ num);</span><br><span class="line">        seenTwice = ~seenOnce &amp; (seenTwice ^ num);</span><br><span class="line">    &#125;</span><br><span class="line">    return seenOnce;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-278-第一个错误的版本（简单）"><a href="#Leetcode-278-第一个错误的版本（简单）" class="headerlink" title="Leetcode 278. 第一个错误的版本（简单）"></a><a href="https://leetcode-cn.com/problems/first-bad-version/">Leetcode 278. 第一个错误的版本（简单）</a></h4><p>给定一个元素 n 代表有 [1, 2, …, n] 版本，在第 x 位置开始出现错误版本，导致后面的版本都错误。</p>
<p>如果第 m 个版本出错，则表示第一个错误的版本在 [l, m] 之间，令 h &#x3D; m；否则第一个错误的版本在 [m + 1, h] 之间，令 l &#x3D; m + 1。因为 h 的赋值表达式为 h &#x3D; m，因此循环条件为 l &lt; h。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 n = 5，并且 version = 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5) -&gt; true</span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。</span><br></pre></td></tr></table></figure>
<p>题解：<br>二分法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int firstBadVersion(int n) &#123;</span><br><span class="line">    int low = 1, hight = n;</span><br><span class="line">    while(low &lt; hight)&#123;</span><br><span class="line">        int mid = low + (hight - low) / 2;</span><br><span class="line">        if(isBadVersion(mid))</span><br><span class="line">            hight = mid;</span><br><span class="line">        else</span><br><span class="line">            low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-153-寻找旋转排序数组中的最小值（中等）"><a href="#Leetcode-153-寻找旋转排序数组中的最小值（中等）" class="headerlink" title="Leetcode 153. 寻找旋转排序数组中的最小值（中等）"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">Leetcode 153. 寻找旋转排序数组中的最小值（中等）</a></h4><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。(例如，数组[0,1,2,4,5,6,7]可能变为[4,5,6,7,0,1,2])</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1 </span><br></pre></td></tr></table></figure>
<p>题解：<br>二分法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int findMin(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int low = 0, hight = nums.size() - 1;</span><br><span class="line">    while(low &lt; hight)&#123;</span><br><span class="line">        int mid = low + (hight - low) / 2;</span><br><span class="line">        if(nums[mid] &lt;= nums[hight])</span><br><span class="line">            hight = mid;</span><br><span class="line">        else</span><br><span class="line">            low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-34-在排序数组中查找元素的第一个和最后一个位置（中等）"><a href="#Leetcode-34-在排序数组中查找元素的第一个和最后一个位置（中等）" class="headerlink" title="Leetcode 34. 在排序数组中查找元素的第一个和最后一个位置（中等）"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">Leetcode 34. 在排序数组中查找元素的第一个和最后一个位置（中等）</a></h4><p>给定一个有序数组 nums 和一个目标 target，要求找到 target 在 nums 中的第一个位置和最后一个位置。  </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 8  </span><br><span class="line">Output: [3,4]  </span><br><span class="line">Input: nums = [5,7,7,8,8,10], target = 6  </span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure>
<p>题解：<br>可以用二分查找找出第一个位置和最后一个位置，但是寻找的方法有所不同，需要实现两个二分查找。</p>
<p>我们将寻找 target 最后一个位置，转换成寻找 target+1 第一个位置，再往前移动一个位置。这样我们只需要实现一个二分查找代码即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int findFirst(vector&lt;int&gt; &amp;nums, int target)&#123;</span><br><span class="line">    int low = 0, hight = nums.size() - 1;</span><br><span class="line">    if(target&gt;nums[hight])&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    while(low&lt;hight)&#123;</span><br><span class="line">        int mid = low + (hight - low) / 2;</span><br><span class="line">        if(nums[mid]&gt;=target)</span><br><span class="line">            hight = mid;</span><br><span class="line">        else</span><br><span class="line">            low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target)&#123;</span><br><span class="line">    if(nums.empty() || target&lt;nums[0] || target&gt;nums[nums.size()-1])</span><br><span class="line">        return &#123;-1, -1&#125;;</span><br><span class="line"></span><br><span class="line">    int first = findFirst(nums, target);</span><br><span class="line">    int next = findFirst(nums, target + 1);</span><br><span class="line">    if (first == -1 || nums[first] != target)</span><br><span class="line">        return &#123;-1, -1&#125;;</span><br><span class="line"></span><br><span class="line">    int last = 0;</span><br><span class="line">    if (next == -1)</span><br><span class="line">        last = nums.size() - 1;</span><br><span class="line">    else</span><br><span class="line">        last = next - 1;</span><br><span class="line">    return &#123;first, last&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>
<h4 id="Leetcode-315-计算右侧小于当前元素的个数"><a href="#Leetcode-315-计算右侧小于当前元素的个数" class="headerlink" title="Leetcode 315. 计算右侧小于当前元素的个数"></a><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">Leetcode 315. 计算右侧小于当前元素的个数</a></h4><p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,2,6,1]</span><br><span class="line">输出：[2,1,1,0] </span><br><span class="line">解释：</span><br><span class="line">5 的右侧有 2 个更小的元素 (2 和 1)</span><br><span class="line">2 的右侧仅有 1 个更小的元素 (1)</span><br><span class="line">6 的右侧有 1 个更小的元素 (1)</span><br><span class="line">1 的右侧有 0 个更小的元素</span><br></pre></td></tr></table></figure>
<p>题解：  </p>
<ol>
<li>归并排序。归并的过程中记录右边比左边小的个数和索引。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; indexs; //原始索引</span><br><span class="line">vector&lt;int&gt; ans;  //要求的答案</span><br><span class="line">vector&lt;int&gt; ordered;  //存排好序的临时数组</span><br><span class="line">vector&lt;int&gt; orderedIndex;  //存排好序的临时数组索引</span><br><span class="line"></span><br><span class="line">void Merge(vector&lt;int&gt; &amp;nums, int l, int mid, int r)&#123;</span><br><span class="line">	int i = l, j = mid + 1, p = l;</span><br><span class="line">	while (i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">		if (nums[i] &lt;= nums[j])&#123;</span><br><span class="line">			ordered[p] = nums[i];</span><br><span class="line">			orderedIndex[p] = indexs[i];</span><br><span class="line">			ans[indexs[i]] += (j - mid - 1);</span><br><span class="line">			i++;</span><br><span class="line">			p++;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			ordered[p] = nums[j];</span><br><span class="line">			orderedIndex[p] = indexs[j];</span><br><span class="line">			j++;</span><br><span class="line">			p++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (i &lt;= mid) &#123;</span><br><span class="line">		ordered[p] = nums[i];</span><br><span class="line">		orderedIndex[p] = indexs[i];</span><br><span class="line">		ans[indexs[i]] += (j - mid - 1);</span><br><span class="line">		i++;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (j &lt;= r)&#123;</span><br><span class="line">		ordered[p] = nums[j];</span><br><span class="line">		orderedIndex[p] = indexs[j];</span><br><span class="line">		j++;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int k = l; k &lt;= r; k++)&#123;</span><br><span class="line">		indexs[k] = orderedIndex[k];</span><br><span class="line">		nums[k] = ordered[k];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> void MergeSort(vector&lt;int&gt; &amp;a, int L, int R)&#123;</span><br><span class="line">	if (L &gt;= R) </span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	int mid = (L + R) &gt;&gt; 1;</span><br><span class="line">	MergeSort(a, L, mid);</span><br><span class="line">	MergeSort(a, mid + 1, R);</span><br><span class="line">	Merge(a, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; countSmaller(vector&lt;int&gt; &amp;nums)&#123;</span><br><span class="line">	int n = nums.size();</span><br><span class="line">	indexs.resize(n);</span><br><span class="line">	ans.resize(n);</span><br><span class="line">	ordered.resize(n);</span><br><span class="line">	orderedIndex.resize(n);</span><br><span class="line"></span><br><span class="line">	for(int i = 0; i &lt; n; ++i)</span><br><span class="line">		indexs[i] = i;</span><br><span class="line"></span><br><span class="line">	MergeSort(nums, 0, n - 1);</span><br><span class="line"></span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(nlogn)<br>空间复杂度：O(n)</p>
<ol start="2">
<li>把数组从后往前的元素依次插入一个初始为空的排序数组，插入的索引即为该元素右侧比它小的元素个数。如：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 [5,2,6,1]</span><br><span class="line"></span><br><span class="line">        排序数组</span><br><span class="line">step1   [1]         return 0</span><br><span class="line">step2   [1,6]       return 1</span><br><span class="line">step3   [1,2,6]     return 1</span><br><span class="line">step4   [1,2,5,6]   return 2</span><br><span class="line"></span><br><span class="line">所以最后答案为  [2,1,1,0]</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int insertNums(vector&lt;int&gt; &amp;sorted, int num)&#123;</span><br><span class="line">	if(sorted.size()==1)&#123;</span><br><span class="line">		if(num&gt;sorted[0])&#123;</span><br><span class="line">			sorted.push_back(num);</span><br><span class="line">			return 1;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			sorted.insert(sorted.begin(),num);</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int l = 0, r = sorted.size()-1;</span><br><span class="line">	int mid = (l + r) / 2;</span><br><span class="line">	while (l &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		if(sorted[mid]&lt;num)</span><br><span class="line">			l = mid + 1;</span><br><span class="line">		else</span><br><span class="line">			r = mid - 1;</span><br><span class="line">		mid = (l+r)/2;</span><br><span class="line">	&#125;</span><br><span class="line">	sorted.insert(sorted.begin()+l, num);</span><br><span class="line">	return l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">	if(nums.empty())</span><br><span class="line">		return &#123;&#125;;</span><br><span class="line">	vector&lt;int&gt; sorted;</span><br><span class="line">	vector&lt;int&gt; res(nums.size());</span><br><span class="line">	sorted.push_back(nums[nums.size()-1]);</span><br><span class="line">	for(int i=nums.size()-2;i&gt;=0;i--)&#123;</span><br><span class="line">		int idx = insertNums(sorted, nums[i]);</span><br><span class="line">		res[i] = idx;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：一开始以为是O(nlogn)，后来发现insert是O(n)的复杂度，所以是O(n^2)，就是插入排序的复杂度。但是Leetcode还是过了<br>空间复杂度：O(n)</p>
<h2 id="3-7-字符串"><a href="#3-7-字符串" class="headerlink" title="3.7 字符串"></a>3.7 字符串</h2><h3 id="字符串的统计字符串"><a href="#字符串的统计字符串" class="headerlink" title="字符串的统计字符串"></a>字符串的统计字符串</h3><p>给定一个字符串str，返回str的统计字符串。例如“aaabbbbcccd”的统计字符串为“a_3_b_4_c_3_d_1”。</p>
<p>题解：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string calcuChar(string s)&#123;</span><br><span class="line">	char c = s[0];</span><br><span class="line">    int cnt = 1;</span><br><span class="line">	string res = &quot;&quot;;</span><br><span class="line">	string cur_s;</span><br><span class="line">	for (int i = 1; i &lt; s.size(); i++)&#123;</span><br><span class="line">		if(s[i] == c)</span><br><span class="line">            cnt++;</span><br><span class="line">        else&#123;</span><br><span class="line">			cur_s = c;</span><br><span class="line">			res += (cur_s + &quot;_&quot; + to_string(cnt) + &quot;_&quot;);</span><br><span class="line">			c = s[i];</span><br><span class="line">			cnt = 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cur_s = c;</span><br><span class="line">	res += (cur_s + &quot;_&quot; + to_string(cnt));</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h3><h4 id="暴力匹配算法框架"><a href="#暴力匹配算法框架" class="headerlink" title="暴力匹配算法框架"></a>暴力匹配算法框架</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int search(String pat, String txt) &#123;</span><br><span class="line">    int M = pat.length;</span><br><span class="line">    int N = txt.length;</span><br><span class="line">    for (int i = 0; i &lt;= N - M; i++) &#123;</span><br><span class="line">        int j;</span><br><span class="line">        for (j = 0; j &lt; M; j++) &#123;</span><br><span class="line">            if (pat[j] != txt[i+j])</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        // pat 全都匹配了</span><br><span class="line">        if (j == M) return i;</span><br><span class="line">    &#125;</span><br><span class="line">    // txt 中不存在 pat 子串</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p><a href="https://blog.csdn.net/v_july_v/article/details/7041827">从头到尾彻底理解KMP</a>  </p>
<h4 id="Leetcode-28-实现-strStr"><a href="#Leetcode-28-实现-strStr" class="headerlink" title="Leetcode 28. 实现 strStr()"></a><a href="https://leetcode-cn.com/problems/implement-strstr/solution/kmp-suan-fa-xiang-jie-by-labuladong/">Leetcode 28. 实现 strStr()</a></h4><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。<br>示例 1:<br>输入: haystack &#x3D; “hello”, needle &#x3D; “ll”<br>输出: 2<br>示例 2:<br>输入: haystack &#x3D; “aaaaa”, needle &#x3D; “bba”<br>输出: -1  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（待完善）</span><br></pre></td></tr></table></figure>

<h3 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h3><p>（待完善）</p>
<h2 id="3-8-并查集（联合-查找算法-Union-find-Algorithm）"><a href="#3-8-并查集（联合-查找算法-Union-find-Algorithm）" class="headerlink" title="3.8 并查集（联合-查找算法 Union-find Algorithm）"></a>3.8 并查集（联合-查找算法 Union-find Algorithm）</h2><p>并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（Union-find Algorithm）定义了两个用于此数据结构的操作：</p>
<ul>
<li>Union：将两个子集合并成同一个集合。<br>由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（Union-find Data Structure）或合并-查找集合（Merge-find Set）。</li>
<li>Find：找到元素的root结点，每个root结点代表了一个子集。就能确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li>
</ul>
<p><a href="https://leetcode-cn.com/tag/union-find/">Leetcode并查集题库</a></p>
<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>我们在查询过程中只关心根结点是什么，并不关心这棵树的形态(有一些题除外)。因此我们可以在查询操作的时候将访问过的每个点都指向树根，这样的方法叫做路径压缩，单次操作复杂度为𝑂(𝑙𝑜𝑔𝑁)。</p>
<h3 id="代码模版"><a href="#代码模版" class="headerlink" title="代码模版"></a>代码模版</h3><ul>
<li>初始化：把每个元素单独成为一个集合，即自己是自己的父结点<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">    pre[i]=i;</span><br></pre></td></tr></table></figure></li>
<li>查询（含路径压缩）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Find(int x)&#123;</span><br><span class="line">    if(x==pre[x]) return x;</span><br><span class="line">    return pre[x]=Find(pre[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>合并<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void merge(int x,int y)&#123;</span><br><span class="line">    int rootX=Find(x),rootY=Find(y);</span><br><span class="line">    if(rootX!=rootY) pre[rootX]=rootY;</span><br><span class="line">&#125;</span><br><span class="line">//主函数内</span><br><span class="line">merge(a,b);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="76-亲戚"><a href="#76-亲戚" class="headerlink" title="76. 亲戚"></a>76. <a href="https://www.luogu.com.cn/problem/P1551">亲戚</a></h3><p>规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。<br>输入格式<br>第一行：三个整数n,m,p，（n&lt;&#x3D;5000,m&lt;&#x3D;5000,p&lt;&#x3D;5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。<br>以下m行：每行两个数Mi，Mj，1&lt;&#x3D;Mi，Mj&lt;&#x3D;N，表示Mi和Mj具有亲戚关系。<br>接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。<br>输出格式<br>P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。  </p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 5 3</span><br><span class="line">1 2</span><br><span class="line">1 5</span><br><span class="line">3 4</span><br><span class="line">5 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 3</span><br><span class="line">5 6</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<p>题解（略）</p>
<h3 id="Leetcode每日一题-2020年六月：6月8日"><a href="#Leetcode每日一题-2020年六月：6月8日" class="headerlink" title="Leetcode每日一题-2020年六月：6月8日"></a><a href="https://suzhilong.github.io/2020/06/01/LeetcodeDaily/">Leetcode每日一题-2020年六月：6月8日</a></h3><h1 id="四、面试高频题"><a href="#四、面试高频题" class="headerlink" title="四、面试高频题"></a>四、面试高频题</h1><h2 id="4-1-自己实现atoi"><a href="#4-1-自己实现atoi" class="headerlink" title="4.1 自己实现atoi"></a>4.1 自己实现atoi</h2><p>这个相当高频，面试遇到过至少2次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int myAtoi(const string &amp;str)&#123;</span><br><span class="line">    string s = str;</span><br><span class="line">    int flag = 1;</span><br><span class="line">    if(str[0]==&#x27;-&#x27;)&#123;</span><br><span class="line">        s = s.substr(1, s.size() - 1);</span><br><span class="line">        flag = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    long res = 0;</span><br><span class="line">    for (int i = 0; i &lt; s.size();i++)&#123;</span><br><span class="line">        res = res * 10 + (s[i] - &#x27;0&#x27;);</span><br><span class="line">        if(res&gt;=INT_MAX &amp;&amp; flag==1)</span><br><span class="line">            return INT_MAX;</span><br><span class="line">        if(res&gt;INT_MAX &amp;&amp; flag==-1)</span><br><span class="line">            return INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    return (int)res * flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-string模拟数字运算"><a href="#4-2-string模拟数字运算" class="headerlink" title="4.2 string模拟数字运算"></a>4.2 string模拟数字运算</h2><h3 id="大数相乘"><a href="#大数相乘" class="headerlink" title="大数相乘"></a>大数相乘</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string bigMultiple(string num1, string num2)&#123;</span><br><span class="line">    int m = num1.size(), n = num2.size();</span><br><span class="line">    vector&lt;long long&gt; num(m + n - 1, 0); //m位*n位 最小是 m+n-1 位，进位插到前面</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m;i++)&#123;//前面是高位，后面是低位</span><br><span class="line">        int a = num1[i] - &#x27;0&#x27;;</span><br><span class="line">        for (int j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int b = num2[j] - &#x27;0&#x27;;</span><br><span class="line">            num[i + j] += a * b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int carry = 0;</span><br><span class="line">    for (int i = num.size() - 1; i &gt;= 0;i--)&#123;//前面是高位，后面是低位</span><br><span class="line">        int cur = num[i] + carry;</span><br><span class="line">        num[i] = cur % 10;</span><br><span class="line">        carry = cur / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    while(carry!=0)&#123;</span><br><span class="line">        int cur = carry % 10;</span><br><span class="line">        carry /= 10;</span><br><span class="line">        num.insert(num.begin(), cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    for (auto a : num)</span><br><span class="line">    &#123;</span><br><span class="line">        res += to_string(a);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(m*n)<br>空间复杂度：O(m+n)</p>
<h3 id="大数相加"><a href="#大数相加" class="headerlink" title="大数相加"></a>大数相加</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string bigAdd(string &amp;num1, string &amp;num2)&#123;</span><br><span class="line">    int i = num1.size() - 1, j = num2.size() - 1;</span><br><span class="line">    int carry = 0;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    while(i&gt;=0 || j&gt;=0 || carry!=0)&#123;</span><br><span class="line">        int n1 = i &gt;= 0 ? num1[i] - &#x27;0&#x27; : 0;</span><br><span class="line">        int n2 = j &gt;= 0 ? num2[j] - &#x27;0&#x27; : 0;</span><br><span class="line">        int tmp = n1 + n2 + carry;</span><br><span class="line">        res.push_back(&#x27;0&#x27; + tmp % 10);</span><br><span class="line">        carry = tmp / 10;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大数相减"><a href="#大数相减" class="headerlink" title="大数相减"></a>大数相减</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string bigAdd(string &amp;num1, string &amp;num2)&#123;</span><br><span class="line">    int i = num1.size() - 1, j = num2.size() - 1;</span><br><span class="line">    int carry = 0;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    while(i&gt;=0 || j&gt;=0 || carry!=0)&#123;</span><br><span class="line">        int n1 = i &gt;= 0 ? num1[i] - &#x27;0&#x27; : 0;</span><br><span class="line">        int n2 = j &gt;= 0 ? num2[j] - &#x27;0&#x27; : 0;</span><br><span class="line">        int tmp = n1 + n2 + carry;</span><br><span class="line">        res.push_back(&#x27;0&#x27; + tmp % 10);</span><br><span class="line">        carry = tmp / 10;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string GreaterMinSmaller(string num1, string num2)&#123;</span><br><span class="line">    int borrow = 0;</span><br><span class="line">    string res = &quot;&quot;;</span><br><span class="line">    int i = num1.size() - 1, j = num2.size() - 1;</span><br><span class="line">    while(i&gt;=0)&#123;</span><br><span class="line">        int cur1 = num1[i] - &#x27;0&#x27; - borrow;</span><br><span class="line">        borrow = 0;</span><br><span class="line">        int cur2 = j &gt;= 0 ? num2[j] - &#x27;0&#x27; : 0;</span><br><span class="line">        if(cur1 &lt; cur2)&#123;</span><br><span class="line">            cur1 += 10;</span><br><span class="line">            borrow = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(&#x27;0&#x27; + (cur1 - cur2));</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    int not0 = 0;</span><br><span class="line">    while(res[not0]==&#x27;0&#x27;)</span><br><span class="line">        not0++;</span><br><span class="line">    return res.substr(not0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string bigMinis(string &amp;num1, string &amp;num2)&#123;</span><br><span class="line">    if(num1 == num2)</span><br><span class="line">        return &quot;0&quot;;</span><br><span class="line">    int flag1 = 1, flag2 = 1;</span><br><span class="line">    string s1 = num1, s2 = num2;</span><br><span class="line">    if (num1[0] == &#x27;-&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        s1 = s1.substr(1);</span><br><span class="line">        flag1 = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (num2[0] == &#x27;-&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        s2 = s2.substr(1);</span><br><span class="line">        flag2 = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag1==-1 &amp;&amp; flag2==1)</span><br><span class="line">        return &quot;-&quot; + bigAdd(s1, s2);</span><br><span class="line">    else if (flag1 == 1 &amp;&amp; flag2 == -1)</span><br><span class="line">        return bigAdd(s1, s2);</span><br><span class="line">    else if (flag1 == 1 &amp;&amp; flag2 == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        bool flag = true;</span><br><span class="line">        if(s1.size()&lt;s2.size())&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;else if(s1.size()==s2.size())&#123;</span><br><span class="line">            int idx = 0;</span><br><span class="line">            while(s1[idx]==s2[idx])</span><br><span class="line">                idx++;</span><br><span class="line">            if(s1[idx]&gt;s2[idx])</span><br><span class="line">                flag = true;</span><br><span class="line">            else</span><br><span class="line">                flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)</span><br><span class="line">            return GreaterMinSmaller(s1, s2);</span><br><span class="line">        else</span><br><span class="line">            return &quot;-&quot; + GreaterMinSmaller(s2, s1);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (flag1 == -1 &amp;&amp; flag2 == -1)</span><br><span class="line">    &#123;//(-a)-(-b) = -(a-b)</span><br><span class="line">        string res = bigMinis(s1, s2);</span><br><span class="line">        if(res[0]==&#x27;-&#x27;)</span><br><span class="line">            return res.substr(1);</span><br><span class="line">        else</span><br><span class="line">            return &quot;-&quot; + res;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-位操作"><a href="#4-3-位操作" class="headerlink" title="4.3 位操作"></a>4.3 位操作</h2><h3 id="奇偶位交换-unsigned-int"><a href="#奇偶位交换-unsigned-int" class="headerlink" title="奇偶位交换(unsigned int)"></a>奇偶位交换(unsigned int)</h3><p>只要把奇数位（从低到高）拿出来左移1位，偶数位拿出来右移1位，再相或。</p>
<p><code>0xAAAA</code> 的偶数位都为1，<code>0x5555</code>的奇数位都为1，分别相与可以得到奇数位和偶数位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void swapBit(unsigned int &amp;num)&#123;</span><br><span class="line">    num = ((num &amp; 0xAAAA) &gt;&gt; 1) | ((num &amp; 0x5555) &lt;&lt; 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-实现sqrt函数"><a href="#4-4-实现sqrt函数" class="headerlink" title="4.4 实现sqrt函数"></a>4.4 实现sqrt函数</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float sqrtBiSearch(float n)&#123;</span><br><span class="line">    if(n&lt;0)</span><br><span class="line">        return 0.0;</span><br><span class="line">    float eps = 1e-8;</span><br><span class="line">    float left, right;</span><br><span class="line">    if (n &gt; 1)&#123;</span><br><span class="line">        left = 0;</span><br><span class="line">        right = n;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        left = n;</span><br><span class="line">        right = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    float mid = (left + right) / 2, last;</span><br><span class="line">    while(abs(mid-last) &gt; eps)&#123;</span><br><span class="line">        if(mid*mid &gt; n)</span><br><span class="line">            right = mid;</span><br><span class="line">        else</span><br><span class="line">            left = mid;</span><br><span class="line">        last = mid;</span><br><span class="line">        mid = (left + right) / 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="牛顿迭代"><a href="#牛顿迭代" class="headerlink" title="牛顿迭代"></a>牛顿迭代</h3><p><code>x_n+1 = x_n - f(x_n)/f&#39;(x_n)</code>。因为<code>f(x) = x^2 - n</code>，所以<code>f&#39;(x) = 2x</code>，即<code>x = (x + n/x)/2</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float sqrtNewton(float n)&#123;</span><br><span class="line">    float eps = 1e-8;</span><br><span class="line">    if(abs(n-0.0) &gt; eps)</span><br><span class="line">        return 0.0;</span><br><span class="line">    float x = n ,last = 0 ;</span><br><span class="line">    while (abs(x-last) &gt; eps)&#123;</span><br><span class="line">        last = x ;</span><br><span class="line">        x = (x + n / x) / 2.0 ;</span><br><span class="line">    &#125;</span><br><span class="line">     return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-抢红包的实现"><a href="#4-5-抢红包的实现" class="headerlink" title="4.5 抢红包的实现"></a>4.5 抢红包的实现</h2><ol>
<li>每次把需要剩下的保证后面的人至少都有最低金额的钱减掉（比如还剩下10个人，每个人至少1分钱，就需要留下至少0.1元）。把金额*100后用int来做，最后 &#x2F;100 就能保证 2 位小数。最后一个人为剩下的所有钱。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;float&gt; redBag(const float &amp;money, int cnt)&#123;</span><br><span class="line">	int Money = money * 100;</span><br><span class="line">	int minMoney = 1;</span><br><span class="line">	int lastMoney = Money;</span><br><span class="line">	int lastCnt = cnt;</span><br><span class="line">	int maxMoney = lastMoney - lastCnt*minMoney;</span><br><span class="line">	vector&lt;float&gt; res;</span><br><span class="line">	for (int i = 0; i &lt; cnt-1; i++)&#123;</span><br><span class="line">		int cur = rand() % maxMoney;</span><br><span class="line">		res.push_back(cur/100.0);</span><br><span class="line">		lastMoney -= cur;</span><br><span class="line">		lastCnt--;</span><br><span class="line">		maxMoney = lastMoney - lastCnt*minMoney;</span><br><span class="line">	&#125;</span><br><span class="line">	res.push_back(lastMoney/100.0);</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>随机生产<code>cnt</code>个整数，这些整数加起来的和为<code>sums</code>，每个人分到的钱就为<code>x/sums * money</code>。<code>((float)(int)(cur * 100) / 100.0)</code>能保证两位小数。最后一个人得到剩下的所有。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;float&gt; redBag(const float &amp;money, int cnt)&#123;</span><br><span class="line">	vector&lt;float&gt; res(cnt);</span><br><span class="line">	int sums = 0;</span><br><span class="line">	for (int i = 0; i &lt; cnt; i++)&#123;</span><br><span class="line">		res[i] = rand() % cnt;</span><br><span class="line">		sums += res[i];</span><br><span class="line">	&#125;</span><br><span class="line">	float sumM = 0.0;</span><br><span class="line">	for (int i = 0; i &lt; cnt - 1; i++)&#123;</span><br><span class="line">		float cur = (res[i] / sums) * money;</span><br><span class="line">		cur = ((float)(int)(cur * 100) / 100.0);</span><br><span class="line">		sumM += cur;</span><br><span class="line">		res[i] = cur;</span><br><span class="line">	&#125;</span><br><span class="line">	res[cnt - 1] = money - sumM;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li>严蔚敏, 吴伟民. 数据结构（C语言版）. 清华大学出版社</li>
<li>算法导论（中文版）. 机械工业出版社</li>
<li>Leetcode</li>
<li>何海涛. 剑指 Offer: 名企面试官精讲典型编程题. 电子工业出版社</li>
<li><a href="https://github.com/CyC2018/CS-Notes">CyC2018</a></li>
<li><a href="https://labuladong.github.io/ebook/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.html">labuladong的算法小抄</a></li>
<li><a href="https://www.cnblogs.com/cyanigence-oi/p/11774190.html#fn1">并查集</a></li>
<li><a href="https://blog.csdn.net/qq_41593380/article/details/81146850?utm_medium=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">通俗易懂的并查集讲解</a></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
